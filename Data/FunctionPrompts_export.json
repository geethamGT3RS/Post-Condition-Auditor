[
    {
        "Prompt_ID": 1,
        "Function_ID": 1,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the shared elements from the given two lists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The set of elements in the result must be exactly the set intersection of the two input lists.",
                "assert_statement": "set(result) == set(list1) & set(list2)"
            },
            {
                "description": "Every element returned in the result list must be present in both input lists.",
                "assert_statement": "all(element in list1 and element in list2 for element in result)"
            },
            {
                "description": "The result list must contain every element that is common to both input lists (completeness check, assuming standard set-like intersection where elements are unique).",
                "assert_statement": "all(element in result for element in (set(list1) & set(list2)))"
            },
            {
                "description": "The output must be a list.",
                "assert_statement": "isinstance(result, list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 2,
        "Function_ID": 1,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def similar_elements(test_tup1, test_tup2):\n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) \n    **Function Description: ** Write a function to find the shared elements from the given two lists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(__result__, tuple)"
            },
            {
                "description": "The set of elements in the resulting tuple must be exactly equal to the intersection of the unique elements found in the two input tuples.",
                "assert_statement": "assert set(__result__) == set(test_tup1).intersection(set(test_tup2))"
            },
            {
                "description": "The returned tuple must contain only unique elements, as it is derived from a set intersection.",
                "assert_statement": "assert len(__result__) == len(set(__result__))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 3,
        "Function_ID": 2,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to identify non-prime numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "A known composite number (9) must be identified as non-prime (True).",
                "assert_statement": "assert is_non_prime(9) == True"
            },
            {
                "description": "A known prime number (13) must be identified as not non-prime (False).",
                "assert_statement": "assert is_non_prime(13) == False"
            },
            {
                "description": "The number 4 (the smallest even composite) must be identified as non-prime (True).",
                "assert_statement": "assert is_non_prime(4) == True"
            },
            {
                "description": "The number 2 (the smallest prime) must be identified as not non-prime (False).",
                "assert_statement": "assert is_non_prime(2) == False"
            },
            {
                "description": "The number 1 must be identified as non-prime, as it is neither prime nor composite.",
                "assert_statement": "assert is_non_prime(1) == True"
            },
            {
                "description": "A very large composite number (e.g., 99) must be identified as non-prime.",
                "assert_statement": "assert is_non_prime(99) == True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 4,
        "Function_ID": 2,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math\ndef is_not_prime(n):\n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result\n    **Function Description: ** Write a python function to identify non-prime numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must always return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the input 'n' is a composite number greater than 3 (e.g., 9), the function returns True.",
                "assert_statement": "assert is_not_prime(9) == True"
            },
            {
                "description": "If the input 'n' is a prime number greater than 3 (e.g., 13), the function returns False.",
                "assert_statement": "assert is_not_prime(13) == False"
            },
            {
                "description": "Due to the implementation logic starting the divisor check at i=2 and including math.sqrt(n) in the divisor test, the function incorrectly returns True for n=2.",
                "assert_statement": "assert is_not_prime(2) == True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 5,
        "Function_ID": 3,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the n largest integers from a given list of numbers, returned in descending order.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned list must have a length equal to the minimum of 'n' and the length of the input list.",
                "assert_statement": "len(result) == min(n, len(input_list))"
            },
            {
                "description": "The elements in the returned list must be sorted in strictly descending order (or equal, if duplicates exist).",
                "assert_statement": "all(result[i] >= result[i+1] for i in range(len(result) - 1))"
            },
            {
                "description": "The returned list must contain the actual largest 'n' elements from the input list.",
                "assert_statement": "result == sorted(input_list, reverse=True)[:min(n, len(input_list))]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 6,
        "Function_ID": 3,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import heapq as hq\ndef heap_queue_largest(nums,n):\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums\n    **Function Description: ** Write a function to find the n largest integers from a given list of numbers, returned in descending order.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be equal to n, or the total length of the input list if n exceeds it.",
                "assert_statement": "assert len(result) == min(n, len(nums))"
            },
            {
                "description": "The returned list must contain the n largest elements of nums, sorted in descending order.",
                "assert_statement": "assert result == sorted(nums, reverse=True)[:n]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 7,
        "Function_ID": 4,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether the two numbers differ at one bit position only or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the numbers must differ by exactly one bit position (the XOR result must be a power of two greater than zero).",
                "assert_statement": "(result and ((a ^ b) > 0) and (((a ^ b) & ((a ^ b) - 1)) == 0)) or (not result)"
            },
            {
                "description": "If the function returns False, the numbers must differ by zero or more than one bit position (the XOR result is either zero or has multiple bits set).",
                "assert_statement": "(not result and not (((a ^ b) > 0) and (((a ^ b) & ((a ^ b) - 1)) == 0))) or result"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 8,
        "Function_ID": 4,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_Power_Of_Two (x): \n    return x and (not(x & (x - 1))) \ndef differ_At_One_Bit_Pos(a,b): \n    return is_Power_Of_Two(a ^ b)\n    **Function Description: ** Write a python function to check whether the two numbers differ at one bit position only or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns True if and only if the bitwise XOR of the two input numbers, (a ^ b), has exactly one bit set.",
                "assert_statement": "assert __result__ == (bin(a ^ b).count('1') == 1)"
            },
            {
                "description": "The return value must always be a boolean.",
                "assert_statement": "assert isinstance(__result__, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 9,
        "Function_ID": 5,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find all words which are at least 4 characters long in a string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is a list (or similar iterable collection).",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "All elements found in the result are strings.",
                "assert_statement": "all(isinstance(word, str) for word in result)"
            },
            {
                "description": "Every word returned in the result must be at least 4 characters long.",
                "assert_statement": "all(len(word) >= 4 for word in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 10,
        "Function_ID": 5,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef find_char_long(text):\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))\n    **Function Description: ** Write a function to find all words which are at least 4 characters long in a string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a list object.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "Every word in the returned list must have a length of 4 or greater.",
                "assert_statement": "assert all(len(word) >= 4 for word in result)"
            },
            {
                "description": "If the input string contains no words of 4 or more characters, the returned list must be empty.",
                "assert_statement": "assert find_char_long('I am two') == []"
            },
            {
                "description": "The function correctly identifies and returns all qualifying words from a mixed string.",
                "assert_statement": "assert find_char_long('This is a test string') == ['This', 'test', 'string']"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 11,
        "Function_ID": 6,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find squares of individual elements in a list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the output list must be equal to the length of the input list.",
                "assert_statement": "len(result) == len(input_list)"
            },
            {
                "description": "Every element in the output list must be the square of the corresponding element in the input list.",
                "assert_statement": "all(result[i] == input_list[i] ** 2 for i in range(len(input_list)))"
            },
            {
                "description": "The output must be a list.",
                "assert_statement": "isinstance(result, list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 12,
        "Function_ID": 6,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def square_nums(nums):\n square_nums = list(map(lambda x: x ** 2, nums))\n return square_nums\n    **Function Description: ** Write a function to find squares of individual elements in a list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned object is a list and must have the same number of elements as the input iterable.",
                "assert_statement": "assert isinstance(result, list) and len(result) == len(nums)"
            },
            {
                "description": "Each element in the returned list must be the square of the corresponding element in the input list.",
                "assert_statement": "assert all(result[i] == nums[i] ** 2 for i in range(len(nums)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 13,
        "Function_ID": 7,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the minimum number of rotations (greater than 0) required to get the same string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be an integer between 1 (inclusive) and the length of the input string (inclusive).",
                "assert_statement": "isinstance(result, int) and 1 <= result <= len(s)"
            },
            {
                "description": "Rotating the string by the resulting number of steps must yield the original string.",
                "assert_statement": "s[result:] + s[:result] == s"
            },
            {
                "description": "The result must represent the minimum positive rotation count; no rotation k where 0 < k < result should yield the original string.",
                "assert_statement": "all(s[k:] + s[:k] != s for k in range(1, result))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 14,
        "Function_ID": 7,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_Rotations(str): \n    tmp = str + str\n    n = len(str) \n    for i in range(1,n + 1): \n        substring = tmp[i: i+n] \n        if (str == substring): \n            return i \n    return n \n    **Function Description: ** Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a non-negative integer less than or equal to the length of the input string.",
                "assert_statement": "N = len(input_str); assert isinstance(result, int) and 0 <= result <= N"
            },
            {
                "description": "Rotating the input string by the returned number of steps (result) must yield the original string, verifying correctness.",
                "assert_statement": "assert result == 0 or input_str == input_str[result:] + input_str[:result]"
            },
            {
                "description": "The returned value is the minimum positive rotation count. If the result R is greater than 1, no rotation k such that 1 <= k < R yields the original string.",
                "assert_statement": "N = len(input_str); if N > 0 and result > 1: for k in range(1, result): assert input_str != input_str[k:] + input_str[:k]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 15,
        "Function_ID": 8,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to remove first and last occurrence of a given character from the string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the character appeared two or more times in the original string, the length of the resulting string must be reduced by 2.",
                "assert_statement": "assert len(result) == len(s) - 2 if s.count(char) >= 2 else True"
            },
            {
                "description": "If the character appeared exactly once in the original string, the length of the resulting string must be reduced by 1.",
                "assert_statement": "assert len(result) == len(s) - 1 if s.count(char) == 1 else True"
            },
            {
                "description": "If the character appeared two or more times, the count of that character in the result must be exactly two less than the count in the original string.",
                "assert_statement": "assert result.count(char) == s.count(char) - 2 if s.count(char) >= 2 else True"
            },
            {
                "description": "If the character appeared exactly once, the resulting string must not contain that character.",
                "assert_statement": "assert result.count(char) == 0 if s.count(char) == 1 else True"
            },
            {
                "description": "If the character did not appear in the original string, the resulting string must be identical to the original string.",
                "assert_statement": "assert result == s if s.count(char) == 0 else True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 16,
        "Function_ID": 8,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s \n    **Function Description: ** Write a python function to remove first and last occurrence of a given character from the string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the returned string must be reduced by the number of occurrences of 'ch' removed, which is at most two.",
                "assert_statement": "assert len(result) == len(s_orig) - min(2, s_orig.count(ch))"
            },
            {
                "description": "The count of the character 'ch' in the resulting string must be the original count reduced by the number of removals (up to 2).",
                "assert_statement": "assert result.count(ch) == max(0, s_orig.count(ch) - 2)"
            },
            {
                "description": "If the character 'ch' was not present in the original string, the returned string must be identical to the input string.",
                "assert_statement": "if s_orig.count(ch) == 0: assert result == s_orig"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 17,
        "Function_ID": 9,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to sort a given matrix in ascending order according to the sum of its rows.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The rows are sorted in ascending order based on the sum of the elements within each row. This means the sum of any row is less than or equal to the sum of the row immediately following it.",
                "assert_statement": "all(sum(sorted_matrix[i]) <= sum(sorted_matrix[i+1]) for i in range(len(sorted_matrix) - 1))"
            },
            {
                "description": "The sorted matrix must contain the exact same rows as the original matrix; it is a permutation of the input rows (i.e., no elements or rows were added, deleted, or internally modified).",
                "assert_statement": "sorted(tuple(map(tuple, sorted_matrix))) == sorted(tuple(map(tuple, original_matrix)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 18,
        "Function_ID": 9,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result\n    **Function Description: ** Write a function to sort a given matrix in ascending order according to the sum of its rows.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned matrix is sorted in ascending order such that the sum of any row is less than or equal to the sum of the subsequent row.",
                "assert_statement": "assert all(sum(result[i]) <= sum(result[i+1]) for i in range(len(result) - 1))"
            },
            {
                "description": "The returned matrix (result) must contain exactly the same rows as the input matrix (M), preserving both the content and the total count of all rows.",
                "assert_statement": "assert len(result) == len(M) and sorted([tuple(r) for r in result]) == sorted([tuple(r) for r in M])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 19,
        "Function_ID": 10,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the volume of a triangular prism.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned volume must equal the mathematical volume of a triangular prism: (0.5 * base * height_triangle) * length_prism.",
                "assert_statement": "result == 0.5 * base_of_triangle * height_of_triangle * length_of_prism"
            },
            {
                "description": "The returned value must be a numeric type (integer or float).",
                "assert_statement": "isinstance(result, (int, float))"
            },
            {
                "description": "The calculated volume must be non-negative.",
                "assert_statement": "result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 20,
        "Function_ID": 10,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_Volume(l,b,h) : \n    return ((l * b * h) / 2) \n    **Function Description: ** Write a python function to find the volume of a triangular prism.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must equal the calculation for the volume of a triangular prism: (l * b * h) / 2.",
                "assert_statement": "assert result == (l * b * h) / 2"
            },
            {
                "description": "The returned volume must be non-negative, assuming non-negative inputs.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The return value must be a numeric type (float or int).",
                "assert_statement": "assert isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 21,
        "Function_ID": 11,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned boolean value must be logically equivalent to whether the input string contains a sequence of one or more lowercase letters, followed by an underscore, and then followed by another sequence of one or more lowercase letters.",
                "assert_statement": "import re; assert result == bool(re.search(r'[a-z]+(?:_[a-z]+)+', input_str))"
            },
            {
                "description": "If the result is False, the input string must not contain any pattern of multiple lowercase words joined by underscores.",
                "assert_statement": "import re; if not result: assert not re.search(r'[a-z]+(?:_[a-z]+)+', input_str)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 22,
        "Function_ID": 11,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef text_lowercase_underscore(text):\n        patterns = '^[a-z]+_[a-z]+$'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n    **Function Description: ** Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input string conforms strictly to the pattern of one or more lowercase letters, followed by a single underscore, followed by one or more lowercase letters, the function returns True.",
                "assert_statement": "assert text_lowercase_underscore('example_string') is True"
            },
            {
                "description": "If the input string contains characters outside of the required lowercase alphabet set (e.g., numbers or uppercase letters), the function returns False.",
                "assert_statement": "assert text_lowercase_underscore('Invalid_pattern_123') is False"
            },
            {
                "description": "If the input string contains zero or multiple underscores, or has incorrect structure (e.g., starts/ends with an underscore), the function returns False.",
                "assert_statement": "assert text_lowercase_underscore('no_underscore') is False and text_lowercase_underscore('too_many_underscores') is False"
            },
            {
                "description": "The return value must always be of type boolean.",
                "assert_statement": "result = text_lowercase_underscore('a_b'); assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 23,
        "Function_ID": 12,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that returns the perimeter of a square given its side length as input.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be the product of the side length and 4.",
                "assert_statement": "result == 4 * side"
            },
            {
                "description": "The returned value must be a numerical type (integer or float).",
                "assert_statement": "isinstance(result, (int, float))"
            },
            {
                "description": "Assuming the side length is non-negative, the perimeter must also be non-negative.",
                "assert_statement": "result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 24,
        "Function_ID": 12,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def square_perimeter(a):\n  perimeter=4*a\n  return perimeter\n    **Function Description: ** Write a function that returns the perimeter of a square given its side length as input.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned perimeter must be exactly four times the input side length 'a'.",
                "assert_statement": "perimeter == 4 * a"
            },
            {
                "description": "The returned value must be of a numerical type (integer or float), provided 'a' was also numeric.",
                "assert_statement": "isinstance(perimeter, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 25,
        "Function_ID": 13,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to remove characters from the first string which are present in the second string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting string must be less than or equal to the length of the original first string.",
                "assert_statement": "len(result) <= len(original_string1)"
            },
            {
                "description": "Every character in the resulting string must not be present in the second string (the string containing characters to remove).",
                "assert_statement": "all(char not in string_to_remove for char in result)"
            },
            {
                "description": "The resulting string must be a substring of the original first string (after removing characters).",
                "assert_statement": "all(char in original_string1 for char in result)"
            },
            {
                "description": "If the second string is empty, the resulting string must be identical to the original first string.",
                "assert_statement": "if not string_to_remove: assert result == original_string1"
            },
            {
                "description": "If the first string is empty, the resulting string must also be empty.",
                "assert_statement": "if not original_string1: assert result == ''"
            },
            {
                "description": "If the second string contains all characters present in the first string, the resulting string must be empty.",
                "assert_statement": "if all(char in string_to_remove for char in original_string1): assert result == ''"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 26,
        "Function_ID": 13,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** NO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) \n    **Function Description: ** Write a function to remove characters from the first string which are present in the second string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The returned string contains only characters from the first input string that are not present in the second input string, maintaining relative order.",
                "assert_statement": "dirty_chars = set(second_string); expected_result = \"\".join([c for c in string if c not in dirty_chars]); assert result == expected_result"
            },
            {
                "description": "The length of the returned string must be equal to or less than the length of the original string.",
                "assert_statement": "assert len(result) <= len(string)"
            },
            {
                "description": "No character present in the second input string exists in the returned string.",
                "assert_statement": "assert len(set(result).intersection(set(second_string))) == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 27,
        "Function_ID": 14,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find whether a given array of integers contains any duplicate element.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True (indicating a duplicate was found), the cardinality of the set formed by the input array must be strictly less than the total number of elements in the input array.",
                "assert_statement": "if result: assert len(set(input_array)) < len(input_array)"
            },
            {
                "description": "If the function returns False (indicating no duplicates were found), the cardinality of the set formed by the input array must be exactly equal to the total number of elements in the input array.",
                "assert_statement": "if not result: assert len(set(input_array)) == len(input_array)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 28,
        "Function_ID": 14,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     \n    **Function Description: ** Write a function to find whether a given array of integers contains any duplicate element.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The return value is True if the input array contains duplicates (i.e., its length is greater than the length of the set derived from it).",
                "assert_statement": "assert result == (len(arraynums) > len(set(arraynums)))"
            },
            {
                "description": "If the input array is empty or contains no duplicates, the function must return False.",
                "assert_statement": "if len(arraynums) == len(set(arraynums)): assert result is False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 29,
        "Function_ID": 15,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check if the given number is woodball or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the input number must satisfy the Woodall formula (W_n = n * 2^n - 1) for some integer n >= 1.",
                "assert_statement": "if result is True: assert _is_woodall_formula_met(num) is True"
            },
            {
                "description": "If the function returns False, the input number must not satisfy the Woodall formula for any integer n >= 1.",
                "assert_statement": "if result is False: assert _is_woodall_formula_met(num) is False"
            },
            {
                "description": "If the input number is not positive (num <= 0), the result must be False, since Woodall numbers are defined for positive integers n.",
                "assert_statement": "if num <= 0: assert result is False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 30,
        "Function_ID": 15,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False\n    **Function Description: ** Write a function to check if the given number is woodball or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must always return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the input x is an even number, the function must return False, based on the specific implementation constraint.",
                "assert_statement": "assert x % 2 != 0 or result == False"
            },
            {
                "description": "If the input x is 1, the function must return True (Woodall number W1).",
                "assert_statement": "assert x != 1 or result == True"
            },
            {
                "description": "If the function returns True, the input x must satisfy the Woodall definition, meaning x = n * (2**n) - 1 for some positive integer n.",
                "assert_statement": "if result and x >= 1: assert any(x == (n * (2**n) - 1) for n in range(1, 40))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 31,
        "Function_ID": 16,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check if a given number is one less than twice its reverse.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the input number must satisfy the condition: number equals twice its reverse minus one.",
                "assert_statement": "(result is True) == (n == (2 * int(str(n)[::-1])) - 1)"
            },
            {
                "description": "If the function returns False, the input number must not satisfy the required mathematical relationship.",
                "assert_statement": "(result is False) == (n != (2 * int(str(n)[::-1])) - 1)"
            },
            {
                "description": "The function must always return a boolean value.",
                "assert_statement": "isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 32,
        "Function_ID": 16,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  \n    **Function Description: ** Write a python function to check if a given number is one less than twice its reverse.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a boolean value (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The returned boolean result must be mathematically equivalent to evaluating the condition: 2 * rev(n) == n + 1.",
                "assert_statement": "assert result == (2 * rev(n) == n + 1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 33,
        "Function_ID": 17,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the largest number that can be formed with the given list of digits.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The final number must be formed using all and only the digits provided in the input list (checking character counts).",
                "assert_statement": "assert sorted([c for s in map(str, digits) for c in s]) == sorted(list(result))"
            },
            {
                "description": "The resulting number must not contain unnecessary leading zeros (e.g., '007' is invalid, but '0' is valid for input [0, 0, 0]).",
                "assert_statement": "assert len(result) <= 1 or result[0] != '0'"
            },
            {
                "description": "If the input list of digits was empty, the result must be an empty string or '0'.",
                "assert_statement": "assert digits or (result == '' or result == '0')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 34,
        "Function_ID": 17,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num \n    **Function Description: ** Write a python function to find the largest number that can be formed with the given list of digits.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a single integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned value is equal to the number formed by sorting the input digits in descending order and concatenating them.",
                "assert_statement": "assert result == int(''.join(map(str, sorted(input_arr, reverse=True))))"
            },
            {
                "description": "If the input list is non-empty and contains non-negative digits, the result must be non-negative.",
                "assert_statement": "assert result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 35,
        "Function_ID": 18,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether the given two integers have opposite sign or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the product of the two input integers must be negative, verifying they have opposite signs.",
                "assert_statement": "assert result == True and (a * b < 0)"
            },
            {
                "description": "If the function returns False, the product of the two input integers must be non-negative, verifying they have the same sign or at least one is zero.",
                "assert_statement": "assert result == False and (a * b >= 0)"
            },
            {
                "description": "The result must always be a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 36,
        "Function_ID": 18,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def opposite_Signs(x,y): \n    return ((x ^ y) < 0); \n    **Function Description: ** Write a python function to check whether the given two integers have opposite sign or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the two integers have strictly opposite signs (one positive and one negative), the function returns True.",
                "assert_statement": "assert opposite_Signs(1, -1) is True and opposite_Signs(-10, 5) is True"
            },
            {
                "description": "If the two integers have the same sign (both positive or both negative), the function returns False.",
                "assert_statement": "assert opposite_Signs(10, 20) is False and opposite_Signs(-5, -1) is False"
            },
            {
                "description": "If one integer is zero and the other is positive, the function correctly returns False, as zero has no sign.",
                "assert_statement": "assert opposite_Signs(0, 5) is False and opposite_Signs(100, 0) is False"
            },
            {
                "description": "Due to the underlying bitwise implementation ((x ^ y) < 0), if one integer is zero and the other is negative, the function incorrectly returns True.",
                "assert_statement": "assert opposite_Signs(0, -1) is True and opposite_Signs(-10, 0) is True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 37,
        "Function_ID": 19,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the nth octagonal number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated result must adhere to the formula for the nth octagonal number: $O_n = 3n^2 - 2n$.",
                "assert_statement": "result == 3 * n**2 - 2 * n"
            },
            {
                "description": "The result must be an integer, as polygonal numbers are defined for integer indices.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "For any index n >= 1, the octagonal number must be non-negative.",
                "assert_statement": "result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 38,
        "Function_ID": 19,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_octagonal(n): \n\treturn 3 * n * n - 2 * n \n    **Function Description: ** Write a function to find the nth octagonal number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is equal to the mathematical formula for the nth octagonal number, $3n^2 - 2n$.",
                "assert_statement": "assert result == 3 * n * n - 2 * n"
            },
            {
                "description": "The returned value is an integer, assuming the input 'n' is an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "If the input 'n' is a positive integer (n >= 1), the resulting octagonal number must be positive and greater than or equal to 1.",
                "assert_statement": "if n >= 1: assert result >= 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 39,
        "Function_ID": 20,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count the number of substrings with the sum of digits equal to their length.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input string contains only '1's, every possible substring satisfies the condition, resulting in N*(N+1)/2 matches, where N is the length of the string.",
                "assert_statement": "result == len(s) * (len(s) + 1) // 2 if all(c == '1' for c in s)"
            },
            {
                "description": "If the input string contains digits whose sum always greatly exceeds their length (e.g., '987'), the count should be zero.",
                "assert_statement": "result == 0 if s == '987'"
            },
            {
                "description": "Specific test case for input '010', checking substrings '0' (sum 0, len 1, no match), '1' (sum 1, len 1, match), '0' (sum 0, len 1, no match), '01' (sum 1, len 2, no match), '10' (sum 1, len 2, no match), '010' (sum 1, len 3, no match). Expected count is 1.",
                "assert_statement": "result == 1 if s == '010'"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 40,
        "Function_ID": 20,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count\n    **Function Description: ** Write a python function to count the number of substrings with the sum of digits equal to their length.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer, as it represents a count.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "For a string composed solely of '1's (e.g., '111'), the number of valid substrings is n*(n+1)/2, which is 6 for n=3.",
                "assert_statement": "assert count_Substrings('111') == 6"
            },
            {
                "description": "If the input string contains only '0's, no substring can satisfy the condition (sum=0, length>0).",
                "assert_statement": "assert count_Substrings('0000') == 0"
            },
            {
                "description": "For '101', the two valid substrings are the individual '1's (length=1, sum=1).",
                "assert_statement": "assert count_Substrings('101') == 2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 41,
        "Function_ID": 21,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find smallest number in a list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be less than or equal to every element in the input list (assuming a non-empty list).",
                "assert_statement": "all(result <= x for x in lst)"
            },
            {
                "description": "The returned smallest number must be an element that was present in the original input list.",
                "assert_statement": "result in lst"
            },
            {
                "description": "The returned value is equal to the minimum value verified by the Python built-in 'min' function (assuming a non-empty list).",
                "assert_statement": "result == min(lst)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 42,
        "Function_ID": 21,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def smallest_num(xs):\n  return min(xs)\n\n    **Function Description: ** Write a python function to find smallest number in a list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input list 'xs' is not empty, the returned value ('result') must be an element contained within 'xs'.",
                "assert_statement": "assert result in xs"
            },
            {
                "description": "If the input list 'xs' is not empty, the returned value ('result') must be less than or equal to all other elements in 'xs'.",
                "assert_statement": "assert all(result <= x for x in xs)"
            },
            {
                "description": "Calling the function with an empty list must raise a ValueError.",
                "assert_statement": "import pytest; pytest.raises(ValueError, smallest_num, [])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 43,
        "Function_ID": 22,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the maximum difference between available pairs in the given tuple list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned difference must be a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The returned value must equal the maximum absolute difference calculated across all pairs in the input list.",
                "assert_statement": "result == max(abs(a - b) for a, b in tuple_list)"
            },
            {
                "description": "If the input list is empty, the result must be 0 (assuming 0 is the defined return value for empty input).",
                "assert_statement": "if not tuple_list: assert result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 44,
        "Function_ID": 22,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_difference(test_list):\n  temp = [abs(b - a) for a, b in test_list]\n  res = max(temp)\n  return (res) \n    **Function Description: ** Write a function to find the maximum difference between available pairs in the given tuple list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be non-negative, as the calculation involves absolute differences.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The returned value must be equal to the largest absolute difference calculated from any pair in the input list.",
                "assert_statement": "expected_diffs = [abs(b - a) for a, b in test_list]; assert result == max(expected_diffs)"
            },
            {
                "description": "If the input list is empty, the function should raise a ValueError when attempting to find the maximum of an empty list of differences.",
                "assert_statement": "import pytest; pytest.raises(ValueError, max_difference, [])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 45,
        "Function_ID": 23,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to sort a list of tuples using the second value of each tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting list must contain the exact same elements (tuples) as the input list, ensuring no elements were lost or modified.",
                "assert_statement": "set(result) == set(input_list)"
            },
            {
                "description": "The list must be sorted in non-decreasing order based on the second value (index 1) of each tuple.",
                "assert_statement": "all(result[i][1] <= result[i+1][1] for i in range(len(result) - 1))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 46,
        "Function_ID": 23,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks\n    **Function Description: ** Write a function to sort a list of tuples using the second value of each tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The returned list must contain the exact same set of subject-mark pairs as the input list, ensuring no elements were added, removed, or corrupted.",
                "assert_statement": "assert set(result) == set(original_input_list)"
            },
            {
                "description": "The returned list is sorted in non-decreasing order based on the second element (the mark) of the tuples.",
                "assert_statement": "assert all(result[i][1] <= result[i+1][1] for i in range(len(result) - 1))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 47,
        "Function_ID": 24,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to flatten a list and sum all of its elements.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a numeric type (integer or float).",
                "assert_statement": "isinstance(result, (int, float))"
            },
            {
                "description": "The returned value must equal the sum of all numerical elements present after recursively flattening the input list.",
                "assert_statement": "result == sum(flatten(input))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 48,
        "Function_ID": 24,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total\n    **Function Description: ** Write a function to flatten a list and sum all of its elements.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function correctly sums numbers across multiple levels of list nesting.",
                "assert_statement": "data_list = [1, [2, [3, 4], 5], 6]; result = recursive_list_sum(data_list); assert result == 21"
            },
            {
                "description": "Passing an empty list or a list containing only empty nested lists results in a total sum of 0.",
                "assert_statement": "data_list = [[], [[]], []]; result = recursive_list_sum(data_list); assert result == 0"
            },
            {
                "description": "The return value must be a numeric type (integer or float), resulting from summation.",
                "assert_statement": "data_list = [10, 2.5, [3]]; result = recursive_list_sum(data_list); assert isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 49,
        "Function_ID": 25,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count the number of positive numbers in a list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned count must be a non-negative integer.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned count must not exceed the total length of the input list.",
                "assert_statement": "result <= len(input_list)"
            },
            {
                "description": "The returned value must exactly match the number of elements in the input list that are strictly greater than zero.",
                "assert_statement": "result == len([x for x in input_list if x > 0])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 50,
        "Function_ID": 25,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count \n    **Function Description: ** Write a python function to count the number of positive numbers in a list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer, as it represents a count.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The count of positive (non-negative) numbers cannot exceed the total number of elements in the input list.",
                "assert_statement": "assert result <= len(L)"
            },
            {
                "description": "The return value must exactly equal the number of elements in the input list 'L' that are greater than or equal to zero.",
                "assert_statement": "assert result == sum(1 for x in L if x >= 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 51,
        "Function_ID": 26,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the number of ways to partition a set of Bell numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result, representing the number of partitions, must be a whole number (integer).",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The number of ways to partition a set must be non-negative.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "If the input represents a non-empty set (n > 0), the result must be greater than or equal to 1 (B0 = 1, B1 = 1, B2 = 2, etc.).",
                "assert_statement": "if n >= 0: assert result >= 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 52,
        "Function_ID": 26,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \n    **Function Description: ** Write a function to find the number of ways to partition a set of Bell numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a positive integer, as Bell numbers count set partitions.",
                "assert_statement": "assert isinstance(result, int) and result > 0"
            },
            {
                "description": "If the input n is 0, the function returns the 0th Bell number, which is 1.",
                "assert_statement": "if n == 0: assert result == 1"
            },
            {
                "description": "The function correctly calculates the second Bell number (B_2), which is 2.",
                "assert_statement": "if n == 2: assert result == 2"
            },
            {
                "description": "The function correctly calculates the fourth Bell number (B_4), which is 15.",
                "assert_statement": "if n == 4: assert result == 15"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 53,
        "Function_ID": 27,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether the given array is monotonic or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the array must satisfy the definition of monotonicity (it is either entirely non-decreasing or entirely non-increasing).",
                "assert_statement": "assert not result or (all(arr[i] <= arr[i+1] for i in range(len(arr) - 1)) or all(arr[i] >= arr[i+1] for i in range(len(arr) - 1)))"
            },
            {
                "description": "If the function returns False, the array must violate monotonicity (it contains both an increasing step and a decreasing step).",
                "assert_statement": "assert result or (any(arr[i] > arr[i+1] for i in range(len(arr) - 1)) and any(arr[i] < arr[i+1] for i in range(len(arr) - 1)))"
            },
            {
                "description": "The return value must be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The input array must not be modified by the function (immutability check). This requires storing the initial state of the array as 'original_arr'.",
                "assert_statement": "assert arr == original_arr"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 54,
        "Function_ID": 27,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_Monotonic(A): \n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) \n    **Function Description: ** Write a python function to check whether the given array is monotonic or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The function returns True if and only if the list A is entirely non-decreasing or entirely non-increasing.",
                "assert_statement": "assert result == (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or all(A[i] >= A[i + 1] for i in range(len(A) - 1)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 55,
        "Function_ID": 28,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether a list contains the given sublist or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the sublist (S) must exist within the main list (L), accounting for the edge case where S is empty (which always returns True).",
                "assert_statement": "assert not result or (len(S) == 0) or any(L[i:i+len(S)] == S for i in range(len(L) - len(S) + 1))"
            },
            {
                "description": "If the function returns False, the sublist (S) must not exist in the main list (L), and S must not be empty.",
                "assert_statement": "assert result or (len(S) > 0 and not any(L[i:i+len(S)] == S for i in range(len(L) - len(S) + 1)))"
            },
            {
                "description": "The function must return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 56,
        "Function_ID": 28,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_sublist(l, s):\n\tsub_set = False\n\tif s == []:\n\t\tsub_set = True\n\telif s == l:\n\t\tsub_set = True\n\telif len(s) > len(l):\n\t\tsub_set = False\n\telse:\n\t\tfor i in range(len(l)):\n\t\t\tif l[i] == s[0]:\n\t\t\t\tn = 1\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\n\t\t\t\t\tn += 1\t\t\t\t\n\t\t\t\tif n == len(s):\n\t\t\t\t\tsub_set = True\n\treturn sub_set\n    **Function Description: ** Write a function to check whether a list contains the given sublist or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the result is True, the sublist 's' must be found as a contiguous segment within 'l'.",
                "assert_statement": "assert not result or any(l[i:i + len(s)] == s for i in range(len(l) - len(s) + 1))"
            },
            {
                "description": "If the result is False, the sublist 's' must not exist as a contiguous segment within 'l'.",
                "assert_statement": "assert result or not any(l[i:i + len(s)] == s for i in range(len(l) - len(s) + 1))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 57,
        "Function_ID": 29,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find whether all the given tuples have equal length or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, it implies that the set of lengths of all tuples in the input list contains zero or one unique value (covering the case where the input list is empty or contains tuples of the same length).",
                "assert_statement": "result == True and len({len(t) for t in input_list}) <= 1"
            },
            {
                "description": "If the function returns False, it implies that the input list contained at least two tuples of differing lengths, resulting in the set of lengths having a cardinality greater than one.",
                "assert_statement": "result == False and len({len(t) for t in input_list}) > 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 58,
        "Function_ID": 29,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_equal_tuple(Input):\n  k = 0 if not Input else len(Input[0])\n  flag = 1\n  for tuple in Input:\n    if len(tuple) != k:\n      flag = 0\n      break\n  return flag\ndef get_equal(Input):\n  return find_equal_tuple(Input) == 1\n    **Function Description: ** Write a function to find whether all the given tuples have equal length or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, it implies that all elements in the input list have the same length, or the input list is empty.",
                "assert_statement": "assert not result or not Input or all(len(t) == len(Input[0]) for t in Input)"
            },
            {
                "description": "If the function returns False, it implies that the input list is non-empty and contains at least one element whose length differs from the length of the first element.",
                "assert_statement": "assert result or any(len(t) != len(Input[0]) for t in Input)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 59,
        "Function_ID": 30,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to sort a list of elements.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting list must be sorted in non-decreasing order.",
                "assert_statement": "all(sorted_list[i] <= sorted_list[i+1] for i in range(len(sorted_list) - 1))"
            },
            {
                "description": "The resulting list must have the same length as the original list.",
                "assert_statement": "len(sorted_list) == len(original_list)"
            },
            {
                "description": "The resulting list must be a permutation of the original list (containing the exact same elements with the same frequencies).",
                "assert_statement": "sorted(original_list) == sorted(sorted_list)"
            },
            {
                "description": "The resulting list must be an instance of a list data type.",
                "assert_statement": "isinstance(sorted_list, list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 60,
        "Function_ID": 30,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums\n    **Function Description: ** Write a function to sort a list of elements.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned list is sorted in non-decreasing order.",
                "assert_statement": "all(result[i] <= result[i+1] for i in range(len(result) - 1))"
            },
            {
                "description": "The length of the returned list must be equal to the length of the original input list.",
                "assert_statement": "len(result) == len(original_nums)"
            },
            {
                "description": "The returned list contains exactly the same elements as the original input list (it is a permutation).",
                "assert_statement": "sorted(result) == sorted(original_nums)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 61,
        "Function_ID": 31,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether the given number can be represented as the difference of two squares or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns True if the absolute value of the input number is congruent to 0 modulo 4 (i.e., divisible by 4).",
                "assert_statement": "if abs(n) % 4 == 0: assert result is True"
            },
            {
                "description": "The function returns True if the absolute value of the input number is odd (i.e., congruent to 1 or 3 modulo 4).",
                "assert_statement": "if abs(n) % 2 != 0: assert result is True"
            },
            {
                "description": "The function returns False if the absolute value of the input number is even but not divisible by 4 (i.e., congruent to 2 modulo 4).",
                "assert_statement": "if abs(n) % 4 == 2: assert result is False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 62,
        "Function_ID": 31,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False\n    **Function Description: ** Write a python function to check whether the given number can be represented as the difference of two squares or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the input number 'n' is congruent to 0, 1, or 3 modulo 4 (meaning n % 4 is not 2), the function must return True.",
                "assert_statement": "n_true = 17; assert dif_Square(n_true) is True"
            },
            {
                "description": "If the input number 'n' is congruent to 2 modulo 4 (meaning n % 4 equals 2), the function must return False.",
                "assert_statement": "n_false = 14; assert dif_Square(n_false) is False"
            },
            {
                "description": "The function must correctly determine that zero (0), which is 0 mod 4, can be represented as a difference of squares (0=1^2-1^2).",
                "assert_statement": "assert dif_Square(0) is True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 63,
        "Function_ID": 32,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether it follows the sequence given in the patterns array.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the lengths of the input sequence and the patterns array are unequal, the result must be False.",
                "assert_statement": "assert len(sequence) == len(patterns) or result == False"
            },
            {
                "description": "If the sequence and patterns have established a successful bijective mapping (consistent one-to-one correspondence), the result must be True.",
                "assert_statement": "if len(sequence) == len(patterns): assert (result == all(p_to_s.setdefault(p, s) == s and s_to_p.setdefault(s, p) == p for p, s in zip(patterns, sequence)))"
            },
            {
                "description": "The return value must be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the patterns array requires a single pattern symbol ('A') to map to two different values in the sequence, the result must be False.",
                "assert_statement": "if len(set(patterns)) < len(set(sequence)) and len(patterns) == len(sequence): assert result == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 64,
        "Function_ID": 32,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False   \n\n    for values in sdict.values():\n\n        for i in range(len(values) - 1):\n            if values[i] != values[i+1]:\n                return False\n\n    return True\n    **Function Description: ** Write a function to check whether it follows the sequence given in the patterns array.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the lengths of the colors and patterns sequences are unequal, the function returns False.",
                "assert_statement": "assert not is_samepatterns(['a', 'b'], ['x', 'y', 'z'])"
            },
            {
                "description": "If the mapping is a consistent one-to-one mapping (e.g., 'a' maps to 'red', 'b' maps to 'blue'), the function returns True.",
                "assert_statement": "assert is_samepatterns(['red', 'blue', 'blue', 'red'], ['a', 'b', 'b', 'a'])"
            },
            {
                "description": "If the number of unique elements in patterns does not equal the number of unique elements in colors, the function returns False, enforcing a bijection across unique elements.",
                "assert_statement": "assert not is_samepatterns(['a', 'b', 'c'], ['x', 'x', 'y'])"
            },
            {
                "description": "If a single pattern element maps to inconsistent color elements (violating the internal pattern consistency rule), the function returns False.",
                "assert_statement": "assert not is_samepatterns(['apple', 'banana', 'apple'], ['x', 'x', 'y'])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 65,
        "Function_ID": 33,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find tuples which have all elements divisible by k from the given list of tuples.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "Every element within every resulting tuple must be perfectly divisible by k.",
                "assert_statement": "all(all(element % k == 0 for element in t) for t in result)"
            },
            {
                "description": "The result list must only contain tuples that were present in the original input list.",
                "assert_statement": "all(t in input_tuples for t in result)"
            },
            {
                "description": "The length of the result must equal the count of valid tuples (where all elements are divisible by k) found in the original input.",
                "assert_statement": "len(result) == len([t for t in input_tuples if all(x % k == 0 for x in t)])"
            },
            {
                "description": "The resulting object must be a list (or iterable capable of holding the results).",
                "assert_statement": "isinstance(result, list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 66,
        "Function_ID": 33,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res\n    **Function Description: ** Write a function to find tuples which have all elements divisible by k from the given list of tuples.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "All tuples included in the returned list must satisfy the condition that every element within the tuple is perfectly divisible by K (assuming K is non-zero).",
                "assert_statement": "assert all(all(ele % K == 0 for ele in sub) for sub in result)"
            },
            {
                "description": "The returned list must be a subset of the original input list; it should not contain any tuples not present in the input.",
                "assert_statement": "assert all(sub in test_list for sub in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 67,
        "Function_ID": 34,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find whether a number is divisible by 11.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return True if and only if the input number (n) is mathematically divisible by 11.",
                "assert_statement": "result == (n % 11 == 0)"
            },
            {
                "description": "The return value must be of type boolean.",
                "assert_statement": "isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 68,
        "Function_ID": 34,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_Diff(n): \n    return (n % 11 == 0) \n    **Function Description: ** Write a python function to find whether a number is divisible by 11.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The return value must be True if and only if the input number n is perfectly divisible by 11.",
                "assert_statement": "assert result == (n % 11 == 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 69,
        "Function_ID": 35,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether the length of the word is odd or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a boolean type.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The returned value must be True if the length of the word is odd.",
                "assert_statement": "assert result == (len(word) % 2 != 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 70,
        "Function_ID": 35,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False\n    **Function Description: ** Write a python function to check whether the length of the word is odd or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is always a boolean.",
                "assert_statement": "isinstance(result, bool)"
            },
            {
                "description": "If the first word resulting from splitting the input string by space has an odd length, the function returns True.",
                "assert_statement": "word_len('odd_word testing') is True"
            },
            {
                "description": "If the first word resulting from splitting the input string by space has an even length, the function returns False.",
                "assert_statement": "word_len('even_word test') is False"
            },
            {
                "description": "The function returns based solely on the length of the first word encountered, ignoring subsequent words.",
                "assert_statement": "word_len('even odd_word_later') is False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 71,
        "Function_ID": 36,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the nth tetrahedral number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must equal the mathematical definition of the nth tetrahedral number, T(n) = n(n+1)(n+2)/6.",
                "assert_statement": "result == (n * (n + 1) * (n + 2)) // 6"
            },
            {
                "description": "The result must be an integer, as tetrahedral numbers are counting numbers.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The result must be non-negative.",
                "assert_statement": "result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 72,
        "Function_ID": 36,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def tetrahedral_number(n): \n\treturn (n * (n + 1) * (n + 2)) / 6\n    **Function Description: ** Write a function to find the nth tetrahedral number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is computed using the standard tetrahedral number formula.",
                "assert_statement": "assert result == (n * (n + 1) * (n + 2)) / 6"
            },
            {
                "description": "The return type must be a float because the true division operator (/) is used in the calculation.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "For any non-negative input n, the tetrahedral number must be non-negative.",
                "assert_statement": "if n >= 0: assert result >= 0.0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 73,
        "Function_ID": 37,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the volume of a sphere.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated volume must be a non-negative number.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The result must accurately represent the volume of a sphere (4/3 * pi * radius^3).",
                "assert_statement": "result == (4.0 / 3.0) * math.pi * (radius ** 3)"
            },
            {
                "description": "The return type of the volume calculation must be a float (or a numeric type capable of representing decimals).",
                "assert_statement": "isinstance(result, float)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 74,
        "Function_ID": 37,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math\ndef volume_sphere(r):\n  volume=(4/3)*math.pi*r*r*r\n  return volume\n    **Function Description: ** Write a function to find the volume of a sphere.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a floating-point number.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "The returned volume must be mathematically equal to (4/3) * pi * r^3, accounting for floating-point precision.",
                "assert_statement": "import math; expected = (4/3) * math.pi * r**3; assert math.isclose(result, expected, rel_tol=1e-9)"
            },
            {
                "description": "If the input radius 'r' is non-negative (r >= 0), the calculated volume must also be non-negative.",
                "assert_statement": "assert result >= 0 if r >= 0 else True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 75,
        "Function_ID": 38,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a string consisting of exactly one character.",
                "assert_statement": "isinstance(result, str) and len(result) == 1"
            },
            {
                "description": "The calculated character's relative index (offset from 'a') must equal the total ASCII sum of the input string modulo 26.",
                "assert_statement": "(ord(result) - ord('a')) == (sum(ord(c) for c in input_string) % 26)"
            },
            {
                "description": "The resulting character must fall within the range of the expected character set (e.g., 'a' through 'z') corresponding to a modulo 26 calculation starting from 0.",
                "assert_statement": "ord('a') <= ord(result) <= ord('z')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 76,
        "Function_ID": 38,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)\n    **Function Description: ** Write a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value matches the character derived from the weighted ASCII sum (a=1, z=26) modulo 26, using ord('z') (122) if the modulo result is 0, or calculating chr(ord('a') + R - 1) otherwise.",
                "assert_statement": "assert get_Char(strr) == (ord('z') if sum(ord(c) - ord('a') + 1 for c in strr) % 26 == 0 else chr(ord('a') + (sum(ord(c) - ord('a') + 1 for c in strr) % 26) - 1))"
            },
            {
                "description": "The return type must be either the integer 122 or a single character string ('a' through 'y'), reflecting the logic split in the implementation.",
                "assert_statement": "result = get_Char(strr); assert (isinstance(result, int) and result == 122) or (isinstance(result, str) and len(result) == 1 and 'a' <= result <= 'y')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 77,
        "Function_ID": 39,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the nth number in the newman conway sequence.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a positive integer.",
                "assert_statement": "isinstance(result, int) and result > 0"
            },
            {
                "description": "The result for the first term (C(1)) must be 1.",
                "assert_statement": "n == 1 and result == 1"
            },
            {
                "description": "The result for the second term (C(2)) must be 1.",
                "assert_statement": "n == 2 and result == 1"
            },
            {
                "description": "Verification against a known sequence value: C(5) must equal 3.",
                "assert_statement": "n == 5 and result == 3"
            },
            {
                "description": "The returned value C(n) must satisfy the recursive relation: C(n) = C(C(n-1)) + C(n - C(n-1)) for n > 2. (This assumes the testing framework can access previously computed terms, e.g., stored in a memoized sequence 'C').",
                "assert_statement": "n <= 2 or result == C[C[n-1]] + C[n - C[n-1]]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 78,
        "Function_ID": 39,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))\n    **Function Description: ** Write a function to find the nth number in the newman conway sequence.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a positive integer.",
                "assert_statement": "assert isinstance(result, int) and result > 0"
            },
            {
                "description": "The function must correctly return 1 for the base case n=2.",
                "assert_statement": "assert sequence(2) == 1"
            },
            {
                "description": "The function must correctly calculate the 6th term of the Newman-Conway sequence, Q(6)=4, verifying the recursive formula.",
                "assert_statement": "assert sequence(6) == 4"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 79,
        "Function_ID": 40,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the surface area of a sphere.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated surface area must be a non-negative value, as physical dimensions cannot result in negative areas.",
                "assert_statement": "area >= 0"
            },
            {
                "description": "The calculated surface area must adhere to the geometric formula for the surface area of a sphere: 4 * PI * (radius)^2.",
                "assert_statement": "area == 4 * PI * (radius ** 2)"
            },
            {
                "description": "If the input radius is positive, the resulting surface area must also be positive (i.e., the area is zero only if the radius is zero).",
                "assert_statement": "radius > 0 implies area > 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 80,
        "Function_ID": 40,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math\ndef surfacearea_sphere(r):\n  surfacearea=4*math.pi*r*r\n  return surfacearea\n    **Function Description: ** Write a function to find the surface area of a sphere.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a floating-point number.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "The returned surface area must accurately equal 4 * pi * r * r, allowing for floating point precision.",
                "assert_statement": "import math; assert math.isclose(result, 4 * math.pi * r * r)"
            },
            {
                "description": "The calculated surface area must be non-negative, as the radius squared is always non-negative.",
                "assert_statement": "assert result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 81,
        "Function_ID": 41,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find nth centered hexagonal number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must equal the mathematical formula for the n-th centered hexagonal number (3n^2 - 3n + 1, assuming n starts at 1).",
                "assert_statement": "result == (3 * (n ** 2)) - (3 * n) + 1"
            },
            {
                "description": "The result must be a positive integer.",
                "assert_statement": "isinstance(result, int) and result > 0"
            },
            {
                "description": "For small values of n, the result must match the known sequence (e.g., if n=3, result must be 19).",
                "assert_statement": "if n == 3: assert result == 19"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 82,
        "Function_ID": 41,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1\n    **Function Description: ** Write a function to find nth centered hexagonal number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be of type integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The centered hexagonal number for n=1 must equal 1 (the base case).",
                "assert_statement": "assert centered_hexagonal_number(1) == 1"
            },
            {
                "description": "The centered hexagonal number for n=3 must equal 19.",
                "assert_statement": "assert centered_hexagonal_number(3) == 19"
            },
            {
                "description": "For any index n >= 1, the returned centered hexagonal number must be positive.",
                "assert_statement": "assert result >= 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 83,
        "Function_ID": 42,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to merge three dictionaries into a single dictionary.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result of the merge operation must be a dictionary instance.",
                "assert_statement": "isinstance(result, dict)"
            },
            {
                "description": "The set of keys in the resulting dictionary must be the union of the keys from all three input dictionaries.",
                "assert_statement": "set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"
            },
            {
                "description": "For any key present in the third dictionary (dict3), its value must override any previous values (rightmost wins merge policy).",
                "assert_statement": "all(result[k] == dict3[k] for k in dict3)"
            },
            {
                "description": "For any key present in the second dictionary (dict2) but not the third (dict3), the value must come from dict2.",
                "assert_statement": "all(result[k] == dict2[k] for k in dict2 if k not in dict3)"
            },
            {
                "description": "For any key unique to the first dictionary (dict1), its value must be preserved in the result.",
                "assert_statement": "all(result[k] == dict1[k] for k in dict1 if k not in dict2 and k not in dict3)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 84,
        "Function_ID": 42,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\n    **Function Description: ** Write a function to merge three dictionaries into a single dictionary.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a dictionary.",
                "assert_statement": "assert isinstance(result, dict)"
            },
            {
                "description": "The set of keys in the merged dictionary must be the union of the keys from all three input dictionaries.",
                "assert_statement": "assert set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"
            },
            {
                "description": "Keys present in dict1 take precedence; all key-value pairs from dict1 must be present in the result.",
                "assert_statement": "assert all(result.get(k) == v for k, v in dict1.items())"
            },
            {
                "description": "If a key is only present in dict3 (and not dict1 or dict2), its value must be preserved in the result, demonstrating correct merge order precedence.",
                "assert_statement": "assert all(result[k] == dict3[k] for k in dict3.keys() if k not in dict1 and k not in dict2)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 85,
        "Function_ID": 43,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to get the frequency of all the elements in a list, returned as a dictionary.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result of the function must be a dictionary.",
                "assert_statement": "isinstance(result, dict)"
            },
            {
                "description": "The set of keys in the result dictionary must exactly match the set of unique elements found in the input list.",
                "assert_statement": "set(result.keys()) == set(input_list)"
            },
            {
                "description": "The value associated with each key in the result dictionary must correctly represent the frequency (count) of that element in the original input list.",
                "assert_statement": "all(result[element] == input_list.count(element) for element in result)"
            },
            {
                "description": "All frequency counts (values in the dictionary) must be positive integers (greater than or equal to 1).",
                "assert_statement": "all(isinstance(freq, int) and freq >= 1 for freq in result.values())"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 86,
        "Function_ID": 43,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import collections\ndef freq_count(list1):\n  freq_count= collections.Counter(list1)\n  return freq_count\n    **Function Description: ** Write a function to get the frequency of all the elements in a list, returned as a dictionary.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an instance of collections.Counter (or a dict-like object inheriting from it).",
                "assert_statement": "import collections; assert isinstance(result, collections.Counter)"
            },
            {
                "description": "The sum of all frequency counts returned must equal the total number of elements in the input list.",
                "assert_statement": "assert sum(result.values()) == len(list1)"
            },
            {
                "description": "The keys of the returned frequency counter must exactly match the unique elements present in the input list.",
                "assert_statement": "assert set(result.keys()) == set(list1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 87,
        "Function_ID": 44,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the closest smaller number than n.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be strictly smaller than the input n.",
                "assert_statement": "result < n"
            },
            {
                "description": "Assuming the function operates on a list of candidates L, the result must be an element of L.",
                "assert_statement": "result in L"
            },
            {
                "description": "The result must be the largest element in the candidate list L that is smaller than n, ensuring it is the closest from below.",
                "assert_statement": "not any(x for x in L if result < x and x < n)"
            },
            {
                "description": "The difference between n and the result must be the minimum positive difference among all numbers in L that are smaller than n.",
                "assert_statement": "all((n - result) <= (n - x) for x in L if x < n)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 88,
        "Function_ID": 44,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def closest_num(N):\n  return (N - 1)\n    **Function Description: ** Write a function to find the closest smaller number than n.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is strictly less than the input N, satisfying the requirement of being a smaller number.",
                "assert_statement": "result < N"
            },
            {
                "description": "The returned value is exactly N minus 1, satisfying the implicit requirement of being the closest integer smaller number.",
                "assert_statement": "result == N - 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 89,
        "Function_ID": 45,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the length of the longest word.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The returned value must be non-negative.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "If the input list of words is empty or contains only empty strings/non-word elements, the length of the longest word is zero.",
                "assert_statement": "if not words or not any(len(str(w).strip()) > 0 for w in words): assert result == 0"
            },
            {
                "description": "The returned value must equal the maximum length of any string element in the input list 'words'.",
                "assert_statement": "result == max(len(str(word)) for word in words) if words else 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 90,
        "Function_ID": 45,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max\n    **Function Description: ** Write a python function to find the length of the longest word.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer, as it represents a length.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The returned value must equal the maximum length of any string found in the input list, ensuring correctness for non-empty lists.",
                "assert_statement": "assert result == max(len(s) for s in list1)"
            },
            {
                "description": "The returned value must be greater than or equal to the length of every individual item in the input list.",
                "assert_statement": "assert all(len(s) <= result for s in list1)"
            },
            {
                "description": "If the input list is empty, an IndexError must be raised because the function attempts to access list1[0] during initialization.",
                "assert_statement": "pytest.raises(IndexError, len_log, [])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 91,
        "Function_ID": 46,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check if a string is present as a substring in a given list of string values.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the target substring must be present in at least one string within the input list.",
                "assert_statement": "if result: assert any(needle in item for item in haystack)"
            },
            {
                "description": "If the function returns False, the target substring must not be present in any string within the input list.",
                "assert_statement": "if not result: assert all(needle not in item for item in haystack)"
            },
            {
                "description": "The return value must always be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 92,
        "Function_ID": 46,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False\n    **Function Description: ** Write a function to check if a string is present as a substring in a given list of string values.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a boolean value (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, it must be verifiable that the substring (sub_str) exists in at least one string within the input list (str1).",
                "assert_statement": "assert not result or any(sub_str in s for s in str1)"
            },
            {
                "description": "If the function returns False, it must be verifiable that the substring (sub_str) does not exist in any string within the input list (str1).",
                "assert_statement": "assert result or all(sub_str not in s for s in str1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 93,
        "Function_ID": 47,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether the given number is undulating or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a boolean value indicating whether the input number is undulating or not.",
                "assert_statement": "isinstance(result, bool)"
            },
            {
                "description": "If the result is True, the number (when treated as a string of digits) must satisfy the alternating pattern property (e.g., ABA, ABAB, ABABA, where A != B).",
                "assert_statement": "if result: s = str(number); assert len(s) < 3 or (len(set(s)) == 2 and all(s[i] == s[i % 2] for i in range(len(s))))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 94,
        "Function_ID": 47,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True\n    **Function Description: ** Write a function to check whether the given number is undulating or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the string representation of the input number must have a length greater than 2, and every digit at index i (starting from 2) must match the digit at index i - 2, confirming the alternating pattern.",
                "assert_statement": "s_n = str(n); if result: assert len(s_n) > 2 and all(s_n[i] == s_n[i - 2] for i in range(2, len(s_n)))"
            },
            {
                "description": "If the function returns False, the length of the string representation of the number must either be 2 or less, OR (if the length is greater than 2) there must be at least one index i where the alternating pattern (s[i] == s[i-2]) is violated.",
                "assert_statement": "s_n = str(n); if not result: assert len(s_n) <= 2 or any(s_n[i] != s_n[i - 2] for i in range(2, len(s_n)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 95,
        "Function_ID": 48,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to calculate the value of 'a' to the power 'b'.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be mathematically equivalent to the base (a) raised to the power of the exponent (b), using the standard language exponentiation operator as the reference implementation.",
                "assert_statement": "result == a ** b"
            },
            {
                "description": "If the exponent (b) is zero and the base (a) is non-zero, the result must be 1.",
                "assert_statement": "if b == 0 and a != 0: result == 1"
            },
            {
                "description": "If the base (a) is 0 and the exponent (b) is positive, the result must be 0.",
                "assert_statement": "if a == 0 and b > 0: result == 0"
            },
            {
                "description": "If the exponent (b) is negative, the result must be the reciprocal of the base raised to the positive power of the exponent.",
                "assert_statement": "if b < 0: result == 1 / (a ** abs(b))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 96,
        "Function_ID": 48,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)\n    **Function Description: ** Write a function to calculate the value of 'a' to the power 'b'.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be mathematically equivalent to 'a' raised to the power 'b', matching Python's native exponentiation operator.",
                "assert_statement": "assert result == a ** b"
            },
            {
                "description": "If the exponent 'b' is 0, the result must be 1, covering the identity case and the specific function handling of 0^0 = 1.",
                "assert_statement": "if b == 0: assert result == 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 97,
        "Function_ID": 49,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toGiven a list of tuples, write a function that returns the first value of the tuple with the smallest second value.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be the first element (index 0) of the tuple whose second element (index 1) is the global minimum value in the list.",
                "assert_statement": "min_second_value = min(t[1] for t in data_list); assert result in [t[0] for t in data_list if t[1] == min_second_value]"
            },
            {
                "description": "If the input list is empty, the function must return None (or handle the resulting error appropriately, assuming a None return for robustness).",
                "assert_statement": "if not data_list: assert result is None"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 98,
        "Function_ID": 49,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) \n    **Function Description: ** Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be the first element (index 0) of the tuple that contains the minimum value at index 1 across all tuples in the input list. Tie-breaking favors the earliest occurring tuple.",
                "assert_statement": "expected_val = min(test_list, key=lambda x: x[1])[0]; assert index_minimum(test_list) == expected_val"
            },
            {
                "description": "If the input list is empty, the function must raise a ValueError because the built-in 'min' function requires a non-empty sequence.",
                "assert_statement": "import pytest; with pytest.raises(ValueError): index_minimum([])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 99,
        "Function_ID": 50,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the length of the smallest list in a list of lists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a non-negative integer, as it represents a length.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input list of lists (L) is not empty, the returned value must be equal to the actual minimum length found among all sublists.",
                "assert_statement": "if L: assert result == min(len(sublist) for sublist in L)"
            },
            {
                "description": "If the input list of lists (L) is empty, the returned value must be 0 (assuming the function handles the absence of sublists gracefully rather than raising an error).",
                "assert_statement": "if not L: assert result == 0"
            },
            {
                "description": "The returned value must be less than or equal to the length of every list contained within the input list of lists (L).",
                "assert_statement": "all(result <= len(sublist) for sublist in L)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 100,
        "Function_ID": 50,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n    **Function Description: ** Write a python function to find the length of the smallest list in a list of lists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input list is not empty, the returned value must be less than or equal to the length of every element in the input list.",
                "assert_statement": "if lst: assert all(result <= len(item) for item in lst)"
            },
            {
                "description": "If the input list is empty, a ValueError must be raised because the built-in min() function is called on an empty sequence of lengths.",
                "assert_statement": "if not lst: pytest.raises(ValueError, lambda: Find_Min_Length(lst))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 101,
        "Function_ID": 51,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the number of divisors of a given integer.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a positive integer.",
                "assert_statement": "isinstance(result, int) and result > 0"
            },
            {
                "description": "The calculated result must equal the definitionally correct number of divisors found by checking every number from 1 up to n.",
                "assert_statement": "result == sum(1 for i in range(1, n + 1) if n % i == 0)"
            },
            {
                "description": "If the input integer 'n' is a perfect square, the number of divisors must be odd.",
                "assert_statement": "if n > 0 and (n**0.5).is_integer(): assert result % 2 != 0"
            },
            {
                "description": "For any integer greater than 1, the number of divisors must be at least 2 (1 and n itself).",
                "assert_statement": "if n > 1: assert result >= 2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 102,
        "Function_ID": 51,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x\n    **Function Description: ** Write a python function to find the number of divisors of a given integer.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer representing a count.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "For any positive integer input n, the result must be the mathematically correct total number of positive divisors.",
                "assert_statement": "if n >= 1: expected_divisors = len([i for i in range(1, n + 1) if n % i == 0]); assert result == expected_divisors"
            },
            {
                "description": "The number of divisors for any positive integer must be at least 1 (since 1 is always a divisor).",
                "assert_statement": "if n >= 1: assert result >= 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 103,
        "Function_ID": 52,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find frequency of each element in a flattened list of lists, returned in a dictionary.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a dictionary.",
                "assert_statement": "isinstance(result_freq_dict, dict)"
            },
            {
                "description": "All values (frequencies) in the dictionary must be positive integers (greater than zero).",
                "assert_statement": "all(isinstance(v, int) and v > 0 for v in result_freq_dict.values())"
            },
            {
                "description": "The sum of all frequencies in the result dictionary must equal the total count of elements in the flattened input list.",
                "assert_statement": "total_elements = sum(len(sublist) for sublist in input_list_of_lists); sum(result_freq_dict.values()) == total_elements"
            },
            {
                "description": "Every key in the resulting dictionary must accurately map to the count of that element found in the flattened input list.",
                "assert_statement": "flattened_list = [item for sublist in input_list_of_lists for item in sublist]; all(result_freq_dict[key] == flattened_list.count(key) for key in result_freq_dict)"
            },
            {
                "description": "The set of keys in the resulting dictionary must exactly match the set of unique elements present in the flattened input list.",
                "assert_statement": "unique_input_elements = set([item for sublist in input_list_of_lists for item in sublist]); set(result_freq_dict.keys()) == unique_input_elements"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 104,
        "Function_ID": 52,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def frequency_lists(list1):\n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        if num in dic_data.keys():\n            dic_data[num] += 1\n        else:\n            key = num\n            value = 1\n            dic_data[key] = value\n    return dic_data\n\n    **Function Description: ** Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a dictionary.",
                "assert_statement": "assert isinstance(result, dict)"
            },
            {
                "description": "The total sum of all frequencies in the result dictionary must equal the length of the flattened input list (L).",
                "assert_statement": "flattened_L = [item for sublist in L for item in sublist]; assert sum(result.values()) == len(flattened_L)"
            },
            {
                "description": "Every unique element present in the flattened input list must be represented as a key in the result dictionary.",
                "assert_statement": "flattened_L = [item for sublist in L for item in sublist]; assert set(result.keys()) == set(flattened_L)"
            },
            {
                "description": "For any element 'x', its frequency count in the result dictionary (result[x]) must exactly match its occurrences in the flattened input list.",
                "assert_statement": "flattened_L = [item for sublist in L for item in sublist]; unique_elements = set(flattened_L); assert all(result[x] == flattened_L.count(x) for x in unique_elements)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 105,
        "Function_ID": 53,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to multiply all the numbers in a list and divide with the length of the list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the input list is not empty, the result must equal the product of all elements divided by the list's length.",
                "assert_statement": "if len(input_list) > 0: assert result == product_of_list(input_list) / len(input_list)"
            },
            {
                "description": "If the input list is empty, the function must return 0 to prevent division by zero.",
                "assert_statement": "if len(input_list) == 0: assert result == 0"
            },
            {
                "description": "The output must be a numeric type (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "If all elements in the input list are positive, the result must also be positive.",
                "assert_statement": "if all(x > 0 for x in input_list): assert result > 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 106,
        "Function_ID": 53,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def multiply_num(numbers):  \n    total = 1\n    for x in numbers:\n        total *= x  \n    return total/len(numbers) \n    **Function Description: ** Write a function to multiply all the numbers in a list and divide with the length of the list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be of type float, as the calculation involves floating-point division.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "The returned value is equal to the product of all elements in the input list divided by the length of the list.",
                "assert_statement": "import math; expected_product = math.prod(numbers); assert result == expected_product / len(numbers)"
            },
            {
                "description": "If the input list 'numbers' is empty, the function must raise a ZeroDivisionError.",
                "assert_statement": "import pytest; pytest.raises(ZeroDivisionError, multiply_num, [])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 107,
        "Function_ID": 54,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The integer value represented by the resulting binary string must be equal to the original input decimal number.",
                "assert_statement": "assert int(result, 2) == n"
            },
            {
                "description": "The binary string must not contain leading zeros, unless the resulting string itself is '0'.",
                "assert_statement": "assert len(result) == 1 or result[0] == '1'"
            },
            {
                "description": "The resulting string must contain only valid binary digits ('0' and '1').",
                "assert_statement": "assert all(c in '01' for c in result)"
            },
            {
                "description": "If the input decimal number is zero, the binary string must be '0'.",
                "assert_statement": "assert not (n == 0) or (result == '0')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 108,
        "Function_ID": 54,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") \n    **Function Description: ** Write a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The returned string must not contain the Python binary prefix '0b'.",
                "assert_statement": "assert '0b' not in result"
            },
            {
                "description": "If the input 'n' is a non-negative integer, the binary string representation must correctly correspond to the original decimal value.",
                "assert_statement": "if n >= 0: assert int(result, 2) == n"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 109,
        "Function_ID": 55,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the next smallest palindrome of a specified integer, returned as an integer.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a palindrome (reads the same forwards and backwards).",
                "assert_statement": "str(result) == str(result)[::-1]"
            },
            {
                "description": "The returned palindrome must be strictly greater than the original input integer.",
                "assert_statement": "result > input_n"
            },
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "There is no other palindrome 'q' such that input_n < q < result (ensuring minimality).",
                "assert_statement": "not any(is_palindrome(q) for q in range(input_n + 1, result))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 110,
        "Function_ID": 55,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i\n    **Function Description: ** Write a function to find the next smallest palindrome of a specified integer, returned as an integer.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned palindrome must be strictly greater than the input number.",
                "assert_statement": "assert result > num"
            },
            {
                "description": "The return value must satisfy the property of being a palindrome.",
                "assert_statement": "assert str(result) == str(result)[::-1]"
            },
            {
                "description": "The return value must be the smallest palindrome strictly greater than the input (i.e., no number between num and result is also a palindrome).",
                "assert_statement": "assert all(str(i) != str(i)[::-1] for i in range(num + 1, result))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 111,
        "Function_ID": 56,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the kth element in the given array using 1-based indexing.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must match the element at the 1-based index K in the original array (translated to the 0-based index k-1).",
                "assert_statement": "return_value == arr[k - 1]"
            },
            {
                "description": "The returned value must be an element present within the input array.",
                "assert_statement": "return_value in arr"
            },
            {
                "description": "The input array should remain unmodified (no changes to its length).",
                "assert_statement": "len(arr) == len(arr_at_start)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 112,
        "Function_ID": 56,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def kth_element(arr, k):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] == arr[j+1], arr[j]\n  return arr[k-1]\n    **Function Description: ** Write a function to find the kth element in the given array using 1-based indexing.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If k is a valid 1-based index (1 <= k <= length of array), the return value must be the k-th smallest element found in the input array.",
                "assert_statement": "arr_copy = list(arr); assert result == sorted(arr_copy)[k - 1]"
            },
            {
                "description": "If k is greater than the length of the array, an IndexError must be raised.",
                "assert_statement": "import pytest; assert pytest.raises(IndexError, kth_element, [1, 2, 3], 4)"
            },
            {
                "description": "If k is less than 1 (i.e., non-positive), an IndexError must be raised.",
                "assert_statement": "import pytest; assert pytest.raises(IndexError, kth_element, [1, 2, 3], 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 113,
        "Function_ID": 57,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert a snake case string to camel case string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting string must not contain any underscore characters.",
                "assert_statement": "'_' not in result"
            },
            {
                "description": "The length of the result must equal the total number of non-underscore characters present in the input string.",
                "assert_statement": "len(result) == len(input_str.replace('_', ''))"
            },
            {
                "description": "If the input string contained underscores, the resulting string must contain at least one uppercase character (representing the beginning of subsequent words).",
                "assert_statement": "if '_' in input_str and input_str.strip('_'): assert any(c.isupper() for c in result)"
            },
            {
                "description": "If the result is non-empty, its first character must be lowercase (adhering to standard lower camel case convention).",
                "assert_statement": "not result or result[0].islower()"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 114,
        "Function_ID": 57,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))\n    **Function Description: ** Write a function to convert a snake case string to camel case string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a string.",
                "assert_statement": "result = snake_to_camel('test_string'); assert isinstance(result, str)"
            },
            {
                "description": "A standard snake case string is converted such that each component separated by a single underscore is capitalized and joined without delimiters.",
                "assert_statement": "assert snake_to_camel('user_data_object') == 'UserDataObject'"
            },
            {
                "description": "Empty segments generated by leading, trailing, or consecutive underscores are preserved as underscores in the output due to the implementation logic (`x.capitalize() or '_'`).",
                "assert_statement": "assert snake_to_camel('_a__b_c') == '_A_B_C'"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 115,
        "Function_ID": 58,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the Eulerian number a(n, m).",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result, being a count of permutations, must be a non-negative integer.",
                "assert_statement": "result >= 0 and isinstance(result, int)"
            },
            {
                "description": "For any fixed n >= 1, the Eulerian number for 0 descents (m=0) must be 1.",
                "assert_statement": "if n >= 1 and m == 0: assert result == 1"
            },
            {
                "description": "For any fixed n >= 1, the Eulerian number for n-1 descents (m=n-1, the maximum) must be 1.",
                "assert_statement": "if n >= 1 and m == n - 1: assert result == 1"
            },
            {
                "description": "The result must satisfy the symmetry property: A(n, m) = A(n, n - 1 - m).",
                "assert_statement": "if 0 <= m < n: assert result == eulerian_number(n, n - 1 - m)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 116,
        "Function_ID": 58,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))\n    **Function Description: ** Write a function to find the Eulerian number a(n, m).",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer, as Eulerian numbers are counts.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If n=0 or m >= n, the Eulerian number A(n, m) must be 0.",
                "assert_statement": "assert eulerian_num(5, 5) == 0 and eulerian_num(0, 0) == 0"
            },
            {
                "description": "The function must calculate the correct value for a specific non-trivial case (A(3, 1) = 4).",
                "assert_statement": "assert eulerian_num(3, 1) == 4"
            },
            {
                "description": "The result must satisfy the symmetry property of Eulerian numbers: A(n, m) = A(n, n - 1 - m) for n > 0.",
                "assert_statement": "N, M = 4, 1; assert eulerian_num(N, M) == eulerian_num(N, N - 1 - M)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 117,
        "Function_ID": 59,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to sort each sublist of strings in a given list of lists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "Every sublist in the result is sorted alphabetically.",
                "assert_statement": "all(sublist == sorted(sublist) for sublist in result)"
            },
            {
                "description": "The result maintains the overall list of lists structure, and all inner elements are strings (assuming the input contained strings).",
                "assert_statement": "isinstance(result, list) and all(isinstance(sublist, list) and all(isinstance(item, str) for item in sublist) for sublist in result)"
            },
            {
                "description": "The number of sublists remains unchanged.",
                "assert_statement": "len(result) == len(original_list)"
            },
            {
                "description": "The total count and identity of all elements are preserved across the entire structure (i.e., the flattened lists contain the same items).",
                "assert_statement": "sorted([item for sublist in result for item in sublist]) == sorted([item for sublist in original_list for item in sublist])"
            },
            {
                "description": "The length of each corresponding sublist is preserved.",
                "assert_statement": "[len(sublist) for sublist in result] == [len(sublist) for sublist in original_list]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 118,
        "Function_ID": 59,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n\n    **Function Description: ** Write a function to sort each sublist of strings in a given list of lists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be equal to the length of the input list.",
                "assert_statement": "assert len(result) == len(input_list)"
            },
            {
                "description": "Every sublist in the returned list must be sorted in ascending order based on the first character of its elements.",
                "assert_statement": "for sublist in result: assert all(sublist[i][0] <= sublist[i+1][0] for i in range(len(sublist) - 1))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 119,
        "Function_ID": 60,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count true booleans in the given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The result is less than or equal to the length of the input list.",
                "assert_statement": "result <= len(input_list)"
            },
            {
                "description": "If the input list is empty, the result is zero.",
                "assert_statement": "not input_list or result == 0"
            },
            {
                "description": "The result equals the sum of booleans in the list (True is 1, False is 0), effectively counting only True values.",
                "assert_statement": "result == sum(1 for item in input_list if item is True)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 120,
        "Function_ID": 60,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count(lst):   \n    return sum(lst) \n    **Function Description: ** Write a python function to count true booleans in the given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer, as counts are integral.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The count cannot be negative.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The return value must equal the number of True booleans in the list (if the list only contains booleans, verifying the intended functionality of counting True elements via summation).",
                "assert_statement": "assert result == lst.count(True)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 121,
        "Function_ID": 61,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to append the given list to the given tuples.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting object must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting tuple must be equal to the sum of the lengths of the input tuple and the input list.",
                "assert_statement": "assert len(result) == len(input_tuple) + len(input_list)"
            },
            {
                "description": "The resulting tuple must correctly represent the concatenation of the input tuple and the input list (converted to a tuple).",
                "assert_statement": "assert result == input_tuple + tuple(input_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 122,
        "Function_ID": 61,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def add_lists(test_list, test_tup):\n  res = tuple(list(test_tup) + test_list)\n  return (res) \n    **Function Description: ** Write a function to append the given list to the given tuples.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting tuple must equal the combined length of the input tuple and the input list.",
                "assert_statement": "assert len(result) == len(test_list) + len(test_tup)"
            },
            {
                "description": "The resulting tuple must start with all elements from the original input tuple.",
                "assert_statement": "assert result[:len(test_tup)] == test_tup"
            },
            {
                "description": "The resulting tuple must end with all elements from the original input list, converted to a tuple.",
                "assert_statement": "assert result[len(test_tup):] == tuple(test_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 123,
        "Function_ID": 62,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to merge three lists into a single sorted list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting list must equal the sum of the lengths of the three input lists.",
                "assert_statement": "len(result) == len(list1) + len(list2) + len(list3)"
            },
            {
                "description": "The resulting list must be sorted in non-decreasing order.",
                "assert_statement": "all(result[i] <= result[i+1] for i in range(len(result) - 1))"
            },
            {
                "description": "The content of the resulting list (including element counts) must exactly match the combined content of the three input lists.",
                "assert_statement": "sorted(result) == sorted(list1 + list2 + list3)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 124,
        "Function_ID": 62,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)\n    **Function Description: ** Write a function to merge three lists into a single sorted list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The resulting list contains the exact number of elements from the combined input lists.",
                "assert_statement": "assert len(result) == len(num1) + len(num2) + len(num3)"
            },
            {
                "description": "The resulting list is correctly sorted and contains all elements from the three input lists, preserving multiplicity.",
                "assert_statement": "assert result == sorted(num1 + num2 + num3)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 125,
        "Function_ID": 63,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result, which is the count of odd numbers found, must be a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The count of odd values must not exceed the total number of rotations specified.",
                "assert_statement": "result <= num_rotations"
            },
            {
                "description": "If the input binary string is empty, the resulting count must be zero.",
                "assert_statement": "len(binary_string) > 0 or result == 0"
            },
            {
                "description": "If the binary string contains no '1's, no rotation will ever result in an odd number (since the LSB will always be 0), so the count must be zero.",
                "assert_statement": "'1' in binary_string or result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 126,
        "Function_ID": 63,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count \n    **Function Description: ** Write a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer count of the character '1' within the prefix s[0:n].",
                "assert_statement": "assert result == s[:n].count('1')"
            },
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The return value must be less than or equal to n, as it represents the count within a substring of length n.",
                "assert_statement": "assert result <= n"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 127,
        "Function_ID": 64,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the common elements in given nested lists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting set of common elements must be equivalent to the calculated intersection of all input lists (ensuring completeness and correctness).",
                "assert_statement": "set(result) == set.intersection(*(set(l) for l in nested_lists))"
            },
            {
                "description": "Every item found in the result must actually be present in every single list provided in the input.",
                "assert_statement": "all(item in sublist for sublist in nested_lists for item in result)"
            },
            {
                "description": "If the result is returned as a list, it should contain only unique elements, as common elements are typically treated as a set operation.",
                "assert_statement": "len(result) == len(set(result))"
            },
            {
                "description": "If any of the nested lists in the input are empty, the resulting common element set must also be empty.",
                "assert_statement": "if nested_lists and any(not sublist for sublist in nested_lists): assert not result"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 128,
        "Function_ID": 64,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def common_in_nested_lists(nestedlist):\n    result = list(set.intersection(*map(set, nestedlist)))\n    return result\n    **Function Description: ** Write a function to find the common elements in given nested lists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The elements of the returned list must exactly match the set of elements common to all lists in the input `nestedlist`, guaranteeing both correctness and completeness regardless of element order.",
                "assert_statement": "assert set(result) == set.intersection(*map(set, nestedlist))"
            },
            {
                "description": "Every element in the returned list must be present in every individual list within the input `nestedlist`.",
                "assert_statement": "assert all(elem in set(sublist) for elem in result for sublist in nestedlist)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 129,
        "Function_ID": 65,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check if a string represents an integer or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the string contains only positive digits, the result must be True.",
                "assert_statement": "is_integer_string('12345') == True"
            },
            {
                "description": "If the string contains a negative sign followed by digits, the result must be True.",
                "assert_statement": "is_integer_string('-987') == True"
            },
            {
                "description": "If the string is '0', the result must be True.",
                "assert_statement": "is_integer_string('0') == True"
            },
            {
                "description": "If the string is empty, the result must be False.",
                "assert_statement": "is_integer_string('') == False"
            },
            {
                "description": "If the string contains non-numeric characters (excluding the potential leading sign), the result must be False.",
                "assert_statement": "is_integer_string('1a2b') == False"
            },
            {
                "description": "If the string contains a decimal point, the result must be False.",
                "assert_statement": "is_integer_string('3.14') == False"
            },
            {
                "description": "If the string contains only a sign character ('+' or '-'), the result must be False.",
                "assert_statement": "is_integer_string('+') == False"
            },
            {
                "description": "If the string contains characters that are technically numeric but formatted improperly (e.g., multiple signs), the result must be False.",
                "assert_statement": "is_integer_string('--5') == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 130,
        "Function_ID": 65,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_integer(text):\n text = text.strip()\n if len(text) < 1:\n    return None\n else:\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\n          return True\n     elif (text[0] in \"+-\") and \\\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\n         return True\n     else:\n        return False\n    **Function Description: ** Write a function to check if a string represents an integer or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input string contains only whitespace or is empty, the function returns None.",
                "assert_statement": "if not text.strip(): assert __result__ is None"
            },
            {
                "description": "If the stripped string is non-empty and matches the defined pattern for an integer (pure digits, or a sign followed by zero or more digits), the function returns True.",
                "assert_statement": "stripped = text.strip(); is_valid = stripped.isdigit() or ((len(stripped) > 0 and stripped[0] in '+-') and all(c.isdigit() for c in stripped[1:])); if len(stripped) > 0 and is_valid: assert __result__ is True"
            },
            {
                "description": "If the stripped string is non-empty but does not match the defined pattern for an integer (e.g., contains internal signs or non-digit characters not preceded by a valid sign), the function returns False.",
                "assert_statement": "stripped = text.strip(); is_valid = stripped.isdigit() or ((len(stripped) > 0 and stripped[0] in '+-') and all(c.isdigit() for c in stripped[1:])); if len(stripped) > 0 and not is_valid: assert __result__ is False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 131,
        "Function_ID": 66,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether all dictionaries in a list are empty or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a boolean value.",
                "assert_statement": "isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, then every dictionary in the input list must be empty.",
                "assert_statement": "if result: assert all(not d for d in input_list)"
            },
            {
                "description": "If the function returns False, then at least one dictionary in the input list must contain one or more key-value pairs.",
                "assert_statement": "if not result: assert any(d for d in input_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 132,
        "Function_ID": 66,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def empty_dit(list1):\n empty_dit=all(not d for d in list1)\n return empty_dit\n    **Function Description: ** Write a function to check whether all dictionaries in a list are empty or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the list is empty or contains only empty dictionaries, the return value must be True.",
                "assert_statement": "assert empty_dit([{}, {}]) is True"
            },
            {
                "description": "If the list contains at least one non-empty dictionary, the return value must be False.",
                "assert_statement": "assert empty_dit([{}, {\"a\": 1}, {}]) is False"
            },
            {
                "description": "If the input list is entirely empty, the function should return True.",
                "assert_statement": "assert empty_dit([]) is True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 133,
        "Function_ID": 67,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert a given tuple of positive integers into a single integer.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is of type integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The returned integer must be non-negative (since the input contained only positive integers).",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned integer is numerically equivalent to the string concatenation of the input tuple elements.",
                "assert_statement": "result == int(''.join(map(str, input_tuple)))"
            },
            {
                "description": "If the input tuple is empty, the result must be zero.",
                "assert_statement": "if len(input_tuple) == 0: assert result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 134,
        "Function_ID": 67,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result\n    **Function Description: ** Write a function to convert a given tuple of positive integers into a single integer.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer type.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned integer must be exactly the numerical representation formed by concatenating the string equivalents of all elements in the input tuple 'nums'.",
                "assert_statement": "assert result == int(''.join(map(str, nums)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 135,
        "Function_ID": 68,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert all possible convertible elements in a list of lists to floats.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting structure remains a list of lists.",
                "assert_statement": "assert isinstance(result, list) and all(isinstance(row, list) for row in result)"
            },
            {
                "description": "The dimensions (number of rows and columns) of the resulting structure are identical to the input structure.",
                "assert_statement": "assert len(result) == len(input_list) and all(len(result[i]) == len(input_list[i]) for i in range(len(input_list)))"
            },
            {
                "description": "Every element that was successfully convertible (e.g., original integers, existing floats, or numeric strings) is now explicitly of type float.",
                "assert_statement": "assert all(isinstance(result[i][j], float) for i in range(len(result)) for j in range(len(result[i])) if is_convertible_to_float(input_list[i][j]))"
            },
            {
                "description": "Every element that was successfully converted has a float value equal to the original numeric value.",
                "assert_statement": "assert all(float(input_list[i][j]) == result[i][j] for i in range(len(result)) for j in range(len(result[i])) if is_convertible_to_float(input_list[i][j]))"
            },
            {
                "description": "Elements that could not be converted (e.g., non-numeric strings) must retain their original value and type.",
                "assert_statement": "assert all(input_list[i][j] == result[i][j] and type(input_list[i][j]) == type(result[i][j]) for i in range(len(result)) for j in range(len(result[i])) if not is_convertible_to_float(input_list[i][j]))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 136,
        "Function_ID": 68,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def list_to_float(test_list):\n  res = []\n  for tup in test_list:\n    temp = []\n    for ele in tup:\n      if ele.isalpha():\n        temp.append(ele)\n      else:\n        temp.append(float(ele))\n    res.append((temp[0],temp[1])) \n  return res\n    **Function Description: ** Write a function to convert all possible convertible elements in a list of lists to floats.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting list must be equal to the length of the input list.",
                "assert_statement": "assert len(result) == len(input_list)"
            },
            {
                "description": "Every element in the returned list must be a tuple containing exactly two elements.",
                "assert_statement": "assert all(isinstance(item, tuple) and len(item) == 2 for item in result)"
            },
            {
                "description": "The types of the elements in the resulting tuples correctly follow the conversion logic: float if the corresponding original input element (at index 0 or 1) was not purely alphabetic, and string otherwise.",
                "assert_statement": "assert all((isinstance(result[i][j], float) if not input_list[i][j].isalpha() else isinstance(result[i][j], str)) for i in range(len(input_list)) for j in range(2))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 137,
        "Function_ID": 69,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert a string to a list of strings split on the space character.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned object must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "Every element within the resulting list must be a string.",
                "assert_statement": "assert all(isinstance(item, str) for item in result)"
            },
            {
                "description": "The resulting list elements must accurately reflect the input string split by spaces (mimicking Python's standard string.split() behavior).",
                "assert_statement": "assert result == s.split()"
            },
            {
                "description": "If the input string contains only whitespace characters (or is empty), the result must be an empty list.",
                "assert_statement": "assert not s.strip() or result == []"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 138,
        "Function_ID": 69,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst\n    **Function Description: ** Write a function to convert a string to a list of strings split on the space character.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be an instance of the built-in list type.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "Every element contained within the returned list must be a string.",
                "assert_statement": "assert all(isinstance(element, str) for element in result)"
            },
            {
                "description": "The returned list is exactly equivalent to calling the standard Python string split method with a space delimiter on the original input string.",
                "assert_statement": "assert result == string.split(\" \")"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 139,
        "Function_ID": 70,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the element that appears only once in a sorted array.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned element must appear exactly once in the input array.",
                "assert_statement": "assert nums.count(result) == 1"
            },
            {
                "description": "The returned element must be present in the original input array.",
                "assert_statement": "assert result in nums"
            },
            {
                "description": "The returned element must be an integer (assuming the input array consists of integers).",
                "assert_statement": "assert isinstance(result, int)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 140,
        "Function_ID": 70,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)\n    **Function Description: ** Write a python function to find the element that appears only once in a sorted array.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function should return an integer.",
                "assert_statement": "assert isinstance(search([1, 2, 2, 3, 3]), int)"
            },
            {
                "description": "If the input array is empty, the function should return 0.",
                "assert_statement": "assert search([]) == 0"
            },
            {
                "description": "The function correctly identifies the single element when all other elements appear twice.",
                "assert_statement": "assert search([1, 2, 2, 3, 3, 4, 4]) == 1"
            },
            {
                "description": "The function correctly identifies the single element when it is the first element.",
                "assert_statement": "assert search([5, 1, 1, 2, 2]) == 5"
            },
            {
                "description": "The function correctly identifies the single element when it is the last element.",
                "assert_statement": "assert search([1, 1, 2, 2, 6]) == 6"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 141,
        "Function_ID": 71,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the maximum absolute product between numbers in pairs of tuples within a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a non-negative number, as it represents an absolute product.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "If the input list is empty, the function should return 0 (or a similar indicator of no valid product).",
                "assert_statement": "if len(input_list) == 0: result == 0"
            },
            {
                "description": "If the input list contains tuples with non-numeric elements, an error or a specific handling mechanism should be in place. This postcondition assumes valid numeric input or that such cases are handled prior to this function's execution or are undefined behavior.",
                "assert_statement": "for tup in input_list: for num in tup: assert isinstance(num, (int, float))"
            },
            {
                "description": "The returned value must be the maximum absolute product found among all possible pairs of tuples.",
                "assert_statement": "for i in range(len(input_list)): for j in range(i + 1, len(input_list)): tup1 = input_list[i]; tup2 = input_list[j]; product1 = tup1[0] * tup2[0]; product2 = tup1[0] * tup2[1]; product3 = tup1[1] * tup2[0]; product4 = tup1[1] * tup2[1]; max_pair_abs_product = max(abs(product1), abs(product2), abs(product3), abs(product4)); assert result >= max_pair_abs_product"
            },
            {
                "description": "The function should handle cases where tuples might have different lengths, though the problem statement implies pairs, so this assumes tuples of length 2. If tuples can have lengths other than 2, the logic for product calculation would need to be specified.",
                "assert_statement": "for tup in input_list: assert len(tup) == 2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 142,
        "Function_ID": 71,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max\n    **Function Description: ** Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative number (float or integer), as it represents a maximum absolute value.",
                "assert_statement": "assert isinstance(result, (int, float)) and result >= 0"
            },
            {
                "description": "The returned value must be equal to the maximum absolute product calculated manually from all pairs in the input list.",
                "assert_statement": "assert result == max([abs(x * y) for x, y in list1])"
            },
            {
                "description": "If the input list is empty, the function must raise a ValueError because the built-in max() function cannot operate on an empty sequence.",
                "assert_statement": "pytest.raises(ValueError, max_product_tuple, [])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 143,
        "Function_ID": 72,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to sum all amicable numbers from 1 to a specified number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function should return a non-negative integer.",
                "assert_statement": "return_value >= 0"
            },
            {
                "description": "If no amicable numbers are found within the specified range, the function should return 0.",
                "assert_statement": "if no amicable numbers found in range: return_value == 0"
            },
            {
                "description": "If the specified number is less than the smallest possible amicable number (220), the function should return 0.",
                "assert_statement": "if upper_bound < 220: return_value == 0"
            },
            {
                "description": "The sum should be accurate based on a known list of amicable numbers.",
                "assert_statement": "if upper_bound == 284: return_value == 220 + 284"
            },
            {
                "description": "The sum should be accurate for a larger range.",
                "assert_statement": "if upper_bound == 1000: return_value == 220 + 284"
            },
            {
                "description": "The sum should include all amicable numbers up to and including the specified number if the number itself is amicable and part of a pair.",
                "assert_statement": "if upper_bound == 284 and 284 is amicable and its pair is <= upper_bound: return_value contains 284"
            },
            {
                "description": "The sum should not include numbers that are not amicable.",
                "assert_statement": "for each number n in range(1, upper_bound + 1): if n is not amicable: return_value does not contain n"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 144,
        "Function_ID": 72,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)\n    **Function Description: ** Write a function to sum all amicable numbers from 1 to a specified number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input is not an integer, the function returns a string indicating the error.",
                "assert_statement": "assert amicable_numbers_sum(10.5) == \"Input is not an integer!\""
            },
            {
                "description": "If the input is less than 1, the function returns a string indicating the error.",
                "assert_statement": "assert amicable_numbers_sum(0) == \"Input must be bigger than 0!\""
            },
            {
                "description": "For a valid positive integer input, the function returns an integer.",
                "assert_statement": "assert isinstance(amicable_numbers_sum(100), int)"
            },
            {
                "description": "For a valid positive integer input, the function returns a non-negative integer.",
                "assert_statement": "assert amicable_numbers_sum(100) >= 0"
            },
            {
                "description": "The function correctly calculates the sum of amicable numbers up to 300 (which is 504).",
                "assert_statement": "assert amicable_numbers_sum(300) == 504"
            },
            {
                "description": "The function correctly calculates the sum of amicable numbers up to 1000 (which is 1234).",
                "assert_statement": "assert amicable_numbers_sum(1000) == 1234"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 145,
        "Function_ID": 73,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to get the angle of a complex number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned angle should be within the range of -pi to pi (inclusive of -pi, exclusive of pi) for a non-zero complex number.",
                "assert_statement": "assert -math.pi <= result < math.pi"
            },
            {
                "description": "The returned angle for a complex number with a positive real part and zero imaginary part should be 0.",
                "assert_statement": "assert result == 0.0 if input_complex.imaginary == 0 and input_complex.real > 0"
            },
            {
                "description": "The returned angle for a complex number with a negative real part and zero imaginary part should be pi.",
                "assert_statement": "assert result == math.pi if input_complex.imaginary == 0 and input_complex.real < 0"
            },
            {
                "description": "The returned angle for a complex number with zero real part and a positive imaginary part should be pi/2.",
                "assert_statement": "assert result == math.pi / 2 if input_complex.real == 0 and input_complex.imaginary > 0"
            },
            {
                "description": "The returned angle for a complex number with zero real part and a negative imaginary part should be -pi/2.",
                "assert_statement": "assert result == -math.pi / 2 if input_complex.real == 0 and input_complex.imaginary < 0"
            },
            {
                "description": "The returned angle for the complex number 0+0i is undefined, but often handled as 0 in implementations. If 0 is returned, it should be 0.",
                "assert_statement": "assert result == 0.0 if input_complex.real == 0 and input_complex.imaginary == 0"
            },
            {
                "description": "The angle of a complex number should satisfy the relationship: real_part = magnitude * cos(angle) and imaginary_part = magnitude * sin(angle).",
                "assert_statement": "assert abs(input_complex.real - abs(input_complex) * math.cos(result)) < 1e-9 and abs(input_complex.imaginary - abs(input_complex) * math.sin(result)) < 1e-9"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 146,
        "Function_ID": 73,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import cmath\ndef angle_complex(a,b):\n  cn=complex(a,b)\n  angle=cmath.phase(a+b)\n  return angle\n    **Function Description: ** Write a function to get the angle of a complex number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a float representing the angle in radians.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "The returned angle is within the valid range of -pi to pi.",
                "assert_statement": "assert -cmath.pi <= result <= cmath.pi"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 147,
        "Function_ID": 74,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function should return an integer representing the maximum difference between the count of 0s and 1s within any substring. This difference must be non-negative, as we're looking for the absolute maximum difference.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "If the input string is empty, the maximum difference is 0.",
                "assert_statement": "if len(binary_string) == 0: result == 0"
            },
            {
                "description": "If the input string contains only 0s, the maximum difference will be the length of the string (all 0s and no 1s).",
                "assert_statement": "if all(c == '0' for c in binary_string): result == len(binary_string)"
            },
            {
                "description": "If the input string contains only 1s, the maximum difference will be 0 (as the difference of 0s and 1s will always be negative, and we consider the absolute difference or a modified count for 0s). Alternatively, if interpreted as max(count_0 - count_1), it could be -len(binary_string). The prompt asks for 'maximum difference', implying a non-negative value when considering the magnitude. If the intent is simply 'count_0 - count_1', this assert would be different.",
                "assert_statement": "if all(c == '1' for c in binary_string): result == 0"
            },
            {
                "description": "The calculated maximum difference should be achievable by at least one substring. This means the result should be less than or equal to the total count of 0s in the string if we are maximizing (count_0 - count_1) or equivalent for other interpretations.",
                "assert_statement": "result <= binary_string.count('0')"
            },
            {
                "description": "The calculated maximum difference should also be constrained by the total number of characters. For instance, the maximum possible difference cannot exceed the length of the string.",
                "assert_statement": "result <= len(binary_string)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 148,
        "Function_ID": 74,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0\n    **Function Description: ** Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input string is empty, the function returns 0.",
                "assert_statement": "assert find_length('') == 0"
            },
            {
                "description": "If the input string contains only '1's, the function returns 0.",
                "assert_statement": "assert find_length('1111') == 0"
            },
            {
                "description": "If the input string contains only '0's, the function returns the length of the string.",
                "assert_statement": "assert find_length('0000') == 4"
            },
            {
                "description": "The function correctly calculates the maximum difference for a mixed string.",
                "assert_statement": "assert find_length('01010') == 3"
            },
            {
                "description": "The function correctly calculates the maximum difference for another mixed string.",
                "assert_statement": "assert find_length('1000110') == 3"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 149,
        "Function_ID": 75,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the sum of common divisors of two given numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function should return a non-negative integer representing the sum of common divisors.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If one or both of the input numbers are zero, the sum of common divisors should be zero. (As divisors are typically positive, and no positive number divides zero in a way that results in a finite sum of common divisors).",
                "assert_statement": "assert (num1 == 0 or num2 == 0) implies result == 0"
            },
            {
                "description": "If one number is a divisor of the other, the sum of common divisors should be the sum of the divisors of the smaller number.",
                "assert_statement": "assert num1 != 0 and num2 != 0 and (num1 % num2 == 0 or num2 % num1 == 0) implies result == sum(d for d in range(1, min(abs(num1), abs(num2))) + [max(abs(num1), abs(num2))] if max(abs(num1), abs(num2)) % d == 0)"
            },
            {
                "description": "The sum of common divisors for two prime numbers should be 1 (since their only common divisor is 1).",
                "assert_statement": "assert is_prime(num1) and is_prime(num2) and num1 != num2 implies result == 1"
            },
            {
                "description": "The sum of common divisors for identical numbers should be the sum of the divisors of that number.",
                "assert_statement": "assert num1 == num2 and num1 != 0 implies result == sum(d for d in range(1, abs(num1) + 1) if abs(num1) % d == 0)"
            },
            {
                "description": "The sum of common divisors for 1 and any number should be 1.",
                "assert_statement": "assert (num1 == 1 or num2 == 1) and num1 != 0 and num2 != 0 implies result == 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 150,
        "Function_ID": 75,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sum(a,b): \n    sum = 0\n    for i in range (1,min(a,b)): \n        if (a % i == 0 and b % i == 0): \n            sum += i \n    return sum\n    **Function Description: ** Write a python function to find the sum of common divisors of two given numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned sum of common divisors is non-negative.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "If both input numbers are positive, the returned sum is at least 1 (since 1 is always a common divisor).",
                "assert_statement": "assert result >= 1 if a > 0 and b > 0 else True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 151,
        "Function_ID": 76,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to multiply two integers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result of multiplying two integers should be equal to the product of the two integers.",
                "assert_statement": "result == num1 * num2"
            },
            {
                "description": "If one of the input integers is zero, the result should be zero.",
                "assert_statement": "(num1 == 0 || num2 == 0) => result == 0"
            },
            {
                "description": "If one of the input integers is one, the result should be the other integer.",
                "assert_statement": "(num1 == 1 && num2 != 0) => result == num2"
            },
            {
                "description": "If one of the input integers is negative and the other is positive, the result should be negative.",
                "assert_statement": "(num1 < 0 && num2 > 0) || (num1 > 0 && num2 < 0) => result < 0"
            },
            {
                "description": "If both input integers are negative, the result should be positive.",
                "assert_statement": "num1 < 0 && num2 < 0 => result > 0"
            },
            {
                "description": "If both input integers are positive, the result should be positive.",
                "assert_statement": "num1 > 0 && num2 > 0 => result > 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 152,
        "Function_ID": 76,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)\n    **Function Description: ** Write a function to multiply two integers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If both inputs are non-negative integers, the function returns their product.",
                "assert_statement": "assert multiply_int(5, 4) == 20"
            },
            {
                "description": "If one input is negative and the other is non-negative, the function returns their product.",
                "assert_statement": "assert multiply_int(5, -4) == -20"
            },
            {
                "description": "If both inputs are negative integers, the function returns their product.",
                "assert_statement": "assert multiply_int(-5, -4) == 20"
            },
            {
                "description": "If one of the inputs is zero, the function returns zero.",
                "assert_statement": "assert multiply_int(100, 0) == 0"
            },
            {
                "description": "If one of the inputs is one, the function returns the other input.",
                "assert_statement": "assert multiply_int(100, 1) == 100"
            },
            {
                "description": "If one of the inputs is negative one, the function returns the negation of the other input.",
                "assert_statement": "assert multiply_int(100, -1) == -100"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 153,
        "Function_ID": 77,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find words that are longer than n characters from a given list of words.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a list containing only words from the input list that have a length strictly greater than n.",
                "assert_statement": "return_value.all(word -> word.length > n)"
            },
            {
                "description": "The function returns an empty list if the input list of words is empty.",
                "assert_statement": "input_words.is_empty() ? return_value.is_empty() : true"
            },
            {
                "description": "The function returns an empty list if no words in the input list are longer than n.",
                "assert_statement": "input_words.all(word -> word.length <= n) ? return_value.is_empty() : true"
            },
            {
                "description": "The order of the words in the returned list is the same as their original order in the input list.",
                "assert_statement": "original_indices_of_return_value.is_sorted()"
            },
            {
                "description": "All words in the returned list are present in the original input list.",
                "assert_statement": "return_value.all(word -> input_words.contains(word))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 154,
        "Function_ID": 77,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t\n    **Function Description: ** Write a function to find words that are longer than n characters from a given list of words.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a list.",
                "assert_statement": "assert isinstance(long_words(3, 'this is a sample string'), list)"
            },
            {
                "description": "All words in the returned list are longer than n characters.",
                "assert_statement": "assert all(len(word) > 3 for word in long_words(3, 'this is a sample string'))"
            },
            {
                "description": "If no words are longer than n characters, an empty list is returned.",
                "assert_statement": "assert long_words(10, 'short words') == []"
            },
            {
                "description": "The original string remains unchanged.",
                "assert_statement": "s = 'sample string'; long_words(3, s); assert s == 'sample string'"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 155,
        "Function_ID": 78,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to calculate whether the matrix is a magic square.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function should return true if the matrix is a magic square, and false otherwise.",
                "assert_statement": "return_value == is_magic_square"
            },
            {
                "description": "If the matrix is a magic square, the sum of each row must be equal to the magic constant.",
                "assert_statement": "if return_value: all(sum(row) == magic_constant for row in matrix)"
            },
            {
                "description": "If the matrix is a magic square, the sum of each column must be equal to the magic constant.",
                "assert_statement": "if return_value: all(sum(matrix[i][j] for i in range(len(matrix))) == magic_constant for j in range(len(matrix[0])))"
            },
            {
                "description": "If the matrix is a magic square, the sum of the main diagonal must be equal to the magic constant.",
                "assert_statement": "if return_value: sum(matrix[i][i] for i in range(len(matrix))) == magic_constant"
            },
            {
                "description": "If the matrix is a magic square, the sum of the anti-diagonal must be equal to the magic constant.",
                "assert_statement": "if return_value: sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) == magic_constant"
            },
            {
                "description": "If the matrix is a magic square, all numbers from 1 to n*n (where n is the dimension of the square) must be present exactly once.",
                "assert_statement": "if return_value: sorted([item for sublist in matrix for item in sublist]) == list(range(1, len(matrix)**2 + 1))"
            },
            {
                "description": "The matrix must be square (number of rows equals number of columns).",
                "assert_statement": "len(matrix) == len(matrix[0])"
            },
            {
                "description": "The matrix must not be empty.",
                "assert_statement": "len(matrix) > 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 156,
        "Function_ID": 78,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True\n    **Function Description: ** Write a function to calculate whether the matrix is a magic square.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a boolean value.",
                "assert_statement": "assert isinstance(magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]]), bool)"
            },
            {
                "description": "If the input matrix is a magic square, the function returns True.",
                "assert_statement": "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == True"
            },
            {
                "description": "If the input matrix is not a magic square, the function returns False.",
                "assert_statement": "assert magic_square_test([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 157,
        "Function_ID": 79,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the item with maximum frequency in a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the input list is empty, the result must be a designated sentinel value (e.g., None).",
                "assert_statement": "not input_list and result is None"
            },
            {
                "description": "If the input list is not empty, the returned item must be an element present in the original list.",
                "assert_statement": "input_list and result in input_list"
            },
            {
                "description": "The frequency of the returned item must be equal to the maximum frequency found among all unique items in the list.",
                "assert_statement": "input_list and input_list.count(result) == max(input_list.count(item) for item in set(input_list))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 158,
        "Function_ID": 79,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from collections import defaultdict\ndef max_occurrences(nums):\n    dict = defaultdict(int)\n    for i in nums:\n        dict[i] += 1\n    result = max(dict.items(), key=lambda x: x[1]) \n    return result[0]\n    **Function Description: ** Write a function to find the item with maximum frequency in a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input list is not empty, the returned value must be an element that exists within the original input list.",
                "assert_statement": "if nums: assert result in nums"
            },
            {
                "description": "The frequency of the returned element must be equal to the highest frequency of any item in the list.",
                "assert_statement": "if nums: from collections import Counter; counts = Counter(nums); max_freq = max(counts.values()); assert counts[result] == max_freq"
            },
            {
                "description": "If the input list is empty, a ValueError must be raised because the internal call to max() on an empty sequence of items is invalid.",
                "assert_statement": "import pytest; with pytest.raises(ValueError): max_occurrences([])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 159,
        "Function_ID": 80,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to reverse only the vowels of a given string (where y is not a vowel).",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting string must match the length of the input string.",
                "assert_statement": "assert len(result) == len(s)"
            },
            {
                "description": "All non-vowel characters (excluding 'y') must remain in their original positions.",
                "assert_statement": "assert all(s[i] == result[i] for i in range(len(s)) if s[i].lower() not in 'aeiou')"
            },
            {
                "description": "The sequence of vowels (a, e, i, o, u, case-insensitive) in the resulting string must be the reverse of the original sequence of vowels.",
                "assert_statement": "assert [c for c in result if c.lower() in 'aeiou'] == [c for c in s if c.lower() in 'aeiou'][::-1]"
            },
            {
                "description": "The output must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 160,
        "Function_ID": 80,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def reverse_vowels(str1):\n\tvowels = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tvowels += char\n\tresult_string = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tresult_string += vowels[-1]\n\t\t\tvowels = vowels[:-1]\n\t\telse:\n\t\t\tresult_string += char\n\treturn result_string\n    **Function Description: ** Write a python function to reverse only the vowels of a given string (where y is not a vowel).",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting string must be equal to the length of the input string.",
                "assert_statement": "assert len(result) == len(str1)"
            },
            {
                "description": "All characters that are not vowels must maintain their original index position.",
                "assert_statement": "assert all(str1[i] == result[i] for i in range(len(str1)) if str1[i].lower() not in 'aeiou')"
            },
            {
                "description": "The multiset of vowels (including case) in the input string must be identical to the multiset of vowels in the resulting string.",
                "assert_statement": "assert sorted([c for c in result if c in 'aeiouAEIOU']) == sorted([c for c in str1 if c in 'aeiouAEIOU'])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 161,
        "Function_ID": 81,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert a tuple to a string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be of type string.",
                "assert_statement": "isinstance(result, str)"
            },
            {
                "description": "The resulting string must match the standard Python string representation of the input tuple.",
                "assert_statement": "result == str(input_tuple)"
            },
            {
                "description": "The string representation must correctly include opening and closing parentheses, typical of a tuple string.",
                "assert_statement": "result.startswith('(') and result.endswith(')')"
            },
            {
                "description": "The string representation must contain the string representation of every element found in the original tuple.",
                "assert_statement": "all(str(item) in result for item in input_tuple)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 162,
        "Function_ID": 81,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def tup_string(tup1):\n  str =  ''.join(tup1)\n  return str\n    **Function Description: ** Write a function to convert a tuple to a string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The returned string must be the exact concatenation of the input tuple elements.",
                "assert_statement": "assert result == \"\".join(tup1)"
            },
            {
                "description": "The length of the returned string must equal the sum of the lengths of all string elements in the input tuple.",
                "assert_statement": "assert len(result) == sum(len(s) for s in tup1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 163,
        "Function_ID": 82,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to calculate the sum of the negative numbers of a given list of numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be an integer or a float, depending on the input types.",
                "assert_statement": "isinstance(result, (int, float))"
            },
            {
                "description": "If the input list is empty, the result must be zero.",
                "assert_statement": "if not numbers: assert result == 0"
            },
            {
                "description": "If the input list contains no negative numbers, the result must be zero.",
                "assert_statement": "if not any(n < 0 for n in numbers): assert result == 0"
            },
            {
                "description": "The result is equal to the sum of all negative numbers in the input list.",
                "assert_statement": "assert result == sum(n for n in numbers if n < 0)"
            },
            {
                "description": "The result must be less than or equal to zero (as it is a sum of only negative numbers and potentially zero).",
                "assert_statement": "assert result <= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 164,
        "Function_ID": 82,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sum_negativenum(nums):\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\n  return sum(sum_negativenum)\n    **Function Description: ** Write a function to calculate the sum of the negative numbers of a given list of numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must exactly equal the sum of all elements strictly less than zero found in the input list.",
                "assert_statement": "assert result == sum(x for x in nums if x < 0)"
            },
            {
                "description": "The returned value is always a numeric type (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "If the input list contains at least one negative number, the returned sum must be strictly less than zero.",
                "assert_statement": "if any(x < 0 for x in nums): assert result < 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 165,
        "Function_ID": 83,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the nth hexagonal number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must equal n * (2 * n - 1), based on the standard formula for the nth hexagonal number.",
                "assert_statement": "result == n * (2 * n - 1)"
            },
            {
                "description": "The result must be a non-negative number, as hexagonal numbers are a sequence of natural numbers (assuming n >= 1).",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The result must be an integer type.",
                "assert_statement": "isinstance(result, int)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 166,
        "Function_ID": 83,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def hexagonal_num(n): \n\treturn n*(2*n - 1) \n    **Function Description: ** Write a function to find the nth hexagonal number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must correctly compute the nth hexagonal number using the formula n*(2n - 1).",
                "assert_statement": "n = 5; assert hexagonal_num(n) == n * (2 * n - 1)"
            },
            {
                "description": "If the input 'n' is an integer, the returned value must also be an integer.",
                "assert_statement": "assert isinstance(hexagonal_num(3), int)"
            },
            {
                "description": "For any non-negative integer input 'n', the resulting hexagonal number must be non-negative.",
                "assert_statement": "n = 10; assert hexagonal_num(n) >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 167,
        "Function_ID": 84,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the ratio of zeroes to non-zeroes in an array of integers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the array contains at least one non-zero element, the result is the ratio of the count of zeros to the count of non-zeros, within a floating-point tolerance.",
                "assert_statement": "len(arr) - arr.count(0) > 0 and abs(result - (arr.count(0) / (len(arr) - arr.count(0)))) < 1e-9"
            },
            {
                "description": "If the array contains only zero elements (or is non-empty and has no non-zeroes), the ratio is considered infinite.",
                "assert_statement": "len(arr) > 0 and len(arr) - arr.count(0) == 0 and result == float('inf')"
            },
            {
                "description": "If the input array is empty, the result of the ratio is defined as zero.",
                "assert_statement": "len(arr) == 0 and result == 0.0"
            },
            {
                "description": "The result must be a non-negative numerical value (including infinity).",
                "assert_statement": "result >= 0.0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 168,
        "Function_ID": 84,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from array import array\ndef zero_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x == 0:\n            n1 += 1\n        else:\n          None\n    return n1/(n-n1)\n    **Function Description: ** Write a function to find the ratio of zeroes to non-zeroes in an array of integers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the count of non-zero elements is greater than zero, the return value is a float equal to the count of zeros divided by the count of non-zeros.",
                "assert_statement": "non_zeros = len(nums) - nums.count(0); if non_zeros > 0: assert result == float(nums.count(0)) / non_zeros"
            },
            {
                "description": "If a result is returned successfully (non-zero denominator), it must be a non-negative floating-point number.",
                "assert_statement": "if len(nums) > nums.count(0): assert isinstance(result, float) and result >= 0.0"
            },
            {
                "description": "If the input list consists entirely of zeros (or is empty), a ZeroDivisionError must be raised because the count of non-zeros results in a zero denominator.",
                "assert_statement": "import pytest; if len(nums) == nums.count(0): pytest.raises(ZeroDivisionError, zero_count, nums)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 169,
        "Function_ID": 85,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the input number is positive and even, meaning it can be represented as a sum exclusively of $2^k$ where $k \\ge 1$, the function must return True.",
                "assert_statement": "assert result == True if n > 0 and n % 2 == 0 else True"
            },
            {
                "description": "If the input number is positive and odd, meaning it requires $2^0=1$ in its binary representation, the function must return False.",
                "assert_statement": "assert result == False if n > 0 and n % 2 != 0 else True"
            },
            {
                "description": "If the input is 1 (the smallest number requiring $2^0$), the function must return False.",
                "assert_statement": "assert func(1) == False"
            },
            {
                "description": "If the input is 2 (the smallest valid number $2^1$), the function must return True.",
                "assert_statement": "assert func(2) == True"
            },
            {
                "description": "For zero or negative inputs, the function must return False.",
                "assert_statement": "assert func(0) == False and func(-4) == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 170,
        "Function_ID": 85,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True\n    **Function Description: ** Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input integer 'n' is even, the function returns True.",
                "assert_statement": "assert is_Sum_Of_Powers_Of_Two(8) == True"
            },
            {
                "description": "If the input integer 'n' is odd, the function returns False.",
                "assert_statement": "assert is_Sum_Of_Powers_Of_Two(9) == False"
            },
            {
                "description": "The function always returns a boolean type.",
                "assert_statement": "result = is_Sum_Of_Powers_Of_Two(2); assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 171,
        "Function_ID": 86,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the circumference of a circle.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a numeric type (float) representing a precise measurement.",
                "assert_statement": "isinstance(result, float)"
            },
            {
                "description": "The calculated circumference must be non-negative.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The result must be mathematically equivalent to 2 * PI * radius, accounting for floating-point tolerance (epsilon).",
                "assert_statement": "abs(result - (2 * PI * radius)) < epsilon"
            },
            {
                "description": "If the radius is positive, the circumference must be greater than twice the diameter (since C = PI * d and PI > 3).",
                "assert_statement": "if radius > 0: result > (4 * radius)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 172,
        "Function_ID": 86,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def circle_circumference(r):\n  perimeter=2*3.1415*r\n  return perimeter\n    **Function Description: ** Write a function to find the circumference of a circle.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a float, as dictated by the multiplication involving the floating-point constant 3.1415.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "The returned circumference must exactly match the calculated value of 2 * 3.1415 * r.",
                "assert_statement": "test_r = 5.0; assert circle_circumference(test_r) == 2 * 3.1415 * test_r"
            },
            {
                "description": "If the radius is zero, the circumference must be zero.",
                "assert_statement": "assert circle_circumference(0) == 0.0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 173,
        "Function_ID": 87,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to flatten the list of lists into a single set of numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a set data structure.",
                "assert_statement": "isinstance(result, set)"
            },
            {
                "description": "All elements within the resulting set must be numeric (integers or floats).",
                "assert_statement": "all(isinstance(x, (int, float)) for x in result)"
            },
            {
                "description": "The resulting set must contain exactly the unique numerical elements present across all sublists of the input.",
                "assert_statement": "result == set(item for sublist in input_list for item in sublist)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 174,
        "Function_ID": 87,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def extract_singly(test_list):\n  res = []\n  temp = set()\n  for inner in test_list:\n    for ele in inner:\n      if not ele in temp:\n        temp.add(ele)\n        res.append(ele)\n  return (res) \n    **Function Description: ** Write a function to flatten the list of lists into a single set of numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(res, list)"
            },
            {
                "description": "The returned list contains only unique elements, effectively having performed deduplication.",
                "assert_statement": "assert len(res) == len(set(res))"
            },
            {
                "description": "The set of elements in the result list must exactly match the set of all unique elements found in the input list of lists.",
                "assert_statement": "unique_elements = set(); [unique_elements.update(sublist) for sublist in test_list]; assert set(res) == unique_elements"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 175,
        "Function_ID": 88,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to sort a list of elements.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting list must be in non-decreasing order (sorted).",
                "assert_statement": "all(result[i] <= result[i+1] for i in range(len(result) - 1))"
            },
            {
                "description": "The resulting list must be a permutation of the original input list (content preservation).",
                "assert_statement": "collections.Counter(result) == collections.Counter(input_list)"
            },
            {
                "description": "The length of the output list must equal the length of the input list.",
                "assert_statement": "len(result) == len(input_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 176,
        "Function_ID": 88,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def pancake_sort(nums):\n    arr_len = len(nums)\n    while arr_len > 1:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums\n    **Function Description: ** Write a function to sort a list of elements.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "The returned list is sorted in non-decreasing order.",
                "assert_statement": "all(result[i] <= result[i+1] for i in range(len(result) - 1))"
            },
            {
                "description": "The returned list must be a permutation of the input list, meaning it contains the same elements with the same frequencies and length.",
                "assert_statement": "len(result) == len(initial_nums) and sorted(result) == sorted(initial_nums)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 177,
        "Function_ID": 89,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to count number items that are identical in the same position of three given lists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned count must be a non-negative integer.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned count must not exceed the length of the shortest input list, as comparisons stop at that boundary.",
                "assert_statement": "result <= min(len(list1), len(list2), len(list3))"
            },
            {
                "description": "The result must exactly match the sum of items where the elements at the same index in all three lists are identical, considering only indices up to the minimum length.",
                "assert_statement": "result == sum(1 for i in range(min(len(list1), len(list2), len(list3))) if list1[i] == list2[i] == list3[i])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 178,
        "Function_ID": 89,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_samepair(list1,list2,list3):\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\n    return result\n    **Function Description: ** Write a function to count number items that are identical in the same position of three given lists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The returned count must be a non-negative integer.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned count cannot exceed the length of the shortest input list, as zip stops at the shortest list.",
                "assert_statement": "L1 = [1, 2, 3]; L2 = [1, 2]; L3 = [1, 2, 3, 4]; assert result <= min(len(L1), len(L2), len(L3))"
            },
            {
                "description": "If all lists are identical, the result must equal the length of the list.",
                "assert_statement": "L = [10, 20, 30]; assert count_samepair(L, L, L) == len(L)"
            },
            {
                "description": "Verify the core counting logic against a heterogeneous test case.",
                "assert_statement": "assert count_samepair([1, 2, 'a', 4, 5], [1, 3, 'a', 4, 5], [1, 2, 'a', 5, 5]) == 3"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 179,
        "Function_ID": 90,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find number of lists present in the given tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The returned value must accurately reflect the total count of elements within the input tuple that are of type list.",
                "assert_statement": "result == sum(1 for item in input_tuple if isinstance(item, list))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 180,
        "Function_ID": 90,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) \n    **Function Description: ** Write a function to find number of lists present in the given tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input argument is of type list, the function must return the integer value 1.",
                "assert_statement": "assert find_lists([1, 2, 3]) == 1 and find_lists([]) == 1"
            },
            {
                "description": "If the input argument is not a list (e.g., a tuple or string), the return value must equal the length of that input.",
                "assert_statement": "test_tuple = (4, 5, 6, 7); assert find_lists(test_tuple) == 4 and find_lists(\"word\") == 4"
            },
            {
                "description": "The function must always return a value that is of type integer, provided no TypeError occurs during the internal call to len().",
                "assert_statement": "assert isinstance(find_lists([1]), int) and isinstance(find_lists((1, 2)), int)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 181,
        "Function_ID": 91,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the maximum difference between any two elements in a given array.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated maximum difference must be a non-negative value.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "If the array has at least two elements, the result must be equal to the difference between the maximum and minimum elements of the array.",
                "assert_statement": "len(arr) < 2 and result == 0) or (len(arr) >= 2 and result == max(arr) - min(arr))"
            },
            {
                "description": "The result must be greater than or equal to the absolute difference between any two elements in the input array.",
                "assert_statement": "all(result >= abs(arr[i] - arr[j]) for i in range(len(arr)) for j in range(len(arr)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 182,
        "Function_ID": 91,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) \n    **Function Description: ** Write a python function to find the maximum difference between any two elements in a given array.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be equal to the difference between the maximum and minimum elements of the input array.",
                "assert_statement": "assert result == (max(arr) - min(arr))"
            },
            {
                "description": "The returned value, representing a difference between two elements, must be non-negative.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "If the input array is non-empty, the returned value must be a number (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 183,
        "Function_ID": 92,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns a result, the calculated values x (result[0]) and y (result[1]) must satisfy the equation ax + by = n.",
                "assert_statement": "if result is not None: assert a * result[0] + b * result[1] == n"
            },
            {
                "description": "If a solution is returned, both x and y must be integers.",
                "assert_statement": "if result is not None: assert isinstance(result[0], int) and isinstance(result[1], int)"
            },
            {
                "description": "If the greatest common divisor (GCD) of a and b does not divide n, the equation has no integer solution, and the function must return None.",
                "assert_statement": "import math; gcd_ab = math.gcd(a, b); if gcd_ab != 0 and n % gcd_ab != 0: assert result is None"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 184,
        "Function_ID": 92,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None\n    **Function Description: ** Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If a solution is returned, it must be a tuple (x, y) of two non-negative integers.",
                "assert_statement": "if result is not None: assert isinstance(result, tuple) and len(result) == 2 and result[0] >= 0 and result[1] >= 0"
            },
            {
                "description": "If a solution (x, y) is returned, it must satisfy the equation ax + by = n.",
                "assert_statement": "if result is not None: assert a * result[0] + b * result[1] == n"
            },
            {
                "description": "If no non-negative integer solution is found, the function returns None.",
                "assert_statement": "if result is None: assert result is None"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 185,
        "Function_ID": 93,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to remove all elements from a given list present in another list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "All elements present in the removal list must be entirely absent from the resulting source list.",
                "assert_statement": "all(item not in source_list for item in remove_list)"
            },
            {
                "description": "The set of remaining elements in the source list must be equal to the set difference between the original source list and the removal list.",
                "assert_statement": "set(source_list) == set(original_source_list) - set(remove_list)"
            },
            {
                "description": "No new elements were introduced into the source list that were not originally present.",
                "assert_statement": "all(element in original_source_list for element in source_list)"
            },
            {
                "description": "The length of the resulting source list must be less than or equal to the original length.",
                "assert_statement": "len(source_list) <= len(original_source_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 186,
        "Function_ID": 93,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result\n    **Function Description: ** Write a function to remove all elements from a given list present in another list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "No element in the resulting list should be present in the second input list (list2).",
                "assert_statement": "assert all(item not in list2 for item in result)"
            },
            {
                "description": "Every element in the resulting list must originate from the first input list (list1).",
                "assert_statement": "assert all(item in list1 for item in result)"
            },
            {
                "description": "The length of the returned list must equal the count of elements in list1 that are absent from list2.",
                "assert_statement": "assert len(result) == sum(1 for x in list1 if x not in list2)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 187,
        "Function_ID": 94,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must equal the closed-form solution: n(n+2)/4 if n is even, or (n+1)^2/4 if n is odd.",
                "assert_statement": "(n % 2 == 0 and result == (n * (n + 2)) // 4) or (n % 2 != 0 and result == ((n + 1) ** 2) // 4)"
            },
            {
                "description": "If n is odd, the result must be a perfect square equal to the square of half of (n+1).",
                "assert_statement": "n % 2 != 0 and result == ((n + 1) // 2) ** 2"
            },
            {
                "description": "If n is even, the result must be the product of half of n and (half of n + 1).",
                "assert_statement": "n % 2 == 0 and result == (n // 2) * (n // 2 + 1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 188,
        "Function_ID": 94,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)\n    **Function Description: ** Write a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input 'n' is less than 1, the function returns 0 (handling the base case and negative inputs).",
                "assert_statement": "assert sum_series(0) == 0 and sum_series(-10) == 0"
            },
            {
                "description": "For any positive integer 'n', the return value is always a non-negative integer.",
                "assert_statement": "assert isinstance(sum_series(4), int) and sum_series(7) >= 0"
            },
            {
                "description": "If 'n' is positive and even (e.g., n=6), the result is the sum of positive even numbers up to n (6+4+2=12), which mathematically equals (n/2) * (n/2 + 1).",
                "assert_statement": "assert sum_series(6) == 12"
            },
            {
                "description": "If 'n' is positive and odd (e.g., n=7), the result is the sum of positive odd numbers up to n (7+5+3+1=16), which mathematically equals ((n+1)/2)^2.",
                "assert_statement": "assert sum_series(7) == 16"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 189,
        "Function_ID": 95,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to calculate the area of a regular polygon given the length and number of its sides.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated area must be a non-negative value (Area >= 0).",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The result must be mathematically equal to the standard formula for the area of a regular polygon (A = (n * s^2) / (4 * tan(pi/n))), accounting for floating point precision.",
                "assert_statement": "abs(result - ((n * s**2) / (4 * math.tan(math.pi / n)))) < 1e-9"
            },
            {
                "description": "If the polygon is a square (n=4), the calculated area must be equal to the side length squared (s^2).",
                "assert_statement": "(n != 4) or (abs(result - s**2) < 1e-9)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 190,
        "Function_ID": 95,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from math import tan, pi\ndef area_polygon(s, l):\n  area = s * (l ** 2) / (4 * tan(pi / s))\n  return area\n    **Function Description: ** Write a function to calculate the area of a regular polygon given the length and number of its sides.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a floating-point number.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "The calculated area must be non-negative (as sides and length are positive/zero).",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "Verification of the result using a known case: A square (s=4, l=5) must yield an area of 25.0.",
                "assert_statement": "import math; assert math.isclose(area_polygon(4, 5), 25.0)"
            },
            {
                "description": "If the side length (l) is zero, the calculated area must be zero.",
                "assert_statement": "assert area_polygon(3, 0) == 0.0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 191,
        "Function_ID": 96,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to determine if the sum of the divisors of two integers are the same.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the sum of the divisors of the first integer (a) must be equal to the sum of the divisors of the second integer (b).",
                "assert_statement": "result == True and sum_of_divisors(a) == sum_of_divisors(b)"
            },
            {
                "description": "If the function returns False, the sum of the divisors of the first integer (a) must not be equal to the sum of the divisors of the second integer (b).",
                "assert_statement": "result == False and sum_of_divisors(a) != sum_of_divisors(b)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 192,
        "Function_ID": 96,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); \n    **Function Description: ** Write a function to determine if the sum of the divisors of two integers are the same.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean type (True or False).",
                "assert_statement": "assert isinstance(are_equivalent(12, 18), bool)"
            },
            {
                "description": "The function returns True if and only if the sum of divisors calculation for the two numbers (via div_sum) results in the same value.",
                "assert_statement": "num1, num2 = 10, 20; expected = div_sum(num1) == div_sum(num2); assert are_equivalent(num1, num2) == expected"
            },
            {
                "description": "If the input numbers are identical, the result must be True.",
                "assert_statement": "assert are_equivalent(42, 42) == True"
            },
            {
                "description": "For two prime numbers (e.g., 13 and 17), div_sum returns 1 for both, thus the result is True.",
                "assert_statement": "assert are_equivalent(13, 17) == True"
            },
            {
                "description": "For 6 (div_sum=6) and 8 (div_sum=7), the result is False.",
                "assert_statement": "assert are_equivalent(6, 8) == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 193,
        "Function_ID": 97,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result returned by the function must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The count of matching characters must be non-negative.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The maximum possible count is 26, as there are 26 letters in the English alphabet, regardless of the input string length.",
                "assert_statement": "result <= 26"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 194,
        "Function_ID": 97,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars \n    **Function Description: ** Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer representing a count, hence non-negative.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The count of matching characters cannot exceed the total length of the input string.",
                "assert_statement": "assert result <= len(str1)"
            },
            {
                "description": "If the input string contains characters perfectly matching their 0-indexed alphabetical position (case insensitive, e.g., 'A' at 0, 'B' at 1, 'c' at 2), the count reflects this.",
                "assert_statement": "assert count_char_position(\"aB C\") == 2"
            },
            {
                "description": "If the input string contains characters that do not match their alphabetical position (e.g., 'Z' at 0, 'Y' at 1), the count must be zero.",
                "assert_statement": "assert count_char_position(\"ZYX\") == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 195,
        "Function_ID": 98,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that counts the number of pairs of integers in a list that xor to an even number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned count must equal the number of combinations of even numbers taken two at a time plus the number of combinations of odd numbers taken two at a time, since xor is even only when both numbers share the same parity.",
                "assert_statement": "evens = len([x for x in input_list if x % 2 == 0]); odds = len(input_list) - evens; expected = (evens * (evens - 1) // 2) + (odds * (odds - 1) // 2); assert result == expected"
            },
            {
                "description": "The result must be a non-negative integer and cannot exceed the total possible number of unique pairs in the list.",
                "assert_statement": "max_pairs = len(input_list) * (len(input_list) - 1) // 2; assert isinstance(result, int) and result >= 0 and result <= max_pairs"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 196,
        "Function_ID": 98,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count\n    **Function Description: ** Write a function that counts the number of pairs of integers in a list that xor to an even number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The returned count must match the total number of unique pairs in A that have the same parity (both even or both odd), as their XOR is even if and only if they share parity.",
                "assert_statement": "E = sum(1 for x in A if x % 2 == 0); O = len(A) - E; assert result == (E * (E - 1) // 2) + (O * (O - 1) // 2)"
            },
            {
                "description": "If the length of A is less than 2, the returned count must be zero.",
                "assert_statement": "assert len(A) < 2 and result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 197,
        "Function_ID": 99,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the smallest power of 2 greater than or equal to n.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must be greater than or equal to the input value n.",
                "assert_statement": "result >= n"
            },
            {
                "description": "The returned result must be a power of 2 (checked by ensuring result > 0 and only one bit is set).",
                "assert_statement": "(result > 0) and ((result & (result - 1)) == 0)"
            },
            {
                "description": "The result must be the smallest such power of 2. If the result is greater than 1, the power of 2 immediately preceding it (result / 2) must be strictly less than n.",
                "assert_statement": "n <= 1 or (result // 2) < n"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 198,
        "Function_ID": 99,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; \n    **Function Description: ** Write a python function to find the smallest power of 2 greater than or equal to n.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer and a positive power of 2.",
                "assert_statement": "assert isinstance(result, int) and result > 0 and (result & (result - 1)) == 0"
            },
            {
                "description": "The return value must be greater than or equal to the input value n.",
                "assert_statement": "assert result >= n"
            },
            {
                "description": "The return value must be the smallest power of 2 satisfying the condition. If n is positive, the previous power of 2 must be strictly less than n.",
                "assert_statement": "assert n == 0 or (result // 2) < n"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 199,
        "Function_ID": 100,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to count the number of occurrences of a number in a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be equal to the actual number of times the target appears in the input list.",
                "assert_statement": "assert result == data.count(target)"
            },
            {
                "description": "The returned count must be a non-negative number (zero or greater).",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The returned value must be of type integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "If the target is not present in the list, the count must be zero.",
                "assert_statement": "if target not in data: assert result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 200,
        "Function_ID": 100,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def frequency(a,x): \n    count = 0  \n    for i in a: \n      if i == x: \n        count += 1\n\n    return count \n    **Function Description: ** Write a function to count the number of occurrences of a number in a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The return value must exactly match the number of times element 'x' appears in list 'a'.",
                "assert_statement": "assert result == a.count(x)"
            },
            {
                "description": "The returned frequency count cannot be greater than the total number of elements in the input list 'a'.",
                "assert_statement": "assert result <= len(a)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 201,
        "Function_ID": 101,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the sum of numbers in a list within a range specified by two indices.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is equal to the sum of the elements in the input list starting at the start_index (inclusive) and ending at the end_index (exclusive), corresponding to standard Python slicing.",
                "assert_statement": "result_sum == sum(input_list[start_index:end_index])"
            },
            {
                "description": "If the start index is greater than or equal to the end index (representing an empty or inverted range), the resulting sum must be zero.",
                "assert_statement": "((start_index >= end_index) or (start_index < 0) or (end_index < 0)) implies (result_sum == 0)"
            },
            {
                "description": "The result returned by the function must be a numeric type (integer or float).",
                "assert_statement": "isinstance(result_sum, (int, float))"
            },
            {
                "description": "The length of the input list must remain unchanged after execution (no side effects on the list structure).",
                "assert_statement": "len(input_list_original) == len(input_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 202,
        "Function_ID": 101,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sum_range_list(list1, m, n):                                                                                                                                                                                                \n    sum_range = 0                                                                                                                                                                                                         \n    for i in range(m, n+1, 1):                                                                                                                                                                                        \n        sum_range += list1[i]                                                                                                                                                                                                  \n    return sum_range   \n    **Function Description: ** Write a function to find the sum of numbers in a list within a range specified by two indices.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be equal to the arithmetic sum of the elements in list1 starting from index m up to and including index n.",
                "assert_statement": "assert return_value == sum(list1[m:n+1])"
            },
            {
                "description": "The returned value must be a numerical type (integer or float), reflecting the sum of the list elements.",
                "assert_statement": "assert isinstance(return_value, (int, float))"
            },
            {
                "description": "If the index range specified by m and n leads to accessing an element outside the bounds of list1 (e.g., n >= len(list1) or m < 0), an IndexError must be raised.",
                "assert_statement": "if n >= len(list1) or m < 0: import pytest; pytest.raises(IndexError, sum_range_list, list1, m, n)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 203,
        "Function_ID": 102,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the perimeter of a regular pentagon from the length of its sides.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated perimeter must be exactly five times the length of the side (P = 5S).",
                "assert_statement": "perimeter == 5 * side_length"
            },
            {
                "description": "The perimeter must be a non-negative value, assuming the side length is non-negative.",
                "assert_statement": "perimeter >= 0"
            },
            {
                "description": "If the side length is zero, the perimeter must also be zero.",
                "assert_statement": "if side_length == 0: assert perimeter == 0"
            },
            {
                "description": "The returned value must be a numeric type (integer or float).",
                "assert_statement": "isinstance(perimeter, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 204,
        "Function_ID": 102,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math\ndef perimeter_pentagon(a):\n  perimeter=(5*a)\n  return perimeter\n    **Function Description: ** Write a function to find the perimeter of a regular pentagon from the length of its sides.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be exactly five times the input side length 'a', corresponding to the perimeter of a regular pentagon.",
                "assert_statement": "assert result == 5 * a"
            },
            {
                "description": "The returned value must be a non-negative number, as perimeter represents a physical distance.",
                "assert_statement": "assert result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 205,
        "Function_ID": 103,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to count the number of occurence of the string 'std' in a given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned count must be a non-negative integer.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "If the input string is empty, the count of 'std' must be zero.",
                "assert_statement": "assert len(input_string) == 0 implies result == 0"
            },
            {
                "description": "The result correctly matches the total number of non-overlapping occurrences of the substring 'std' within the input string.",
                "assert_statement": "assert result == count_occurrences(input_string, 'std')"
            },
            {
                "description": "If the input string contains only 'std', the count must be exactly one.",
                "assert_statement": "assert input_string == 'std' implies result == 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 206,
        "Function_ID": 103,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_occurance(s):\n  count = 0\n  for i in range(len(s) - 2):\n    if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):\n      count = count + 1\n  return count\n    **Function Description: ** Write a function to count the number of occurence of the string 'std' in a given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The return value must equal the number of occurrences of 'std' found by sliding a 3-character window across the input string s.",
                "assert_statement": "assert result == sum(1 for i in range(len(s) - 2) if s[i:i+3] == 'std')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 207,
        "Function_ID": 104,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check if all the elements in tuple have same data type or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, the set of data types found in the tuple must contain exactly one or zero elements (the zero case handles empty tuples).",
                "assert_statement": "if result: assert len(set(type(item) for item in input_tuple)) <= 1"
            },
            {
                "description": "If the function returns False, there must be at least two distinct data types in the input tuple.",
                "assert_statement": "if not result: assert len(set(type(item) for item in input_tuple)) > 1"
            },
            {
                "description": "An empty tuple should always return True (vacuously true condition).",
                "assert_statement": "if len(input_tuple) == 0: assert result is True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 208,
        "Function_ID": 104,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) \n    **Function Description: ** Write a function to check if all the elements in tuple have same data type or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must always return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, then every element in the tuple must share the exact data type of the first element, unless the tuple was empty.",
                "assert_statement": "if result: assert not test_tuple or all(type(x) is type(test_tuple[0]) for x in test_tuple)"
            },
            {
                "description": "If the function returns False, there must be at least one element in the tuple whose data type is strictly different from the data type of the first element.",
                "assert_statement": "if not result: assert any(type(x) is not type(test_tuple[0]) for x in test_tuple)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 209,
        "Function_ID": 105,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the count of the candidate element must be strictly greater than n/2.",
                "assert_statement": "if result: assert arr.count(element) > n / 2"
            },
            {
                "description": "If the function returns False, the count of the candidate element must be less than or equal to n/2.",
                "assert_statement": "if not result: assert arr.count(element) <= n / 2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 210,
        "Function_ID": 105,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1\n    **Function Description: ** Write a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the element x must occur strictly more than n/2 times in the array.",
                "assert_statement": "if __return__: assert arr.count(x) > (n / 2)"
            },
            {
                "description": "If the function returns False, the element x must occur at most n/2 times in the array.",
                "assert_statement": "if not __return__: assert arr.count(x) <= (n / 2)"
            },
            {
                "description": "The return value must be a boolean.",
                "assert_statement": "assert isinstance(__return__, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 211,
        "Function_ID": 106,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count the number of set bits (binary digits with value 1) in a given number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The result is equal to the number of set bits in the binary representation of the input number.",
                "assert_statement": "result == bin(number).count('1')"
            },
            {
                "description": "For input zero, the result is zero.",
                "assert_statement": "if number == 0: assert result == 0"
            },
            {
                "description": "The result for powers of two (1, 2, 4, 8, ...) is one.",
                "assert_statement": "if number > 0 and (number & (number - 1)) == 0: assert result == 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 212,
        "Function_ID": 106,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count \n    **Function Description: ** Write a python function to count the number of set bits (binary digits with value 1) in a given number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned count of set bits must be non-negative.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The returned value (the count of set bits) must be equal to the actual Hamming weight of the input integer n, verifiable using Python's built-in binary representation count.",
                "assert_statement": "assert result == bin(n).count('1')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 213,
        "Function_ID": 107,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to remove the characters which have odd index values of a given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting string must be composed of the characters remaining after removing those at odd indices (which is equivalent to taking every second character starting from index 0).",
                "assert_statement": "assert result == original_string[::2]"
            },
            {
                "description": "The length of the resulting string must correspond to the number of even indices in the original string (ceiling of length divided by two).",
                "assert_statement": "assert len(result) == (len(original_string) + 1) // 2"
            },
            {
                "description": "If the input string was empty, the result must also be an empty string.",
                "assert_statement": "if not original_string: assert result == ''"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 214,
        "Function_ID": 107,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result\n    **Function Description: ** Write a python function to remove the characters which have odd index values of a given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The length of the returned string must be equal to the count of even indices in the input string (which is calculated as ceiling(length(s) / 2)).",
                "assert_statement": "assert len(result) == (len(s) + 1) // 2"
            },
            {
                "description": "The returned string must be exactly equal to the concatenation of characters from the original string located at even indices (0, 2, 4, ...).",
                "assert_statement": "assert result == \"\".join(s[i] for i in range(len(s)) if i % 2 == 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 215,
        "Function_ID": 108,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find minimum of three numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned minimum value must be one of the three input numbers.",
                "assert_statement": "result == a or result == b or result == c"
            },
            {
                "description": "The returned result must be less than or equal to the first input (a).",
                "assert_statement": "result <= a"
            },
            {
                "description": "The returned result must be less than or equal to the second input (b).",
                "assert_statement": "result <= b"
            },
            {
                "description": "The returned result must be less than or equal to the third input (c).",
                "assert_statement": "result <= c"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 216,
        "Function_ID": 108,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def min_of_three(a,b,c): \n      if (a <= b) and (a <= c): \n        smallest = a \n      elif (b <= a) and (b <= c): \n        smallest = b \n      else: \n        smallest = c \n      return smallest \n    **Function Description: ** Write a function to find minimum of three numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be less than or equal to the first input 'a'.",
                "assert_statement": "assert result <= a"
            },
            {
                "description": "The returned value must be less than or equal to the second input 'b'.",
                "assert_statement": "assert result <= b"
            },
            {
                "description": "The returned value must be less than or equal to the third input 'c'.",
                "assert_statement": "assert result <= c"
            },
            {
                "description": "The returned value must be one of the original inputs (a, b, or c).",
                "assert_statement": "assert result in (a, b, c)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 217,
        "Function_ID": 109,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether all the bits are unset in the given range or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function result must be True if and only if all bits in the range [L, R] of N are unset (zero). The assertion checks if the number masked by the range L to R evaluates to zero.",
                "assert_statement": "assert result == ((N & (((1 << (R - L + 1)) - 1) << L)) == 0)"
            },
            {
                "description": "The function must always return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the function returns False, then at least one bit within the range [L, R] must be set.",
                "assert_statement": "if not result: assert (N & (((1 << (R - L + 1)) - 1) << L)) != 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 218,
        "Function_ID": 109,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False\n    **Function Description: ** Write a python function to check whether all the bits are unset in the given range or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input number `n` has all bits unset (0) within the 1-indexed range `[l, r]`, the function returns `True`.",
                "assert_statement": "assert all_Bits_Set_In_The_Given_Range(n=1, l=2, r=4) is True"
            },
            {
                "description": "If the input number `n` has any bit set (1) within the 1-indexed range `[l, r]`, the function returns `False`.",
                "assert_statement": "assert all_Bits_Set_In_The_Given_Range(n=17, l=5, r=5) is False"
            },
            {
                "description": "The function must return `True` if and only if the result of the bitwise AND operation between `n` and the calculated range mask is exactly zero.",
                "assert_statement": "mask_func = lambda l, r: (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)); n_test, l_test, r_test = 42, 3, 6; expected = (n_test & mask_func(l_test, r_test)) == 0; assert all_Bits_Set_In_The_Given_Range(n_test, l_test, r_test) == expected"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 219,
        "Function_ID": 110,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The elements from index n to the end of the array remain unchanged.",
                "assert_statement": "A_result[n:] == A_original[n:]"
            },
            {
                "description": "The content of the modified section (first n elements) is an exact permutation of the original first n elements.",
                "assert_statement": "sorted(A_result[:n]) == sorted(A_original[:n])"
            },
            {
                "description": "All negative elements within the first n positions appear before all non-negative elements within the first n positions. (Note: Non-negative includes zero and positive numbers, adhering to standard partitioning schemes where the pivot is 0).",
                "assert_statement": "neg_count = sum(1 for x in A_original[:n] if x < 0); assert all(x < 0 for x in A_result[:neg_count]) and all(x >= 0 for x in A_result[neg_count:n])"
            },
            {
                "description": "The relative order of the negative elements within the first n positions is preserved.",
                "assert_statement": "neg_original = [x for x in A_original[:n] if x < 0]; neg_result = [x for x in A_result[:n] if x < 0]; assert neg_original == neg_result"
            },
            {
                "description": "The relative order of the non-negative (positive or zero) elements within the first n positions is preserved.",
                "assert_statement": "pos_original = [x for x in A_original[:n] if x >= 0]; pos_result = [x for x in A_result[:n] if x >= 0]; assert pos_original == pos_result"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 220,
        "Function_ID": 110,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\n    **Function Description: ** Write a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The first 'n' elements of the resulting array are partitioned such that all negative numbers in the original slice precede all non-negative numbers in that slice. The partition boundary is correctly determined by the total number of negative elements originally present.",
                "assert_statement": "neg_count = sum(1 for x in arr_original[:n] if x < 0); assert all(x < 0 for x in result[:neg_count]) and all(x >= 0 for x in result[neg_count:n])"
            },
            {
                "description": "The set of elements within the first 'n' positions of the resulting array must be a permutation of the input elements in those positions, ensuring no elements are lost or altered besides position.",
                "assert_statement": "assert sorted(result[:n]) == sorted(arr_original[:n])"
            },
            {
                "description": "If the array length is greater than 'n', the elements beyond index 'n' remain unchanged.",
                "assert_statement": "assert result[n:] == arr_original[n:]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 221,
        "Function_ID": 111,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned string must contain no blank spaces.",
                "assert_statement": "result_string.count(' ') == 0"
            },
            {
                "description": "The length of the returned string must be identical to the length of the input string, as only single character replacements are performed.",
                "assert_statement": "len(result_string) == len(input_string)"
            },
            {
                "description": "The count of the replacement character in the returned string must equal the count of blank spaces in the original input string.",
                "assert_statement": "result_string.count(replacement_char) == input_string.count(' ')"
            },
            {
                "description": "All characters that were not spaces in the input must be preserved in the output string (preserving relative order).",
                "assert_statement": "\"\".join(c for c in result_string if c != replacement_char) == \"\".join(c for c in input_string if c != ' ')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 222,
        "Function_ID": 111,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def replace_blank(str1,char):\n str2 = str1.replace(' ', char)\n return str2\n    **Function Description: ** Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The returned string should not contain any blank spaces (' '), as they should have been replaced.",
                "assert_statement": "assert ' ' not in result"
            },
            {
                "description": "The length of the returned string must equal the original length minus the count of spaces, plus the count of spaces multiplied by the length of the replacement character.",
                "assert_statement": "assert len(result) == len(str1) - str1.count(' ') + (str1.count(' ') * len(char))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 223,
        "Function_ID": 112,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in a list and an integer n and returns a list containing the n largest items from the list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the returned list must be equal to n, unless the input list L is smaller than n.",
                "assert_statement": "len(result) == min(n, len(L))"
            },
            {
                "description": "The returned list must contain the n largest items from L, typically sorted in descending order.",
                "assert_statement": "result == sorted(L, reverse=True)[:min(n, len(L))]"
            },
            {
                "description": "Every element in the result list must have originated from the input list L.",
                "assert_statement": "all(item in L for item in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 224,
        "Function_ID": 112,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import heapq\ndef larg_nnum(list1,n):\n largest=heapq.nlargest(n,list1)\n return largest\n    **Function Description: ** Write a function that takes in a list and an integer n and returns a list containing the n largest items from the list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be the minimum of n and the length of the input list.",
                "assert_statement": "assert len(result) == min(n, len(list1))"
            },
            {
                "description": "The returned list contains the n largest elements from the input list, sorted in descending order.",
                "assert_statement": "assert result == sorted(list1, reverse=True)[:n]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 225,
        "Function_ID": 113,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the lateral surface area of a cylinder.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned area must be a non-negative number.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned area should be calculated as 2 * pi * radius * height.",
                "assert_statement": "result == 2 * math.pi * radius * height"
            },
            {
                "description": "If the radius is zero, the lateral surface area must be zero.",
                "assert_statement": "if radius == 0: assert result == 0"
            },
            {
                "description": "If the height is zero, the lateral surface area must be zero.",
                "assert_statement": "if height == 0: assert result == 0"
            },
            {
                "description": "The returned result must be a float type.",
                "assert_statement": "isinstance(result, float)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 226,
        "Function_ID": 113,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def lateralsuface_cylinder(r,h):\n  lateralsurface= 2*3.1415*r*h\n  return lateralsurface\n    **Function Description: ** Write a function to find the lateral surface area of a cylinder.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is the exact calculation of the lateral surface area using the formula 2 * 3.1415 * r * h.",
                "assert_statement": "assert result == 2 * 3.1415 * r * h"
            },
            {
                "description": "The return value is a numeric type (float or integer).",
                "assert_statement": "assert isinstance(result, (float, int))"
            },
            {
                "description": "The sign of the result must correspond to the sign of the product of the radius and height, as the constants used are positive.",
                "assert_statement": "assert (result >= 0) == ((r * h) >= 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 227,
        "Function_ID": 114,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the volume of a cube given its side length.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned volume must be mathematically equal to the side length cubed.",
                "assert_statement": "result == side_length ** 3"
            },
            {
                "description": "The calculated volume must be non-negative, assuming the side length is non-negative (a physical constraint).",
                "assert_statement": "result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 228,
        "Function_ID": 114,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def volume_cube(l):\n  volume = l * l * l\n  return volume\n    **Function Description: ** Write a function to find the volume of a cube given its side length.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be mathematically equal to the cube of the input side length (l * l * l).",
                "assert_statement": "assert result == l * l * l"
            },
            {
                "description": "The return value must be a numeric type (either integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "Assuming the side length l is non-negative, the resulting volume must also be non-negative.",
                "assert_statement": "assert result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 229,
        "Function_ID": 115,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to set all even bits of a given number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "All even-indexed bits (0, 2, 4, ...) in the resulting number must be set to 1.",
                "assert_statement": "(result & 0x5555555555555555) == 0x5555555555555555"
            },
            {
                "description": "All odd-indexed bits (1, 3, 5, ...) in the result must retain their original value.",
                "assert_statement": "(result & 0xAAAAAAAAAAAAAAAA) == (num & 0xAAAAAAAAAAAAAAAA)"
            },
            {
                "description": "The result must be equivalent to performing a bitwise OR operation between the original number and the mask consisting of all set even bits.",
                "assert_statement": "result == (num | 0x5555555555555555)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 230,
        "Function_ID": 115,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def even_bit_set_number(n): \n    count = 0;res = 0;temp = n \n    while(temp > 0): \n        if (count % 2 == 1): \n            res |= (1 << count)\n        count+=1\n        temp >>= 1\n    return (n | res) \n    **Function Description: ** Write a python function to set all even bits of a given number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a non-negative integer.",
                "assert_statement": "assert isinstance(__result__, int) and __result__ >= 0"
            },
            {
                "description": "The returned value must be greater than or equal to the input n, as the operation only involves setting bits.",
                "assert_statement": "assert __result__ >= n"
            },
            {
                "description": "All odd bit positions (1, 3, 5, ...) that are less than the bit length of n are guaranteed to be set (1) in the returned value.",
                "assert_statement": "assert all(((__result__ >> i) & 1) == 1 for i in range(1, n.bit_length(), 2))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 231,
        "Function_ID": 116,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a dictionary.",
                "assert_statement": "isinstance(result, dict)"
            },
            {
                "description": "The set of keys in the resulting dictionary must exactly match the set of unique tuples present in the input list.",
                "assert_statement": "set(result.keys()) == set(input_list)"
            },
            {
                "description": "For every key (tuple) in the result, its corresponding value must be the count of that tuple's occurrence in the original input list.",
                "assert_statement": "all(result[key] == input_list.count(key) for key in result)"
            },
            {
                "description": "The total sum of all values (counts) in the dictionary must equal the length of the original input list.",
                "assert_statement": "sum(result.values()) == len(input_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 232,
        "Function_ID": 116,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from collections import Counter \ndef check_occurences(test_list):\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\n  return  (res) \n    **Function Description: ** Write a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a dictionary.",
                "assert_statement": "assert isinstance(result, dict)"
            },
            {
                "description": "The sum of all occurrence counts (dictionary values) must equal the total number of elements in the input list.",
                "assert_statement": "assert sum(result.values()) == len(test_list)"
            },
            {
                "description": "All keys in the resulting dictionary must be tuples, and these tuples must be in canonical sorted order based on their elements.",
                "assert_statement": "assert all(isinstance(k, tuple) and all(k[i] <= k[i+1] for i in range(len(k) - 1)) for k in result.keys())"
            },
            {
                "description": "For any non-empty input, all counts (values) must be integers greater than or equal to one.",
                "assert_statement": "assert all(isinstance(v, int) and v >= 1 for v in result.values())"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 233,
        "Function_ID": 117,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count the number of non-empty substrings of a given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be an integer, as it represents a count.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The count of non-empty substrings must be non-negative.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The result must equal the mathematically required number of substrings for a string of length N: N * (N + 1) / 2.",
                "assert_statement": "result == len(s) * (len(s) + 1) // 2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 234,
        "Function_ID": 117,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def number_of_substrings(str): \n\tstr_len = len(str); \n\treturn int(str_len * (str_len + 1) / 2); \n    **Function Description: ** Write a python function to count the number of non-empty substrings of a given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned count of substrings must be non-negative.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The number of substrings must equal L * (L + 1) / 2, where L is the length of the input string.",
                "assert_statement": "L = len(str); expected = (L * (L + 1)) // 2; assert result == expected"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 235,
        "Function_ID": 118,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a non-negative integer count, as it represents the number of valid sequences.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the maximum element 'm' is too small to accommodate a sequence of length 'n' (even starting with the minimum value 1), the number of sequences must be zero. (The minimum possible last element is 2^(n-1) assuming a starting element of 1).",
                "assert_statement": "if n > 0 and m < (2**(n - 1)): assert result == 0"
            },
            {
                "description": "For the specific case where m=5 and n=2, the number of possible sequences is 6: (1, 2), (1, 3), (1, 4), (1, 5), (2, 4), (2, 5).",
                "assert_statement": "if m == 5 and n == 2: assert result == 6"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 236,
        "Function_ID": 118,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def get_total_number_of_sequences(m,n): \n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \n\tfor i in range(m+1): \n\t\tfor j in range(n+1): \n\t\t\tif i==0 or j==0: \n\t\t\t\tT[i][j]=0\n\t\t\telif i<j: \n\t\t\t\tT[i][j]=0\n\t\t\telif j==1: \n\t\t\t\tT[i][j]=i \n\t\t\telse: \n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \n\treturn T[m][n]\n    **Function Description: ** Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer, as it represents a count of sequences.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the maximum element limit m is less than the required sequence length n, the number of valid sequences is 0 (e.g., m=1, n=2).",
                "assert_statement": "assert get_total_number_of_sequences(1, 2) == 0"
            },
            {
                "description": "Verification of a known non-trivial case: for m=10 and n=3, the total number of sequences is 20.",
                "assert_statement": "assert get_total_number_of_sequences(10, 3) == 20"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 237,
        "Function_ID": 119,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in two lists and replaces the last element of the first list with the elements of the second list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The new length of the first list must equal the original length minus one (for the removed element) plus the length of the second list.",
                "assert_statement": "len(list1) == len(original_list1) - 1 + len(list2)"
            },
            {
                "description": "All elements of the first list, up to the index where the replacement occurred, must remain unchanged.",
                "assert_statement": "list1[:len(original_list1) - 1] == original_list1[:-1]"
            },
            {
                "description": "The segment of the first list beginning at the replacement point (where the last original element was) must exactly match the contents of the second list.",
                "assert_statement": "list1[len(original_list1) - 1:] == list2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 238,
        "Function_ID": 119,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n\n    **Function Description: ** Write a function that takes in two lists and replaces the last element of the first list with the elements of the second list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list instance.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The function must modify the input list1 in place and return a reference to it.",
                "assert_statement": "assert result is list1"
            },
            {
                "description": "If the original list1 was non-empty, the length of the resulting list must equal the original length of list1 minus one, plus the length of list2.",
                "assert_statement": "if old_len1 > 0: assert len(result) == old_len1 - 1 + len(list2_copy)"
            },
            {
                "description": "The starting elements of the resulting list must match the prefix of the original list1 (excluding the last element).",
                "assert_statement": "if old_len1 > 0: assert result[:old_len1 - 1] == prefix"
            },
            {
                "description": "The tail of the resulting list must consist entirely of the elements from the second input list (list2).",
                "assert_statement": "if old_len1 > 0: assert result[old_len1 - 1:] == list2_copy"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 239,
        "Function_ID": 120,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to count the total number of characters in a string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must equal the exact length (number of characters) of the input string.",
                "assert_statement": "result == len(input_string)"
            },
            {
                "description": "The result, being a count, must be a non-negative integer.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned value must be of an integer type.",
                "assert_statement": "isinstance(result, int)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 240,
        "Function_ID": 120,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_charac(str1):\n total = 0\n for i in str1:\n    total = total + 1\n return total\n    **Function Description: ** Write a function to count the total number of characters in a string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be equal to the length of the input string 'str1'.",
                "assert_statement": "assert result == len(str1)"
            },
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned count must be greater than or equal to zero.",
                "assert_statement": "assert result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 241,
        "Function_ID": 121,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the next perfect square greater than a given number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value (result) is strictly greater than the input number (n).",
                "assert_statement": "result > n"
            },
            {
                "description": "The return value (result) must be a perfect square (i.e., its integer square root squared equals itself).",
                "assert_statement": "math.isqrt(result) ** 2 == result"
            },
            {
                "description": "The return value is the *next* perfect square, meaning the previous perfect square is less than or equal to the input (n).",
                "assert_statement": "(math.isqrt(result) - 1) ** 2 <= n"
            },
            {
                "description": "The return value is a positive integer.",
                "assert_statement": "isinstance(result, int) and result > 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 242,
        "Function_ID": 121,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN \n    **Function Description: ** Write a python function to find the next perfect square greater than a given number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be strictly greater than the input N.",
                "assert_statement": "assert result > N"
            },
            {
                "description": "The returned value is an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned value must be the smallest perfect square greater than N. This is verified by ensuring the previous perfect square is less than or equal to N.",
                "assert_statement": "import math; assert (int(math.sqrt(result)) - 1)**2 <= N"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 243,
        "Function_ID": 122,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result is a numeric type (integer or float).",
                "assert_statement": "isinstance(result, (int, float))"
            },
            {
                "description": "If the input array is empty, the maximum sum of any subsequence (including bitonic) must be zero.",
                "assert_statement": "len(arr) == 0 and result == 0"
            },
            {
                "description": "If the array is not empty, the resulting maximum sum must be at least the value of the largest single element, as any single element forms a trivial bitonic subsequence.",
                "assert_statement": "len(arr) > 0 and result >= max(arr)"
            },
            {
                "description": "The calculated maximum sum of the bitonic subsequence cannot exceed the total sum of all elements in the input array.",
                "assert_statement": "result <= sum(arr)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 244,
        "Function_ID": 122,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_sum(arr): \n\tMSIBS = arr[:] \n\tfor i in range(len(arr)): \n\t\tfor j in range(0, i): \n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \n\tMSDBS = arr[:] \n\tfor i in range(1, len(arr) + 1): \n\t\tfor j in range(1, i): \n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \n\tmax_sum = float(\"-Inf\") \n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \n\t\tmax_sum = max(max_sum, i + j - k) \n\treturn max_sum\n    **Function Description: ** Write a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must be a numerical type (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "If the input array is empty, the maximum sum bitonic subsequence is negative infinity.",
                "assert_statement": "if len(arr) == 0: assert result == float(\"-Inf\")"
            },
            {
                "description": "If the input array is non-empty, the returned maximum sum must be greater than or equal to the maximum single element in the array, as any single element forms a trivial bitonic subsequence.",
                "assert_statement": "if len(arr) > 0: assert result >= max(arr)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 245,
        "Function_ID": 123,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function for computing square roots using the babylonian method.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The square of the computed result must be within the specified tolerance (epsilon) of the original input number.",
                "assert_statement": "abs(result * result - n) < epsilon"
            },
            {
                "description": "The computed square root must be non-negative (representing the principal square root).",
                "assert_statement": "result >= 0"
            },
            {
                "description": "If the input number is zero, the result must be exactly zero (requiring no tolerance check for this specific edge case).",
                "assert_statement": "n == 0 and result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 246,
        "Function_ID": 123,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def babylonian_squareroot(number):\n    if(number == 0):\n        return 0;\n    g = number/2.0;\n    g2 = g + 1;\n    while(g != g2):\n        n = number/ g;\n        g2 = g;\n        g = (g + n)/2;\n    return g;\n    **Function Description: ** Write a function for computing square roots using the babylonian method.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is an accurate approximation of the square root of the input number, verified by checking if the square of the result is close to the input number within a small floating-point tolerance (1e-9).",
                "assert_statement": "abs(result * result - number) < 1e-9"
            },
            {
                "description": "The returned value, representing the principal square root, must be non-negative.",
                "assert_statement": "result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 247,
        "Function_ID": 124,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the length of the longest palindromic subsequence in the given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned length must be a non-negative integer.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The length of any subsequence cannot exceed the length of the original string.",
                "assert_statement": "result <= len(s)"
            },
            {
                "description": "If the input string is empty, the length of the longest palindromic subsequence must be zero.",
                "assert_statement": "if not s: assert result == 0"
            },
            {
                "description": "The returned value must accurately represent the length of the LONGEST palindromic subsequence, verified against a trusted reference implementation or property checker.",
                "assert_statement": "result == reference_lps_calculator(s)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 248,
        "Function_ID": 124,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def lps(str): \n\tn = len(str) \n\tL = [[0 for x in range(n)] for x in range(n)] \n\tfor i in range(n): \n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1): \n\t\tfor i in range(n-cl+1): \n\t\t\tj = i+cl-1\n\t\t\tif str[i] == str[j] and cl == 2: \n\t\t\t\tL[i][j] = 2\n\t\t\telif str[i] == str[j]: \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse: \n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\treturn L[0][n-1]\n    **Function Description: ** Write a function to find the length of the longest palindromic subsequence in the given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the Longest Palindromic Subsequence (LPS) must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The length of the LPS cannot exceed the length of the input string.",
                "assert_statement": "assert result <= len(str)"
            },
            {
                "description": "If the input string is itself a palindrome, the length of the LPS must equal the length of the input string.",
                "assert_statement": "assert (str != str[::-1]) or (result == len(str))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 249,
        "Function_ID": 125,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in an integer n and calculates the harmonic sum of n-1.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a float, as the harmonic sum involves floating-point arithmetic (division by integers).",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "If the input integer n is less than or equal to 1, the upper bound of the sum (n-1) is non-positive, and the harmonic sum should be 0 (representing H_0).",
                "assert_statement": "assert n > 1 or result == 0.0"
            },
            {
                "description": "For inputs n greater than 1, the result must be mathematically equivalent to the sum of the reciprocals of integers from 1 up to n-1.",
                "assert_statement": "assert n <= 1 or math.isclose(result, sum(1/k for k in range(1, n)))"
            },
            {
                "description": "The result, being a sum of positive terms (for n > 1), must always be non-negative.",
                "assert_statement": "assert result >= 0.0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 250,
        "Function_ID": 125,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def harmonic_sum(n):\n  if n < 2:\n    return 1\n  else:\n    return 1 / n + (harmonic_sum(n - 1)) \n    **Function Description: ** Write a function that takes in an integer n and calculates the harmonic sum of n-1.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a floating-point number.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "For n=2, the calculated harmonic sum (1 + 1/2) must equal 1.5.",
                "assert_statement": "assert n == 2 and result == 1.5"
            },
            {
                "description": "If n is a positive integer, the calculated harmonic sum must be greater than or equal to 1.0 (since H_1=1 and H_n is increasing).",
                "assert_statement": "assert n >= 1 and result >= 1.0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 251,
        "Function_ID": 126,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the intersection of two arrays.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "Every element present in the resulting intersection must also be present in the first input array.",
                "assert_statement": "all(elem in arr1 for elem in result)"
            },
            {
                "description": "Every element present in the resulting intersection must also be present in the second input array.",
                "assert_statement": "all(elem in arr2 for elem in result)"
            },
            {
                "description": "The resulting array is exactly equal to the theoretical set intersection of the two input arrays (ensuring completeness and correctness).",
                "assert_statement": "set(result) == (set(arr1) & set(arr2))"
            },
            {
                "description": "The resulting intersection array must not contain duplicate elements (assuming a standard set intersection).",
                "assert_statement": "len(result) == len(set(result))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 252,
        "Function_ID": 126,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result\n    **Function Description: ** Write a function to find the intersection of two arrays.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "Every unique element in the resulting list must be present in both input arrays (set intersection property).",
                "assert_statement": "assert set(result).issubset(set(array_nums1)) and set(result).issubset(set(array_nums2))"
            },
            {
                "description": "The resulting list must exactly match the elements of array_nums2 that are present in array_nums1, preserving order and frequency as dictated by the function's filtering logic.",
                "assert_statement": "assert result == [x for x in array_nums2 if x in array_nums1]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 253,
        "Function_ID": 127,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function that takes in a tuple and an element and counts the occcurences of the element in the tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value, representing the count, must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The count of occurrences must be non-negative (zero or greater).",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned count must exactly equal the actual number of times the element appears in the tuple.",
                "assert_statement": "result == input_tuple.count(target_element)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 254,
        "Function_ID": 127,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_X(tup, x): \n    count = 0\n    for ele in tup: \n        if (ele == x): \n            count = count + 1\n    return count \n    **Function Description: ** Write a python function that takes in a tuple and an element and counts the occcurences of the element in the tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The returned count must be exactly equal to the number of times 'x' appears in the input tuple 'tup'.",
                "assert_statement": "assert result == tup.count(x)"
            },
            {
                "description": "The returned count cannot exceed the total number of elements in the input tuple 'tup'.",
                "assert_statement": "assert result <= len(tup)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 255,
        "Function_ID": 128,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting list must be exactly twice the length of the input list.",
                "assert_statement": "len(result_list) == 2 * len(input_list)"
            },
            {
                "description": "All elements at even indices in the resulting list (the inserted positions) must be equal to the inserted element.",
                "assert_statement": "all(result_list[i] == element for i in range(0, len(result_list), 2))"
            },
            {
                "description": "The subsequence of the resulting list formed by the elements at odd indices (the original list elements) must be equal to the original input list.",
                "assert_statement": "result_list[1::2] == input_list"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 256,
        "Function_ID": 128,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def insert_element(list,element):\n list = [v for elt in list for v in (element, elt)]\n return list\n    **Function Description: ** Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be exactly double the length of the input list.",
                "assert_statement": "assert len(result) == 2 * len(input_list)"
            },
            {
                "description": "Every element at an even index (0, 2, 4, ...) in the returned list must be equal to the inserted element.",
                "assert_statement": "assert all(result[i] == element for i in range(0, len(result), 2))"
            },
            {
                "description": "Every element at an odd index (1, 3, 5, ...) in the returned list must correspond sequentially to the elements of the original input list.",
                "assert_statement": "assert all(result[i] == input_list[i // 2] for i in range(1, len(result), 2))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 257,
        "Function_ID": 129,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to convert complex numbers to polar coordinates.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a tuple or list containing exactly two elements: magnitude (r) and phase (phi).",
                "assert_statement": "assert isinstance(result, (tuple, list)) and len(result) == 2"
            },
            {
                "description": "The magnitude (r) must be a non-negative real number.",
                "assert_statement": "assert result[0] >= 0"
            },
            {
                "description": "The phase angle (phi) must be within the standard principal value range, typically $(-\\pi, \\pi]$ radians.",
                "assert_statement": "assert -math.pi < result[1] <= math.pi"
            },
            {
                "description": "Converting the resulting polar coordinates back to a complex number yields the original input complex number 'z', accounting for floating point precision.",
                "assert_statement": "assert math.isclose(z.real, result[0] * math.cos(result[1])) and math.isclose(z.imag, result[0] * math.sin(result[1]))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 258,
        "Function_ID": 129,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import cmath  \ndef convert(numbers):    \n  num = cmath.polar(numbers)  \n  return (num) \n    **Function Description: ** Write a python function to convert complex numbers to polar coordinates.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple of exactly two elements (magnitude and phase), where both elements are floating-point numbers.",
                "assert_statement": "assert isinstance(result, tuple) and len(result) == 2 and isinstance(result[0], float) and isinstance(result[1], float)"
            },
            {
                "description": "The magnitude (first element) must be non-negative.",
                "assert_statement": "assert result[0] >= 0.0"
            },
            {
                "description": "The phase angle (second element) must be within the standardized range (-pi, pi].",
                "assert_statement": "import cmath; assert -cmath.pi < result[1] <= cmath.pi"
            },
            {
                "description": "The original complex number can be accurately reconstructed using the returned magnitude and phase.",
                "assert_statement": "import cmath; assert cmath.isclose(cmath.rect(result[0], result[1]), numbers)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 259,
        "Function_ID": 130,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function that returns the number of integer elements in a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer type.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The count of integers must be non-negative.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned count must exactly match the number of elements in the input list that are instances of the integer type.",
                "assert_statement": "result == sum(1 for item in input_list if isinstance(item, int))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 260,
        "Function_ID": 130,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr\n    **Function Description: ** Write a python function that returns the number of integer elements in a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is always an integer, representing the count.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The count of elements must be non-negative.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The return value must equal the number of elements in the input list that are instances of type int (note: this includes boolean values True and False).",
                "assert_statement": "assert result == sum(1 for i in list1 if isinstance(i, int))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 261,
        "Function_ID": 131,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a tuple for each combination.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "Every element in the resulting list must be a tuple.",
                "assert_statement": "all(isinstance(combination, tuple) for combination in result)"
            },
            {
                "description": "Every resulting tuple must have the specified length 'n'.",
                "assert_statement": "all(len(combination) == N for combination in result)"
            },
            {
                "description": "All elements within the generated tuples must belong to the original input list.",
                "assert_statement": "allowed_elements = set(L); all(element in allowed_elements for combination in result for element in combination)"
            },
            {
                "description": "The total number of combinations generated must match the mathematical formula for combinations with replacement: C(k + n - 1, n), where k is len(L).",
                "assert_statement": "import math; k = len(L); expected_count = math.comb(k + N - 1, N); len(result) == expected_count"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 262,
        "Function_ID": 131,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from itertools import combinations_with_replacement \ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l,n))\n\n    **Function Description: ** Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a tuple for each combination.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "Every element in the returned list must be a tuple whose length is exactly equal to the input length n.",
                "assert_statement": "assert all(isinstance(combo, tuple) and len(combo) == n for combo in result)"
            },
            {
                "description": "All elements contained within the resulting combinations must originate from the input list l.",
                "assert_statement": "assert all(item in l for combo in result for item in combo)"
            },
            {
                "description": "If the requested combination length n is zero, the function must return a list containing a single empty tuple.",
                "assert_statement": "if n == 0: assert result == [()]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 263,
        "Function_ID": 132,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a non-negative integer, as it represents a count.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input number is 2 or less (0, 1, or 2), the count of primes less than the input must be zero.",
                "assert_statement": "if n <= 2: assert result == 0"
            },
            {
                "description": "A specific known count check: For an input of 10, the count of primes (2, 3, 5, 7) must be 4.",
                "assert_statement": "if n == 10: assert result == 4"
            },
            {
                "description": "A specific known count check: For an input of 20, the count of primes (2, 3, 5, 7, 11, 13, 17, 19) must be 8.",
                "assert_statement": "if n == 20: assert result == 8"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 264,
        "Function_ID": 132,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_Primes_nums(n):\n    ctr = 0\n    for num in range(n):\n        if num <= 1:\n            continue\n        for i in range(2,num):\n            if (num % i) == 0:\n                break\n        else:\n            ctr += 1\n    return ctr\n    **Function Description: ** Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "For inputs n <= 2, the count of primes must be zero.",
                "assert_statement": "assert count_Primes_nums(0) == 0 and count_Primes_nums(1) == 0 and count_Primes_nums(2) == 0"
            },
            {
                "description": "The function correctly counts the number of primes less than 17 (2, 3, 5, 7, 11, 13), which is 6.",
                "assert_statement": "assert count_Primes_nums(17) == 6"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 265,
        "Function_ID": 133,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in two numbers and returns a tuple with the second number and then the first number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The returned tuple must contain exactly two elements.",
                "assert_statement": "assert len(result) == 2"
            },
            {
                "description": "The first element of the returned tuple must be the second input number.",
                "assert_statement": "assert result[0] == num2"
            },
            {
                "description": "The second element of the returned tuple must be the first input number.",
                "assert_statement": "assert result[1] == num1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 266,
        "Function_ID": 133,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def swap_numbers(a,b):\n temp = a\n a = b\n b = temp\n return (a,b)\n    **Function Description: ** Write a function that takes in two numbers and returns a tuple with the second number and then the first number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The returned tuple must contain exactly two elements.",
                "assert_statement": "assert len(result) == 2"
            },
            {
                "description": "The first element of the returned tuple (result[0]) must be equal to the original value of the second argument (b).",
                "assert_statement": "assert result[0] == b"
            },
            {
                "description": "The second element of the returned tuple (result[1]) must be equal to the original value of the first argument (a).",
                "assert_statement": "assert result[1] == a"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 267,
        "Function_ID": 134,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to maximize the given two tuples.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a tuple.",
                "assert_statement": "isinstance(result, tuple)"
            },
            {
                "description": "The resulting tuple contains all elements from the two input tuples combined.",
                "assert_statement": "sorted(list(result)) == sorted(list(t1) + list(t2))"
            },
            {
                "description": "The resulting tuple is ordered (maximized usually implies sorting in ascending order).",
                "assert_statement": "list(result) == sorted(result)"
            },
            {
                "description": "The length of the resulting tuple is equal to the sum of the lengths of the two input tuples.",
                "assert_statement": "len(result) == len(t1) + len(t2)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 268,
        "Function_ID": 134,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \n    **Function Description: ** Write a function to maximize the given two tuples.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a nested tuple (tuple of tuples).",
                "assert_statement": "assert isinstance(res, tuple) and all(isinstance(t, tuple) for t in res)"
            },
            {
                "description": "The structure of the resulting tuple matches the structure of the input tuples (assuming equal input lengths).",
                "assert_statement": "assert len(res) == len(test_tup1) and all(len(res[i]) == len(test_tup1[i]) for i in range(len(res)))"
            },
            {
                "description": "Each element in the resulting tuple is the maximum of the corresponding elements from the two input tuples.",
                "assert_statement": "assert all(res[i][j] == max(test_tup1[i][j], test_tup2[i][j]) for i in range(len(res)) for j in range(len(res[i])))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 269,
        "Function_ID": 135,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the nth newmanshankswilliams prime number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The result must be a prime number.",
                "assert_statement": "is_prime(result)"
            },
            {
                "description": "The result must be a term that belongs to the NewmanShanksWilliams sequence.",
                "assert_statement": "is_nsw_number(result)"
            },
            {
                "description": "The result must be greater than or equal to the NSW prime indexed at n-1 (if n > 1).",
                "assert_statement": "n == 1 or result > find_nth_nsw_prime(n - 1)"
            },
            {
                "description": "The count of all NewmanShanksWilliams primes strictly smaller than the result must be exactly n-1.",
                "assert_statement": "count_nsw_primes_less_than(result) == n - 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 270,
        "Function_ID": 135,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def newman_prime(n): \n\tif n == 0 or n == 1: \n\t\treturn 1\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)\n    **Function Description: ** Write a function to find the nth newmanshankswilliams prime number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input n is 0, the function must return the base case value of 1.",
                "assert_statement": "assert newman_prime(0) == 1"
            },
            {
                "description": "The function correctly calculates the 4th term of the sequence (n=4) based on the defined recurrence relation, resulting in 17.",
                "assert_statement": "assert newman_prime(4) == 17"
            },
            {
                "description": "The return value must always be an integer, as defined by the arithmetic operations on integer inputs.",
                "assert_statement": "assert isinstance(newman_prime(5), int)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 271,
        "Function_ID": 136,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting output structure must be equal to the length of the input tuples.",
                "assert_statement": "len(result) == len(tuple1)"
            },
            {
                "description": "Each element in the result should be the quotient of the corresponding elements from the first tuple divided by the second tuple.",
                "assert_statement": "all(result[i] == tuple1[i] / tuple2[i] for i in range(len(result)))"
            },
            {
                "description": "The function must raise a ZeroDivisionError if any element in the second tuple (the denominator) is zero.",
                "assert_statement": "pytest.raises(ZeroDivisionError, func, tuple1, tuple_with_zero)"
            },
            {
                "description": "If the input tuples have unequal lengths, the function must raise a ValueError.",
                "assert_statement": "pytest.raises(ValueError, func, short_tuple, long_tuple)"
            },
            {
                "description": "The result structure must contain numeric elements (typically floats, as division often produces floating-point numbers).",
                "assert_statement": "all(isinstance(x, (int, float)) for x in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 272,
        "Function_ID": 136,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def division_elements(test_tup1, test_tup2):\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) \n    **Function Description: ** Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the returned tuple is equal to the minimum length of the two input tuples, due to the use of zip.",
                "assert_statement": "assert len(result) == min(len(test_tup1), len(test_tup2))"
            },
            {
                "description": "Each element in the result tuple is the result of element-wise integer division (floor division) of the corresponding elements from the input tuples.",
                "assert_statement": "t1 = (25, 17, 9); t2 = (5, 4, 2); result = division_elements(t1, t2); expected = (5, 4, 4); assert result == expected"
            },
            {
                "description": "If any element in the second input tuple (divisor) is zero, the execution of the function must raise a ZeroDivisionError.",
                "assert_statement": "import pytest; pytest.raises(ZeroDivisionError, division_elements, (1, 1), (1, 0))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 273,
        "Function_ID": 137,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a tuple containing exactly two elements.",
                "assert_statement": "isinstance(result, tuple) and len(result) == 2"
            },
            {
                "description": "The length of the first resulting list (result[0]) must be equal to the specified split length L.",
                "assert_statement": "len(result[0]) == L"
            },
            {
                "description": "The length of the second resulting list (result[1]) must be the remainder of the original list length minus L.",
                "assert_statement": "len(result[1]) == len(input_list) - L"
            },
            {
                "description": "Concatenating the two resulting lists must exactly match the original input list, ensuring no loss or corruption of data.",
                "assert_statement": "result[0] + result[1] == input_list"
            },
            {
                "description": "Both elements within the resulting tuple must be lists.",
                "assert_statement": "isinstance(result[0], list) and isinstance(result[1], list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 274,
        "Function_ID": 137,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def split_two_parts(list1, L):\n    return list1[:L], list1[L:]\n    **Function Description: ** Write a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a tuple containing exactly two elements, representing the two split parts.",
                "assert_statement": "assert isinstance(result, tuple) and len(result) == 2"
            },
            {
                "description": "The concatenation of the first and second resulting lists must exactly reconstruct the original input list.",
                "assert_statement": "assert result[0] + result[1] == list1"
            },
            {
                "description": "The first resulting list must be equivalent to slicing the input list from the beginning up to the index L.",
                "assert_statement": "assert result[0] == list1[:L]"
            },
            {
                "description": "The sum of the lengths of the two resulting lists must equal the length of the original input list.",
                "assert_statement": "assert len(result[0]) + len(result[1]) == len(list1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 275,
        "Function_ID": 138,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to calculate a dog's age in dog's years.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated dog age must be a non-negative number.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "If the input human age is between zero and two years (exclusive), the conversion rate is 10.5 dog years per human year.",
                "assert_statement": "if human_years > 0 and human_years < 2: result == human_years * 10.5"
            },
            {
                "description": "If the input human age is exactly two years, the dog age must be 21.",
                "assert_statement": "if human_years == 2: result == 21"
            },
            {
                "description": "If the input human age is greater than two years, the calculation must follow the standard formula (21 plus 4 dog years for every year beyond the second).",
                "assert_statement": "if human_years > 2: result == 21 + (human_years - 2) * 4"
            },
            {
                "description": "If the input age is zero, the dog age must also be zero.",
                "assert_statement": "if human_years == 0: result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 276,
        "Function_ID": 138,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def dog_age(h_age):\n if h_age < 0:\n \texit()\n elif h_age <= 2:\n\t d_age = h_age * 10.5\n else:\n\t d_age = 21 + (h_age - 2)*4\n return d_age\n    **Function Description: ** Write a function to calculate a dog's age in dog's years.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value (dog age) is always a non-negative floating-point number when the input is non-negative.",
                "assert_statement": "assert isinstance(result, float) and result >= 0.0"
            },
            {
                "description": "If the human age is less than or equal to 2, the result must equal h_age multiplied by 10.5 (e.g., age 2 must be 21.0).",
                "assert_statement": "assert dog_age(2) == 21.0"
            },
            {
                "description": "If the human age is greater than 2, the result must follow the formula 21 + (h_age - 2) * 4 (e.g., age 5 must be 33.0).",
                "assert_statement": "assert dog_age(5) == 33.0"
            },
            {
                "description": "If the human age is 0, the dog age must be 0.0.",
                "assert_statement": "assert dog_age(0) == 0.0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 277,
        "Function_ID": 139,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is a list containing only lists (a list of lists).",
                "assert_statement": "isinstance(result, list) and all(isinstance(sublist, list) for sublist in result)"
            },
            {
                "description": "The concatenation of all resulting sub-lists must exactly match the original input list, ensuring completeness and order.",
                "assert_statement": "[item for sublist in result for item in sublist] == input_list"
            },
            {
                "description": "The length of every resulting sub-list must be less than or equal to n.",
                "assert_statement": "all(len(sublist) <= n for sublist in result)"
            },
            {
                "description": "If the input list is empty, the result must be an empty list.",
                "assert_statement": "if not input_list: assert result == []"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 278,
        "Function_ID": 139,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def list_split(S, step):\n    return [S[i::step] for i in range(step)]\n    **Function Description: ** Write a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value R is a list whose length equals the input parameter 'step', assuming step is positive.",
                "assert_statement": "assert isinstance(R, list) and len(R) == step"
            },
            {
                "description": "The total count of elements across all sublists in R equals the length of the original input list S.",
                "assert_statement": "assert sum(len(sublist) for sublist in R) == len(S)"
            },
            {
                "description": "The element integrity is maintained: an element S[i] is correctly placed at R[i % step][i // step] across all indices i in S (assuming step > 0).",
                "assert_statement": "assert all(S[i] == R[i % step][i // step] for i in range(len(S)))"
            },
            {
                "description": "If the step size is zero, a ValueError must be raised due to invalid slicing stride.",
                "assert_statement": "import pytest; with pytest.raises(ValueError): list_split([1, 2, 3], 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 279,
        "Function_ID": 140,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the lateral surface area of a cube given its side length.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated result must be equal to four times the square of the side length (4 * side_length^2).",
                "assert_statement": "result == 4 * (side_length ** 2)"
            },
            {
                "description": "The calculated lateral surface area must be non-negative, as side length cannot be negative in geometric context.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "If the side length is zero, the lateral surface area must be zero.",
                "assert_statement": "side_length == 0 implies result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 280,
        "Function_ID": 140,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def lateralsurface_cube(l):\n  LSA = 4 * (l * l)\n  return LSA\n    **Function Description: ** Write a function to find the lateral surface area of a cube given its side length.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must equal four times the square of the input side length l.",
                "assert_statement": "assert lateralsurface_cube(l) == 4 * (l ** 2)"
            },
            {
                "description": "The returned value, representing an area, must be a non-negative number (assuming l is real).",
                "assert_statement": "assert lateralsurface_cube(l) >= 0"
            },
            {
                "description": "The return value must be a numerical type (integer or float).",
                "assert_statement": "assert isinstance(lateralsurface_cube(l), (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 281,
        "Function_ID": 141,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is an integer.",
                "assert_statement": "isinstance(_, int)"
            },
            {
                "description": "The returned sum must be non-negative.",
                "assert_statement": "_ >= 0"
            },
            {
                "description": "The returned value equals the closed-form sum of the squares of the first n odd natural numbers, where the sum is calculated as n * (2n - 1) * (2n + 1) / 3. (If n is non-positive, the sum is 0).",
                "assert_statement": "_ == max(0, n) * (2 * max(0, n) - 1) * (2 * max(0, n) + 1) // 3"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 282,
        "Function_ID": 141,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def square_Sum(n):  \n    return int(n*(4*n*n-1)/3) \n    **Function Description: ** Write a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer, as specified by the function's explicit casting.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "If the input n is a non-negative integer (representing a count of items), the sum of squares must be non-negative.",
                "assert_statement": "assert result >= 0 if n >= 0 else True"
            },
            {
                "description": "The function correctly calculates the sum of the squares of the first n odd numbers, verified specifically for n=3 (1^2 + 3^2 + 5^2 = 35).",
                "assert_statement": "assert result == 35 if n == 3 else True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 283,
        "Function_ID": 142,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the n'th star number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must exactly match the mathematical formula for the n'th star number (6n(n-1) + 1).",
                "assert_statement": "result == 6 * n * (n - 1) + 1"
            },
            {
                "description": "The result must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The star number must be a positive integer (since the function typically assumes n >= 1).",
                "assert_statement": "result >= 1"
            },
            {
                "description": "If the input n is 2, the result must be 13 (a specific test case verification).",
                "assert_statement": "n != 2 or result == 13"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 284,
        "Function_ID": 142,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_star_num(n): \n\treturn (6 * n * (n - 1) + 1) \n    **Function Description: ** Write a function to find the n'th star number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The return value must be equal to the definition of the n'th star number: 6 * n * (n - 1) + 1.",
                "assert_statement": "assert result == (6 * n * (n - 1) + 1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 285,
        "Function_ID": 143,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the ascii value of a character.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer, as ASCII values are numeric.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned value must be non-negative, as ASCII/Unicode values start at zero.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "For a standard ASCII character like 'A', the returned value must be the corresponding ASCII code (65).",
                "assert_statement": "assert result == 65"
            },
            {
                "description": "The calculated ASCII value must correctly match the result of the standard built-in 'ord' function for the given input character.",
                "assert_statement": "assert result == ord(input_char)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 286,
        "Function_ID": 143,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def ascii_value(k):\n  ch=k\n  return ord(ch)\n    **Function Description: ** Write a function to find the ascii value of a character.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned integer value must be equal to the ordinal (ASCII/Unicode) value of the input character k.",
                "assert_statement": "assert result == ord(k)"
            },
            {
                "description": "If the input k is a string of length greater than 1, a ValueError must be raised by the underlying ord() function.",
                "assert_statement": "pytest.raises(ValueError, ascii_value, \"AB\")"
            },
            {
                "description": "If the input k is an empty string, a ValueError must be raised by the underlying ord() function.",
                "assert_statement": "pytest.raises(ValueError, ascii_value, \"\")"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 287,
        "Function_ID": 144,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the sum of even numbers at even positions of a list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns the correct sum when multiple even numbers are found at even indices (0, 2, 4...).",
                "assert_statement": "assert result == 12 if input_list == [4, 1, 8, 2, 9, 3]"
            },
            {
                "description": "The function correctly skips numbers that are at even positions but are odd.",
                "assert_statement": "assert result == 0 if input_list == [1, 10, 3, 20, 5, 30]"
            },
            {
                "description": "The function correctly skips numbers that are even but are at odd positions (1, 3, 5...).",
                "assert_statement": "assert result == 4 if input_list == [4, 20, 10, 3, 2, 1]"
            },
            {
                "description": "The function returns 0 if the input list is empty.",
                "assert_statement": "assert result == 0 if input_list == []"
            },
            {
                "description": "The return value must be a numeric type (integer or float, assuming the input list contains numbers).",
                "assert_statement": "assert isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 288,
        "Function_ID": 144,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sum_even_and_even_index(arr):  \n    i = 0\n    sum = 0\n    for i in range(0, len(arr),2): \n        if (arr[i] % 2 == 0) : \n            sum += arr[i]  \n    return sum\n    **Function Description: ** Write a python function to find the sum of even numbers at even positions of a list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer, as it represents a sum of numerical elements.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned sum must equal the total of all elements found at even indices (0, 2, 4, ...) that satisfy the condition of being an even number themselves.",
                "assert_statement": "assert result == sum(arr[i] for i in range(0, len(arr), 2) if arr[i] % 2 == 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 289,
        "Function_ID": 145,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The sum for n=0 must be 0 (the sum of the first zero terms).",
                "assert_statement": "calculate_sum(0) == 0"
            },
            {
                "description": "Checks the base case where n=1 (2^5 = 32).",
                "assert_statement": "calculate_sum(1) == 32"
            },
            {
                "description": "Checks the sum for n=2 (2^5 + 4^5 = 32 + 1024 = 1056).",
                "assert_statement": "calculate_sum(2) == 1056"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 290,
        "Function_ID": 145,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; \n    **Function Description: ** Write a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns 0 if the input n is zero or negative, as the summation range is empty.",
                "assert_statement": "assert even_Power_Sum(0) == 0 and even_Power_Sum(-3) == 0"
            },
            {
                "description": "The result for a known input (n=2) must match the calculated sum (2^5 + 4^5 = 32 + 1024 = 1056).",
                "assert_statement": "assert even_Power_Sum(2) == 1056"
            },
            {
                "description": "The return value must be a non-negative integer, regardless of the input n >= 0.",
                "assert_statement": "assert isinstance(even_Power_Sum(5), int) and even_Power_Sum(5) >= 0"
            },
            {
                "description": "The result must equal the summation of (2*i)^5 for i ranging from 1 to n for any positive integer n.",
                "assert_statement": "n_test = 4; expected = sum((2*i)**5 for i in range(1, n_test + 1)); assert even_Power_Sum(n_test) == expected"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 291,
        "Function_ID": 146,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in a list of tuples and returns a list containing the rear element of each tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be equal to the length of the input list.",
                "assert_statement": "len(result) == len(input_list)"
            },
            {
                "description": "Every element in the resulting list must be the rear element (index 1) of the corresponding tuple in the input list.",
                "assert_statement": "all(result[i] == input_list[i][1] for i in range(len(input_list)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 292,
        "Function_ID": 146,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def rear_extract(test_list):\n  res = [lis[-1] for lis in test_list]\n  return (res) \n    **Function Description: ** Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the resulting list must be equal to the length of the input list.",
                "assert_statement": "assert len(result) == len(test_list)"
            },
            {
                "description": "Each element in the resulting list must correspond exactly to the last element of the corresponding iterable in the input list.",
                "assert_statement": "for i in range(len(test_list)): assert result[i] == test_list[i][-1]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 293,
        "Function_ID": 147,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting structure (list or tuple) must have the same length as the input tuples, assuming they were of equal length.",
                "assert_statement": "len(result) == len(T1)"
            },
            {
                "description": "Every element in the resulting structure must equal the difference between the elements at the corresponding index in the first tuple (T1) and the second tuple (T2).",
                "assert_statement": "all(r == t1 - t2 for r, t1, t2 in zip(result, T1, T2))"
            },
            {
                "description": "The output of the function must be an iterable type (such as a list or a tuple).",
                "assert_statement": "isinstance(result, (list, tuple))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 294,
        "Function_ID": 147,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def substract_elements(test_tup1, test_tup2):\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n  return (res) \n    **Function Description: ** Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting tuple must be equal to the length of the shorter input tuple.",
                "assert_statement": "assert len(result) == min(len(test_tup1), len(test_tup2))"
            },
            {
                "description": "Each element in the result tuple must equal the subtraction of the corresponding elements from the input tuples (test_tup1[i] - test_tup2[i]).",
                "assert_statement": "assert all(result[i] == test_tup1[i] - test_tup2[i] for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 295,
        "Function_ID": 148,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must equal 2 raised to the power of (n minus 1), which is the standard mathematical identity for the sum of even index binomial coefficients.",
                "assert_statement": "result == 2**(n - 1)"
            },
            {
                "description": "The returned result must be an integer, as binomial coefficients are integers and their sum must also be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "Since n is a positive integer (n >= 1), the sum of even index binomial coefficients must be greater than or equal to 1.",
                "assert_statement": "result >= 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 296,
        "Function_ID": 148,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math  \ndef even_binomial_Coeff_Sum( n): \n    return (1 << (n - 1)) \n    **Function Description: ** Write a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The return value must equal 2 raised to the power of (n - 1), which is the mathematical sum of the even index binomial coefficients.",
                "assert_statement": "assert result == (2 ** (n - 1))"
            },
            {
                "description": "If n is a positive integer (n >= 1), the result must be a positive integer greater than or equal to 1.",
                "assert_statement": "assert result >= 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 297,
        "Function_ID": 149,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in the radius and height of a cylinder and returns the the volume.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be equal to the volume calculation (pi * radius squared * height). Assumes 'math.pi' is available.",
                "assert_statement": "result == math.pi * radius ** 2 * height"
            },
            {
                "description": "The calculated volume must be a non-negative number (since radius and height are physical dimensions).",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned result must be a floating-point number, given the inclusion of pi in the calculation.",
                "assert_statement": "isinstance(result, float)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 298,
        "Function_ID": 149,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def volume_cylinder(r,h):\n  volume=3.1415*r*r*h\n  return volume\n    **Function Description: ** Write a function that takes in the radius and height of a cylinder and returns the the volume.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is a floating point number, forced by the constant 3.1415 used for PI.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "The returned volume strictly adheres to the implementation formula V = 3.1415 * r^2 * h.",
                "assert_statement": "assert result == 3.1415 * r * r * h"
            },
            {
                "description": "If the radius (r) or height (h) is zero, the calculated volume must be zero.",
                "assert_statement": "if r == 0 or h == 0: assert result == 0"
            },
            {
                "description": "If both radius and height are non-negative (standard physical constraints), the resulting volume must be non-negative.",
                "assert_statement": "if r >= 0 and h >= 0: assert result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 299,
        "Function_ID": 150,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned object must be a dictionary.",
                "assert_statement": "isinstance(result, dict)"
            },
            {
                "description": "All values in the filtered dictionary must be greater than or equal to n.",
                "assert_statement": "all(value >= n for value in result.values())"
            },
            {
                "description": "Every entry from the original dictionary whose value met the criteria (value >= n) must be present in the filtered dictionary.",
                "assert_statement": "all(key in result for key, value in input_dict.items() if value >= n)"
            },
            {
                "description": "The number of entries in the filtered dictionary cannot exceed the number of entries in the original dictionary.",
                "assert_statement": "len(result) <= len(input_dict)"
            },
            {
                "description": "All keys present in the filtered dictionary must also be present in the original input dictionary.",
                "assert_statement": "all(key in input_dict for key in result.keys())"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 300,
        "Function_ID": 150,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def dict_filter(dict,n):\n result = {key:value for (key, value) in dict.items() if value >=n}\n return result\n    **Function Description: ** Write a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return an object of type dictionary.",
                "assert_statement": "assert isinstance(result, dict)"
            },
            {
                "description": "All values present in the resulting dictionary must be greater than or equal to the input threshold n.",
                "assert_statement": "assert all(value >= n for value in result.values())"
            },
            {
                "description": "The returned dictionary must contain exactly those key-value pairs from the input dictionary where the value satisfied the condition (value >= n).",
                "assert_statement": "assert result == {k: v for k, v in dict.items() if v >= n}"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 301,
        "Function_ID": 151,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the number of elements that occurs before the tuple element in the given tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer representing the count of elements preceding the target element.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "If the target element exists, the returned count must be a non-negative integer representing a valid index in the tuple.",
                "assert_statement": "0 <= result < len(input_tuple)"
            },
            {
                "description": "The element at the resulting index position must be equal to the target element.",
                "assert_statement": "input_tuple[result] == target_element"
            },
            {
                "description": "The function must find the first occurrence of the target element, ensuring that the target element does not exist in the sub-tuple preceding the resulting index.",
                "assert_statement": "target_element not in input_tuple[:result]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 302,
        "Function_ID": 151,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) \n    **Function Description: ** Write a function to find the number of elements that occurs before the tuple element in the given tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be an integer, provided the function executes successfully (i.e., the input tuple is not empty).",
                "assert_statement": "if len(test_tup) > 0: assert isinstance(__result__, int)"
            },
            {
                "description": "If a nested tuple is present, the return value is the index of the first encountered tuple. This means the element at the returned index is a tuple, and all preceding elements are not tuples.",
                "assert_statement": "if len(test_tup) > 0 and __result__ < len(test_tup): assert isinstance(test_tup[__result__], tuple) and all(not isinstance(test_tup[i], tuple) for i in range(__result__))"
            },
            {
                "description": "If no nested tuple is found (and the input is non-empty), the return value equals the index of the last element, which is one less than the length of the tuple.",
                "assert_statement": "if len(test_tup) > 0 and __result__ == len(test_tup) - 1: assert not any(isinstance(ele, tuple) for ele in test_tup)"
            },
            {
                "description": "If the input tuple is empty, the function raises an UnboundLocalError because the loop defining 'count' does not execute.",
                "assert_statement": "if len(test_tup) == 0: import pytest; with pytest.raises(UnboundLocalError): count_first_elements(test_tup)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 303,
        "Function_ID": 152,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the nth decagonal number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must equal the nth decagonal number calculated using the formula n * (4n - 3).",
                "assert_statement": "result == n * (4 * n - 3)"
            },
            {
                "description": "The result must be an integer, as decagonal numbers are a type of figurate number.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "For any positive index n (n >= 1), the decagonal number must be positive (>= 1).",
                "assert_statement": "result >= 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 304,
        "Function_ID": 152,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_num_decagonal(n): \n\treturn 4 * n * n - 3 * n \n    **Function Description: ** Write a function to find the nth decagonal number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must strictly conform to the decagonal number formula: 4*n^2 - 3*n.",
                "assert_statement": "assert result == (4 * n * n - 3 * n)"
            },
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "For a standard input index n >= 1, the decagonal number must be positive and greater than or equal to 1.",
                "assert_statement": "if n >= 1: assert result >= 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 305,
        "Function_ID": 153,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the element is reported as found (boolean True), the returned index must be valid and must point to the element in the array.",
                "assert_statement": "if result[0]: assert 0 <= result[1] < len(array) and array[result[1]] == element"
            },
            {
                "description": "If the element is reported as not found (boolean False), the returned index must be -1.",
                "assert_statement": "if not result[0]: assert result[1] == -1"
            },
            {
                "description": "If the element is reported as not found (boolean False), the element must not exist anywhere within the input array.",
                "assert_statement": "if not result[0]: assert element not in array"
            },
            {
                "description": "The returned value must be a tuple containing a boolean and an integer.",
                "assert_statement": "assert isinstance(result, tuple) and len(result) == 2 and isinstance(result[0], bool) and isinstance(result[1], int)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 306,
        "Function_ID": 153,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos\n    **Function Description: ** Write a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple of size two, consisting of a boolean followed by an integer.",
                "assert_statement": "assert isinstance(result, tuple) and len(result) == 2 and isinstance(result[0], bool) and isinstance(result[1], int)"
            },
            {
                "description": "If the item is found (result[0] is True), the index returned (result[1]) must be valid (0 <= index < len(dlist)), and the element at that index must equal the item searched.",
                "assert_statement": "found, pos = result; assert not found or (0 <= pos < len(dlist) and dlist[pos] == item)"
            },
            {
                "description": "If the item is not found (result[0] is False), the returned position must be equal to the length of the input list.",
                "assert_statement": "found, pos = result; assert found or pos == len(dlist)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 307,
        "Function_ID": 154,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check if the elements of a given list are unique or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be True if the length of the input list is equal to the length of a set created from that list (i.e., all elements are unique).",
                "assert_statement": "assert result == (len(input_list) == len(set(input_list)))"
            },
            {
                "description": "If the input list contains duplicate elements, the function must return False.",
                "assert_statement": "assert not result if len(input_list) > len(set(input_list)) else result"
            },
            {
                "description": "The return value must always be a boolean (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 308,
        "Function_ID": 154,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def all_unique(test_list):\n    if len(test_list) > len(set(test_list)):\n        return False\n    return True\n    **Function Description: ** Write a python function to check if the elements of a given list are unique or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a boolean value (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The return value must be True if and only if the number of elements in the input list is exactly equal to the number of unique elements (length of the set derived from the list).",
                "assert_statement": "assert result == (len(test_list) == len(set(test_list)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 309,
        "Function_ID": 155,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to subtract two lists element-wise.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result of the subtraction is a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "The length of the resulting list matches the length of the input lists (assuming equal length inputs).",
                "assert_statement": "len(result) == len(list_a)"
            },
            {
                "description": "Each element in the result list is the difference of the corresponding elements from the two input lists.",
                "assert_statement": "all(result[i] == list_a[i] - list_b[i] for i in range(len(result)))"
            },
            {
                "description": "If the input lists are empty, the resulting list is also empty.",
                "assert_statement": "len(list_a) == 0 and len(result) == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 310,
        "Function_ID": 155,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sub_list(nums1,nums2):\n  result = map(lambda x, y: x - y, nums1, nums2)\n  return list(result)\n    **Function Description: ** Write a function to subtract two lists element-wise.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must equal the length of the shortest input list, as map truncates the output.",
                "assert_statement": "assert len(result) == min(len(nums1), len(nums2))"
            },
            {
                "description": "Each element in the returned list must be the difference between the corresponding elements of nums1 and nums2 (nums1[i] - nums2[i]).",
                "assert_statement": "assert all(result[i] == nums1[i] - nums2[i] for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 311,
        "Function_ID": 156,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, then for every digit present in the input number, its frequency must be less than or equal to the digit's value.",
                "assert_statement": "if result: assert all(count <= digit for digit, count in freq.items())"
            },
            {
                "description": "If the function returns False, then there must be at least one digit in the input number whose frequency is strictly greater than the digit's value.",
                "assert_statement": "if not result: assert any(count > digit for digit, count in freq.items())"
            },
            {
                "description": "The return value must always be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 312,
        "Function_ID": 156,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def validate(n): \n    for i in range(10): \n        temp = n;  \n        count = 0; \n        while (temp): \n            if (temp % 10 == i): \n                count+=1;  \n            if (count > i): \n                return False\n            temp //= 10; \n    return True\n    **Function Description: ** Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, it guarantees that for every digit D (0-9), the frequency of D in N is less than or equal to D.",
                "assert_statement": "assert not _ret or all(str(n).count(str(d)) <= d for d in range(10))"
            },
            {
                "description": "If the function returns False, it guarantees that there is at least one digit D (0-9) whose frequency in N strictly exceeds D.",
                "assert_statement": "assert _ret or any(str(n).count(str(d)) > d for d in range(10))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 313,
        "Function_ID": 157,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes in a list and element and checks whether all items in the list are equal to the given element.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, every item in the input list must be equal to the specified element.",
                "assert_statement": "if result: assert all(item == element for item in lst)"
            },
            {
                "description": "If the function returns False, there must be at least one item in the input list that is not equal to the specified element.",
                "assert_statement": "if not result: assert any(item != element for item in lst)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 314,
        "Function_ID": 157,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\n    **Function Description: ** Write a function that takes in a list and element and checks whether all items in the list are equal to the given element.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean type.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the input list contains only elements equal to the target element, the result is True.",
                "assert_statement": "assert check_element([10, 10, 10], 10) is True"
            },
            {
                "description": "If the input list contains at least one element unequal to the target element, the result is False.",
                "assert_statement": "assert check_element([10, 5, 10], 10) is False"
            },
            {
                "description": "If the input list is empty, the result must be True, following the behavior of Python's 'all()' function.",
                "assert_statement": "assert check_element([], 'any_element') is True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 315,
        "Function_ID": 158,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, the input string must contain the pattern 'a' followed by exactly two or three 'b' characters (e.g., 'abb' or 'abbb'). This assertion assumes the use of Python's 're' module for verification.",
                "assert_statement": "if result: assert re.search(r'abb{2,3}', input_string)"
            },
            {
                "description": "If the function returns False, the input string must not contain the required pattern ('abb' or 'abbb'). This assertion assumes the use of Python's 're' module for verification.",
                "assert_statement": "if not result: assert not re.search(r'abb{2,3}', input_string)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 316,
        "Function_ID": 158,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef text_match_two_three(text):\n        patterns = 'ab{2,3}'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n    **Function Description: ** Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The function returns True if and only if the input string contains a match for the pattern 'a' followed by two or three 'b' characters ('abb' or 'abbb').",
                "assert_statement": "import re; assert result == (re.search('ab{2,3}', text) is not None)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 317,
        "Function_ID": 159,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "If k equals 1, the result must be equal to the standard maximum contiguous subarray sum (Kadane's algorithm) applied to the original array.",
                "assert_statement": "if k == 1: assert result == max_contiguous_sum(arr)"
            },
            {
                "description": "If the total sum of the array is non-positive, the maximum contiguous sum cannot benefit from repeating the array more than twice. Thus, the result must equal the maximum contiguous sum of the array repeated twice (arr + arr).",
                "assert_statement": "if sum(arr) <= 0: assert result == max_contiguous_sum(arr + arr)"
            },
            {
                "description": "If the total sum of the array is positive and k is greater than 1, the result is the maximum of two possibilities: the sum found within the first two repetitions, or the sum formed by the optimal prefix, optimal suffix, and (k-2) full repetitions of the array sum.",
                "assert_statement": "if sum(arr) > 0 and k > 1: assert result == max(max_contiguous_sum(arr + arr), max_prefix_sum(arr) + max_suffix_sum(arr) + sum(arr) * (k - 2))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 318,
        "Function_ID": 159,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_sub_array_sum_repeated(a, n, k): \n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k): \n\t\tmax_ending_here = max_ending_here + a[i%n] \n\t\tif (max_so_far < max_ending_here): \n\t\t\tmax_so_far = max_ending_here \n\t\tif (max_ending_here < 0): \n\t\t\tmax_ending_here = 0\n\treturn max_so_far\n    **Function Description: ** Write a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a numeric type (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "The calculated maximum subarray sum cannot exceed the total sum of the original array 'a' repeated 'k' times.",
                "assert_statement": "assert result <= sum(a) * k"
            },
            {
                "description": "If the repetition count 'k' is zero, the loop is skipped, and the function returns the initialized minimum value (-2147483648).",
                "assert_statement": "assert k > 0 or result == -2147483648"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 319,
        "Function_ID": 160,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function takes in an integer n and returns the sum of squares of first n even natural numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The result must equal the closed-form sum of squares of the first n even numbers: (2 * n * (n + 1) * (2 * n + 1)) / 3.",
                "assert_statement": "result == (2 * n * (n + 1) * (2 * n + 1)) // 3"
            },
            {
                "description": "If n is zero, the sum must be zero (the empty sum).",
                "assert_statement": "n != 0 or result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 320,
        "Function_ID": 160,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def square_Sum(n):  \n    return int(2*n*(n+1)*(2*n+1)/3)\n    **Function Description: ** Write a python function takes in an integer n and returns the sum of squares of first n even natural numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The return value must be non-negative, as it represents a sum of squares of real numbers.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The result correctly calculates the sum of squares of the first n even natural numbers, $\\sum_{k=1}^{n} (2k)^2$.",
                "assert_statement": "assert result == sum((2*k)**2 for k in range(1, n + 1))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 321,
        "Function_ID": 161,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the list of maximum length in a list of lists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned list must be a list type.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be greater than or equal to the length of every list in the input.",
                "assert_statement": "all(len(result) >= len(lst) for lst in list_of_lists)"
            },
            {
                "description": "If the input list of lists is not empty, the returned list must be one of the elements present in the input.",
                "assert_statement": "result in list_of_lists if list_of_lists else result == []"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 322,
        "Function_ID": 161,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_length(list1):\n    max_length = max(len(x) for x in  list1 )  \n    max_list = max((x) for x in   list1)\n    return(max_length, max_list)\n    **Function Description: ** Write a function to find the list of maximum length in a list of lists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple containing exactly two elements: the maximum length found and the lexicographically largest element.",
                "assert_statement": "assert isinstance(result, tuple) and len(result) == 2"
            },
            {
                "description": "The first element of the returned tuple must represent the maximum length of any element within the input list.",
                "assert_statement": "assert result[0] == max(len(x) for x in list1)"
            },
            {
                "description": "The second element of the returned tuple must be the element from the input list that is lexicographically greatest, as determined by Python's default comparison rules.",
                "assert_statement": "assert result[1] == max(x for x in list1)"
            },
            {
                "description": "The maximum length value returned (result[0]) must be a non-negative integer.",
                "assert_statement": "assert isinstance(result[0], int) and result[0] >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 323,
        "Function_ID": 162,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a non-negative integer, as it represents a count of ways.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "If the number of posts (N) is 1, the number of ways is simply the number of available colors (K).",
                "assert_statement": "(N == 1) implies (result == K)"
            },
            {
                "description": "If the number of posts (N) is 2, the number of ways is K squared (K ways to paint them the same, K*(K-1) ways to paint them differently).",
                "assert_statement": "(N == 2) implies (result == K * K)"
            },
            {
                "description": "The result must follow the dynamic programming relationship: Total[N] = (K-1) * (Total[N-1] + Total[N-2]) + Total[N-2]. (Where Total[N-1] includes ways ending in either Same or Different color schemes).",
                "assert_statement": "if N > 2: same_n = diff_{n-1}; diff_n = (same_{n-1} + diff_{n-1}) * (K-1); result == same_n + diff_n"
            },
            {
                "description": "For a specific test case where N=3 and K=2, the calculated result must be 6 (e.g., RBR, RBB, RRB, BRB, BBR, BRR).",
                "assert_statement": "(N == 3 && K == 2) implies (result == 6)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 324,
        "Function_ID": 162,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]\n    **Function Description: ** Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned count must be non-negative, as it represents a physical count.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The returned value must be strictly less than the modulo constant (1000000007), as the final step involves the modulo operation.",
                "assert_statement": "assert result < 1000000007"
            },
            {
                "description": "For n=1, the number of ways is equal to the number of colors k.",
                "assert_statement": "if n == 1: assert result == k"
            },
            {
                "description": "For n=2, all k*k combinations are valid since the constraint requires at most 2 adjacent posts of the same color.",
                "assert_statement": "if n == 2: assert result == (k * k) % 1000000007"
            },
            {
                "description": "For n=3, the number of ways must equal k^3 - k (k ways are invalid where all three colors are identical), calculated modulo MOD.",
                "assert_statement": "if n == 3: assert result == (k * (k * k - 1)) % 1000000007"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 325,
        "Function_ID": 163,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find quotient of two numbers (rounded down to the nearest integer).",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned quotient must be an integer (as required by floor division).",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The result must match the Python floor division operator (//) for the given numerator and denominator.",
                "assert_statement": "result == numerator // denominator"
            },
            {
                "description": "The mathematical definition of the floor division (q) must hold: q * denominator <= numerator < (q + 1) * denominator.",
                "assert_statement": "result * denominator <= numerator and numerator < (result + 1) * denominator"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 326,
        "Function_ID": 163,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find(n,m):  \n    q = n//m \n    return (q)\n    **Function Description: ** Write a python function to find quotient of two numbers (rounded down to the nearest integer).",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be equal to the result of Python's floor division of n by m.",
                "assert_statement": "assert result == n // m"
            },
            {
                "description": "The return value must be an integer (as it is the result of floor division on standard numeric types).",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The quotient multiplied by the divisor must not exceed the dividend (n >= result * m).",
                "assert_statement": "assert result * m <= n"
            },
            {
                "description": "If the divisor m is zero, the function must raise a ZeroDivisionError.",
                "assert_statement": "pytest.raises(ZeroDivisionError, find, 5, 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 327,
        "Function_ID": 164,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the third side of a right angled triangle.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated side length must be a non-negative value (as all physical lengths must be positive).",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The square of the longest side (the hypotenuse, which is the maximum of the two input sides s1, s2, and the calculated result) must be equal to the sum of the squares of the two shorter sides (legs), confirming the Pythagorean theorem.",
                "assert_statement": "sides = sorted([s1, s2, result]); leg1, leg2, hypotenuse = sides[0], sides[1], sides[2]; math.isclose(hypotenuse**2, leg1**2 + leg2**2)"
            },
            {
                "description": "The calculated side, when combined with the two input sides, must satisfy the triangle inequality (the sum of any two sides must be greater than the third side).",
                "assert_statement": "s1 + s2 > result and s1 + result > s2 and s2 + result > s1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 328,
        "Function_ID": 164,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math\ndef otherside_rightangle(w,h):\n  s=math.sqrt((w*w)+(h*h))\n  return s\n    **Function Description: ** Write a function to find the third side of a right angled triangle.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a floating-point number, as the calculation involves a square root.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "The square of the returned side length (hypotenuse) must equal the sum of the squares of the two input legs (Pythagorean theorem), verified within floating-point tolerance.",
                "assert_statement": "assert math.isclose(result * result, (w * w) + (h * h))"
            },
            {
                "description": "The calculated side length must be non-negative and must be greater than or equal to both input lengths w and h (since it is the hypotenuse).",
                "assert_statement": "assert result >= 0 and result >= w and result >= h"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 329,
        "Function_ID": 165,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the maximum value in a given heterogeneous list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the input list contains comparable numerical elements (int or float), the result must equal the mathematical maximum of those elements.",
                "assert_statement": "numeric_elements = [x for x in input_list if isinstance(x, (int, float))]; if numeric_elements: assert result == max(numeric_elements)"
            },
            {
                "description": "If the list is empty or contains no comparable numerical types, the function must return None (assuming None is the defined handling for no maximum).",
                "assert_statement": "numeric_elements = [x for x in input_list if isinstance(x, (int, float))]; if not numeric_elements: assert result is None"
            },
            {
                "description": "If a numerical maximum is found (result is not None), it must be greater than or equal to every other numerical element in the original list.",
                "assert_statement": "numeric_elements = [x for x in input_list if isinstance(x, (int, float))]; if result is not None: assert all(result >= x for x in numeric_elements)"
            },
            {
                "description": "If the function returns a value (not None), that value must be a numerical type (int or float).",
                "assert_statement": "if result is not None: assert isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 330,
        "Function_ID": 165,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_val(listval):\n     max_val = max(i for i in listval if isinstance(i, int)) \n     return(max_val)\n    **Function Description: ** Write a function to find the maximum value in a given heterogeneous list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer, as the function filters for and calculates the maximum of only integer elements.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned value must be equal to the maximum integer found among all elements in the input list.",
                "assert_statement": "expected_max = max(i for i in listval if isinstance(i, int)); assert result == expected_max"
            },
            {
                "description": "If the input list contains no integers (meaning the filtered sequence is empty), a ValueError must be raised.",
                "assert_statement": "import pytest; empty_int_list = [1.0, 'a', 'b']; with pytest.raises(ValueError): max_val(empty_int_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 331,
        "Function_ID": 166,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to return the sum of all divisors of a number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The sum of divisors must be greater than or equal to the input number, as the number itself is always a divisor.",
                "assert_statement": "result >= n"
            },
            {
                "description": "For an input n > 1, the result must be greater than n.",
                "assert_statement": "if n > 1: assert result > n"
            },
            {
                "description": "The result must equal the mathematical definition: the sum of all positive integers 'd' (including 1 and n) that divide n evenly.",
                "assert_statement": "result == sum(d for d in range(1, n + 1) if n % d == 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 332,
        "Function_ID": 166,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sum_div(number):\n    divisors = [1]\n    for i in range(2, number):\n        if (number % i)==0:\n            divisors.append(i)\n    return sum(divisors)\n    **Function Description: ** Write a function to return the sum of all divisors of a number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned value must exactly equal the sum of all positive integers 'd' which divide 'number' and are strictly less than 'number'.",
                "assert_statement": "assert result == sum(d for d in range(1, number) if number % d == 0)"
            },
            {
                "description": "If the input number is 1, the returned sum of divisors must be 1.",
                "assert_statement": "if number == 1: assert result == 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 333,
        "Function_ID": 167,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count inversions in an array.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer representing the count of inversions.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The count of inversions must be non-negative.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned count must exactly equal the total number of pairs (i, j) where i < j and arr[i] > arr[j].",
                "assert_statement": "result == sum(1 for i in range(len(arr)) for j in range(i + 1, len(arr)) if arr[i] > arr[j])"
            },
            {
                "description": "If the array is sorted (no inversions), the count must be zero.",
                "assert_statement": "all(arr[i] <= arr[i+1] for i in range(len(arr) - 1)) or result > 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 334,
        "Function_ID": 167,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def get_Inv_Count(arr): \n    inv_count = 0\n    for i in range(len(arr)): \n        for j in range(i + 1, len(arr)): \n            if (arr[i] > arr[j]): \n                inv_count += 1\n    return inv_count \n    **Function Description: ** Write a python function to count inversions in an array.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input array is sorted (no inversions), the count must be 0.",
                "assert_statement": "assert get_Inv_Count([1, 2, 3, 4, 5]) == 0"
            },
            {
                "description": "The function correctly calculates the inversion count for a standard test case.",
                "assert_statement": "assert get_Inv_Count([1, 20, 6, 4, 5]) == 5"
            },
            {
                "description": "For a completely reversed array of length N, the inversion count must be N*(N-1)/2.",
                "assert_statement": "arr = [4, 3, 2, 1]; N = len(arr); expected = N * (N - 1) // 2; assert get_Inv_Count(arr) == expected"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 335,
        "Function_ID": 168,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to flatten a given nested list structure.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must be a list type.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "All elements in the resulting list must be non-list types (i.e., the list is fully flattened and contains no nested lists).",
                "assert_statement": "all(not isinstance(item, list) for item in result)"
            },
            {
                "description": "The number of elements in the flattened list must equal the total number of non-list elements present in the original input structure.",
                "assert_statement": "len(result) == count_atomic_elements(input_list)"
            },
            {
                "description": "If the original input list contained non-list elements, the resulting list must not be empty.",
                "assert_statement": "(len(result) > 0) == (count_atomic_elements(input_list) > 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 336,
        "Function_ID": 168,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def flatten_list(list1):\n    result_list = []\n    if not list1: return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if c_num: stack.append(c_num)\n        if isinstance(next, list):\n            if next: stack.append(list(next))\n        else: result_list.append(next)\n    result_list.reverse()\n    return result_list \n    **Function Description: ** Write a function to flatten a given nested list structure.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list and must not contain any nested list elements (it must be fully flattened).",
                "assert_statement": "assert isinstance(result, list) and all(not isinstance(item, list) for item in result)"
            },
            {
                "description": "If the input list is empty, the function returns an empty list.",
                "assert_statement": "assert flatten_list([]) == []"
            },
            {
                "description": "The resulting list contains all scalar elements from the input structure, preserving the correct depth-first order.",
                "assert_statement": "test_input = [1, [2, [3, 4]], 5, [6]]; assert flatten_list(test_input) == [1, 2, 3, 4, 5, 6]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 337,
        "Function_ID": 169,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to calculate the maximum aggregate from the list of tuples.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must equal the maximum aggregated sum derived from grouping the input data by the first element of each tuple.",
                "assert_statement": "groups = {}; [groups.update({t[0]: groups.get(t[0], 0) + t[1]}) for t in data if len(t) == 2 and isinstance(t[1], (int, float))]; expected_max = max(groups.values()) if groups else 0; assert result == expected_max"
            },
            {
                "description": "If the input list of tuples is empty, the calculated maximum aggregate must be zero (assuming no negative inputs are possible, or 0 is the neutral maximum).",
                "assert_statement": "if not data: assert result == 0"
            },
            {
                "description": "The return value must be a numerical type (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 338,
        "Function_ID": 169,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from collections import defaultdict\ndef max_aggregate(stdata):\n    temp = defaultdict(int)\n    for name, marks in stdata:\n        temp[name] += marks\n    return max(temp.items(), key=lambda x: x[1])\n    **Function Description: ** Write a function to calculate the maximum aggregate from the list of tuples.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple containing exactly two elements: the student name and their maximum aggregate marks.",
                "assert_statement": "assert isinstance(result, tuple) and len(result) == 2"
            },
            {
                "description": "The second element of the returned tuple (the aggregate marks) must equal the highest total score calculated across all students in the input data.",
                "assert_statement": "from collections import defaultdict; expected_agg = defaultdict(int); for name, marks in stdata: expected_agg[name] += marks; assert result[1] == max(expected_agg.values())"
            },
            {
                "description": "The returned student name (first element) must be the key corresponding exactly to the maximum aggregate marks (second element) calculated from the input data.",
                "assert_statement": "from collections import defaultdict; expected_agg = defaultdict(int); for name, marks in stdata: expected_agg[name] += marks; assert expected_agg[result[0]] == result[1]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 339,
        "Function_ID": 170,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must equal the central binomial coefficient C(2n, n), which is the closed form solution for the sum of the squares of binomial coefficients C(n, k).",
                "assert_statement": "result == math.comb(2 * n, n)"
            },
            {
                "description": "The result must equal the sum of the squares of the binomial coefficients C(n, k) for k ranging from 0 to n (this confirms the combinatorial definition).",
                "assert_statement": "result == sum(math.comb(n, k)**2 for k in range(n + 1))"
            },
            {
                "description": "The result must be a non-negative integer, as it represents a count of sequences.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 340,
        "Function_ID": 170,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_binary_seq(n): \n\tnCr = 1\n\tres = 1\n\tfor r in range(1, n + 1): \n\t\tnCr = (nCr * (n + 1 - r)) / r \n\t\tres += nCr * nCr \n\treturn res \n    **Function Description: ** Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be non-negative, as it represents a count of sequences.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The returned value, though potentially a float due to intermediate division, must be mathematically an exact integer since it represents a count.",
                "assert_statement": "assert result == int(result)"
            },
            {
                "description": "The returned count must equal the sum of squares of binomial coefficients, which is known to be the central binomial coefficient C(2n, n).",
                "assert_statement": "import math; assert int(result) == math.comb(2 * n, n)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 341,
        "Function_ID": 171,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the depth of a dictionary.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer greater than or equal to 1, as the dictionary itself constitutes the first level.",
                "assert_statement": "isinstance(result, int) and result >= 1"
            },
            {
                "description": "If the input dictionary is a flat structure (no values are dictionaries), the depth must be exactly 1.",
                "assert_statement": "if not any(isinstance(v, dict) for v in d.values()): assert result == 1"
            },
            {
                "description": "If the dictionary contains at least one nested dictionary, the depth must be strictly greater than 1.",
                "assert_statement": "if any(isinstance(v, dict) for v in d.values()): assert result > 1"
            },
            {
                "description": "The calculated depth must be based on the longest path; it must be greater than or equal to the depth required by any direct child dictionary.",
                "assert_statement": "for v in d.values(): if isinstance(v, dict): assert result > find_depth(v)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 342,
        "Function_ID": 171,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0\n    **Function Description: ** Write a function to find the depth of a dictionary.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input is not a dictionary (e.g., list, string, integer), the depth returned must be 0.",
                "assert_statement": "assert dict_depth([1, 2]) == 0 and dict_depth(5) == 0"
            },
            {
                "description": "An empty dictionary or a dictionary containing only scalar values must return a depth of 1.",
                "assert_statement": "assert dict_depth({}) == 1 and dict_depth({'a': 1, 'b': 'c'}) == 1"
            },
            {
                "description": "The function correctly identifies the maximum nesting depth, returning N for a structure nested N levels deep.",
                "assert_statement": "assert dict_depth({'k1': 1, 'k2': {'k3': {'k4': 4}}}) == 3"
            },
            {
                "description": "When dictionary values have varying depths, the return value must equal the maximum depth found.",
                "assert_statement": "assert dict_depth({'a': 1, 'b': {'c': 2}, 'd': {'e': {'f': 3}}}) == 3"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 343,
        "Function_ID": 172,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find element at a given index after number of rotations.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must match the element at the mathematically calculated original index, considering that the target index 'index' must have originated from the position (index - effective_rotations).",
                "assert_statement": "N = len(arr); effective_rotations = rotations % N; expected_original_index = (index - effective_rotations + N) % N; assert result == arr[expected_original_index]"
            },
            {
                "description": "If the number of rotations is zero or a multiple of the array length, the result must be the element at the original index.",
                "assert_statement": "if rotations % len(arr) == 0: assert result == arr[index]"
            },
            {
                "description": "The index calculated for retrieval (the expected original index) must be a non-negative integer and within the valid bounds of the array.",
                "assert_statement": "N = len(arr); effective_rotations = rotations % N; calculated_index = (index - effective_rotations + N) % N; assert 0 <= calculated_index < N"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 344,
        "Function_ID": 172,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] \n    **Function Description: ** Write a python function to find element at a given index after number of rotations.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an element originally present in the input array 'arr'.",
                "assert_statement": "assert result in arr"
            },
            {
                "description": "If the array 'arr' is non-empty, the type of the returned element must match the type of the elements in 'arr'.",
                "assert_statement": "if arr: assert type(result) == type(arr[0])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 345,
        "Function_ID": 173,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to return two words from a list of words starting with letter 'p'.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a list (or iterable) containing exactly two elements.",
                "assert_statement": "assert len(result) == 2"
            },
            {
                "description": "Both returned elements must be strings.",
                "assert_statement": "assert all(isinstance(word, str) for word in result)"
            },
            {
                "description": "Both returned words must start with the letter 'p' (case-insensitive).",
                "assert_statement": "assert all(word.lower().startswith('p') for word in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 346,
        "Function_ID": 173,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef start_withp(words):\n for w in words:\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\n        if m:\n            return m.groups()\n    **Function Description: ** Write a function to return two words from a list of words starting with letter 'p'.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If a match is found, the return value must be a tuple containing exactly two elements.",
                "assert_statement": "result = start_withp([\"Perfect.Pigeon\"]); assert isinstance(result, tuple) and len(result) == 2"
            },
            {
                "description": "If a match is found, both returned elements must be strings that begin with the character 'P'.",
                "assert_statement": "result = start_withp([\"Test Program,Partial\"]); assert result[0].startswith('P') and result[1].startswith('P')"
            },
            {
                "description": "If the input list contains no string matching the pattern (two 'P'-words separated by a non-word character), the function must return None.",
                "assert_statement": "assert start_withp([\"Apple Banana\", \"Programmer Beta\"]) is None"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 347,
        "Function_ID": 174,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned sum must be the maximum possible sum achievable, defined as the value of the element A[k] plus the maximum sum of any Increasing Subsequence (IS) ending at some index j, such that j <= i and A[j] < A[k].",
                "assert_statement": "result == A[k] + max(0, max_is_sum_ending_at_j for j in range(i + 1) if A[j] < A[k])"
            },
            {
                "description": "The calculated sum must be non-zero and must be at least the value of the required k-th element, as A[k] must always be included in the subsequence.",
                "assert_statement": "result >= A[k] and result > 0"
            },
            {
                "description": "If the prefix A[0...i] contains no elements strictly smaller than A[k], then the subsequence cannot be extended beyond A[k] (as it must be increasing), and the resulting sum must be exactly A[k].",
                "assert_statement": "if all(A[j] >= A[k] for j in range(i + 1)): assert result == A[k]"
            },
            {
                "description": "The result must not exceed the sum of A[k] and the maximum possible Increasing Subsequence sum found in the entire prefix A[0...i] (unconstrained by A[k]).",
                "assert_statement": "result <= A[k] + max_increasing_subsequence_sum(A[0:i+1])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 348,
        "Function_ID": 174,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]\n    **Function Description: ** Write a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a numeric type (integer or float) as it represents a calculated sum of array elements.",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "The calculated value represents the maximum achievable sum, and since the element a[k] must be included in the subsequence, the return value must be at least the value of a[k] itself.",
                "assert_statement": "assert result >= a[k]"
            },
            {
                "description": "The calculated maximum sum cannot exceed the total sum of all elements in the input array 'a'.",
                "assert_statement": "assert result <= sum(a)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 349,
        "Function_ID": 175,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to get a colon of a tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result of the colon operation (full slice) must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The resulting tuple must have the same number of elements as the input tuple.",
                "assert_statement": "assert len(result) == len(input_tuple)"
            },
            {
                "description": "The resulting tuple must be content-equal to the input tuple (as a full slice creates a copy with identical elements).",
                "assert_statement": "assert result == input_tuple"
            },
            {
                "description": "The elements of the resulting tuple must maintain the order of the elements in the input tuple.",
                "assert_statement": "assert all(result[i] == input_tuple[i] for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 350,
        "Function_ID": 175,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon\n    **Function Description: ** Write a function to get a colon of a tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned object is a deep copy of the input tuple.",
                "assert_statement": "assert result is not tuplex and result[m] is not tuplex[m]"
            },
            {
                "description": "The element at index 'm' in the returned tuple has the value 'n' appended to it, increasing its length by exactly one.",
                "assert_statement": "assert result[m][-1] == n and len(result[m]) == len(tuplex[m]) + 1"
            },
            {
                "description": "All elements in the returned tuple, except for the element at index 'm', are identical to the corresponding elements in the input tuple.",
                "assert_statement": "assert all(result[i] == tuplex[i] for i in range(len(tuplex)) if i != m)"
            },
            {
                "description": "Due to the deep copy operation, the original input tuple's content (specifically the mutable element at index 'm') remains unmodified.",
                "assert_statement": "assert tuplex[m] == original_tuplex_m_content"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 351,
        "Function_ID": 176,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the specified number of largest products from two given lists, selecting one factor from each list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the returned list must be equal to k, unless the total number of possible product pairs is less than k.",
                "assert_statement": "len(result) == min(k, len(list_a) * len(list_b))"
            },
            {
                "description": "The returned list contains the correct values, which are the k largest products derivable from one factor in list_a and one factor in list_b.",
                "assert_statement": "sorted(result, reverse=True) == sorted([a * b for a in list_a for b in list_b], reverse=True)[:k]"
            },
            {
                "description": "All elements in the result are positive or negative numerical values (products).",
                "assert_statement": "all(isinstance(p, (int, float)) for p in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 352,
        "Function_ID": 176,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def large_product(nums1, nums2, N):\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\n    return result\n    **Function Description: ** Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list equals the minimum of N and the total count of pairwise products possible (len(nums1) * len(nums2)).",
                "assert_statement": "assert len(result) == min(N, len(nums1) * len(nums2))"
            },
            {
                "description": "The returned list is sorted in descending order (non-increasing).",
                "assert_statement": "assert all(result[i] >= result[i+1] for i in range(len(result) - 1))"
            },
            {
                "description": "Every element in the returned list must be a valid product formed by one element from nums1 and one element from nums2.",
                "assert_statement": "assert all(r in {x * y for x in nums1 for y in nums2} for r in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 353,
        "Function_ID": 177,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the maximum of two numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value (the maximum) must be greater than or equal to the first input number.",
                "assert_statement": "result >= a"
            },
            {
                "description": "The returned value (the maximum) must be greater than or equal to the second input number.",
                "assert_statement": "result >= b"
            },
            {
                "description": "The returned value must be one of the two input numbers.",
                "assert_statement": "result == a or result == b"
            },
            {
                "description": "If the first number is strictly greater than the second number, the result must equal the first number.",
                "assert_statement": "if a > b: assert result == a"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 354,
        "Function_ID": 177,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def maximum(a,b):   \n    if a >= b: \n        return a \n    else: \n        return b \n    **Function Description: ** Write a python function to find the maximum of two numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be equal to one of the input arguments (a or b).",
                "assert_statement": "assert result == a or result == b"
            },
            {
                "description": "The returned value must be greater than or equal to the first input 'a'.",
                "assert_statement": "assert result >= a"
            },
            {
                "description": "The returned value must be greater than or equal to the second input 'b'.",
                "assert_statement": "assert result >= b"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 355,
        "Function_ID": 178,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert a given string to a tuple of characters.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an instance of a tuple.",
                "assert_statement": "isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting tuple must be equal to the length of the input string.",
                "assert_statement": "len(result) == len(input_string)"
            },
            {
                "description": "The resulting tuple must contain the characters of the input string in the exact sequence.",
                "assert_statement": "result == tuple(input_string)"
            },
            {
                "description": "Every element within the resulting tuple must be a single character string.",
                "assert_statement": "all(isinstance(c, str) and len(c) == 1 for c in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 356,
        "Function_ID": 178,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def string_to_tuple(str1):\n    result = tuple(x for x in str1 if not x.isspace()) \n    return result\n    **Function Description: ** Write a function to convert a given string to a tuple of characters.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an instance of the tuple type.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The returned tuple must only contain characters that were not whitespace in the input string.",
                "assert_statement": "assert all(not char.isspace() for char in result)"
            },
            {
                "description": "The length of the returned tuple must equal the total count of non-whitespace characters in the original input string.",
                "assert_statement": "assert len(result) == sum(1 for char in str1 if not char.isspace())"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 357,
        "Function_ID": 179,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to set the left most unset bit.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be strictly greater than the input, as exactly one unset bit is changed to a set bit.",
                "assert_statement": "result > n"
            },
            {
                "description": "The result must preserve all bits that were originally set in the input (non-destructive operation).",
                "assert_statement": "(result | n) == result"
            },
            {
                "description": "The difference between the result and the input must correspond to a single set bit (i.e., the difference must be a power of two).",
                "assert_statement": "diff = result - n; diff > 0 and (diff & (diff - 1)) == 0"
            },
            {
                "description": "If P is the power of two difference (the flipped bit), then the bit immediately higher (2*P) must either be set in the original input 'n' OR 'n' must be smaller than 2*P (implying 2*P is beyond the current highest active bit of 'n'), ensuring 'P' was the leftmost unset bit.",
                "assert_statement": "diff = result - n; next_bit = diff * 2; (n & next_bit) != 0 or n < next_bit"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 358,
        "Function_ID": 179,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def set_left_most_unset_bit(n): \n    if not (n & (n + 1)): \n        return n \n    pos, temp, count = 0, n, 0 \n    while temp: \n        if not (temp & 1): \n            pos = count      \n        count += 1; temp>>=1\n    return (n | (1 << (pos))) \n    **Function Description: ** Write a python function to set the left most unset bit.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input 'n' is composed only of set bits up to its most significant bit (i.e., n is of the form 2^k - 1), the function returns n, adhering to the implementation's specific edge case.",
                "assert_statement": "if not (n & (n + 1)): assert result == n"
            },
            {
                "description": "If 'n' is not the edge case (meaning an unset bit was found), the result must be strictly greater than n.",
                "assert_statement": "if (n & (n + 1)): assert result > n"
            },
            {
                "description": "In the general case, the result 'R' is generated by flipping exactly one bit (the rightmost zero bit) in 'n'. Therefore, R XOR n must be a positive power of two.",
                "assert_statement": "if (n & (n + 1)): P = result ^ n; assert P > 0 and (P & (P - 1) == 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 359,
        "Function_ID": 180,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the volume of a cone.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated volume must match the standard geometric formula (V = 1/3 * pi * r^2 * h).",
                "assert_statement": "result == (1.0 / 3.0) * math.pi * (radius ** 2) * height"
            },
            {
                "description": "The calculated volume must be a non-negative number, assuming radius and height are non-negative inputs.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned value must be of a numerical type (float is expected due to pi and division).",
                "assert_statement": "isinstance(result, (float, int))"
            },
            {
                "description": "If the radius or height is zero, the resulting volume must be zero.",
                "assert_statement": "(radius == 0 or height == 0) and result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 360,
        "Function_ID": 180,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math\ndef volume_cone(r,h):\n  volume = (1.0/3) * math.pi * r * r * h\n  return volume\n    **Function Description: ** Write a function to find the volume of a cone.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a floating-point number.",
                "assert_statement": "import math; assert isinstance(result, float)"
            },
            {
                "description": "The calculated volume must match the geometric formula for a cone V = (1/3) * pi * r^2 * h.",
                "assert_statement": "import math; expected = (1.0/3) * math.pi * r * r * h; assert abs(result - expected) < 1e-9"
            },
            {
                "description": "If the radius (r) or height (h) is zero, the resulting volume must be zero.",
                "assert_statement": "assert not ((r == 0 or h == 0) and result != 0.0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 361,
        "Function_ID": 181,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the highest power of 2 that is less than or equal to n.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value (result) must be less than or equal to the input integer n.",
                "assert_statement": "result <= n"
            },
            {
                "description": "The returned value must be a positive integer that is a power of 2 (using bit manipulation check).",
                "assert_statement": "(result > 0) and ((result & (result - 1)) == 0)"
            },
            {
                "description": "The returned value must be the highest power of 2 satisfying the condition, meaning the next power of 2 must strictly exceed n.",
                "assert_statement": "2 * result > n"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 362,
        "Function_ID": 181,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def highest_Power_of_2(n): \n    res = 0 \n    for i in range(n, 0, -1): \n        if ((i & (i - 1)) == 0): \n            res = i \n            break \n    return res \n    **Function Description: ** Write a python function to find the highest power of 2 that is less than or equal to n.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be less than or equal to the input n.",
                "assert_statement": "assert result <= n"
            },
            {
                "description": "If the input n is positive (n >= 1), the returned value must itself be a positive power of 2.",
                "assert_statement": "if n >= 1: assert result > 0 and (result & (result - 1)) == 0"
            },
            {
                "description": "If the result is positive, the next power of 2 (twice the result) must strictly exceed n, proving the maximality of the result.",
                "assert_statement": "if result > 0: assert result * 2 > n"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 363,
        "Function_ID": 182,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the n'th lucas number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "If n is 0, the Lucas number (L0) must be 2.",
                "assert_statement": "n == 0 and result == 2"
            },
            {
                "description": "If n is 1, the Lucas number (L1) must be 1.",
                "assert_statement": "n == 1 and result == 1"
            },
            {
                "description": "For n greater than 1, the result must equal the sum of the (n-1)th and (n-2)th Lucas numbers (L_n = L_{n-1} + L_{n-2}).",
                "assert_statement": "n > 1 and result == lucas_number(n - 1) + lucas_number(n - 2)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 364,
        "Function_ID": 182,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_lucas(n): \n\tif (n == 0): \n\t\treturn 2\n\tif (n == 1): \n\t\treturn 1\n\treturn find_lucas(n - 1) + find_lucas(n - 2) \n    **Function Description: ** Write a function to find the n'th lucas number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input n is 1, the function must return the first Lucas number, L(1) = 1.",
                "assert_statement": "assert find_lucas(1) == 1"
            },
            {
                "description": "The function must correctly calculate the Lucas number for a recursive case, L(4)=7.",
                "assert_statement": "assert find_lucas(4) == 7"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 365,
        "Function_ID": 183,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to apply a given format string to all of the elements in a list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting list must have the same number of elements as the input list.",
                "assert_statement": "len(result_list) == len(input_list)"
            },
            {
                "description": "All elements in the resulting list must be strings, as formatting typically converts values to string representations.",
                "assert_statement": "all(isinstance(element, str) for element in result_list)"
            },
            {
                "description": "Each element in the resulting list must equal the format string applied to the corresponding input element.",
                "assert_statement": "all(fmt_string.format(i) == o for i, o in zip(input_list, result_list))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 366,
        "Function_ID": 183,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def add_string(list_, string):\n add_string=[string.format(i) for i in  list_]\n return add_string\n    **Function Description: ** Write a function to apply a given format string to all of the elements in a list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list equals the length of the input list.",
                "assert_statement": "assert len(result) == len(list_)"
            },
            {
                "description": "Each element in the returned list is the result of applying the format string to the corresponding input list element.",
                "assert_statement": "assert all(result[i] == string.format(list_[i]) for i in range(len(list_)))"
            },
            {
                "description": "All elements in the returned list must be strings.",
                "assert_statement": "assert all(isinstance(x, str) for x in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 367,
        "Function_ID": 184,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert more than one list to nested dictionary.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a dictionary object.",
                "assert_statement": "isinstance(result, dict)"
            },
            {
                "description": "If the input lists were non-empty, the resulting nested dictionary must also not be empty.",
                "assert_statement": "bool(result)"
            },
            {
                "description": "To confirm nesting, at least one top-level value must be a dictionary itself, provided the inputs required a depth greater than one.",
                "assert_statement": "any(isinstance(value, dict) for value in result.values())"
            },
            {
                "description": "All values corresponding to the deepest keys in the dictionary structure must match the final value elements provided by the input lists.",
                "assert_statement": "check_all_final_values_are_correct(result, expected_values)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 368,
        "Function_ID": 184,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def convert_list_dictionary(l1, l2, l3):\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\n     return result\n    **Function Description: ** Write a function to convert more than one list to nested dictionary.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the resulting list must equal the length of the shortest input list, determined by zip behavior.",
                "assert_statement": "assert len(result) == min(len(l1), len(l2), len(l3))"
            },
            {
                "description": "If the input lists are not empty, every element in the resulting list at index 'i' must be a dictionary structured as {l1[i]: {l2[i]: l3[i]}}.",
                "assert_statement": "assert all(result[i] == {l1[i]: {l2[i]: l3[i]}} for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 369,
        "Function_ID": 185,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be an integer and non-negative, as all intermediate sums and the base value n are non-negative.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The calculated maximum sum must be greater than or equal to the input value n, because the function definition uses max(..., n).",
                "assert_statement": "result >= n"
            },
            {
                "description": "The result must satisfy the defining equation, meaning the result is either n or the sum of the recursive calls using integer division.",
                "assert_statement": "(result == n) or (result == f_solve(n // 2) + f_solve(n // 3) + f_solve(n // 4) + f_solve(n // 5))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 370,
        "Function_ID": 185,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def get_max_sum (n):\n\tres = list()\n\tres.append(0)\n\tres.append(1)\n\ti = 2\n\twhile i<n + 1:\n\t\tres.append(max(i, (res[int(i / 2)] \n\t\t\t\t\t\t+ res[int(i / 3)] +\n\t\t\t\t\t\t\tres[int(i / 4)]\n\t\t\t\t\t\t+ res[int(i / 5)])))\n\t\ti = i + 1\n\treturn res[n]\n    **Function Description: ** Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "For input n=6, the maximum sum calculated using the recurrence relation f(n) = max(n, f(n/2) + f(n/3) + f(n/4) + f(n/5)) should be 7.",
                "assert_statement": "assert get_max_sum(6) == 7"
            },
            {
                "description": "For input n=12, the maximum sum calculated using the recurrence relation should be 16.",
                "assert_statement": "assert get_max_sum(12) == 16"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 371,
        "Function_ID": 186,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the list with maximum length.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "The returned list is one of the lists in the input iterable.",
                "assert_statement": "result in iterable_of_lists"
            },
            {
                "description": "The returned list's length is greater than or equal to the length of every other list in the input iterable.",
                "assert_statement": "all(len(result) >= len(lst) for lst in iterable_of_lists)"
            },
            {
                "description": "If the input iterable is empty, the function should return an empty list (assuming a specified default behavior for the empty case, otherwise a specific exception might be expected, but for standard max-finding without explicit default this is a common proxy/default).",
                "assert_statement": "not iterable_of_lists or result != [] or any(len(lst) == 0 for lst in iterable_of_lists)"
            },
            {
                "description": "If there are multiple lists with the maximum length, the function should return one of those lists (the behavior is typically determined by the underlying 'max' function, usually returning the first encountered or the lexicographically smallest/largest if lists are compared directly, but here we only enforce it has the max length).",
                "assert_statement": "len(result) == max(len(lst) for lst in iterable_of_lists) if iterable_of_lists else True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 372,
        "Function_ID": 186,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_length_list(input_list):\n    max_length = max(len(x) for x in input_list )   \n    max_list = max(input_list, key = lambda i: len(i))    \n    return(max_length, max_list)\n    **Function Description: ** Write a function to find the list with maximum length.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a tuple of length two, where the first element is an integer (the maximum length) and the second element is the iterable item having that length.",
                "assert_statement": "assert isinstance(result, tuple) and len(result) == 2 and isinstance(result[0], int)"
            },
            {
                "description": "The length of the identified maximum list (the second element) must equal the calculated maximum length (the first element).",
                "assert_statement": "assert len(result[1]) == result[0]"
            },
            {
                "description": "The returned maximum length must be greater than or equal to the length of every iterable contained within the original input list.",
                "assert_statement": "assert all(len(item) <= result[0] for item in input_list)"
            },
            {
                "description": "The returned maximum list must be one of the items present in the original input list.",
                "assert_statement": "assert result[1] in input_list"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 373,
        "Function_ID": 187,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check if given tuple contains no duplicates.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the input tuple contains only unique elements (i.e., its length equals the length of its set representation), the function must return True.",
                "assert_statement": "if len(set(input_tuple)) == len(input_tuple): assert result == True"
            },
            {
                "description": "If the input tuple contains duplicates (i.e., the length of its set representation is less than the tuple's total length), the function must return False.",
                "assert_statement": "if len(set(input_tuple)) < len(input_tuple): assert result == False"
            },
            {
                "description": "The function must always return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 374,
        "Function_ID": 187,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res \n    **Function Description: ** Write a function to check if given tuple contains no duplicates.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The function returns True if and only if the number of elements in the tuple is equal to the number of unique elements (i.e., the tuple contains no duplicates).",
                "assert_statement": "assert result == (len(test_tup) == len(set(test_tup)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 375,
        "Function_ID": 188,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the first non-repeated character in a given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If a character is found, the result must be a single-character string.",
                "assert_statement": "(result is None) or (len(result) == 1)"
            },
            {
                "description": "If a character is found, it must appear exactly once in the entire input string.",
                "assert_statement": "(result is None) or (input_str.count(result) == 1)"
            },
            {
                "description": "If a character is found, no character preceding it in the input string may also be a non-repeated character (ensuring it is the 'first').",
                "assert_statement": "(result is None) or (not any(input_str.count(c) == 1 for c in input_str[:input_str.index(result)]))"
            },
            {
                "description": "If no character is returned (result is None), then every character in the input string must appear more than once.",
                "assert_statement": "(result is not None) or (all(input_str.count(c) > 1 for c in input_str))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 376,
        "Function_ID": 188,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def first_non_repeating_character(str1):\n  char_order = []\n  ctr = {}\n  for c in str1:\n    if c in ctr:\n      ctr[c] += 1\n    else:\n      ctr[c] = 1 \n      char_order.append(c)\n  for c in char_order:\n    if ctr[c] == 1:\n      return c\n  return None\n    **Function Description: ** Write a python function to find the first non-repeated character in a given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns a non-None value, it must be a single character string.",
                "assert_statement": "assert result is None or (isinstance(result, str) and len(result) == 1)"
            },
            {
                "description": "If a character is returned, its count in the original string must be exactly one.",
                "assert_statement": "assert result is None or str1.count(result) == 1"
            },
            {
                "description": "If the result is None, it implies that either the input string was empty or all characters in the string appeared more than once.",
                "assert_statement": "assert result is not None or (not str1 or all(str1.count(c) > 1 for c in set(str1)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 377,
        "Function_ID": 189,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether the given string starts and ends with the same character or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the string has a length of one or greater than one and the first character equals the last character, the result must be True.",
                "assert_statement": "(len(s) == 1 or (len(s) > 1 and s[0] == s[-1])) and result == True"
            },
            {
                "description": "If the string has a length of at least two and the first character does not equal the last character, the result must be False.",
                "assert_statement": "len(s) >= 2 and s[0] != s[-1] and result == False"
            },
            {
                "description": "If the string is empty, the result must be False.",
                "assert_statement": "len(s) == 0 and result == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 378,
        "Function_ID": 189,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re  \nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef check_char(string): \n\tif(re.search(regex, string)): \n\t\treturn \"Valid\" \n\telse: \n\t\treturn \"Invalid\" \n    **Function Description: ** Write a function to check whether the given string starts and ends with the same character or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input string matches the defined pattern (is a single lowercase character, or starts and ends with the same lowercase character), the return value must be 'Valid'.",
                "assert_statement": "import re; regex = r'^[a-z]$|^([a-z]).*\\1$'; if re.search(regex, input_string): assert result == 'Valid'"
            },
            {
                "description": "If the input string does not match the defined pattern (e.g., different start/end characters, non-lowercase start/end, or empty), the return value must be 'Invalid'.",
                "assert_statement": "import re; regex = r'^[a-z]$|^([a-z]).*\\1$'; if not re.search(regex, input_string): assert result == 'Invalid'"
            },
            {
                "description": "The return value must always be a string and one of the two defined constants, 'Valid' or 'Invalid'.",
                "assert_statement": "assert isinstance(result, str) and result in ('Valid', 'Invalid')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 379,
        "Function_ID": 190,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the median of three numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be equal to one of the three input numbers (a, b, or c).",
                "assert_statement": "result == a or result == b or result == c"
            },
            {
                "description": "The number of inputs that are less than or equal to the result must be at least two.",
                "assert_statement": "((a <= result) + (b <= result) + (c <= result)) >= 2"
            },
            {
                "description": "The number of inputs that are greater than or equal to the result must be at least two.",
                "assert_statement": "((a >= result) + (b >= result) + (c >= result)) >= 2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 380,
        "Function_ID": 190,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def median_numbers(a,b,c):\n if a > b:\n    if a < c:\n        median = a\n    elif b > c:\n        median = b\n    else:\n        median = c\n else:\n    if a > c:\n        median = a\n    elif b < c:\n        median = b\n    else:\n        median = c\n return median\n    **Function Description: ** Write a function to find the median of three numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be equal to the median element, which is the middle element when the three inputs are sorted.",
                "assert_statement": "assert result == sorted([a, b, c])[1]"
            },
            {
                "description": "The returned value must be one of the three input numbers (a, b, or c).",
                "assert_statement": "assert result in (a, b, c)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 381,
        "Function_ID": 191,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to compute the sum of digits of each number of a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a list.",
                "assert_statement": "isinstance(result_list, list)"
            },
            {
                "description": "The resulting list must have the same length as the input list (one sum for each input number).",
                "assert_statement": "len(result_list) == len(input_list)"
            },
            {
                "description": "Each element in the resulting list must be a non-negative integer.",
                "assert_statement": "all(isinstance(x, int) and x >= 0 for x in result_list)"
            },
            {
                "description": "Each element in the result list must equal the sum of the digits of the corresponding number in the input list.",
                "assert_statement": "all(result_list[i] == sum(int(d) for d in str(abs(input_list[i]))) for i in range(len(input_list)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 382,
        "Function_ID": 191,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sum_of_digits(nums):\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())\n    **Function Description: ** Write a function to compute the sum of digits of each number of a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer and cannot be negative, as it represents a sum of digits (0-9).",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input list contains standard positive integers, the result should be the total sum of all their digits (e.g., [10, 200] -> 1 + 0 + 2 + 0 + 0 = 3).",
                "assert_statement": "assert sum_of_digits([10, 200, 5]) == 8"
            },
            {
                "description": "Non-digit characters, including signs ('-'), decimals ('.'), and letters, must be filtered out before summation (e.g., [-1.2, 'a30'] -> 1 + 2 + 3 + 0 = 6).",
                "assert_statement": "assert sum_of_digits([-1.2, \"a30\", 5000]) == 11"
            },
            {
                "description": "If the input list is empty, the resulting sum must be zero.",
                "assert_statement": "assert sum_of_digits([]) == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 383,
        "Function_ID": 192,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to perform the mathematical bitwise xor operation across the given tuples.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result of the operation must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The resulting tuple must have the same length as the input tuples.",
                "assert_statement": "assert len(result) == len(tuple_a)"
            },
            {
                "description": "Every element in the resulting tuple is the bitwise XOR (^) of the corresponding elements in the input tuples.",
                "assert_statement": "assert all(result[i] == (tuple_a[i] ^ tuple_b[i]) for i in range(len(result)))"
            },
            {
                "description": "All elements in the result tuple must be integers (as bitwise operations usually produce integers).",
                "assert_statement": "assert all(isinstance(x, int) for x in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 384,
        "Function_ID": 192,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def bitwise_xor(test_tup1, test_tup2):\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) \n    **Function Description: ** Write a function to perform the mathematical bitwise xor operation across the given tuples.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is always a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting tuple is equal to the length of the shortest input tuple.",
                "assert_statement": "assert len(result) == min(len(test_tup1), len(test_tup2))"
            },
            {
                "description": "Each element in the result tuple is the bitwise XOR of the corresponding elements in the input tuples.",
                "assert_statement": "assert all(result[i] == (test_tup1[i] ^ test_tup2[i]) for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 385,
        "Function_ID": 193,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to extract the number of unique tuples in the given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result, representing the count of unique tuples, must be equal to the length of the set of all unique elements of type 'tuple' found in the input list.",
                "assert_statement": "assert result == len(set(item for item in input_list if isinstance(item, tuple)))"
            },
            {
                "description": "The returned result must be an integer and cannot be negative.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 386,
        "Function_ID": 193,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def extract_freq(test_list):\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\n  return (res)\n    **Function Description: ** Write a function to extract the number of unique tuples in the given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a non-negative integer, representing a count.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The return value must equal the number of unique sub-iterables in the input list, considering sub-iterables identical if they contain the same elements regardless of internal order.",
                "assert_statement": "assert result == len(list(set(tuple(sorted(sub)) for sub in test_list)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 387,
        "Function_ID": 194,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to perform index wise addition of tuple elements in the given two nested tuples.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The overall result must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The structure of the resulting tuple must maintain the original nesting, meaning all inner elements must also be tuples.",
                "assert_statement": "assert all(isinstance(inner_tuple, tuple) for inner_tuple in result)"
            },
            {
                "description": "The length of the resulting outer tuple must match the length of the input tuples.",
                "assert_statement": "assert len(result) == len(input_tuple_1)"
            },
            {
                "description": "The length of every inner tuple in the result must match the length of the corresponding inner tuples in the input.",
                "assert_statement": "assert all(len(result[i]) == len(input_tuple_1[i]) for i in range(len(result)))"
            },
            {
                "description": "Every element in the resulting nested tuple must equal the sum of the corresponding elements from the two input tuples.",
                "assert_statement": "assert all(result[i][j] == input_tuple_1[i][j] + input_tuple_2[i][j] for i in range(len(result)) for j in range(len(result[i])))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 388,
        "Function_ID": 194,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def add_nested_tuples(test_tup1, test_tup2):\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \n    **Function Description: ** Write a function to perform index wise addition of tuple elements in the given two nested tuples.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting outer tuple must be equal to the length of the shorter input tuple, as determined by the external zip operation.",
                "assert_statement": "assert len(result) == min(len(test_tup1), len(test_tup2))"
            },
            {
                "description": "The resulting nested tuple contains the exact element-wise sums of the corresponding inner tuples from the inputs, respecting the length constraints imposed by nested zip operations.",
                "assert_statement": "expected = tuple(tuple(a + b for a, b in zip(tup1, tup2)) for tup1, tup2 in zip(test_tup1, test_tup2)); assert result == expected"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 389,
        "Function_ID": 195,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the minimum of two numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned minimum value must be one of the two input numbers.",
                "assert_statement": "min_val == a or min_val == b"
            },
            {
                "description": "The returned minimum value must be less than or equal to the first input.",
                "assert_statement": "min_val <= a"
            },
            {
                "description": "The returned minimum value must be less than or equal to the second input.",
                "assert_statement": "min_val <= b"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 390,
        "Function_ID": 195,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b \n    **Function Description: ** Write a python function to find the minimum of two numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be less than or equal to both input arguments a and b.",
                "assert_statement": "assert result <= a and result <= b"
            },
            {
                "description": "The returned value must be one of the two input arguments (a or b).",
                "assert_statement": "assert result == a or result == b"
            },
            {
                "description": "If a is less than or equal to b, the returned value must equal a.",
                "assert_statement": "if a <= b: assert result == a"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 391,
        "Function_ID": 196,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether an element exists within a tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a boolean value that accurately reflects whether the target element is present in the input tuple.",
                "assert_statement": "assert result == (element in input_tuple)"
            },
            {
                "description": "The type of the return value must be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, the element must logically exist within the input tuple.",
                "assert_statement": "assert element in input_tuple if result else True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 392,
        "Function_ID": 196,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_tuplex(tuplex,tuple1): \n  if tuple1 in tuplex:\n    return True\n  else:\n     return False\n    **Function Description: ** Write a function to check whether an element exists within a tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is True if the element (tuple1) is a member of the tuple (tuplex), and False otherwise.",
                "assert_statement": "assert result == (tuple1 in tuplex)"
            },
            {
                "description": "The function always returns a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 393,
        "Function_ID": 197,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find whether the parity of a given number is odd.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a boolean type.",
                "assert_statement": "isinstance(result, bool)"
            },
            {
                "description": "The returned value must be True if the count of set bits (1s) in the binary representation of the input number 'n' is odd.",
                "assert_statement": "result == (bin(n).count('1') % 2 != 0)"
            },
            {
                "description": "If the function returns True, the input number 'n' must necessarily have an odd parity (odd number of set bits).",
                "assert_statement": "not result or (bin(n).count('1') % 2 != 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 394,
        "Function_ID": 197,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False\n    **Function Description: ** Write a python function to find whether the parity of a given number is odd.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a boolean indicating the parity of the input integer x (True if parity is odd, False if parity is even).",
                "assert_statement": "assert __return__ == (bin(__x__).count('1') % 2 == 1)"
            },
            {
                "description": "The return value must always be a boolean type.",
                "assert_statement": "assert isinstance(__return__, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 395,
        "Function_ID": 198,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to create the next bigger number by rearranging the digits of a given number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting number must be strictly greater than the input number (when a solution exists).",
                "assert_statement": "assert result > input_num"
            },
            {
                "description": "The resulting number must consist of the exact same digits (same count/frequency) as the input number.",
                "assert_statement": "assert sorted(str(result)) == sorted(str(input_num))"
            },
            {
                "description": "If a valid number is returned, it must be the smallest number satisfying the conditions (the 'next' bigger number).",
                "assert_statement": "assert not any(p for p in generate_all_permutations(input_num) if input_num < p < result)"
            },
            {
                "description": "If the input is already the largest possible permutation of its digits, the function must return the designated indicator for failure (e.g., -1 or 0).",
                "assert_statement": "if is_maximal_permutation(input_num): assert result in [-1, 0, None]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 396,
        "Function_ID": 198,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums)-2,-1,-1):\n        if nums[i] < nums[i+1]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(\"\".join(nums))\n    return False\n    **Function Description: ** Write a function to create the next bigger number by rearranging the digits of a given number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the return value is not False (indicating a successful rearrangement), it must be an integer strictly greater than the input n.",
                "assert_statement": "assert result is False or (isinstance(result, int) and result > n)"
            },
            {
                "description": "If a number is successfully rearranged (result is not False), the returned number must be an anagram of the input n (contain the same digits).",
                "assert_statement": "assert result is False or sorted(str(result)) == sorted(str(n))"
            },
            {
                "description": "The function must return either an integer (for success) or the boolean value False (for failure).",
                "assert_statement": "assert isinstance(result, int) or result is False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 397,
        "Function_ID": 199,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The number of returned pairs must be equal to k, unless the total number of possible unique pairs is less than k.",
                "assert_statement": "len(result) == min(k, len(nums1) * len(nums2))"
            },
            {
                "description": "Every element in the result must be a pair (list or tuple of size 2) where the first element originates from nums1 and the second from nums2.",
                "assert_statement": "all(isinstance(pair, list) and len(pair) == 2 and pair[0] in nums1 and pair[1] in nums2 for pair in result)"
            },
            {
                "description": "The set of sums of the returned pairs must correspond exactly to the set of the k smallest sums achievable by combining elements from nums1 and nums2.",
                "assert_statement": "expected_sums = sorted([n1 + n2 for n1 in nums1 for n2 in nums2]); returned_sums = [pair[0] + pair[1] for pair in result]; assert sorted(returned_sums) == sorted(expected_sums[:len(returned_sums)])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 398,
        "Function_ID": 199,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import heapq\ndef k_smallest_pairs(nums1, nums2, k):\n   queue = []\n   def push(i, j):\n       if i < len(nums1) and j < len(nums2):\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n   push(0, 0)\n   pairs = []\n   while queue and len(pairs) < k:\n       _, i, j = heapq.heappop(queue)\n       pairs.append([nums1[i], nums2[j]])\n       push(i, j + 1)\n       if j == 0:\n           push(i + 1, 0)\n   return pairs\n    **Function Description: ** Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a list of pairs, where each pair is a list of exactly two elements.",
                "assert_statement": "assert isinstance(result, list) and all(isinstance(p, list) and len(p) == 2 for p in result)"
            },
            {
                "description": "The number of returned pairs must be less than or equal to k and cannot exceed the total possible number of pairs formed by nums1 and nums2.",
                "assert_statement": "assert len(result) <= k and len(result) <= len(nums1) * len(nums2)"
            },
            {
                "description": "The pairs are returned in non-decreasing order based on the sum of elements within each pair, satisfying the requirement for finding the smallest pairs.",
                "assert_statement": "assert all((result[i][0] + result[i][1]) <= (result[i+1][0] + result[i+1][1]) for i in range(len(result) - 1))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 399,
        "Function_ID": 200,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the minimum product from the pairs of tuples within a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is an integer or float representing the minimum product.",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "The returned result must be equal to the minimum product calculated across all tuples in the input list (L).",
                "assert_statement": "assert result == min(x * y for x, y in L)"
            },
            {
                "description": "The result must be less than or equal to every individual product calculated from the pairs in the input list (L).",
                "assert_statement": "assert all(result <= x * y for x, y in L)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 400,
        "Function_ID": 200,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min\n    **Function Description: ** Write a function to find the minimum product from the pairs of tuples within a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value, being the absolute minimum product, must be non-negative.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The returned value must be equal to the smallest absolute product derived from all (x, y) pairs in the input list.",
                "assert_statement": "assert result == min([abs(x * y) for x, y in list1])"
            },
            {
                "description": "The returned value must be a numeric type (integer or float), resulting from applying min() to a list of absolute products.",
                "assert_statement": "assert isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 401,
        "Function_ID": 201,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the minimum value in a given heterogeneous list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned minimum value must be an element of the original input list (assuming the list was not empty and a comparable element was found).",
                "assert_statement": "assert result in input_list"
            },
            {
                "description": "The returned value must be less than or equal to every other comparable element in the input list.",
                "assert_statement": "assert all(result <= x for x in input_list if type(x) == type(result) or (isinstance(x, (int, float)) and isinstance(result, (int, float))))"
            },
            {
                "description": "If the input list is empty or contains no comparable values, the function should return a specific predefined failure value (e.g., None).",
                "assert_statement": "assert result is None if not input_list else True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 402,
        "Function_ID": 201,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val\n    **Function Description: ** Write a function to find the minimum value in a given heterogeneous list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be of type integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned value must be less than or equal to every integer element found within the original input list.",
                "assert_statement": "assert all(result <= i for i in listval if isinstance(i, int))"
            },
            {
                "description": "The returned value must be an element present in the original input list.",
                "assert_statement": "assert result in listval"
            },
            {
                "description": "If the input list contains no elements of type integer, a ValueError must be raised.",
                "assert_statement": "import pytest; with pytest.raises(ValueError): min_val(['a', 'b', 3.5])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 403,
        "Function_ID": 202,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert the given snake case string to camel case string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting string must not contain any underscores, as they are used as separators and removed during the conversion.",
                "assert_statement": "assert '_' not in result"
            },
            {
                "description": "The length of the resulting camel case string must be equal to the length of the original string minus the count of all removed underscores.",
                "assert_statement": "assert len(result) == len(input_string) - input_string.count('_')"
            },
            {
                "description": "The function must return a string type.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "If the original string contained underscores, the resulting string must be different from the original string (i.e., conversion occurred).",
                "assert_statement": "assert input_string == result or '_' in input_string"
            },
            {
                "description": "If the input string was empty, the output string must also be empty.",
                "assert_statement": "assert input_string or result == ''"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 404,
        "Function_ID": 202,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))\n    **Function Description: ** Write a function to convert the given snake case string to camel case string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "For standard snake_case input (segments separated by single underscores), the function converts it to PascalCase (no underscores).",
                "assert_statement": "assert snake_to_camel('input_string_test') == 'InputStringTest'"
            },
            {
                "description": "If the input contains empty segments (e.g., consecutive underscores, leading, or trailing underscores), those segments are preserved as literal underscores ('_') in the output.",
                "assert_statement": "assert snake_to_camel('__start_end__') == '__StartEnd__'"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 405,
        "Function_ID": 203,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to remove odd numbers from a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "All elements remaining in the resulting list must be even numbers.",
                "assert_statement": "all(x % 2 == 0 for x in result_list)"
            },
            {
                "description": "The resulting list must be identical to the original list filtered to contain only even numbers, preserving relative order.",
                "assert_statement": "result_list == [x for x in input_list if x % 2 == 0]"
            },
            {
                "description": "The length of the resulting list must be less than or equal to the length of the original list.",
                "assert_statement": "len(result_list) <= len(input_list)"
            },
            {
                "description": "If the original list contained no even numbers, the resulting list must be empty.",
                "assert_statement": "not any(x % 2 == 0 for x in input_list) == (len(result_list) == 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 406,
        "Function_ID": 203,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l\n    **Function Description: ** Write a python function to remove odd numbers from a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function modifies the input list `l` in place and returns a reference to the same list object.",
                "assert_statement": "l_in = [1, 2]; original_id = id(l_in); result = remove_odd(l_in); assert id(result) == original_id"
            },
            {
                "description": "For a test case [1, 2, 3, 4], the resulting list contains only even numbers, fulfilling the function's stated goal for this input.",
                "assert_statement": "l_test = [1, 2, 3, 4]; result = remove_odd(l_test); assert all(x % 2 == 0 for x in result)"
            },
            {
                "description": "When the input list is [1, 2, 3, 4], the list is modified in place to be exactly [2, 4].",
                "assert_statement": "l_check = [1, 2, 3, 4]; remove_odd(l_check); assert l_check == [2, 4]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 407,
        "Function_ID": 204,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to extract the nth element from a given list of tuples.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting list must be equal to the length of the input list of tuples.",
                "assert_statement": "len(result) == len(data)"
            },
            {
                "description": "The resulting object must be a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "Each element in the result list corresponds exactly to the nth element extracted from the respective input tuple.",
                "assert_statement": "all(result[i] == data[i][n] for i in range(len(data)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 408,
        "Function_ID": 204,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def extract_nth_element(list1, n):\n    result = [x[n] for x in list1]\n    return result\n    **Function Description: ** Write a function to extract the nth element from a given list of tuples.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input is valid, the returned list must have the same length as the input list, and each element must be the nth component extracted from the corresponding inner sequence.",
                "assert_statement": "input_list = [('a', 10), ('b', 20), ('c', 30)]; n_idx = 1; result = extract_nth_element(input_list, n_idx); assert len(result) == len(input_list) and all(result[i] == input_list[i][n_idx] for i in range(len(result)))"
            },
            {
                "description": "If the index 'n' is out of bounds for any inner element, an IndexError must be raised.",
                "assert_statement": "import pytest; with pytest.raises(IndexError): extract_nth_element([(1, 2), (3, 4)], 5)"
            },
            {
                "description": "If the input list contains elements that are not indexable (e.g., an integer), a TypeError must be raised during the extraction attempt.",
                "assert_statement": "import pytest; with pytest.raises(TypeError): extract_nth_element([(1, 2), 5, (6, 7)], 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 409,
        "Function_ID": 205,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether any value in a sequence exists in a sequence or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, it must be verified that at least one item from the first sequence (seq1) exists within the second sequence (seq2).",
                "assert_statement": "if result is True: assert any(item in seq2 for item in seq1)"
            },
            {
                "description": "If the function returns False, it must be verified that no item from the first sequence (seq1) exists within the second sequence (seq2).",
                "assert_statement": "if result is False: assert not any(item in seq2 for item in seq1)"
            },
            {
                "description": "The return value must always be a boolean (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 410,
        "Function_ID": 205,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def overlapping(list1,list2):  \n    for i in range(len(list1)): \n        for j in range(len(list2)): \n            if(list1[i]==list2[j]): \n                return True\n    return False\n    **Function Description: ** Write a python function to check whether any value in a sequence exists in a sequence or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The function returns True if and only if the intersection of the elements in list1 and list2 is non-empty (i.e., there is at least one common element).",
                "assert_statement": "assert result == bool(set(list1) & set(list2))"
            },
            {
                "description": "If either input list is empty, the function must return False, as no overlap is possible.",
                "assert_statement": "if not list1 or not list2: assert result is False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 411,
        "Function_ID": 206,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find a pair with highest product from a given array of integers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must be a pair (tuple or list) containing exactly two elements.",
                "assert_statement": "assert len(result) == 2"
            },
            {
                "description": "Both elements of the resulting pair must be present in the original input array.",
                "assert_statement": "assert result[0] in arr and result[1] in arr"
            },
            {
                "description": "The product of the returned pair must be the maximum product achievable from any two distinct elements in the input array.",
                "assert_statement": "assert result[0] * result[1] == max(arr[i] * arr[j] for i in range(len(arr)) for j in range(i + 1, len(arr)))"
            },
            {
                "description": "The product of the returned pair must be greater than or equal to the product of the two largest positive numbers and also greater than or equal to the product of the two smallest negative numbers (if they exist), ensuring the global maximum is found.",
                "assert_statement": "if len(arr) >= 2: \n    current_product = result[0] * result[1]\n    all_products = [arr[i] * arr[j] for i in range(len(arr)) for j in range(i + 1, len(arr))]\n    assert current_product >= max(all_products)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 412,
        "Function_ID": 206,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    \n    **Function Description: ** Write a python function to find a pair with highest product from a given array of integers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input array contains fewer than two elements, the function must return the specified error string.",
                "assert_statement": "if len(arr) < 2: assert result == \"No pairs exists\""
            },
            {
                "description": "If the array contains two or more elements, the returned value must be a tuple containing two elements from the original array.",
                "assert_statement": "if len(arr) >= 2: assert isinstance(result, tuple) and len(result) == 2 and result[0] in arr and result[1] in arr"
            },
            {
                "description": "If pairs exist, the product of the two returned elements must equal the maximum product achievable by any pair of distinct elements in the input array.",
                "assert_statement": "if len(arr) >= 2: R1, R2 = result; expected_max = max(arr[i] * arr[j] for i in range(len(arr)) for j in range(i + 1, len(arr))); assert R1 * R2 == expected_max"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 413,
        "Function_ID": 207,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find common first element in given list of tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "Every element present in the result must be the first element of all tuples in the input list (guaranteeing commonality).",
                "assert_statement": "all(all(t[0] == common_val for t in input_list) for common_val in result)"
            },
            {
                "description": "If the input list is empty, the result (the set of common elements) must also be empty.",
                "assert_statement": "len(input_list) > 0 or len(result) == 0"
            },
            {
                "description": "If a common element exists, it must be included in the result; otherwise, the result must be empty.",
                "assert_statement": "len(result) > 0 or not all(input_list[0][0] == t[0] for t in input_list) or len(input_list) == 0"
            },
            {
                "description": "The result set can contain at most one element (as the search is for *the* common element).",
                "assert_statement": "len(result) <= 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 414,
        "Function_ID": 207,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def group_tuples(Input): \n\tout = {} \n\tfor elem in Input: \n\t\ttry: \n\t\t\tout[elem[0]].extend(elem[1:]) \n\t\texcept KeyError: \n\t\t\tout[elem[0]] = list(elem) \n\treturn [tuple(values) for values in out.values()] \n    **Function Description: ** Write a function to find common first element in given list of tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a list, and all elements within that list are tuples.",
                "assert_statement": "assert isinstance(result, list) and all(isinstance(t, tuple) for t in result)"
            },
            {
                "description": "The number of resulting tuples must equal the count of unique first elements (keys) present in the input list of tuples, provided the input is not empty.",
                "assert_statement": "if Input: assert len(result) == len(set(i[0] for i in Input))"
            },
            {
                "description": "The total count of individual elements across all returned tuples must exactly match the total count of individual elements across all input tuples, ensuring data conservation.",
                "assert_statement": "assert sum(len(t) for t in result) == sum(len(t) for t in Input)"
            },
            {
                "description": "The first element of every output tuple must correspond to a grouping key found in the original input data.",
                "assert_statement": "unique_keys = set(i[0] for i in Input); assert all(t[0] in unique_keys for t in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 415,
        "Function_ID": 208,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the element of a list having maximum length.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the input list is empty, the returned value must be None.",
                "assert_statement": "assert input_list or result is None"
            },
            {
                "description": "If the input list is non-empty, the returned element must be one of the elements present in the input list.",
                "assert_statement": "assert not input_list or result in input_list"
            },
            {
                "description": "If the input list is non-empty, the length of the returned element must be greater than or equal to the length of every other element in the input list.",
                "assert_statement": "assert not input_list or all(len(result) >= len(item) for item in input_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 416,
        "Function_ID": 208,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList\n    **Function Description: ** Write a python function to find the element of a list having maximum length.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input list is non-empty, the returned value must be present in the original input list.",
                "assert_statement": "result = Find_Max(lst); assert result in lst"
            },
            {
                "description": "If the input list is non-empty, the returned value must be the maximum element based on standard comparison (greater than or equal to all other elements).",
                "assert_statement": "result = Find_Max(lst); assert all(result >= x for x in lst)"
            },
            {
                "description": "If the input list is empty, a ValueError must be raised by the built-in max function.",
                "assert_statement": "import pytest; with pytest.raises(ValueError): Find_Max([])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 417,
        "Function_ID": 209,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The final calculated result must be equal to the total sum of all rounded numbers in the input list, multiplied by the length of the input list.",
                "assert_statement": "result == sum(round(n) for n in input_list) * len(input_list)"
            },
            {
                "description": "The final result, being the product of a sum of integers and an integer length, must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The function must produce a single, non-negative numerical output if the input list is non-empty.",
                "assert_statement": "result >= 0 or len(input_list) == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 418,
        "Function_ID": 209,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def round_and_sum(list1):\n  lenght=len(list1)\n  round_and_sum=sum(list(map(round,list1))* lenght)\n  return round_and_sum\n    **Function Description: ** Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer, as the function performs rounding and subsequent arithmetic operations on integers derived from the input.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The return value must equal the sum of all elements in the input list after rounding, multiplied by the length of the original input list.",
                "assert_statement": "assert result == len(list1) * sum(round(x) for x in list1)"
            },
            {
                "description": "If the input list is empty, the length is zero, and the sum of rounded elements is zero, resulting in a return value of 0.",
                "assert_statement": "if len(list1) == 0: assert result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 419,
        "Function_ID": 210,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the cube sum of first n even natural numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The result must match the derived mathematical formula for the cube sum of the first n even natural numbers, which is 2n(n+1).",
                "assert_statement": "result == 2 * (n ** 2) * ((n + 1) ** 2)"
            },
            {
                "description": "The result must always be non-negative, since we are summing cubes of positive numbers (or zero if n=0).",
                "assert_statement": "result >= 0"
            },
            {
                "description": "If n is 1, the result must be the cube of the first even number (2 = 8).",
                "assert_statement": "n != 1 or result == 8"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 420,
        "Function_ID": 210,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def cube_Sum(n): \n    sum = 0\n    for i in range(1,n + 1): \n        sum += (2*i)*(2*i)*(2*i) \n    return sum\n    **Function Description: ** Write a python function to find the cube sum of first n even natural numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(R, int)"
            },
            {
                "description": "The returned sum must be non-negative, as it is a sum of cubes of positive numbers.",
                "assert_statement": "assert R >= 0"
            },
            {
                "description": "The return value must equal the closed-form mathematical result for the sum of the cubes of the first n even natural numbers, which is 2 * n^2 * (n + 1)^2.",
                "assert_statement": "assert R == 2 * (n ** 2) * ((n + 1) ** 2)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 421,
        "Function_ID": 211,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to concatenate each element of tuple by the delimiter.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting output must be a string data type.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The resulting string must be the concatenation of the input tuple elements joined by the specified delimiter.",
                "assert_statement": "assert result == delimiter.join(input_tuple)"
            },
            {
                "description": "If the input tuple is empty, the resulting string must be an empty string.",
                "assert_statement": "assert len(input_tuple) > 0 or result == \"\""
            },
            {
                "description": "If the input tuple is non-empty, the resulting string must contain exactly length(tuple) - 1 occurrences of the delimiter.",
                "assert_statement": "assert len(input_tuple) <= 1 or result.count(delimiter) == len(input_tuple) - 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 422,
        "Function_ID": 211,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) \n    **Function Description: ** Write a function to concatenate each element of tuple by the delimiter.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be of type string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "If the input tuple is empty, the return value must be an empty string.",
                "assert_statement": "if not test_tup: assert result == \"\""
            },
            {
                "description": "If the input tuple is non-empty, the returned string must equal the string representations of the elements joined by the delimiter '-'.",
                "assert_statement": "if test_tup: assert result == \"-\".join(str(e) for e in test_tup)"
            },
            {
                "description": "If the input tuple is non-empty, the resulting string must not end with the delimiter '-'.",
                "assert_statement": "if test_tup: assert not result.endswith(\"-\")"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 423,
        "Function_ID": 212,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the average of cubes of first n natural numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a numeric type (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "The result must be positive, as the input n is a natural number (n >= 1).",
                "assert_statement": "assert result > 0"
            },
            {
                "description": "The calculated average must match the closed-form mathematical formula: n * (n + 1)^2 / 4.",
                "assert_statement": "assert result == (n * (n + 1)**2) / 4"
            },
            {
                "description": "The calculated average must equal the sum of the cubes of the first n natural numbers divided by n.",
                "assert_statement": "assert result == (sum(i**3 for i in range(1, n + 1)) / n)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 424,
        "Function_ID": 212,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_Average_Of_Cube(n):  \n    sum = 0\n    for i in range(1, n + 1): \n        sum += i * i * i  \n    return round(sum / n, 6) \n    **Function Description: ** Write a python function to find the average of cubes of first n natural numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a floating-point number, resulting from the division and subsequent rounding operation.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "The returned value must exactly match the mathematically derived average of the cubes of the first n natural numbers, computed as n*(n+1)^2 / 4, rounded precisely to 6 decimal places.",
                "assert_statement": "expected_sum_of_cubes = (n * (n + 1) / 2)**2; expected_avg = round(expected_sum_of_cubes / n, 6); assert result == expected_avg"
            },
            {
                "description": "The returned average value must be non-negative, assuming n is a positive integer.",
                "assert_statement": "assert result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 425,
        "Function_ID": 213,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to extract only the rear index element of each string in the given tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting collection must match the length of the input tuple.",
                "assert_statement": "len(result) == len(input_tuple)"
            },
            {
                "description": "Each element in the result must be the last character (rear index element) of the corresponding string in the input tuple.",
                "assert_statement": "all(result[i] == input_tuple[i][-1] for i in range(len(input_tuple)))"
            },
            {
                "description": "Every item in the result collection must be a single-character string.",
                "assert_statement": "all(isinstance(char, str) and len(char) == 1 for char in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 426,
        "Function_ID": 213,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def extract_rear(test_tuple):\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\n  return (res) \n    **Function Description: ** Write a function to extract only the rear index element of each string in the given tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be equal to the length of the input tuple.",
                "assert_statement": "assert len(result) == len(test_tuple)"
            },
            {
                "description": "Every element in the returned list must correspond to the last element (rear index) of the sequence at the corresponding index in the input tuple.",
                "assert_statement": "assert all(result[i] == test_tuple[i][-1] for i in range(len(test_tuple)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 427,
        "Function_ID": 214,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to count the number of sublists containing a particular element.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The count cannot be a negative number.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The count must not exceed the total number of sublists present in the input list.",
                "assert_statement": "assert result <= len(list_of_lists)"
            },
            {
                "description": "The returned value must equal the actual number of sublists that contain the specified target element.",
                "assert_statement": "assert result == sum(1 for sublist in list_of_lists if target_element in sublist)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 428,
        "Function_ID": 214,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_element_in_list(list1, x): \n    ctr = 0\n    for i in range(len(list1)): \n        if x in list1[i]: \n            ctr+= 1          \n    return ctr\n    **Function Description: ** Write a function to count the number of sublists containing a particular element.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer, representing a count.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned count cannot exceed the total number of sublists in the input list.",
                "assert_statement": "assert result <= len(list1)"
            },
            {
                "description": "The returned value must equal the exact number of sublists in 'list1' that contain the element 'x'.",
                "assert_statement": "assert result == sum(1 for sublist in list1 if x in sublist)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 429,
        "Function_ID": 215,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to filter odd numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "Every element remaining in the resulting list must be an odd number.",
                "assert_statement": "all(n % 2 != 0 for n in result)"
            },
            {
                "description": "The length of the resulting list must be less than or equal to the length of the original input list.",
                "assert_statement": "len(result) <= len(input_list)"
            },
            {
                "description": "The resulting list must be exactly equal to the input list filtered to include only odd numbers, maintaining the relative order.",
                "assert_statement": "result == [n for n in input_list if n % 2 != 0]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 430,
        "Function_ID": 215,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums\n    **Function Description: ** Write a function to filter odd numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a list whose length is less than or equal to the length of the input list `nums`.",
                "assert_statement": "assert isinstance(result, list) and len(result) <= len(nums)"
            },
            {
                "description": "All elements contained within the returned list must be odd numbers.",
                "assert_statement": "assert all(x % 2 != 0 for x in result)"
            },
            {
                "description": "All elements in the returned list are derived solely from the elements present in the original input list `nums`.",
                "assert_statement": "assert all(x in nums for x in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 431,
        "Function_ID": 216,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting date string must have a total length of 10 characters (dd-mm-yyyy).",
                "assert_statement": "assert len(result) == 10"
            },
            {
                "description": "The separator characters in the resulting string must be hyphens, appearing at indices 2 and 5.",
                "assert_statement": "assert result[2] == '-' and result[5] == '-'"
            },
            {
                "description": "The components of the date must be correctly rearranged, where the first two characters of the result are the day component (indices 8-10 of input).",
                "assert_statement": "assert result[0:2] == input_date[8:10]"
            },
            {
                "description": "The components of the date must be correctly rearranged, where the middle two characters of the result are the month component (indices 5-7 of input).",
                "assert_statement": "assert result[3:5] == input_date[5:7]"
            },
            {
                "description": "The components of the date must be correctly rearranged, where the last four characters of the result are the year component (indices 0-4 of input).",
                "assert_statement": "assert result[6:10] == input_date[0:4]"
            },
            {
                "description": "The resulting string must exactly match the concatenated day, month, and year components separated by hyphens.",
                "assert_statement": "assert result == input_date[8:10] + '-' + input_date[5:7] + '-' + input_date[0:4]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 432,
        "Function_ID": 216,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef change_date_format(dt):\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)\n    **Function Description: ** Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input string successfully matches the YYYY-MM-DD format, the output string must be in the corresponding DD-MM-YYYY format.",
                "assert_statement": "result = change_date_format(\"2023-11-09\"); assert result == \"09-11-2023\""
            },
            {
                "description": "The function must handle dates where month or day components are single digits by correctly rearranging them.",
                "assert_statement": "result = change_date_format(\"2020-5-1\"); assert result == \"1-5-2020\""
            },
            {
                "description": "The return value must always be a string.",
                "assert_statement": "assert isinstance(change_date_format(\"1999-12-31\"), str)"
            },
            {
                "description": "If the input string does not contain the required date pattern, the function must return the original input string unchanged.",
                "assert_statement": "input_str = \"This is just text\"; assert change_date_format(input_str) == input_str"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 433,
        "Function_ID": 217,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to sort the given array by using shell sort.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting array is in non-decreasing (sorted) order.",
                "assert_statement": "all(arr[i] <= arr[i+1] for i in range(len(arr) - 1))"
            },
            {
                "description": "The resulting array has the same number of elements as the original input array.",
                "assert_statement": "len(arr) == len(original_arr)"
            },
            {
                "description": "The resulting array is a permutation of the original input array (i.e., it contains the exact same elements).",
                "assert_statement": "sorted(arr) == sorted(original_arr)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 434,
        "Function_ID": 217,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > current_item:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n\n    return my_list\n    **Function Description: ** Write a function to sort the given array by using shell sort.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned list must be sorted in non-decreasing order.",
                "assert_statement": "assert all(result[i] <= result[i+1] for i in range(len(result) - 1))"
            },
            {
                "description": "The returned list must be a permutation of the original input list (contain the same elements).",
                "assert_statement": "assert sorted(my_list_copy) == result"
            },
            {
                "description": "The function performs the sort in-place, returning a reference to the modified input list.",
                "assert_statement": "assert result is my_list"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 435,
        "Function_ID": 218,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to extract the elementwise and tuples from the given two tuples.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a tuple.",
                "assert_statement": "isinstance(result, tuple)"
            },
            {
                "description": "All elements contained within the resulting tuple must also be tuples.",
                "assert_statement": "all(isinstance(item, tuple) for item in result)"
            },
            {
                "description": "The length of the resulting tuple must be equal to the length of the shortest input tuple (standard zip behavior).",
                "assert_statement": "len(result) == min(len(input_tuple_1), len(input_tuple_2))"
            },
            {
                "description": "Each generated elementwise tuple must have exactly two components.",
                "assert_statement": "all(len(item) == 2 for item in result)"
            },
            {
                "description": "The element mapping must be correct; checking the first element confirms it pairs the first elements of the two input tuples.",
                "assert_statement": "result[0] == (input_tuple_1[0], input_tuple_2[0])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 436,
        "Function_ID": 218,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def and_tuples(test_tup1, test_tup2):\n  res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) \n    **Function Description: ** Write a function to extract the elementwise and tuples from the given two tuples.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting tuple is equal to the length of the shortest input tuple, reflecting the behavior of zip().",
                "assert_statement": "assert len(result) == min(len(test_tup1), len(test_tup2))"
            },
            {
                "description": "Each element in the resulting tuple is the bitwise AND of the corresponding elements from the input tuples.",
                "assert_statement": "assert all(result[i] == (test_tup1[i] & test_tup2[i]) for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 437,
        "Function_ID": 219,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the directrix of a parabola.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the parabola's axis of symmetry is vertical (e.g., defined by (x-h)^2 = 4p(y-k)), the resulting directrix must be a horizontal line defined by y = k - p, where (h, k) is the vertex and p is the focal length.",
                "assert_statement": "axis_orientation == 'vertical' and result['axis'] == 'y' and result['constant'] == k - p"
            },
            {
                "description": "If the parabola's axis of symmetry is horizontal (e.g., defined by (y-k)^2 = 4p(x-h)), the resulting directrix must be a vertical line defined by x = h - p.",
                "assert_statement": "axis_orientation == 'horizontal' and result['axis'] == 'x' and result['constant'] == h - p"
            },
            {
                "description": "The returned value representing the constant of the directrix line (the intercept) must be a number (float or integer).",
                "assert_statement": "isinstance(result['constant'], (int, float))"
            },
            {
                "description": "The identified axis of the directrix must be either 'x' or 'y'.",
                "assert_statement": "result['axis'] in ('x', 'y')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 438,
        "Function_ID": 219,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix\n    **Function Description: ** Write a function to find the directrix of a parabola.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value, which represents the directrix, is guaranteed to be an integer due to explicit casting in the function implementation.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned value must exactly match the calculated formula: c minus (b^2 plus 1) times 4a, cast to an integer.",
                "assert_statement": "assert result == int(c - ((b * b) + 1) * 4 * a)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 439,
        "Function_ID": 220,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes two lists and returns true if they have at least one common element.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the intersection of the two input lists (a and b) must contain at least one element.",
                "assert_statement": "if result: assert len(set(a) & set(b)) > 0"
            },
            {
                "description": "If the function returns False, the intersection of the two input lists (a and b) must be empty.",
                "assert_statement": "if not result: assert len(set(a) & set(b)) == 0"
            },
            {
                "description": "The function must return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 440,
        "Function_ID": 220,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result\n    **Function Description: ** Write a function that takes two lists and returns true if they have at least one common element.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean (True or False).",
                "assert_statement": "assert isinstance(__result__, bool)"
            },
            {
                "description": "The function returns True if and only if the set intersection of list1 and list2 is non-empty.",
                "assert_statement": "assert __result__ == bool(set(list1) & set(list2))"
            },
            {
                "description": "If the return value is False, it guarantees that no element in list1 is present in list2.",
                "assert_statement": "assert __result__ or len(set(list1) & set(list2)) == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 441,
        "Function_ID": 221,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the median length of a trapezium.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated median length must be equal to the arithmetic mean (average) of the two parallel bases.",
                "assert_statement": "assert result == (base1 + base2) / 2"
            },
            {
                "description": "The calculated median length must be a non-negative number.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The median length must be greater than or equal to the minimum length of the two bases and less than or equal to the maximum length of the two bases.",
                "assert_statement": "assert min(base1, base2) <= result <= max(base1, base2)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 442,
        "Function_ID": 221,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median\n    **Function Description: ** Write a function to find the median length of a trapezium.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must equal the arithmetic mean of base1 and base2, as defined by the median calculation for a trapezium.",
                "assert_statement": "assert result == 0.5 * (base1 + base2)"
            },
            {
                "description": "The return value must lie between or be equal to the smaller and larger of the two bases (base1 and base2).",
                "assert_statement": "assert min(base1, base2) <= result <= max(base1, base2)"
            },
            {
                "description": "The returned value is of type float because the calculation involves multiplication by 0.5.",
                "assert_statement": "assert isinstance(result, float)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 443,
        "Function_ID": 222,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether the entered number is greater than the elements of the given array.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the input number must be strictly greater than every element in the array.",
                "assert_statement": "if result is True: assert all(num > element for element in arr)"
            },
            {
                "description": "If the function returns False, there must be at least one element in the array that is greater than or equal to the input number.",
                "assert_statement": "if result is False: assert any(num <= element for element in arr)"
            },
            {
                "description": "The return value must accurately reflect the truth value of the condition that all array elements are smaller than the input number.",
                "assert_statement": "assert result == all(num > element for element in arr)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 444,
        "Function_ID": 222,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_greater(arr, number):\n  arr.sort()\n  return number > arr[-1]\n    **Function Description: ** Write a function to check whether the entered number is greater than the elements of the given array.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The input list 'arr' is mutated and sorted in ascending order.",
                "assert_statement": "assert arr == sorted(arr)"
            },
            {
                "description": "The return value is True if the 'number' is strictly greater than the maximum element of the array (arr[-1] after sorting), and False otherwise.",
                "assert_statement": "assert result == (number > arr[-1])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 445,
        "Function_ID": 223,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that matches a string that has an a followed by one or more b's.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a truthy value (match found) for the minimum required pattern: 'a' followed by one 'b'.",
                "assert_statement": "assert match_a_b_plus('ab')"
            },
            {
                "description": "The function must return a truthy value (match found) for 'a' followed by multiple 'b's.",
                "assert_statement": "assert match_a_b_plus('abbbb')"
            },
            {
                "description": "The function must return a falsy value (no match) if 'a' is present but no 'b' follows.",
                "assert_statement": "assert not match_a_b_plus('a')"
            },
            {
                "description": "The function must return a falsy value (no match) if the pattern is broken by other characters ('a' followed by 'c').",
                "assert_statement": "assert not match_a_b_plus('ac')"
            },
            {
                "description": "The function must return a falsy value for an empty input string.",
                "assert_statement": "assert not match_a_b_plus('')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 446,
        "Function_ID": 223,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef text_match_one(text):\n        patterns = 'ab+?'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n\n    **Function Description: ** Write a function that matches a string that has an a followed by one or more b's.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the input string contains 'a' followed by one or more 'b's (e.g., 'ab', 'abb'), the function returns True.",
                "assert_statement": "assert text_match_one('XabY') == True"
            },
            {
                "description": "If the input string contains 'a' but it is not immediately followed by at least one 'b', the function returns False.",
                "assert_statement": "assert text_match_one('a_c') == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 447,
        "Function_ID": 224,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the last digit of a given number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must be an integer type.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The returned result must be a single non-negative digit (between 0 and 9 inclusive).",
                "assert_statement": "0 <= result <= 9"
            },
            {
                "description": "The returned result must match the absolute last digit of the input number.",
                "assert_statement": "result == abs(num) % 10"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 448,
        "Function_ID": 224,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def last_Digit(n) :\n    return (n % 10) \n    **Function Description: ** Write a python function to find the last digit of a given number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer between 0 and 9, inclusive.",
                "assert_statement": "assert 0 <= result <= 9 and isinstance(result, int)"
            },
            {
                "description": "The difference between the input number and the returned last digit must be evenly divisible by 10.",
                "assert_statement": "assert (n - result) % 10 == 0"
            },
            {
                "description": "For any non-negative integer input, the result is the same as the absolute value of the input mod 10.",
                "assert_statement": "if n >= 0: assert result == abs(n) % 10"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 449,
        "Function_ID": 225,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to return the negative numbers in a list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "Every element in the resulting list must be strictly negative (less than zero).",
                "assert_statement": "all(x < 0 for x in result)"
            },
            {
                "description": "The resulting list must only contain elements that were present in the original input list.",
                "assert_statement": "all(x in input_list for x in result)"
            },
            {
                "description": "The resulting list is exactly equal to the list of negative numbers filtered from the input, preserving their original order.",
                "assert_statement": "result == [x for x in input_list if x < 0]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 450,
        "Function_ID": 225,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def neg_nos(list1):\n  out = []\n  for num in list1: \n    if num < 0: \n      out.append(num)\n  return out \n    **Function Description: ** Write a python function to return the negative numbers in a list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "All elements contained within the returned list must be strictly negative.",
                "assert_statement": "assert all(x < 0 for x in result)"
            },
            {
                "description": "The returned list contains exactly the elements from the input list that are strictly negative.",
                "assert_statement": "assert result == [n for n in list1 if n < 0]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 451,
        "Function_ID": 226,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to remove odd characters in a string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting string consists only of the characters originally located at even indices (0, 2, 4, ...) of the input string, preserving their relative order.",
                "assert_statement": "all(result[i] == input_str[2 * i] for i in range(len(result)))"
            },
            {
                "description": "The length of the resulting string is equal to the ceiling of half the length of the input string.",
                "assert_statement": "len(result) == (len(input_str) + 1) // 2"
            },
            {
                "description": "All characters present in the result must originate from the input string.",
                "assert_statement": "all(c in input_str for c in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 452,
        "Function_ID": 226,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def remove_odd(str1):\n str2 = ''\n for i in range(1, len(str1) + 1):\n    if(i % 2 == 0):\n        str2 = str2 + str1[i - 1]\n return str2\n    **Function Description: ** Write a function to remove odd characters in a string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The length of the returned string must be exactly half the input length, rounded down.",
                "assert_statement": "assert len(result) == len(str1) // 2"
            },
            {
                "description": "The returned string consists only of characters from the input string that were located at odd 0-based indices (1, 3, 5, ...).",
                "assert_statement": "assert result == str1[1::2]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 453,
        "Function_ID": 227,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to count bidirectional tuple pairs.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input data contains no pairs that are reverses of each other (e.g., only (1, 2) but not (2, 1)), the count must be zero.",
                "assert_statement": "if all((b, a) not in set(data) for a, b in set(data) if a != b): assert result == sum(1 for a, b in set(data) if a == b)"
            },
            {
                "description": "The result equals the total number of unique, bidirectional tuple pairs found in the input set. A pair (a, b) contributes 1 to the count only if (b, a) is also present, and we avoid double-counting the pair (a, b) when iterating over (b, a).",
                "assert_statement": "result == calculate_unique_bidirectional_pairs(data)"
            },
            {
                "description": "For any symmetric tuple (a, a), if it exists in the input data, it is counted as exactly one bidirectional pair.",
                "assert_statement": "if any(a == b for a, b in data): assert result >= 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 454,
        "Function_ID": 227,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res\n    **Function Description: ** Write a function to count bidirectional tuple pairs.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The returned count equals the total number of unique pairs (test_list[idx], test_list[iidx]) where idx < iidx, such that the first element of the second item (test_list[iidx][0]) matches the second element of the first item (test_list[idx][1]).",
                "assert_statement": "assert result == sum(1 for idx in range(len(test_list)) for iidx in range(idx + 1, len(test_list)) if test_list[iidx][0] == test_list[idx][1])"
            },
            {
                "description": "If the input list is empty, the result must be 0.",
                "assert_statement": "assert count_bidirectional([]) == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 455,
        "Function_ID": 228,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to join a list of multiple integers into a single integer.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The resulting integer must be the numerical representation formed by concatenating the string equivalents of the input integers.",
                "assert_statement": "result == int(\"\".join(str(x) for x in input_list))"
            },
            {
                "description": "If the input list is empty, the resulting integer must be zero.",
                "assert_statement": "if not input_list: assert result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 456,
        "Function_ID": 228,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def multiple_to_single(L):\n  x = int(\"\".join(map(str, L)))\n  return x\n    **Function Description: ** Write a function to join a list of multiple integers into a single integer.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be of type integer (int).",
                "assert_statement": "L = [10, 20]; assert isinstance(multiple_to_single(L), int)"
            },
            {
                "description": "For a non-empty list, the returned integer must equal the numerical value formed by concatenating the string representations of the elements.",
                "assert_statement": "L = [99, 0, 15]; expected = 99015; assert multiple_to_single(L) == expected"
            },
            {
                "description": "If the input list is empty, a ValueError must be raised because the function attempts to cast an empty string to an integer.",
                "assert_statement": "import pytest; with pytest.raises(ValueError): multiple_to_single([])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 457,
        "Function_ID": 229,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the first adverb and their positions in a given sentence.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If an adverb is found, the result must be a list or tuple containing exactly two elements: the adverb (string) and its non-negative integer index (position).",
                "assert_statement": "isinstance(result, (list, tuple)) and len(result) == 2 and isinstance(result[0], str) and len(result[0]) > 0 and isinstance(result[1], int) and result[1] >= 0"
            },
            {
                "description": "If no adverb is present in the sentence, the function must return an empty list, an empty tuple, or None.",
                "assert_statement": "result is None or result == [] or result == ()"
            },
            {
                "description": "If an adverb is found, the returned index must correspond to the absolute first occurrence of an adverb in the sentence.",
                "assert_statement": "if result: assert result[1] == min(index for word, index in sentence_parts if is_adverb(word))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 458,
        "Function_ID": 229,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef find_adverb_position(text):\n for m in re.finditer(r\"\\w+ly\", text):\n    return (m.start(), m.end(), m.group(0))\n    **Function Description: ** Write a function to find the first adverb and their positions in a given sentence.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If a match is found, the return value must be a 3-element tuple where the first two elements are non-negative integers representing the start and end indices, and the third element is the matched string.",
                "assert_statement": "assert result is None or (isinstance(result, tuple) and len(result) == 3 and isinstance(result[0], int) and result[0] >= 0 and isinstance(result[1], int) and result[1] > result[0] and isinstance(result[2], str))"
            },
            {
                "description": "If a match is found, the third element of the tuple (the matched word) must exactly correspond to the slice of the input text defined by the first two elements (indices).",
                "assert_statement": "if result is not None: assert text[result[0]:result[1]] == result[2]"
            },
            {
                "description": "If the input text contains no sequence matching the pattern '\\w+ly', the function must return None.",
                "assert_statement": "if not re.search(r\"\\w+ly\", text): assert result is None"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 459,
        "Function_ID": 230,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the surface area of a cube of a given size.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated result must equal 6 times the square of the side size (adhering to the surface area formula 6s^2).",
                "assert_statement": "result == 6 * size ** 2"
            },
            {
                "description": "The calculated surface area must be non-negative.",
                "assert_statement": "result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 460,
        "Function_ID": 230,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def surfacearea_cube(l):\n  surfacearea= 6*l*l\n  return surfacearea\n    **Function Description: ** Write a function to find the surface area of a cube of a given size.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must accurately reflect the surface area calculation using the formula 6 * l^2.",
                "assert_statement": "assert __return__ == 6 * l * l"
            },
            {
                "description": "The returned value, representing an area, must be non-negative.",
                "assert_statement": "assert __return__ >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 461,
        "Function_ID": 231,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the ration of positive numbers in an array of integers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned ratio must be a valid probability, falling within the range [0.0, 1.0].",
                "assert_statement": "0.0 <= result and result <= 1.0"
            },
            {
                "description": "If the array is non-empty, the result must be the count of positive numbers divided by the total length of the array.",
                "assert_statement": "if len(arr) > 0: positive_count = sum(1 for x in arr if x > 0); assert (positive_count / len(arr)) == result"
            },
            {
                "description": "If the input array is empty, the ratio returned should be 0.0 (handling division by zero by convention).",
                "assert_statement": "if len(arr) == 0: assert result == 0.0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 462,
        "Function_ID": 231,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from array import array\ndef positive_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)\n    **Function Description: ** Write a function to find the ration of positive numbers in an array of integers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a floating-point number.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "The returned ratio must be within the range [0.0, 1.0], inclusive.",
                "assert_statement": "assert 0.0 <= result <= 1.0"
            },
            {
                "description": "The return value must equal the count of positive numbers divided by the total count, rounded precisely to two decimal places (assuming len(nums) > 0).",
                "assert_statement": "positive_count = sum(1 for x in nums if x > 0); expected_ratio = positive_count / len(nums); assert result == round(expected_ratio, 2)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 463,
        "Function_ID": 232,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the largest negative number from the given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If a largest negative number is found, the returned value ('result') must be negative.",
                "assert_statement": "assert 'result' is None or 'result' < 0"
            },
            {
                "description": "If negative numbers exist in the input list, the returned value ('result') must be greater than or equal to every other negative number in the list.",
                "assert_statement": "assert all('result' >= x for x in input_list if x < 0)"
            },
            {
                "description": "If the list contains no negative numbers, the function must return None.",
                "assert_statement": "assert (not any(x < 0 for x in input_list)) == ('result' is None)"
            },
            {
                "description": "If a value is returned (i.e., not None), that value must be present in the original input list.",
                "assert_statement": "assert 'result' is None or 'result' in input_list"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 464,
        "Function_ID": 232,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def largest_neg(list1): \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max\n    **Function Description: ** Write a python function to find the largest negative number from the given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must equal the minimum element of the input list, as the provided implementation incorrectly calculates the minimum instead of the largest negative number.",
                "assert_statement": "result == min(list1)"
            },
            {
                "description": "The returned value must be an element present within the original input list.",
                "assert_statement": "result in list1"
            },
            {
                "description": "If the input list is empty, the function must raise an IndexError because it attempts to access list1[0].",
                "assert_statement": "pytest.raises(IndexError, largest_neg, [])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 465,
        "Function_ID": 233,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to trim each tuple by k in the given tuple list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The output structure is a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "The resulting list has the same number of elements as the input list (no tuples were removed or added).",
                "assert_statement": "len(result) == len(input_list)"
            },
            {
                "description": "Every element in the output list remains a tuple.",
                "assert_statement": "all(isinstance(t, tuple) for t in result)"
            },
            {
                "description": "Every resulting tuple's length is less than or equal to the trimming parameter k.",
                "assert_statement": "all(len(t) <= k for t in result)"
            },
            {
                "description": "Each resulting tuple correctly represents the input tuple sliced up to k elements.",
                "assert_statement": "all(result[i] == input_list[i][:k] for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 466,
        "Function_ID": 233,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def trim_tuple(test_list, K):\n  res = []\n  for ele in test_list:\n    N = len(ele)\n    res.append(tuple(list(ele)[K: N - K]))\n  return (str(res)) \n    **Function Description: ** Write a function to trim each tuple by k in the given tuple list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string, as dictated by the function's final operation str(res).",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The returned string, when interpreted as a Python list, must contain the correctly trimmed version of every input tuple, maintaining the original order. Trimming is performed by slicing from index K up to index N-K.",
                "assert_statement": "assert result == str([tuple(list(ele)[K: len(ele) - K]) for ele in test_list])"
            },
            {
                "description": "If the input list is empty, the return value must be the string representation of an empty list.",
                "assert_statement": "if not test_list: assert result == '[]'"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 467,
        "Function_ID": 234,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to perform index wise multiplication of tuple elements in the given two tuples.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting sequence (result) must be equal to the length of the shorter input tuple.",
                "assert_statement": "len(result) == min(len(tup1), len(tup2))"
            },
            {
                "description": "Every element in the resulting sequence is the product of the corresponding elements from the two input tuples.",
                "assert_statement": "all(result[i] == tup1[i] * tup2[i] for i in range(len(result)))"
            },
            {
                "description": "The type of the output is a sequence (list or tuple).",
                "assert_statement": "isinstance(result, (list, tuple))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 468,
        "Function_ID": 234,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def index_multiplication(test_tup1, test_tup2):\n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \n    **Function Description: ** Write a function to perform index wise multiplication of tuple elements in the given two tuples.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(res, tuple)"
            },
            {
                "description": "The length of the resulting tuple matches the length of the shortest input tuple, due to the outer zip operation.",
                "assert_statement": "assert len(res) == min(len(test_tup1), len(test_tup2))"
            },
            {
                "description": "The content of the resulting nested tuple is the exact index-wise multiplication of corresponding elements from the input tuples.",
                "assert_statement": "assert res == tuple(tuple(a * b for a, b in zip(tup1, tup2)) for tup1, tup2 in zip(test_tup1, test_tup2))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 469,
        "Function_ID": 235,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count the occurence of all elements of list in a tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a dictionary, mapping elements to their counts.",
                "assert_statement": "isinstance(result, dict)"
            },
            {
                "description": "The keys of the result dictionary must exactly match the set of unique elements present in the input list.",
                "assert_statement": "set(result.keys()) == set(search_list)"
            },
            {
                "description": "The count for every element requested in the list is accurately reflected by comparing the result to the actual count within the source tuple.",
                "assert_statement": "all(result[element] == source_tuple.count(element) for element in set(search_list))"
            },
            {
                "description": "All counts (values in the dictionary) must be non-negative integers.",
                "assert_statement": "all(isinstance(count, int) and count >= 0 for count in result.values())"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 470,
        "Function_ID": 235,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from collections import Counter \ndef count_Occurrence(tup, lst): \n    count = 0\n    for item in tup: \n        if item in lst: \n            count+= 1 \n    return count  \n    **Function Description: ** Write a python function to count the occurence of all elements of list in a tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The count returned cannot exceed the total number of elements in the input tuple 'tup'.",
                "assert_statement": "assert result <= len(tup)"
            },
            {
                "description": "The return value must equal the total number of elements found in the tuple 'tup' that are also present in the list 'lst'.",
                "assert_statement": "assert result == sum(1 for item in tup if item in lst)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 471,
        "Function_ID": 236,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find cubes of individual elements in a list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the returned list must be equal to the length of the input list.",
                "assert_statement": "len(result) == len(input_list)"
            },
            {
                "description": "Every element in the output list must be the cube of the corresponding element in the input list.",
                "assert_statement": "all(result[i] == input_list[i] ** 3 for i in range(len(input_list)))"
            },
            {
                "description": "The returned value is a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "The original input list remains unchanged (assuming a pure function).",
                "assert_statement": "input_list == original_input_list_state"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 472,
        "Function_ID": 236,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums\n    **Function Description: ** Write a function to find cubes of individual elements in a list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be equal to the length of the input list.",
                "assert_statement": "assert len(result) == len(nums)"
            },
            {
                "description": "Each element in the returned list is the cube of the corresponding element in the input list, preserving order.",
                "assert_statement": "assert all(result[i] == nums[i] ** 3 for i in range(len(nums)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 473,
        "Function_ID": 237,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to calculate the sum of perrin numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must equal the mathematically correct sum of the Perrin sequence from index 0 up to and including the input index N.",
                "assert_statement": "result == reference_sum_perrin(N)"
            },
            {
                "description": "The result must be an integer, as the sequence consists of integers and the sum of integers is an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The sum of Perrin numbers must be non-negative, assuming N >= 0.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "For N=0, the sum is P(0), which equals 3.",
                "assert_statement": "if N == 0: assert result == 3"
            },
            {
                "description": "For N=1, the sum is P(0) + P(1), which equals 3 + 0 = 3.",
                "assert_statement": "if N == 1: assert result == 3"
            },
            {
                "description": "For N > 1, the sum S(N) must be greater than or equal to S(N-1), given that P(n) >= 0 for n != 1.",
                "assert_statement": "if N > 1: assert result >= sum_perrin(N - 1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 474,
        "Function_ID": 237,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def cal_sum(n): \n\ta = 3\n\tb = 0\n\tc = 2\n\tif (n == 0): \n\t\treturn 3\n\tif (n == 1): \n\t\treturn 3\n\tif (n == 2): \n\t\treturn 5\n\tsum = 5\n\twhile (n > 2): \n\t\td = a + b \n\t\tsum = sum + d \n\t\ta = b \n\t\tb = c \n\t\tc = d \n\t\tn = n-1\n\treturn sum\n    **Function Description: ** Write a function to calculate the sum of perrin numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The return value must be non-negative, as the sum of Perrin numbers (P(i) for i>=0) is non-negative.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "If the input n is 0, the sum of Perrin numbers (P(0)) is 3.",
                "assert_statement": "assert cal_sum(0) == 3"
            },
            {
                "description": "If the input n is 4, the function returns the sum of Perrin numbers from P(0) to P(4), which is 10 (3 + 0 + 2 + 3 + 2).",
                "assert_statement": "assert cal_sum(4) == 10"
            },
            {
                "description": "If the input n is 5, the function returns the sum of Perrin numbers up to P(5), which is 15.",
                "assert_statement": "assert cal_sum(5) == 15"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 475,
        "Function_ID": 238,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to extract specified size of strings from a given list of string values.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a list (or the expected iterable type).",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "Every string in the resulting list must have a length equal to the specified target size.",
                "assert_statement": "all(len(s) == target_size for s in result)"
            },
            {
                "description": "The resulting list must contain exactly all the strings from the input list that matched the specified size (ensuring completeness).",
                "assert_statement": "len(result) == sum(1 for s in input_list if len(s) == target_size)"
            },
            {
                "description": "Every string in the result must have originally existed in the input list.",
                "assert_statement": "all(s in input_list for s in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 476,
        "Function_ID": 238,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def extract_string(str, l):\n    result = [e for e in str if len(e) == l] \n    return result\n    **Function Description: ** Write a function to extract specified size of strings from a given list of string values.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be of type list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "All elements in the returned list must have a length exactly equal to the specified length 'l'.",
                "assert_statement": "assert all(len(e) == l for e in result)"
            },
            {
                "description": "The total count of elements returned must equal the number of elements in the input list 'str' that satisfy the length condition 'l', ensuring completeness.",
                "assert_statement": "assert len(result) == sum(1 for e in str if len(e) == l)"
            },
            {
                "description": "Every element in the returned list must be present in the original input list 'str' (maintaining data integrity and ensuring no new elements were created).",
                "assert_statement": "assert all(e in str for e in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 477,
        "Function_ID": 239,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to remove all whitespaces from the given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting string contains no characters defined as whitespace (space, tab, newline, etc.).",
                "assert_statement": "all(not c.isspace() for c in result)"
            },
            {
                "description": "The resulting string is equivalent to the input string with all whitespace characters filtered out, ensuring preservation of the order of remaining characters.",
                "assert_statement": "result == ''.join(c for c in input_string if not c.isspace())"
            },
            {
                "description": "The length of the resulting string is exactly equal to the count of non-whitespace characters in the input string.",
                "assert_statement": "len(result) == sum(1 for c in input_string if not c.isspace())"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 478,
        "Function_ID": 239,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef remove_whitespaces(text1):\n  return (re.sub(r'\\s+', '',text1))\n    **Function Description: ** Write a function to remove all whitespaces from the given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The returned string must contain no whitespace characters (spaces, tabs, newlines, etc.).",
                "assert_statement": "import re; assert re.search(r'\\s', result) is None"
            },
            {
                "description": "The length of the returned string must be equal to the total count of non-whitespace characters present in the input string.",
                "assert_statement": "assert len(result) == sum(1 for char in text1 if not char.isspace())"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 479,
        "Function_ID": 240,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that gives loss amount on a sale if the given amount has loss else return 0.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the cost price (cp) is strictly greater than the selling price (sp), the returned result must equal the positive difference (the loss amount).",
                "assert_statement": "if cp > sp: assert result == cp - sp"
            },
            {
                "description": "If the selling price (sp) is greater than or equal to the cost price (cp), the function must return 0, indicating no loss.",
                "assert_statement": "if sp >= cp: assert result == 0"
            },
            {
                "description": "The returned value must always be non-negative, as it represents a calculated loss amount or zero.",
                "assert_statement": "assert result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 480,
        "Function_ID": 240,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def loss_amount(actual_cost,sale_amount): \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return 0\n    **Function Description: ** Write a function that gives loss amount on a sale if the given amount has loss else return 0.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the sale amount is strictly greater than the actual cost, the returned value must equal the positive difference (sale_amount - actual_cost).",
                "assert_statement": "if sale_amount > actual_cost: assert __result__ == sale_amount - actual_cost"
            },
            {
                "description": "If the sale amount is less than or equal to the actual cost, the returned value must be 0.",
                "assert_statement": "if sale_amount <= actual_cost: assert __result__ == 0"
            },
            {
                "description": "The returned value, representing a calculated amount, must be non-negative.",
                "assert_statement": "assert __result__ >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 481,
        "Function_ID": 241,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the sum of even factors of a number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "isinstance(return_value, int)"
            },
            {
                "description": "The returned sum must be non-negative.",
                "assert_statement": "return_value >= 0"
            },
            {
                "description": "If the input number (n) is zero or negative, the sum of even factors should be zero.",
                "assert_statement": "if n <= 0: assert return_value == 0"
            },
            {
                "description": "The returned value must equal the sum of all positive integers that are both factors of n and are even.",
                "assert_statement": "if n > 0: assert return_value == sum(f for f in range(1, n + 1) if n % f == 0 and f % 2 == 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 482,
        "Function_ID": 241,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math \ndef sumofFactors(n) : \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res\n    **Function Description: ** Write a python function to find the sum of even factors of a number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input number 'n' is odd, the sum of even factors must be zero, as no even factors exist.",
                "assert_statement": "if n % 2 != 0: assert __return__ == 0"
            },
            {
                "description": "If the input 'n' is a positive even number, the returned value must be a positive integer.",
                "assert_statement": "if n > 0 and n % 2 == 0: assert isinstance(__return__, int) and __return__ > 0"
            },
            {
                "description": "The returned value must equal the known sum of even factors for a small complex number (e.g., n=30, even factors: 2, 6, 10, 30; Sum = 48).",
                "assert_statement": "assert sumofFactors(30) == 48"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 483,
        "Function_ID": 242,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that matches a word containing 'z'.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a match object (or True) when the input string contains the lowercase letter 'z'.",
                "assert_statement": "result_with_z is not None"
            },
            {
                "description": "The function must return a match object (or True) when the input string contains the uppercase letter 'Z'.",
                "assert_statement": "result_with_Z is not None"
            },
            {
                "description": "The function must return None (or False) when the input string does not contain the letter 'z' (or 'Z').",
                "assert_statement": "result_without_z is None"
            },
            {
                "description": "The matched object, if successful, must confirm that the character 'z' (or 'Z') was found within the string.",
                "assert_statement": "result_with_z.group(0) in input_string_z"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 484,
        "Function_ID": 242,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef text_match_wordz(text):\n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n    **Function Description: ** Write a function that matches a word containing 'z'.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the input string contains the sequence of zero or more word characters, followed by 'z', followed by any single character, followed by zero or more word characters (matching the pattern '\\w*z.\\w*'), the function returns True.",
                "assert_statement": "assert text_match_wordz('lazy cat') is True"
            },
            {
                "description": "If the input string contains 'z' but it is not followed by at least one character (i.e., 'z' is the last character of the string), the required '.' in the pattern fails, and the function returns False.",
                "assert_statement": "assert text_match_wordz('fizz') is False"
            },
            {
                "description": "If the input string does not contain 'z', the function returns False.",
                "assert_statement": "assert text_match_wordz('apple') is False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 485,
        "Function_ID": 243,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether the given month number contains 31 days or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the input month is January (1), which has 31 days, the result must be True.",
                "assert_statement": "assert result == True and input == 1"
            },
            {
                "description": "If the input month is April (4), which has 30 days, the result must be False.",
                "assert_statement": "assert result == False and input == 4"
            },
            {
                "description": "If the input month is February (2), which has fewer than 31 days, the result must be False.",
                "assert_statement": "assert result == False and input == 2"
            },
            {
                "description": "If the input month is July (7), which has 31 days, the result must be True.",
                "assert_statement": "assert result == True and input == 7"
            },
            {
                "description": "If the input month is December (12), which is the upper valid boundary and has 31 days, the result must be True.",
                "assert_statement": "assert result == True and input == 12"
            },
            {
                "description": "If the input is an invalid month number (e.g., 0), the result must indicate failure (e.g., False) since it is out of the valid range (1-12).",
                "assert_statement": "assert result == False and input == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 486,
        "Function_ID": 243,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_monthnumb_number(monthnum2):\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\n    return True\n  else:\n    return False\n    **Function Description: ** Write a function to check whether the given month number contains 31 days or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns True if the month number corresponds to a month with 31 days (e.g., 8).",
                "assert_statement": "assert check_monthnumb_number(8) is True"
            },
            {
                "description": "The function returns False if the month number corresponds to a month with fewer than 31 days (e.g., 11).",
                "assert_statement": "assert check_monthnumb_number(11) is False"
            },
            {
                "description": "The return value must be of type boolean.",
                "assert_statement": "assert isinstance(check_monthnumb_number(5), bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 487,
        "Function_ID": 244,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to reverse each string in a given list of string values.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting list must have the same number of elements as the input list.",
                "assert_statement": "assert len(result_list) == len(input_list)"
            },
            {
                "description": "Every element in the resulting list must be the reverse of its corresponding element in the input list.",
                "assert_statement": "assert all(result_str == input_str[::-1] for input_str, result_str in zip(input_list, result_list))"
            },
            {
                "description": "The length of each string element in the resulting list must be identical to the length of the corresponding string in the input list.",
                "assert_statement": "assert all(len(result_str) == len(input_str) for input_str, result_str in zip(input_list, result_list))"
            },
            {
                "description": "All elements in the resulting list must be of type string.",
                "assert_statement": "assert all(isinstance(s, str) for s in result_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 488,
        "Function_ID": 244,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def reverse_string_list(stringlist):\n    result = [x[::-1] for x in stringlist]\n    return result\n    **Function Description: ** Write a function to reverse each string in a given list of string values.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is always a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be identical to the length of the input list.",
                "assert_statement": "assert len(result) == len(stringlist)"
            },
            {
                "description": "Every element in the returned list is the exact reversal of the corresponding element in the input list.",
                "assert_statement": "assert all(result[i] == stringlist[i][::-1] for i in range(len(stringlist)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 489,
        "Function_ID": 245,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the sublist having minimum length.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the returned sublist must be less than or equal to the length of every other sublist present in the input list of lists.",
                "assert_statement": "all(len(result) <= len(sublist) for sublist in input_list_of_lists)"
            },
            {
                "description": "The returned sublist must be one of the sublists originally provided in the input.",
                "assert_statement": "result in input_list_of_lists"
            },
            {
                "description": "The returned result must be of type list (assuming the function handles non-empty valid input).",
                "assert_statement": "isinstance(result, list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 490,
        "Function_ID": 245,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def Find_Min(lst): \n    return min(lst, key=len) \n    **Function Description: ** Write a python function to find the sublist having minimum length.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an element that exists within the original input list.",
                "assert_statement": "assert result in lst"
            },
            {
                "description": "The length of the returned element must be less than or equal to the length of every other element in the input list.",
                "assert_statement": "assert all(len(result) <= len(item) for item in lst)"
            },
            {
                "description": "If the input list is empty, a ValueError must be raised.",
                "assert_statement": "import pytest; with pytest.raises(ValueError): Find_Min([])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 491,
        "Function_ID": 246,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the area of a rectangle.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated area must be a non-negative value.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The calculated area must be equal to the product of the length and width of the rectangle.",
                "assert_statement": "result == length * width"
            },
            {
                "description": "If the length or width is zero, the area must be zero.",
                "assert_statement": "(length == 0 or width == 0) and (result == 0)"
            },
            {
                "description": "The calculated area must be a numerical type (integer or float).",
                "assert_statement": "isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 492,
        "Function_ID": 246,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def rectangle_area(l,b):\n  area=l*b\n  return area\n    **Function Description: ** Write a function to find the area of a rectangle.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is mathematically equal to the product of the input length (l) and breadth (b).",
                "assert_statement": "assert result == l * b"
            },
            {
                "description": "The returned value is a standard numeric type (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "Assuming non-negative inputs for length and breadth, the calculated area must be non-negative.",
                "assert_statement": "assert result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 493,
        "Function_ID": 247,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to remove uppercase substrings from a given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting string must contain no uppercase alphabetic characters.",
                "assert_statement": "all(not c.isupper() for c in result)"
            },
            {
                "description": "The length of the resulting string must be less than or equal to the length of the input string.",
                "assert_statement": "len(result) <= len(input_str)"
            },
            {
                "description": "The resulting string must be composed exactly of the characters from the original string that were not uppercase, preserving their relative order.",
                "assert_statement": "result == \"\".join([c for c in input_str if not c.isupper()])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 494,
        "Function_ID": 247,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef remove_uppercase(str1):\n  return re.sub('[A-Z]', '', str1)\n    **Function Description: ** Write a function to remove uppercase substrings from a given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The returned string must not contain any uppercase English letters (A-Z).",
                "assert_statement": "assert re.search(r'[A-Z]', result) is None"
            },
            {
                "description": "The length of the returned string must equal the length of the original string minus the number of uppercase characters present in the original string.",
                "assert_statement": "assert len(result) == len(str1) - len([c for c in str1 if c.isupper()])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 495,
        "Function_ID": 248,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to get the first element of each sublist.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "Each element in the result is the first element of a corresponding sublist in the input.",
                "assert_statement": "all(result[i] == input_list[i][0] for i in range(len(result)))"
            },
            {
                "description": "The length of the result list is equal to the number of sublists in the input.",
                "assert_statement": "len(result) == len(input_list)"
            },
            {
                "description": "If the input list is empty, the result is an empty list.",
                "assert_statement": "if not input_list: assert result == []"
            },
            {
                "description": "Each element in the result is of the same type as the first element of its corresponding sublist.",
                "assert_statement": "all(type(result[i]) == type(input_list[i][0]) for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 496,
        "Function_ID": 248,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def Extract(lst): \n    return [item[0] for item in lst] \n    **Function Description: ** Write a python function to get the first element of each sublist.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be equal to the length of the input list 'lst'.",
                "assert_statement": "assert len(result) == len(lst)"
            },
            {
                "description": "Each element in the returned list must be the first element (index 0) of the corresponding sublist in the input 'lst'.",
                "assert_statement": "assert all(result[i] == lst[i][0] for i in range(len(lst)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 497,
        "Function_ID": 249,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count the upper case characters in a given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned count must be non-negative (greater than or equal to zero).",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The returned count cannot exceed the total length of the input string.",
                "assert_statement": "assert result <= len(input_string)"
            },
            {
                "description": "If the input string is empty, the count must be zero.",
                "assert_statement": "assert count_uppercase('') == 0"
            },
            {
                "description": "If the string contains only lowercase or non-alphabetic characters, the count must be zero.",
                "assert_statement": "assert count_uppercase('hello 123 world') == 0"
            },
            {
                "description": "If the string contains only uppercase characters, the count must equal the length of the string.",
                "assert_statement": "assert count_uppercase('ASSERT') == 6"
            },
            {
                "description": "The function correctly counts mixed-case strings.",
                "assert_statement": "assert count_uppercase('PyThOn PrOgRaMmInG') == 6"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 498,
        "Function_ID": 249,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr\n    **Function Description: ** Write a python function to count the upper case characters in a given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input string is non-empty and starts with an uppercase ASCII character ('A' through 'Z'), the function returns 1.",
                "assert_statement": "assert upper_ctr(\"UpperCase\") == 1"
            },
            {
                "description": "If the input string is non-empty and does not start with an uppercase ASCII character, the function returns 0.",
                "assert_statement": "assert upper_ctr(\"lowercase\") == 0"
            },
            {
                "description": "If the input string is empty, the function implicitly returns None because the return statement is incorrectly nested within the loop.",
                "assert_statement": "assert upper_ctr(\"\") is None"
            },
            {
                "description": "For any non-empty string, the return value is restricted to 0 or 1, regardless of the actual count of uppercase letters.",
                "assert_statement": "result = upper_ctr(\"ALL CAPS\"); assert result in (0, 1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 499,
        "Function_ID": 250,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find all possible combinations of the elements of a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The total number of combinations generated must equal 2 raised to the power of the number of elements in the input list (the power set size).",
                "assert_statement": "len(result) == 2**len(input_list)"
            },
            {
                "description": "All generated combinations must be unique (the output list, when treated as a collection of sets, should not contain duplicates).",
                "assert_statement": "len(result) == len(set(tuple(sorted(c)) for c in result))"
            },
            {
                "description": "Every element used in any combination must be present in the original input list.",
                "assert_statement": "all(all(elem in input_list for elem in combination) for combination in result)"
            },
            {
                "description": "The result set must contain the empty combination (the combination of zero elements).",
                "assert_statement": "[] in result"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 500,
        "Function_ID": 250,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result\n    **Function Description: ** Write a function to find all possible combinations of the elements of a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list of lists, where each inner list represents a combination.",
                "assert_statement": "assert isinstance(result, list) and all(isinstance(c, list) for c in result)"
            },
            {
                "description": "The total number of combinations returned must equal 2^N, where N is the length of the input list.",
                "assert_statement": "assert len(result) == (2**len(list1))"
            },
            {
                "description": "Every element in every resulting combination must be present in the original input list.",
                "assert_statement": "input_set = set(list1); assert all(all(item in input_set for item in combination) for combination in result)"
            },
            {
                "description": "If the input list is empty, the function must return a list containing exactly one empty list, representing the empty set combination.",
                "assert_statement": "assert combinations_list([]) == [[]]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 501,
        "Function_ID": 251,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the maximum product subarray of the given array.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned maximum product must be a numeric value (integer or float), consistent with the array elements.",
                "assert_statement": "isinstance(result, (int, float))"
            },
            {
                "description": "Assuming a non-empty array, the maximum product must be greater than or equal to the largest single element in the array, as any single element forms a valid subarray.",
                "assert_statement": "result >= max(arr)"
            },
            {
                "description": "If the input array contains only non-negative numbers, the maximum product must also be non-negative.",
                "assert_statement": "if all(x >= 0 for x in arr): assert result >= 0"
            },
            {
                "description": "If the input array contains only positive numbers, the maximum product must be positive.",
                "assert_statement": "if all(x > 0 for x in arr): assert result > 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 502,
        "Function_ID": 251,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_subarray_product(arr):\n\tn = len(arr)\n\tmax_ending_here = 1\n\tmin_ending_here = 1\n\tmax_so_far = 0\n\tflag = 0\n\tfor i in range(0, n):\n\t\tif arr[i] > 0:\n\t\t\tmax_ending_here = max_ending_here * arr[i]\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\n\t\t\tflag = 1\n\t\telif arr[i] == 0:\n\t\t\tmax_ending_here = 1\n\t\t\tmin_ending_here = 1\n\t\telse:\n\t\t\ttemp = max_ending_here\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\n\t\t\tmin_ending_here = temp * arr[i]\n\t\tif (max_so_far < max_ending_here):\n\t\t\tmax_so_far = max_ending_here\n\tif flag == 0 and max_so_far == 0:\n\t\treturn 0\n\treturn max_so_far\n    **Function Description: ** Write a function to find the maximum product subarray of the given array.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a non-negative number, as the logic prevents the result from being less than zero by initialization and intermediate floor operations.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "If the input array contains only zero elements or is empty, the maximum product returned is 0.",
                "assert_statement": "if not arr or all(x == 0 for x in arr): assert result == 0"
            },
            {
                "description": "If the array contains at least one positive element, the calculated maximum product must be greater than or equal to that element (specifically, greater than or equal to the maximum single non-negative value in the array).",
                "assert_statement": "if arr and any(x > 0 for x in arr): assert result >= max(x for x in arr if x >= 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 503,
        "Function_ID": 252,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check if all values are same in a dictionary.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns True if all values in the dictionary are identical (meaning the set of unique values has a size of 1).",
                "assert_statement": "assert result is True and len(set(dictionary.values())) == 1"
            },
            {
                "description": "The function returns False if the dictionary contains at least two distinct values (meaning the set of unique values has a size greater than 1).",
                "assert_statement": "assert result is False and len(set(dictionary.values())) > 1"
            },
            {
                "description": "The function returns True if the dictionary is empty (vacuously true, as there are no distinct values to compare).",
                "assert_statement": "assert result is True and not dictionary"
            },
            {
                "description": "The function does not modify the original input dictionary.",
                "assert_statement": "assert original_dictionary_state == dictionary"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 504,
        "Function_ID": 252,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_value(dict, n):\n    result = all(x == n for x in dict.values()) \n    return result\n    **Function Description: ** Write a function to check if all values are same in a dictionary.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean type.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The returned boolean must accurately reflect whether all values in the input dictionary are strictly equal to the target value 'n'.",
                "assert_statement": "assert result == all(value == n for value in dict.values())"
            },
            {
                "description": "If the input dictionary is empty, the result must be True, as there are no values violating the condition.",
                "assert_statement": "if not dict: assert result is True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 505,
        "Function_ID": 253,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to drop empty items from a given dictionary.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned object is a dictionary.",
                "assert_statement": "isinstance(result, dict)"
            },
            {
                "description": "No values remaining in the dictionary are considered empty (falsy values like None, [], {}, or '').",
                "assert_statement": "all(result.values())"
            },
            {
                "description": "All truthy (non-empty) key-value pairs from the input dictionary must be preserved in the output.",
                "assert_statement": "all(key in result and result[key] == value for key, value in input_dict.items() if value)"
            },
            {
                "description": "The output dictionary contains only keys that were present in the input dictionary.",
                "assert_statement": "set(result.keys()).issubset(set(input_dict.keys()))"
            },
            {
                "description": "If the input dictionary was empty, the output dictionary must also be empty.",
                "assert_statement": "if not input_dict: assert not result"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 506,
        "Function_ID": 253,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def drop_empty(dict1):\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1\n    **Function Description: ** Write a function to drop empty items from a given dictionary.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a dictionary.",
                "assert_statement": "assert isinstance(result, dict)"
            },
            {
                "description": "No value in the returned dictionary should be None.",
                "assert_statement": "assert all(v is not None for v in result.values())"
            },
            {
                "description": "The returned dictionary must exactly match the input dictionary after filtering out key-value pairs where the value was None.",
                "assert_statement": "assert result == {k: v for k, v in dict1.items() if v is not None}"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 507,
        "Function_ID": 254,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a positive number if the input array is not empty and contains at least one positive number, otherwise it can be zero or a negative number.",
                "assert_statement": "if array and any(x > 0 for x in array): assert result > 0 or result == 0 or result < 0 else: assert result >= 0 or result < 0"
            },
            {
                "description": "The result must be the maximum product achievable from any increasing subsequence.",
                "assert_statement": "assert result == max(product(subsequence) for subsequence in all_increasing_subsequences(array))"
            },
            {
                "description": "The result must be an integer or a floating-point number representing the product.",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "If the array is empty, the maximum product must be 1 (representing an empty product or neutral element for multiplication).",
                "assert_statement": "if not array: assert result == 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 508,
        "Function_ID": 254,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_product(arr):   \n  n = len(arr)\n  mpis = arr[:]\n  for i in range(n): \n    current_prod = arr[i]\n    j = i + 1\n    while j < n:\n      if arr[j-1] > arr[j]: \n        break\n      current_prod *= arr[j]\n      if current_prod > mpis[j]:\n        mpis[j] = current_prod \n      j = j + 1\n  return max(mpis)\n    **Function Description: ** Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input array is non-empty, the return value must be a number (int or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "If the input array is non-empty, the maximum product returned must be greater than or equal to the maximum single element in the array (as a single element is always a valid non-decreasing contiguous subsequence).",
                "assert_statement": "assert result >= max(input_arr)"
            },
            {
                "description": "Calling the function with an empty list raises a ValueError because the implementation calls max(mpis) on an empty list derived from an empty input.",
                "assert_statement": "import pytest; pytest.raises(ValueError, max_product, [])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 509,
        "Function_ID": 255,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the pairwise addition of the neighboring elements of the given tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting sequence must be one less than the length of the input tuple, provided the input tuple has at least two elements (or zero if the input has zero or one element).",
                "assert_statement": "assert len(result) == len(input_tuple) - 1 if len(input_tuple) >= 2 else len(result) == 0"
            },
            {
                "description": "Every element in the output sequence must equal the sum of the corresponding adjacent elements (i.e., element i and element i+1) in the input tuple.",
                "assert_statement": "assert all(result[i] == input_tuple[i] + input_tuple[i+1] for i in range(len(result)))"
            },
            {
                "description": "The resulting sequence maintains the same numerical type compatibility as the input elements (e.g., if the input contains integers, the results are integers).",
                "assert_statement": "assert not result or all(isinstance(r, type(input_tuple[0] + input_tuple[1])) for r in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 510,
        "Function_ID": 255,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def add_pairwise(test_tup):\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) \n    **Function Description: ** Write a function to find the pairwise addition of the neighboring elements of the given tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the result tuple is one less than the length of the input tuple, or zero if the input tuple has fewer than two elements.",
                "assert_statement": "assert len(result) == max(0, len(test_tup) - 1)"
            },
            {
                "description": "Each element in the result tuple is the sum of two adjacent elements from the input tuple: result[i] equals test_tup[i] + test_tup[i+1].",
                "assert_statement": "assert all(result[i] == test_tup[i] + test_tup[i+1] for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 511,
        "Function_ID": 256,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the product of the array multiplication modulo n.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is the total product of all elements in the array calculated modulo n.",
                "assert_statement": "import functools; expected = functools.reduce(lambda x, y: x * y, arr, 1) % n; assert result == expected"
            },
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The returned value must be non-negative.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned value must be strictly less than the modulus n (assuming n is positive).",
                "assert_statement": "result < n"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 512,
        "Function_ID": 256,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_remainder(arr, n): \n    mul = 1\n    for i in range(len(arr)):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n \n    **Function Description: ** Write a python function to find the product of the array multiplication modulo n.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be mathematically equal to the product of all elements in the input array, calculated modulo n.",
                "assert_statement": "import functools, operator; if n != 0: assert __result__ == functools.reduce(operator.mul, arr, 1) % n"
            },
            {
                "description": "If the modulus n is positive, the returned value must be non-negative and strictly less than n.",
                "assert_statement": "if n > 0: assert 0 <= __result__ < n"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 513,
        "Function_ID": 257,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether the given list contains consecutive numbers or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a boolean type.",
                "assert_statement": "isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, it must be because there exists at least one adjacent pair of elements (data_list[i], data_list[i+1]) in the original list such that data_list[i+1] equals data_list[i] + 1.",
                "assert_statement": "result == (any(data_list_orig[i+1] == data_list_orig[i] + 1 for i in range(len(data_list_orig) - 1)))"
            },
            {
                "description": "If the list has fewer than two elements, the function must return False, as no adjacent comparison is possible.",
                "assert_statement": "len(data_list_orig) < 2 and result == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 514,
        "Function_ID": 257,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_Consecutive(l): \n    return sorted(l) == list(range(min(l),max(l)+1)) \n    **Function Description: ** Write a python function to check whether the given list contains consecutive numbers or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the list contains all unique integers consecutively between its minimum and maximum elements (e.g., [5, 3, 4]), the function returns True.",
                "assert_statement": "assert check_Consecutive([5, 3, 4]) == True"
            },
            {
                "description": "If there is a gap (a missing number) between the minimum and maximum elements (e.g., [1, 2, 4]), the function returns False.",
                "assert_statement": "assert check_Consecutive([1, 2, 4]) == False"
            },
            {
                "description": "If the list contains duplicate numbers, it is not considered consecutive by the implementation logic (e.g., [1, 2, 2, 3]), and the function returns False.",
                "assert_statement": "assert check_Consecutive([1, 2, 2, 3]) == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 515,
        "Function_ID": 258,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the tuple intersection of elements in the given tuple list irrespective of their order.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting set must contain exactly all the elements that are common to every tuple in the input list (treating tuples as sets, ignoring internal order).",
                "assert_statement": "assert result == set.intersection(*[set(t) for t in tuple_list])"
            },
            {
                "description": "Every element present in the result must belong to the set representation of every input tuple.",
                "assert_statement": "assert all(item in set(t) for item in result for t in tuple_list)"
            },
            {
                "description": "No element that belongs to all input tuples (when viewed as sets) is missing from the result (ensuring maximality).",
                "assert_statement": "expected = set.intersection(*[set(t) for t in tuple_list]); assert expected.issubset(result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 516,
        "Function_ID": 258,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def tuple_intersection(test_list1, test_list2):\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\n  return (res)\n    **Function Description: ** Write a function to find the tuple intersection of elements in the given tuple list irrespective of their order.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a set, as it represents the intersection of elements.",
                "assert_statement": "assert isinstance(result, set)"
            },
            {
                "description": "The returned set must contain exactly the normalized tuples that are present in both input lists.",
                "assert_statement": "expected_set1 = set(tuple(sorted(ele)) for ele in test_list1); expected_set2 = set(tuple(sorted(ele)) for ele in test_list2); assert result == (expected_set1 & expected_set2)"
            },
            {
                "description": "Every tuple contained within the resulting set must have its elements internally sorted, based on the normalization applied during calculation.",
                "assert_statement": "assert all(list(t) == sorted(t) for t in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 517,
        "Function_ID": 259,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to replace characters in a string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must always be a string type.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The replaced substring/character ('old') must not be present in the resulting string (assuming a global replacement function).",
                "assert_statement": "assert old not in result"
            },
            {
                "description": "If the original string was empty, the result string must also be empty, regardless of the old or new substrings.",
                "assert_statement": "assert original or result == \"\""
            },
            {
                "description": "The length of the resulting string must equal the original length plus the net change in length caused by the replacements (count of 'old' times the difference in length between 'new' and 'old').",
                "assert_statement": "assert len(result) == len(original) + original.count(old) * (len(new) - len(old))"
            },
            {
                "description": "The resulting string must be equivalent to the expected output produced by a reliable reference implementation (e.g., Python's built-in replace method).",
                "assert_statement": "assert result == original.replace(old, new)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 518,
        "Function_ID": 259,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2\n    **Function Description: ** Write a function to replace characters in a string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The returned string is functionally equivalent to the result of applying the built-in string replace method using the provided arguments.",
                "assert_statement": "assert result == str1.replace(ch, newch)"
            },
            {
                "description": "If the substring to be replaced ('ch') is not present in the original string ('str1'), the returned string must be identical to the original string.",
                "assert_statement": "if ch not in str1: assert result == str1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 519,
        "Function_ID": 260,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to sort a dictionary by value.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The output must be an iterable sequence (like a list) containing the items of the dictionary.",
                "assert_statement": "isinstance(result, list) or isinstance(result, tuple)"
            },
            {
                "description": "The set of (key, value) pairs in the output must be identical to the set of (key, value) pairs in the input, ensuring all data is preserved.",
                "assert_statement": "set(result) == set(original_dict.items())"
            },
            {
                "description": "The result is sorted in ascending order based on the values (the second element of each tuple).",
                "assert_statement": "all(result[i][1] <= result[i+1][1] for i in range(len(result) - 1))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 520,
        "Function_ID": 260,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from collections import Counter\ndef sort_counter(dict1):\n x = Counter(dict1)\n sort_counter=x.most_common()\n return sort_counter\n    **Function Description: ** Write a function to sort a dictionary by value.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "Every element in the returned list must be a tuple of length 2 (key, value).",
                "assert_statement": "assert all(isinstance(item, tuple) and len(item) == 2 for item in result)"
            },
            {
                "description": "The list must be sorted by the second element (the value/count) of the tuples in strictly descending order.",
                "assert_statement": "assert all(result[i][1] >= result[i+1][1] for i in range(len(result) - 1))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 521,
        "Function_ID": 261,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the sum of the largest and smallest value in a given array.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be the sum of the maximum and minimum elements found in the input array.",
                "assert_statement": "result == max(arr) + min(arr)"
            },
            {
                "description": "The returned value must be a numeric type (integer or float).",
                "assert_statement": "isinstance(result, (int, float))"
            },
            {
                "description": "If the input array contains only one element, the result must be double that element's value.",
                "assert_statement": "if len(arr) == 1: assert result == 2 * arr[0]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 522,
        "Function_ID": 261,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def big_sum(nums):\n      sum= max(nums)+min(nums)\n      return sum\n    **Function Description: ** Write a python function to find the sum of the largest and smallest value in a given array.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must equal the sum of the maximum and minimum elements found in the input list 'nums'.",
                "assert_statement": "assert result == max(nums) + min(nums)"
            },
            {
                "description": "The return value must be an instance of a numeric type (int or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "If the input list 'nums' is empty, the function must raise a ValueError.",
                "assert_statement": "pytest.raises(ValueError, big_sum, [])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 523,
        "Function_ID": 262,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to convert the given string to lower case.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting string must match the expected lowercase transformation of the original string.",
                "assert_statement": "assert result == original_string.lower()"
            },
            {
                "description": "The length of the resulting string must be equal to the length of the original input string.",
                "assert_statement": "assert len(result) == len(original_string)"
            },
            {
                "description": "Every character in the resulting string must be lowercase (i.e., calling .lower() on the result should not change it).",
                "assert_statement": "assert result == result.lower()"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 524,
        "Function_ID": 262,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_lower(string):\n  return (string.lower())\n    **Function Description: ** Write a python function to convert the given string to lower case.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be of type string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The returned string must be completely lowercase, meaning applying .lower() again yields the identical string.",
                "assert_statement": "assert result == result.lower()"
            },
            {
                "description": "The length of the returned string must be identical to the length of the input string, as capitalization does not alter length.",
                "assert_statement": "assert len(result) == len(string)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 525,
        "Function_ID": 263,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to remove lowercase substrings from a given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting string must not contain any lowercase letters.",
                "assert_statement": "all(not char.islower() for char in result_string)"
            },
            {
                "description": "The resulting string must be shorter than or equal to the length of the original string.",
                "assert_statement": "len(result_string) <= len(original_string)"
            },
            {
                "description": "The resulting string must be identical to the original string after removing all characters that are lowercase, ensuring relative order of remaining characters is preserved.",
                "assert_statement": "result_string == \"\".join(c for c in original_string if not c.islower())"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 526,
        "Function_ID": 263,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef remove_lowercase(str1):\n return re.sub('[a-z]', '', str1)\n    **Function Description: ** Write a function to remove lowercase substrings from a given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The returned string must not contain any lowercase English letters (a-z).",
                "assert_statement": "assert re.search('[a-z]', result) is None"
            },
            {
                "description": "The length of the output string must be less than or equal to the length of the input string.",
                "assert_statement": "assert len(result) <= len(str1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 527,
        "Function_ID": 264,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the first digit of a given number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be an integer representing a single digit (0 through 9).",
                "assert_statement": "isinstance(result, int) and 0 <= result <= 9"
            },
            {
                "description": "The returned value must be the first digit of the absolute value of the input number.",
                "assert_statement": "result == int(str(abs(number))[0])"
            },
            {
                "description": "If the input number is zero, the returned digit must be zero.",
                "assert_statement": "if number == 0: assert result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 528,
        "Function_ID": 264,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def first_Digit(n) :  \n    while n >= 10:  \n        n = n / 10 \n    return int(n) \n    **Function Description: ** Write a python function to find the first digit of a given number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "If the input 'n' is non-negative, the result must be a single digit between 0 and 9.",
                "assert_statement": "if n >= 0: assert 0 <= result <= 9"
            },
            {
                "description": "If the input 'n' is non-negative and less than 10, the result must be the integer part of 'n'.",
                "assert_statement": "if 0 <= n < 10: assert result == int(n)"
            },
            {
                "description": "If the input 'n' is 10 or greater, the returned value (R) must represent the most significant digit, satisfying R * P <= n < (R + 1) * P, where P is the largest power of 10 less than or equal to n.",
                "assert_statement": "if n >= 10: import math; P = 10 ** math.floor(math.log10(n)); assert result * P <= n and n < (result + 1) * P"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 529,
        "Function_ID": 265,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function which takes a list of integers and only returns the odd ones.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "Every element in the returned list must be an odd integer.",
                "assert_statement": "all(x % 2 != 0 for x in result)"
            },
            {
                "description": "The returned list contains all odd integers that were present in the input list.",
                "assert_statement": "all(x in result for x in input_list if x % 2 != 0)"
            },
            {
                "description": "Every element in the returned list must have originated from the input list (no new elements are introduced).",
                "assert_statement": "all(x in input_list for x in result)"
            },
            {
                "description": "The result is a list.",
                "assert_statement": "isinstance(result, list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 530,
        "Function_ID": 265,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def Split(list): \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li\n    **Function Description: ** Write a python function which takes a list of integers and only returns the odd ones.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "All elements present in the returned list are odd integers.",
                "assert_statement": "assert all(x % 2 != 0 for x in result)"
            },
            {
                "description": "The returned list contains only elements that were originally present in the input list.",
                "assert_statement": "assert all(x in input_list for x in result)"
            },
            {
                "description": "The length of the returned list must be equal to the count of odd numbers in the input list.",
                "assert_statement": "assert len(result) == sum(1 for x in input_list if x % 2 != 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 531,
        "Function_ID": 266,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must equal the difference between the square of the sum of the first n natural numbers (sum of cubes formula) and the sum of the first n natural numbers.",
                "assert_statement": "assert result == ((n * (n + 1) // 2) ** 2) - (n * (n + 1) // 2)"
            },
            {
                "description": "The return value must be an integer, as the inputs and the calculation involve only natural numbers and standard arithmetic operations.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The calculated difference must be non-negative, since the sum of cubes is always greater than or equal to the sum of naturals for n >= 1.",
                "assert_statement": "assert result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 532,
        "Function_ID": 266,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def difference(n) :  \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  \n    **Function Description: ** Write a python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The result is equal to the sum of the first n natural numbers (S) multiplied by one less than that sum (S - 1).",
                "assert_statement": "S = (n * (n + 1)) // 2; assert result == S * (S - 1)"
            },
            {
                "description": "The result is equal to the difference between the square of the sum of the first n naturals (which is the sum of cubes) and the sum of the first n naturals.",
                "assert_statement": "S = (n * (n + 1)) // 2; assert result == (S * S) - S"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 533,
        "Function_ID": 267,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count the number of pairs whose xor value is odd.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result, being a count of pairs, must be a non-negative integer.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The result must equal twice the product of the count of odd numbers and the count of even numbers in the input list, as $x \\oplus y$ is odd if and only if one operand is odd and the other is even.",
                "assert_statement": "odd_count = sum(1 for x in arr if x % 2 != 0); even_count = len(arr) - odd_count; assert result == 2 * odd_count * even_count"
            },
            {
                "description": "If the input list is empty, the count of pairs must be zero.",
                "assert_statement": "len(arr) == 0 and result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 534,
        "Function_ID": 267,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_Odd_Pair(A,N) : \n    oddPair = 0\n    for i in range(0,N) :  \n        for j in range(i+1,N) :  \n            if ((A[i] ^ A[j]) % 2 != 0):  \n                oddPair+=1  \n    return oddPair  \n    **Function Description: ** Write a python function to count the number of pairs whose xor value is odd.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value, which counts the number of odd XOR pairs, must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The count of odd XOR pairs must equal the total number of unique pairs formed by selecting one odd number and one even number from the input list A. (Since A[i] ^ A[j] is odd if and only if one is even and the other is odd).",
                "assert_statement": "assert result == sum(1 for x in A if x % 2) * sum(1 for x in A if x % 2 == 0)"
            },
            {
                "description": "The return value cannot exceed the maximum number of unique pairs available in a list of size N.",
                "assert_statement": "assert result <= N * (N - 1) // 2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 535,
        "Function_ID": 268,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to toggle the case of all characters in a string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The output string must have the same length as the input string.",
                "assert_statement": "len(output_str) == len(input_str)"
            },
            {
                "description": "The output string must be the case-toggled version of the input string, where every character is the inverse case of the corresponding input character (or identical if non-alphabetic).",
                "assert_statement": "output_str == input_str.swapcase()"
            },
            {
                "description": "If the input string contained at least one alphabetic character, the resulting output string must be different from the input string.",
                "assert_statement": "(output_str != input_str) if any(c.isalpha() for c in input_str) else (output_str == input_str)"
            },
            {
                "description": "Characters that were not alphabetic (numbers, symbols, spaces) must remain unchanged.",
                "assert_statement": "all(input_str[i] == output_str[i] for i in range(len(input_str)) if not input_str[i].isalpha())"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 536,
        "Function_ID": 268,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def toggle_string(string):\n string1 = string.swapcase()\n return string1\n    **Function Description: ** Write a function to toggle the case of all characters in a string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a string and maintains the same length as the input string.",
                "assert_statement": "assert isinstance(result, str) and len(result) == len(string)"
            },
            {
                "description": "Applying the toggle function a second time (swapping the case of the returned string) must yield the original input string.",
                "assert_statement": "assert result.swapcase() == string"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 537,
        "Function_ID": 269,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the sum of the per-digit difference between two integers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is always non-negative.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "If both numbers are 0, the result is 0.",
                "assert_statement": "((num1 == 0) and (num2 == 0)) == (result == 0)"
            },
            {
                "description": "The result for (10, 1) is 1 (calculated as |0-1| + |1-0| = 1 + 1 = 2, but the intended functionality is often digit-wise until the shorter number runs out, then sum remaining digits of the longer number, e.g., |0-1| + |1-0| = 1 + 1 = 2, so let's clarify the expected behavior. Assuming standard padding or iterative difference: |0-1| + |1-0| = 2. Let's use an example that clarifies digit-by-digit summation: 123 and 45. The calculation is |3-5| + |2-4| + |1-0| = 2 + 2 + 1 = 5.",
                "assert_statement": "find_per_digit_difference_sum(123, 45) == 5"
            },
            {
                "description": "The result for two identical numbers is 0.",
                "assert_statement": "result == 0 if num1 == num2 else True"
            },
            {
                "description": "The result for 99 and 1 is 17 (|9-1| + |9-0| = 8 + 9 = 17).",
                "assert_statement": "find_per_digit_difference_sum(99, 1) == 17"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 538,
        "Function_ID": 269,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def digit_distance_nums(n1, n2):\n         return sum(map(int,str(abs(n1-n2))))\n    **Function Description: ** Write a python function to find the sum of the per-digit difference between two integers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The return value must be non-negative, as it is a sum of absolute differences of digits.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The result must equal the sum of the digits of the absolute difference between the two input numbers (e.g., if n1=100, n2=50, abs(n1-n2)=50, result=5+0=5).",
                "assert_statement": "assert result == sum(int(d) for d in str(abs(n1 - n2)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 539,
        "Function_ID": 270,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the sum of the largest contiguous sublist in the given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned sum must be exactly equal to the maximum sum achievable by any contiguous sublist of the input list. If the list is empty, the result must be 0.",
                "assert_statement": "assert result == (max(sum(input_list[i:j+1]) for i in range(len(input_list)) for j in range(i, len(input_list))) if input_list else 0)"
            },
            {
                "description": "If the input list is non-empty, the result must be greater than or equal to the largest single element, as that element itself constitutes a valid contiguous sublist.",
                "assert_statement": "assert not input_list or result >= max(input_list)"
            },
            {
                "description": "The result must be a numeric value (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 540,
        "Function_ID": 270,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_sub_array_sum(a, size):\n  max_so_far = 0\n  max_ending_here = 0\n  for i in range(0, size):\n    max_ending_here = max_ending_here + a[i]\n    if max_ending_here < 0:\n      max_ending_here = 0\n    elif (max_so_far < max_ending_here):\n      max_so_far = max_ending_here\n  return max_so_far\n    **Function Description: ** Write a function to find the sum of the largest contiguous sublist in the given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned maximum contiguous sum must be non-negative, as the algorithm initializes the maximum sum found so far to zero and resets negative running sums to zero.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "If the input list 'a' contains at least one positive element, the calculated maximum subarray sum must be greater than zero, provided the size is greater than zero.",
                "assert_statement": "assert size == 0 or all(x <= 0 for x in a) or result > 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 541,
        "Function_ID": 271,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the union of the elements of two given tuples and output them in sorted order.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must contain all unique elements from both input tuples (the mathematical union).",
                "assert_statement": "set(result) == set(input_tuple_1).union(set(input_tuple_2))"
            },
            {
                "description": "The elements in the resulting sequence must be in sorted ascending order.",
                "assert_statement": "result == sorted(result)"
            },
            {
                "description": "The length of the result must equal the size of the union set, ensuring no duplicates are present.",
                "assert_statement": "len(result) == len(set(input_tuple_1).union(set(input_tuple_2)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 542,
        "Function_ID": 271,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def union_elements(test_tup1, test_tup2):\n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) \n    **Function Description: ** Write a function to find the union of the elements of two given tuples and output them in sorted order.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The returned tuple must contain only unique elements, representing the union of the inputs.",
                "assert_statement": "assert len(result) == len(set(result))"
            },
            {
                "description": "The elements of the returned tuple must exactly match the union of the elements from the two input tuples.",
                "assert_statement": "assert set(result) == (set(test_tup1) | set(test_tup2))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 543,
        "Function_ID": 272,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the length of the longest sublists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input list is empty, the result is 0.",
                "assert_statement": "not input_list and result == 0"
            },
            {
                "description": "The result is equal to the maximum length of any sublist found within the input list.",
                "assert_statement": "result == max(len(sublist) for sublist in input_list) if input_list else result == 0"
            },
            {
                "description": "The result cannot be greater than the length of the longest sublist contained in the input.",
                "assert_statement": "all(result >= len(sublist) for sublist in input_list) if input_list else result == 0"
            },
            {
                "description": "If the input list contains at least one non-list element, that element's length is ignored, and the result is based only on list elements.",
                "assert_statement": "result == max(len(item) for item in input_list if isinstance(item, list)) if any(isinstance(item, list) for item in input_list) else result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 544,
        "Function_ID": 272,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def Find_Max_Length(lst):  \n    maxLength = max(len(x) for x in lst )\n    return maxLength \n    **Function Description: ** Write a python function to find the length of the longest sublists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer, as it represents a length.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The returned value must be greater than or equal to the length of every element (sublist) found in the input list `lst`.",
                "assert_statement": "all(result >= len(x) for x in lst)"
            },
            {
                "description": "The returned value must be exactly equal to the length of at least one element (sublist) in the input list `lst`.",
                "assert_statement": "any(result == len(x) for x in lst)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 545,
        "Function_ID": 273,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to extract values between quotation marks from a string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result returned by the function must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "If the input string contains quotation marks, the resulting list should not be empty.",
                "assert_statement": "assert len(result) > 0"
            },
            {
                "description": "If the input string contains no quotation marks, the resulting list must be empty.",
                "assert_statement": "assert result == []"
            },
            {
                "description": "All elements extracted and returned in the list must be strings.",
                "assert_statement": "assert all(isinstance(value, str) for value in result)"
            },
            {
                "description": "The extracted content must accurately match the string inside the quotation marks (e.g., extracting 'content' from 'text \"content\"').",
                "assert_statement": "assert 'example string' in result"
            },
            {
                "description": "The number of extracted items must match the expected count of quoted values (e.g., 2 from a string with two pairs of quotes).",
                "assert_statement": "assert len(result) == 2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 546,
        "Function_ID": 273,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef extract_values(text):\n return (re.findall(r'\"(.*?)\"', text))\n    **Function Description: ** Write a function to extract values between quotation marks from a string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "If the returned list is not empty, all elements must be strings, corresponding to the extracted values.",
                "assert_statement": "assert all(isinstance(item, str) for item in result)"
            },
            {
                "description": "The function correctly identifies and extracts content between non-greedy double quotes in a typical input string.",
                "assert_statement": "assert extract_values('Text \"Value1\" and \"Value2\" ending here.') == ['Value1', 'Value2']"
            },
            {
                "description": "If no quotation marks are present in the input text, the function returns an empty list.",
                "assert_statement": "assert extract_values('No quotes here') == []"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 547,
        "Function_ID": 274,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The count of unequal pairs cannot exceed the total possible unordered pairs (N choose 2).",
                "assert_statement": "result <= len(input_list) * (len(input_list) - 1) // 2"
            },
            {
                "description": "The result must equal the total number of unordered pairs minus the count of unordered pairs where the elements are identical (i.e., pairs of duplicate numbers).",
                "assert_statement": "(lambda L: result == (len(L) * (len(L) - 1) // 2) - sum(c * (c - 1) // 2 for c in {x: L.count(x) for x in set(L)}.values()))(input_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 548,
        "Function_ID": 274,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_Pairs(arr,n): \n    cnt = 0; \n    for i in range(n): \n        for j in range(i + 1,n): \n            if (arr[i] != arr[j]): \n                cnt += 1; \n    return cnt; \n    **Function Description: ** Write a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The return value must be less than or equal to the maximum possible number of pairs, which is n * (n - 1) / 2.",
                "assert_statement": "N = n; max_pairs = N * (N - 1) // 2 if N >= 2 else 0; assert result <= max_pairs"
            },
            {
                "description": "The returned count must match the total number of unique unordered index pairs (i, j) where i < j and arr[i] is not equal to arr[j].",
                "assert_statement": "expected = sum(1 for i in range(n) for j in range(i + 1, n) if arr[i] != arr[j]); assert result == expected"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 549,
        "Function_ID": 275,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to split a string into characters.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result of the function must be a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "The length of the resulting list must equal the length of the input string.",
                "assert_statement": "len(result) == len(s)"
            },
            {
                "description": "Every element in the resulting list must be a string of length 1 (a single character).",
                "assert_statement": "all(isinstance(char, str) and len(char) == 1 for char in result)"
            },
            {
                "description": "Joining the elements of the resulting list must reconstruct the original input string, ensuring correct order and content.",
                "assert_statement": "\"\".join(result) == s"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 550,
        "Function_ID": 275,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def split(word): \n    return [char for char in word] \n    **Function Description: ** Write a python function to split a string into characters.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be equal to the length of the input string.",
                "assert_statement": "assert len(result) == len(word)"
            },
            {
                "description": "Joining the elements of the returned list must reconstitute the original input string.",
                "assert_statement": "assert \"\".join(result) == word"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 551,
        "Function_ID": 276,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to get the sum of the digits of a non-negative integer.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The result must equal the sum of the digits obtained by converting the input integer (n) to a string and summing its individual components.",
                "assert_statement": "result == sum(int(digit) for digit in str(n))"
            },
            {
                "description": "If the input integer is 0, the sum of its digits must be 0.",
                "assert_statement": "if n == 0: assert result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 552,
        "Function_ID": 276,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sum_digits(n):\n  if n == 0:\n    return 0\n  else:\n    return n % 10 + sum_digits(int(n / 10))\n    **Function Description: ** Write a function to get the sum of the digits of a non-negative integer.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input integer 'n' is zero, the sum of digits must be zero.",
                "assert_statement": "assert n != 0 or result == 0"
            },
            {
                "description": "The function correctly calculates the sum of digits for a multi-digit test case (e.g., 123).",
                "assert_statement": "assert sum_digits(123) == 6"
            },
            {
                "description": "The function correctly calculates the sum of digits for a large number consisting of repeated high digits (e.g., 999).",
                "assert_statement": "assert sum_digits(999) == 27"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 553,
        "Function_ID": 277,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether a specified list is sorted or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, every element in the list must be in non-decreasing order relative to its successor.",
                "assert_statement": "result == True ==> all(L[i] <= L[i+1] for i in range(len(L) - 1))"
            },
            {
                "description": "If the function returns False, there must exist at least one adjacent pair of elements that is out of order.",
                "assert_statement": "result == False ==> any(L[i] > L[i+1] for i in range(len(L) - 1))"
            },
            {
                "description": "The returned value must be a boolean.",
                "assert_statement": "isinstance(result, bool)"
            },
            {
                "description": "The input list L must not be modified (idempotence/no side effects).",
                "assert_statement": "id(L) == initial_id_L and L == initial_L"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 554,
        "Function_ID": 277,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def issort_list(list1):\n    result = all(list1[i] <= list1[i+1] for i in range(len(list1)-1))\n    return result\n    **Function Description: ** Write a function to check whether a specified list is sorted or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean type (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the input list is sorted in non-decreasing order, the function must return True.",
                "assert_statement": "test_list = [1, 2, 2, 5, 10]; assert issort_list(test_list) == True"
            },
            {
                "description": "If the input list contains elements out of non-decreasing order, the function must return False.",
                "assert_statement": "test_list = [1, 10, 5, 8]; assert issort_list(test_list) == False"
            },
            {
                "description": "An empty list or a list containing only one element is considered sorted and must return True.",
                "assert_statement": "assert issort_list([]) == True and issort_list([42]) == True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 555,
        "Function_ID": 278,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to create a list of N empty dictionaries.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function output must be a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "The length of the resulting list must equal the input N.",
                "assert_statement": "len(result) == N"
            },
            {
                "description": "All elements in the list must be empty dictionaries.",
                "assert_statement": "all(isinstance(d, dict) and not d for d in result)"
            },
            {
                "description": "All dictionaries in the resulting list must be distinct objects, ensuring modifications to one dictionary do not affect others.",
                "assert_statement": "len(set(id(d) for d in result)) == len(result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 556,
        "Function_ID": 278,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def empty_list(length):\n empty_list = [{} for _ in range(length)]\n return empty_list\n    **Function Description: ** Write a function to create a list of N empty dictionaries.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must equal the input length.",
                "assert_statement": "assert len(result) == length"
            },
            {
                "description": "Every element in the list must be an instance of a dictionary.",
                "assert_statement": "assert all(isinstance(item, dict) for item in result)"
            },
            {
                "description": "Every dictionary element in the list must be empty.",
                "assert_statement": "assert all(len(item) == 0 for item in result)"
            },
            {
                "description": "All dictionary objects within the list must be unique instances, ensuring modification of one does not affect others.",
                "assert_statement": "assert len(set(id(d) for d in result)) == len(result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 557,
        "Function_ID": 279,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to sort each sublist of strings in a given list of lists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "Every sublist in the resulting list of lists is sorted alphabetically.",
                "assert_statement": "all(sublist == sorted(sublist) for sublist in result_list_of_lists)"
            },
            {
                "description": "The resulting list of lists maintains the same number of sublists as the input list of lists.",
                "assert_statement": "len(result_list_of_lists) == len(input_list_of_lists)"
            },
            {
                "description": "The set of elements (and their counts) within each corresponding sublist are preserved, ensuring no elements were lost or added during the sort.",
                "assert_statement": "all(sorted(result_list_of_lists[i]) == sorted(input_list_of_lists[i]) for i in range(len(input_list_of_lists)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 558,
        "Function_ID": 279,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sort_sublists(list1):\n    result = list(map(sorted,list1)) \n    return result\n    **Function Description: ** Write a function to sort each sublist of strings in a given list of lists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The returned list contains the same number of sublists as the input list.",
                "assert_statement": "assert len(result) == len(list1)"
            },
            {
                "description": "Every sublist in the returned list is sorted in non-decreasing order.",
                "assert_statement": "assert all(sublist == sorted(sublist) for sublist in result)"
            },
            {
                "description": "Each returned sublist is the sorted version of the corresponding original input sublist, ensuring content and transformation correctness.",
                "assert_statement": "assert all(returned == sorted(original) for original, returned in zip(list1, result))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 559,
        "Function_ID": 280,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to remove duplicate numbers from a given number of lists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned structure must contain only unique elements (no duplicates).",
                "assert_statement": "len(result) == len(set(result))"
            },
            {
                "description": "The resulting collection must contain exactly the unique union of all elements from all input lists. (Assuming 'inputs' refers to the tuple or list of input lists passed to the function).",
                "assert_statement": "set(result) == set(item for sublist in inputs for item in sublist)"
            },
            {
                "description": "The function must return a list type.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "All elements in the result must be numeric (integer or float, assuming the input only contains numbers).",
                "assert_statement": "all(isinstance(x, (int, float)) for x in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 560,
        "Function_ID": 280,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def two_unique_nums(nums):\n  return [i for i in nums if nums.count(i)==1]\n    **Function Description: ** Write a python function to remove duplicate numbers from a given number of lists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "Every element present in the returned list appeared exactly once in the original input list 'nums'.",
                "assert_statement": "assert all(nums.count(i) == 1 for i in result)"
            },
            {
                "description": "The length of the returned list equals the total count of elements appearing exactly once in the input list.",
                "assert_statement": "assert len(result) == len([i for i in nums if nums.count(i) == 1])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 561,
        "Function_ID": 281,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to calculate the product of the unique numbers in a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must equal the product of the unique elements in a standard list of positive integers.",
                "assert_statement": "calculate_unique_product([1, 2, 2, 3, 5]) == 30"
            },
            {
                "description": "If the input list is empty, the product should return the multiplicative identity (1).",
                "assert_statement": "calculate_unique_product([]) == 1"
            },
            {
                "description": "The function correctly handles inputs containing negative numbers and duplicates.",
                "assert_statement": "calculate_unique_product([-1, 4, -1, 3]) == -12"
            },
            {
                "description": "If zero is one of the unique numbers in the list, the resulting product must be zero.",
                "assert_statement": "calculate_unique_product([7, 0, 5, 7]) == 0"
            },
            {
                "description": "The result must be of numeric type (integer or float).",
                "assert_statement": "isinstance(calculate_unique_product([1, 2, 3]), (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 562,
        "Function_ID": 281,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def unique_product(list_data):\n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p\n    **Function Description: ** Write a python function to calculate the product of the unique numbers in a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be equal to the product of all unique elements found in the input list.",
                "assert_statement": "expected_product = 1; for x in set(list_data): expected_product *= x; assert result == expected_product"
            },
            {
                "description": "The returned value must be a numeric type (integer or float), reflecting the product operation.",
                "assert_statement": "assert isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 563,
        "Function_ID": 282,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the surface area of a cylinder.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned surface area must be non-negative, as area cannot be negative.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The returned value must be a number (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "The calculated result must match the standard surface area formula: 2 * PI * r * (r + h).",
                "assert_statement": "assert result == 2 * math.pi * r * (r + h)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 564,
        "Function_ID": 282,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def surfacearea_cylinder(r,h):\n  surfacearea=((2*3.1415*r*r) +(2*3.1415*r*h))\n  return surfacearea\n    **Function Description: ** Write a function to find the surface area of a cylinder.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a numerical type (float or int), resulting from the multiplication involving the fixed constant 3.1415.",
                "assert_statement": "assert isinstance(result, (float, int))"
            },
            {
                "description": "The returned surface area calculation adheres exactly to the formula specified in the function body, $2 \\cdot 3.1415 \\cdot r^2 + 2 \\cdot 3.1415 \\cdot r \\cdot h$.",
                "assert_statement": "expected = (2 * 3.1415 * r * r) + (2 * 3.1415 * r * h); assert result == expected"
            },
            {
                "description": "If the input radius (r) and height (h) are non-negative, the resulting surface area must be non-negative.",
                "assert_statement": "if r >= 0 and h >= 0: assert result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 565,
        "Function_ID": 283,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether a list is sublist of another or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns True when the sublist is found as a contiguous sequence within the main list.",
                "assert_statement": "assert is_sublist([2, 3], [1, 2, 3, 4]) == True"
            },
            {
                "description": "The function returns False if the elements of the potential sublist are present but not in a contiguous sequence.",
                "assert_statement": "assert is_sublist([1, 3], [1, 2, 3, 4]) == False"
            },
            {
                "description": "The function returns True when the sublist is an empty list (the empty list is always a sublist).",
                "assert_statement": "assert is_sublist([], [1, 2, 3]) == True"
            },
            {
                "description": "The function returns True when the sublist is identical to the main list.",
                "assert_statement": "assert is_sublist(['a', 'b'], ['a', 'b']) == True"
            },
            {
                "description": "The function returns False when the sublist contains elements not present in the main list.",
                "assert_statement": "assert is_sublist([5], [1, 2, 3]) == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 566,
        "Function_ID": 283,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_Sub_Array(A,B): \n    n = len(A)\n    m = len(B)\n    i = 0; j = 0; \n    while (i < n and j < m):  \n        if (A[i] == B[j]): \n            i += 1; \n            j += 1; \n            if (j == m): \n                return True;  \n        else: \n            i = i - j + 1; \n            j = 0;       \n    return False; \n    **Function Description: ** Write a python function to check whether a list is sublist of another or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean.",
                "assert_statement": "assert isinstance(R, bool)"
            },
            {
                "description": "If the function returns True, list B must be a contiguous sublist of A.",
                "assert_statement": "if R: assert len(B) <= len(A) and any(A[i:i + len(B)] == B for i in range(len(A) - len(B) + 1))"
            },
            {
                "description": "If the function returns False, list B must not be a contiguous sublist of A.",
                "assert_statement": "if not R: assert len(B) > len(A) or not any(A[i:i + len(B)] == B for i in range(len(A) - len(B) + 1))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 567,
        "Function_ID": 284,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the last digit in factorial of a given number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function output must be an integer (a single digit) between 0 and 9, inclusive.",
                "assert_statement": "assert isinstance(func_result, int) and 0 <= func_result <= 9"
            },
            {
                "description": "For an input of N=0, the last digit of 0! (1) must be 1.",
                "assert_statement": "assert last_digit_factorial(0) == 1"
            },
            {
                "description": "For an input of N=4, the last digit of 4! (24) must be 4.",
                "assert_statement": "assert last_digit_factorial(4) == 4"
            },
            {
                "description": "For any input N >= 5, the last digit of N! must be 0.",
                "assert_statement": "assert last_digit_factorial(5) == 0 and last_digit_factorial(10) == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 568,
        "Function_ID": 284,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def last_Digit_Factorial(n): \n    if (n == 0): return 1\n    elif (n <= 2): return n  \n    elif (n == 3): return 6\n    elif (n == 4): return 4 \n    else: \n      return 0\n    **Function Description: ** Write a python function to find the last digit in factorial of a given number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer between 0 and 9, inclusive, as it represents a single digit.",
                "assert_statement": "RET = last_Digit_Factorial(n); assert isinstance(RET, int) and 0 <= RET <= 9"
            },
            {
                "description": "For inputs n=0 through n=4, the function returns the correct last digit of n! according to the defined rules (1, 1, 2, 6, 4 respectively).",
                "assert_statement": "results = {0: 1, 1: 1, 2: 2, 3: 6, 4: 4}; for k, v in results.items(): assert last_Digit_Factorial(k) == v"
            },
            {
                "description": "For any input n greater than or equal to 5, the last digit of n! is 0 because the factorial contains factors of 2 and 5.",
                "assert_statement": "assert last_Digit_Factorial(5) == 0 and last_Digit_Factorial(10) == 0 and last_Digit_Factorial(50) == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 569,
        "Function_ID": 285,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to interleave 3 lists of the same length into a single flat list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting list must equal the combined length of the three input lists.",
                "assert_statement": "len(result) == len(list1) + len(list2) + len(list3)"
            },
            {
                "description": "Elements from the first list (list1) must occupy indices 0, 3, 6, ... (3*i) in the result list.",
                "assert_statement": "all(result[3 * i] == list1[i] for i in range(len(list1)))"
            },
            {
                "description": "Elements from the second list (list2) must occupy indices 1, 4, 7, ... (3*i + 1) in the result list.",
                "assert_statement": "all(result[3 * i + 1] == list2[i] for i in range(len(list2)))"
            },
            {
                "description": "Elements from the third list (list3) must occupy indices 2, 5, 8, ... (3*i + 2) in the result list.",
                "assert_statement": "all(result[3 * i + 2] == list3[i] for i in range(len(list3)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 570,
        "Function_ID": 285,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def interleave_lists(list1,list2,list3):\n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result\n    **Function Description: ** Write a function to interleave 3 lists of the same length into a single flat list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the resulting list is equal to the sum of the lengths of the three input lists (assuming equal initial lengths).",
                "assert_statement": "assert len(result) == len(list1) + len(list2) + len(list3)"
            },
            {
                "description": "Elements from the first list occupy indices 0, 3, 6, etc., in the interleaved result.",
                "assert_statement": "assert all(result[i] == list1[i // 3] for i in range(0, len(result), 3))"
            },
            {
                "description": "Elements from the third list occupy indices 2, 5, 8, etc., in the interleaved result.",
                "assert_statement": "assert all(result[i] == list3[(i - 2) // 3] for i in range(2, len(result), 3))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 571,
        "Function_ID": 286,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the dissimilar elements in the given two tuples.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The set of elements returned must be the symmetric difference of the two input tuples.",
                "assert_statement": "set(result) == set(tuple1).symmetric_difference(set(tuple2))"
            },
            {
                "description": "Any element present in the intersection of the two tuples must not be present in the result.",
                "assert_statement": "set(result).isdisjoint(set(tuple1) & set(tuple2))"
            },
            {
                "description": "If the two input tuples are identical (when converted to sets), the result must be empty.",
                "assert_statement": "if set(tuple1) == set(tuple2): assert not result"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 572,
        "Function_ID": 286,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_dissimilar(test_tup1, test_tup2):\n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) \n    **Function Description: ** Write a function to find the dissimilar elements in the given two tuples.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The set of elements in the returned tuple must be equal to the symmetric difference of the input sets, containing only elements unique to either input tuple.",
                "assert_statement": "assert set(result) == set(test_tup1) ^ set(test_tup2)"
            },
            {
                "description": "The returned tuple should only contain unique elements, as it is derived from a set operation.",
                "assert_statement": "assert len(result) == len(set(result))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 573,
        "Function_ID": 287,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to remove uneven elements in the nested mixed tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting structure must be a tuple, preserving immutability.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "No integer element remaining in the final structure, regardless of nesting depth, should be odd.",
                "assert_statement": "assert all(i % 2 == 0 for i in deep_get_integers(result))"
            },
            {
                "description": "If the filtering operation results in an empty nested structure (e.g., a tuple containing only odd numbers), that empty structure must be preserved (e.g., () or []).",
                "assert_statement": "assert all(elem in result or isinstance(elem, (tuple, list)) and len(elem) == 0 for elem in input_tuple if not isinstance(elem, int))"
            },
            {
                "description": "The total count of all integer elements remaining in the output must be less than or equal to the count of even integers in the input.",
                "assert_statement": "assert len(deep_get_integers(result)) <= sum(1 for i in deep_get_integers(input_tuple) if i % 2 == 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 574,
        "Function_ID": 287,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def even_ele(test_tuple, even_fnc): \n\tres = tuple() \n\tfor ele in test_tuple: \n\t\tif isinstance(ele, tuple): \n\t\t\tres += (even_ele(ele, even_fnc), ) \n\t\telif even_fnc(ele): \n\t\t\tres += (ele, ) \n\treturn res \ndef extract_even(test_tuple):\n  res = even_ele(test_tuple, lambda x: x % 2 == 0)\n  return (res) \n    **Function Description: ** Write a function to remove uneven elements in the nested mixed tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned tuple must maintain the nesting structure of the input, containing only the even integer elements from the original tuple.",
                "assert_statement": "test_tuple = (1, 2, (3, 4, 5), 6, (7, (8, 9))); assert extract_even(test_tuple) == (2, (4,), 6, ((8,)))"
            },
            {
                "description": "If the input is a flat tuple of integers, the output is a flat tuple containing only the even integers.",
                "assert_statement": "test_tuple = (10, 11, 12, 13, 14); assert extract_even(test_tuple) == (10, 12, 14)"
            },
            {
                "description": "If the input contains no even numbers, the resulting tuple must contain only empty tuples corresponding to the structural nesting, or be empty itself.",
                "assert_statement": "test_tuple = (1, (3, 5), 7, ()); assert extract_even(test_tuple) == ((), ())"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 575,
        "Function_ID": 288,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the surface area of a square pyramid with a given base edge and height.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a floating-point number, suitable for representing geometric measurements.",
                "assert_statement": "isinstance(result, float)"
            },
            {
                "description": "The result must be positive, as surface area cannot be negative.",
                "assert_statement": "result > 0"
            },
            {
                "description": "The result equals the total surface area (Base Area + Lateral Area), calculated using the formula SA = b + 2b * (h + (b/2)), where b is the base edge and h is the height.",
                "assert_statement": "result == base_edge**2 + 2 * base_edge * (height**2 + (base_edge/2)**2)**0.5"
            },
            {
                "description": "The total surface area must be greater than or equal to the area of the base (base_edge squared).",
                "assert_statement": "result >= base_edge**2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 576,
        "Function_ID": 288,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def surface_Area(b,s): \n    return 2 * b * s + pow(b,2) \n    **Function Description: ** Write a python function to find the surface area of a square pyramid with a given base edge and height.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be mathematically equal to the surface area calculated by the formula 2 * b * s + b^2.",
                "assert_statement": "assert result == 2 * b * s + pow(b, 2)"
            },
            {
                "description": "The calculated surface area must be a non-negative number, assuming non-negative inputs b and s.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The return value must be an instance of a numerical type (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 577,
        "Function_ID": 289,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check if a dictionary is empty",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function result must correctly indicate if the input dictionary is empty (i.e., has a length of zero).",
                "assert_statement": "assert result == (len(d) == 0)"
            },
            {
                "description": "The return value must be a boolean type.",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 578,
        "Function_ID": 289,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def my_dict(dict1):\n  if bool(dict1):\n     return False\n  else:\n     return True\n    **Function Description: ** Write a function to check if a dictionary is empty",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input dictionary is empty, the function must return True.",
                "assert_statement": "assert my_dict({}) == True"
            },
            {
                "description": "If the input dictionary contains items (is not empty), the function must return False.",
                "assert_statement": "assert my_dict({'a': 1, 'b': 2}) == False"
            },
            {
                "description": "The return value must always be a boolean type.",
                "assert_statement": "assert isinstance(my_dict({}), bool) and isinstance(my_dict({'x': 0}), bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 579,
        "Function_ID": 290,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function which returns nth catalan number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The returned Catalan number must be non-negative (C_n >= 1 for n >= 0).",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The Catalan number sequence starts with C_0 = 1.",
                "assert_statement": "if n == 0: assert result == 1"
            },
            {
                "description": "The returned result should match the known combinatorial identity C_n = (1/(n+1)) * (2n choose n). (Requires a helper function for combinations or factorials).",
                "assert_statement": "if n > 0: assert result * (n + 1) == factorial(2*n) // (factorial(n) * factorial(n))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 580,
        "Function_ID": 290,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def catalan_number(num):\n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num\n    **Function Description: ** Write a function which returns nth catalan number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The result for input 0 (C_0) must be 1.",
                "assert_statement": "assert catalan_number(0) == 1"
            },
            {
                "description": "The result for input 3 (C_3) must be 5.",
                "assert_statement": "assert catalan_number(3) == 5"
            },
            {
                "description": "The result for input 5 (C_5) must be 42.",
                "assert_statement": "assert catalan_number(5) == 42"
            },
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "result = catalan_number(4); assert isinstance(result, int) and result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 581,
        "Function_ID": 291,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the first adverb ending with ly and its positions in a given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If a matching adverb is found, the returned word must end with the suffix 'ly' (case insensitive).",
                "assert_statement": "assert found_adverb.lower().endswith('ly')"
            },
            {
                "description": "If an adverb is found, the returned start and end indices must correctly slice the input string to match the found adverb.",
                "assert_statement": "assert input_string[start_index:end_index] == found_adverb"
            },
            {
                "description": "If no adverb is found, the returned values must be standardized sentinel values (e.g., None/empty string for the adverb, -1 for indices).",
                "assert_statement": "assert found_adverb is None and start_index == -1 and end_index == -1"
            },
            {
                "description": "If an adverb is found, the returned start_index must be the absolute lowest starting index for any valid 'ly' ending word in the input string (ensuring it is the first occurrence).",
                "assert_statement": "assert not has_ly_ending_word_before(input_string, start_index)"
            },
            {
                "description": "If an adverb is found, the indices must be valid and ordered.",
                "assert_statement": "assert 0 <= start_index < end_index <= len(input_string)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 582,
        "Function_ID": 291,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef find_adverbs(text):\n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))\n    **Function Description: ** Write a function to find the first adverb ending with ly and its positions in a given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If a match is found, the return value must be a string formatted as 'start_index-end_index: matched_word', where the matched_word ends in 'ly'.",
                "assert_statement": "if _result is not None: assert isinstance(_result, str) and re.match(r'^\\d+-\\d+: \\w+ly$', _result)"
            },
            {
                "description": "If the input string does not contain any sequence matching the pattern '\\w+ly', the function must return None.",
                "assert_statement": "if not re.search(r'\\w+ly', text): assert _result is None"
            },
            {
                "description": "If a result is returned, the indices reported must correctly capture the matched word ending in 'ly'.",
                "assert_statement": "if _result is not None: start, end, word = re.match(r'(\\d+)-(\\d+): (.*)', _result).groups(); assert text[int(start):int(end)] == word"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 583,
        "Function_ID": 292,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the n most expensive items in a given dataset.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned list must contain exactly N items, or fewer if the original dataset contained less than N items.",
                "assert_statement": "len(result) == min(N, len(dataset))"
            },
            {
                "description": "The items in the returned list must be sorted in descending order based on their price (most expensive first). (Assumes item objects have a 'price' key).",
                "assert_statement": "all(result[i]['price'] >= result[i+1]['price'] for i in range(len(result) - 1))"
            },
            {
                "description": "All items returned in the result set must be present in the original dataset.",
                "assert_statement": "all(item in dataset for item in result)"
            },
            {
                "description": "The least expensive item in the result set (the Nth item) must have a price greater than or equal to the price of every item NOT included in the result set (if any remain).",
                "assert_statement": "other_items = [item for item in dataset if item not in result]; assert not other_items or result[-1]['price'] >= max(item['price'] for item in other_items)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 584,
        "Function_ID": 292,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import heapq\ndef expensive_items(items,n):\n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items\n    **Function Description: ** Write a function to find the n most expensive items in a given dataset.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list is the minimum of 'n' and the total number of items.",
                "assert_statement": "assert len(result) == min(n, len(items))"
            },
            {
                "description": "The returned items are sorted in descending order based on their 'price' attribute, reflecting the 'most expensive' requirement.",
                "assert_statement": "assert all(result[i]['price'] >= result[i+1]['price'] for i in range(len(result) - 1))"
            },
            {
                "description": "All elements present in the result list must have originated from the input list 'items'.",
                "assert_statement": "assert all(item in items for item in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 585,
        "Function_ID": 293,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to split a list at the nth eelment and add the first part to the end.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting list must be identical to the length of the original list (assuming n is within bounds).",
                "assert_statement": "assert len(result) == len(L_original)"
            },
            {
                "description": "The new prefix of the list (elements up to the rotation point) must match the suffix of the original list starting from the nth element.",
                "assert_statement": "assert result[0:len(L_original) - n] == L_original[n:]"
            },
            {
                "description": "The new suffix of the list (elements after the rotation point) must match the prefix of the original list up to the nth element.",
                "assert_statement": "assert result[len(L_original) - n:] == L_original[:n]"
            },
            {
                "description": "If the split point n is 0, the list should remain unchanged.",
                "assert_statement": "if n == 0: assert result == L_original"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 586,
        "Function_ID": 293,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def split_Arr(l, n):\n  return l[n:] + l[:n]\n    **Function Description: ** Write a python function to split a list at the nth eelment and add the first part to the end.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned list must have the same number of elements as the input list.",
                "assert_statement": "assert len(result) == len(l)"
            },
            {
                "description": "The returned list must be exactly the input list split at index n and rotated, where the sublist from index n onward precedes the sublist before index n.",
                "assert_statement": "assert result == l[n:] + l[:n]"
            },
            {
                "description": "The set of elements in the returned list must be identical to the set of elements in the input list, maintaining counts (i.e., no elements were added or lost).",
                "assert_statement": "assert sorted(result) == sorted(l)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 587,
        "Function_ID": 294,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert a list to a tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is an instance of the built-in tuple type.",
                "assert_statement": "assert isinstance(result_tuple, tuple)"
            },
            {
                "description": "The length of the resulting tuple is equal to the length of the input list.",
                "assert_statement": "assert len(result_tuple) == len(input_list)"
            },
            {
                "description": "The elements of the resulting tuple are identical to the elements of the input list, maintaining order.",
                "assert_statement": "assert result_tuple == tuple(input_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 588,
        "Function_ID": 294,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def list_tuple(listx):\n  tuplex = tuple(listx)\n  return tuplex\n    **Function Description: ** Write a function to convert a list to a tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be of type tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the returned tuple must match the length of the input list.",
                "assert_statement": "assert len(result) == len(listx)"
            },
            {
                "description": "The elements and their order in the returned tuple must exactly match those in the input list.",
                "assert_statement": "assert result == tuple(listx)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 589,
        "Function_ID": 295,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the difference between largest and smallest value in a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value (result) must equal the difference between the maximum element and the minimum element of the input list, provided the list is non-empty.",
                "assert_statement": "result == max(input_list) - min(input_list)"
            },
            {
                "description": "The calculated difference must always be a non-negative number.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "If the input list is empty, the function must return 0 (standard safe handling for operations on empty lists).",
                "assert_statement": "not input_list and result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 590,
        "Function_ID": 295,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def big_diff(nums):\n     diff= max(nums)-min(nums)\n     return diff\n    **Function Description: ** Write a python function to find the difference between largest and smallest value in a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be non-negative, as the difference is calculated by subtracting the minimum from the maximum value.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The return value must equal the actual difference between the maximum and minimum elements of the input list 'nums'.",
                "assert_statement": "assert result == max(nums) - min(nums)"
            },
            {
                "description": "The return value must be a numeric type (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 591,
        "Function_ID": 296,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find perfect squares between two given numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is a list (or iterable) of integers.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "All elements in the result are perfect squares (their square root is an integer).",
                "assert_statement": "all(x >= 0 and x**0.5 == int(x**0.5) for x in result)"
            },
            {
                "description": "Every element in the list is strictly greater than the 'start' number.",
                "assert_statement": "all(x > start for x in result)"
            },
            {
                "description": "Every element in the list is strictly less than the 'end' number.",
                "assert_statement": "all(x < end for x in result)"
            },
            {
                "description": "The resulting list is sorted in ascending order.",
                "assert_statement": "result == sorted(result)"
            },
            {
                "description": "The result contains all possible perfect squares that satisfy the (start, end) range constraint (ensuring no perfect squares were missed).",
                "assert_statement": "import math; expected_squares = sorted([i*i for i in range(math.ceil((start + 1)**0.5), math.floor((end - 1)**0.5) + 1)]) if end > start else []; assert result == expected_squares"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 592,
        "Function_ID": 296,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def perfect_squares(a, b):\n    lists=[]\n    for i in range (a,b+1):\n        j = 1;\n        while j*j <= i:\n            if j*j == i:\n                 lists.append(i)  \n            j = j+1\n        i = i+1\n    return lists\n    **Function Description: ** Write a function to find perfect squares between two given numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "All elements in the returned list must be within the inclusive range [a, b].",
                "assert_statement": "assert all(a <= x <= b for x in result)"
            },
            {
                "description": "Every element in the list must be a perfect square of a positive integer (since the implementation starts checking roots from j=1).",
                "assert_statement": "assert all(x > 0 and int(x**0.5) ** 2 == x for x in result)"
            },
            {
                "description": "The returned list contains exactly all positive perfect squares $k^2$ such that $a \\le k^2 \\le b$, ensuring completeness and correctness.",
                "assert_statement": "assert set(result) == {k*k for k in range(1, int((b**0.5)) + 1) if k*k >= a}"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 593,
        "Function_ID": 297,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert polar coordinates to rectangular coordinates.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The x-coordinate is calculated correctly using r * cos(theta).",
                "assert_statement": "x == r * Math.cos(theta)"
            },
            {
                "description": "The y-coordinate is calculated correctly using r * sin(theta).",
                "assert_statement": "y == r * Math.sin(theta)"
            },
            {
                "description": "The result is a pair or structure containing both x and y coordinates.",
                "assert_statement": "typeof result === 'object' && 'x' in result && 'y' in result"
            },
            {
                "description": "If r is non-negative, x and y are finite numbers.",
                "assert_statement": "Number.isFinite(x) && Number.isFinite(y)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 594,
        "Function_ID": 297,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import cmath\ndef polar_rect(x,y):\n cn = complex(x,y)\n cn=cmath.polar(cn)\n cn1 = cmath.rect(2, cmath.pi)\n return (cn,cn1)\n    **Function Description: ** Write a function to convert polar coordinates to rectangular coordinates.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The first element of the return value is the polar representation (magnitude, phase) of the input complex number x + yi.",
                "assert_statement": "assert all(abs(result[0][i] - expected[i]) < 1e-9 for i, expected in enumerate(cmath.polar(complex(x, y))))"
            },
            {
                "description": "The second element of the return value is the fixed complex number calculated by cmath.rect(2, cmath.pi), which is approximately -2.0 + 0j.",
                "assert_statement": "assert abs(result[1] - complex(-2.0, 0.0)) < 1e-9"
            },
            {
                "description": "The magnitude component of the polar coordinate result (result[0][0]) must be non-negative.",
                "assert_statement": "assert result[0][0] >= 0.0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 595,
        "Function_ID": 298,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to interchange the first and last elements in a list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the list must remain unchanged.",
                "assert_statement": "len(result) == len(original_list)"
            },
            {
                "description": "If the list has two or more elements, the new first element must be equal to the original last element.",
                "assert_statement": "len(result) < 2 or result[0] == original_list[-1]"
            },
            {
                "description": "If the list has two or more elements, the new last element must be equal to the original first element.",
                "assert_statement": "len(result) < 2 or result[-1] == original_list[0]"
            },
            {
                "description": "All intermediate elements (excluding the first and the last) must remain in their original positions and values.",
                "assert_statement": "len(result) <= 2 or result[1:-1] == original_list[1:-1]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 596,
        "Function_ID": 298,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def swap_List(newList): \n    size = len(newList) \n    temp = newList[0] \n    newList[0] = newList[size - 1] \n    newList[size - 1] = temp  \n    return newList \n    **Function Description: ** Write a python function to interchange the first and last elements in a list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The first element of the returned list must be equal to the original last element, and the last element of the returned list must be equal to the original first element.",
                "assert_statement": "assert result[0] == original_list[-1] and result[-1] == original_list[0]"
            },
            {
                "description": "The length of the returned list must be identical to the length of the input list.",
                "assert_statement": "assert len(result) == len(original_list)"
            },
            {
                "description": "The function modifies the list in place and returns a reference to the modified list object.",
                "assert_statement": "assert result is L"
            },
            {
                "description": "If the input list is empty (size 0), the function raises an IndexError when attempting to access the first element (newList[0]).",
                "assert_statement": "pytest.raises(IndexError, swap_List, [])"
            },
            {
                "description": "If the input list has more than two elements, all intermediate elements between the swapped first and last elements remain unchanged.",
                "assert_statement": "assert len(L) <= 2 or result[1:-1] == original_list[1:-1]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 597,
        "Function_ID": 299,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the sum of the product of consecutive binomial co-efficients.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The returned value must be non-negative, as it represents a sum of products of counts.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The result must satisfy the combinatorial identity: $\\sum_{r=0}^{n-1} \\binom{n}{r}\\binom{n}{r+1} = \\binom{2n}{n+1}$. (Requires 'math.comb' for comparison).",
                "assert_statement": "import math; result == math.comb(2 * n, n + 1)"
            },
            {
                "description": "For any n > 0, the result must be less than the total number of subsets of size n from a set of 2n elements, $\\binom{2n}{n}$, as $\\binom{2n}{n+1} < \\binom{2n}{n}$.",
                "assert_statement": "import math; result <= math.comb(2 * n, n)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 598,
        "Function_ID": 299,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def binomial_Coeff(n,k): \n    C = [0] * (k + 1); \n    C[0] = 1; # nC0 is 1 \n    for i in range(1,n + 1):  \n        for j in range(min(i, k),0,-1): \n            C[j] = C[j] + C[j - 1]; \n    return C[k]; \ndef sum_Of_product(n): \n    return binomial_Coeff(2 * n,n - 1); \n    **Function Description: ** Write a python function to find the sum of the product of consecutive binomial co-efficients.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer, as binomial coefficients are defined as positive integers or zero.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input n is 3, the result must be 15, corresponding to C(2*3, 3-1) = C(6, 2).",
                "assert_statement": "assert sum_Of_product(3) == 15"
            },
            {
                "description": "If the input n is 4, the result must be 56, corresponding to C(2*4, 4-1) = C(8, 3).",
                "assert_statement": "assert sum_Of_product(4) == 56"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 599,
        "Function_ID": 300,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to remove leading zeroes from an ip address.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting IP address must consist of exactly four octets separated by periods.",
                "assert_statement": "len(result_ip.split('.')) == 4"
            },
            {
                "description": "No octet in the resulting IP address should contain a leading zero, unless the octet itself is the single digit '0'.",
                "assert_statement": "all(not octet.startswith('0') or octet == '0' for octet in result_ip.split('.'))"
            },
            {
                "description": "The numerical value of the resulting IP address must be equivalent to the numerical value of the original input IP address.",
                "assert_statement": "all(int(result_octet) == int(original_octet) for result_octet, original_octet in zip(result_ip.split('.'), original_ip.split('.')))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 600,
        "Function_ID": 300,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef removezero_ip(ip):\n string = re.sub('\\.[0]*', '.', ip)\n return string\n\n    **Function Description: ** Write a function to remove leading zeroes from an ip address.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The function correctly processes an IP string with leading zeros, demonstrating the specific transformation rule applied by the regex.",
                "assert_statement": "assert removezero_ip('192.010.005.100') == '192.10.5.100'"
            },
            {
                "description": "The transformation ensures that the specific pattern targeted for removal (a dot followed by one or more zeros) is no longer present in the resulting string.",
                "assert_statement": "import re; assert re.search(r'\\.[0]+', result) is None"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 601,
        "Function_ID": 301,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the difference of the first even and first odd number of a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must equal the difference of the first even number found and the first odd number found, provided both exist.",
                "assert_statement": "result == first_even_val - first_odd_val and first_even_val is not None and first_odd_val is not None"
            },
            {
                "description": "If the list contains no even numbers, the result must signal a failure state (e.g., None).",
                "assert_statement": "result is None and first_even_val is None"
            },
            {
                "description": "If the list contains no odd numbers, the result must signal a failure state (e.g., None).",
                "assert_statement": "result is None and first_odd_val is None"
            },
            {
                "description": "If the input list is empty, the result must signal a failure state (e.g., None).",
                "assert_statement": "result is None and len(L) == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 602,
        "Function_ID": 301,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def diff_even_odd(list1):\n    first_even = next((el for el in list1 if el%2==0),-1)\n    first_odd = next((el for el in list1 if el%2!=0),-1)\n    return (first_even-first_odd)\n    **Function Description: ** Write a function to find the difference of the first even and first odd number of a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The result is equal to the difference between the first even number found and the first odd number found; using -1 as a placeholder if either parity is missing.",
                "assert_statement": "expected_first_even = next((el for el in list1 if el % 2 == 0), -1); expected_first_odd = next((el for el in list1 if el % 2 != 0), -1); assert result == expected_first_even - expected_first_odd"
            },
            {
                "description": "If neither an even nor an odd number is found in the list (triggering both default values of -1), the function must return 0.",
                "assert_statement": "if next((el for el in list1 if el % 2 == 0), -1) == -1 and next((el for el in list1 if el % 2 != 0), -1) == -1: assert result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 603,
        "Function_ID": 302,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count minimum number of swaps required to convert one binary number represented as a string to another.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must be an integer representing a non-negative number of swaps, or -1 if the conversion is impossible.",
                "assert_statement": "assert isinstance(result, int) and result >= -1"
            },
            {
                "description": "If the lengths of the strings are unequal, or if the character counts ('0's vs '1's) are unequal, conversion is impossible, and the result must be -1.",
                "assert_statement": "if len(s1) != len(s2) or s1.count('0') != s2.count('0'): assert result == -1"
            },
            {
                "description": "If conversion is possible (equal length and equal character counts), the minimum number of swaps required is equal to the count of positions where s1 has '0' and s2 has '1' (or vice versa).",
                "assert_statement": "if result != -1: assert result == sum(1 for i in range(len(s1)) if s1[i] == '0' and s2[i] == '1')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 604,
        "Function_ID": 302,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") \n    **Function Description: ** Write a python function to count minimum number of swaps required to convert one binary number represented as a string to another.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the total count of differing characters (mismatches) is even, the function returns an integer equal to half the mismatch count, representing the minimum required swaps.",
                "assert_statement": "assert min_Swaps(\"1100\", \"0011\") == 2"
            },
            {
                "description": "If the total count of differing characters (mismatches) is odd, the function returns the string 'Not Possible'.",
                "assert_statement": "assert min_Swaps(\"100\", \"000\") == \"Not Possible\""
            },
            {
                "description": "If the two strings are identical, the number of required swaps is zero.",
                "assert_statement": "assert min_Swaps(\"0101\", \"0101\") == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 605,
        "Function_ID": 303,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the size in bytes of the given tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer, representing the size in bytes.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The size in bytes must be a positive value, as all objects (including an empty tuple) consume a base amount of memory.",
                "assert_statement": "result > 0"
            },
            {
                "description": "The returned value must exactly match the system's reported size for the input tuple.",
                "assert_statement": "result == sys.getsizeof(input_tuple)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 606,
        "Function_ID": 303,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import sys \ndef tuple_size(tuple_list):\n  return (sys.getsizeof(tuple_list)) \n    **Function Description: ** Write a function to find the size in bytes of the given tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer, representing the size of the input object in bytes.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The size returned must be non-negative (zero or positive).",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The return value must exactly match the memory size reported by the built-in sys.getsizeof for the input tuple.",
                "assert_statement": "import sys; assert result == sys.getsizeof(tuple_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 607,
        "Function_ID": 304,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find kth element from the given two sorted arrays.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result (R) must equal the element at the k-th position (1-indexed) when both input arrays are combined and sorted.",
                "assert_statement": "merged_sorted = sorted(A + B); assert R == merged_sorted[k - 1]"
            },
            {
                "description": "The number of elements in the combined array that are strictly less than R must be less than k.",
                "assert_statement": "merged = A + B; assert len([x for x in merged if x < R]) < k"
            },
            {
                "description": "The number of elements in the combined array that are less than or equal to R must be at least k.",
                "assert_statement": "merged = A + B; assert len([x for x in merged if x <= R]) >= k"
            },
            {
                "description": "The resulting element R must exist within the original input arrays.",
                "assert_statement": "assert R in A or R in B"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 608,
        "Function_ID": 304,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_kth(arr1, arr2, k):\n\tm = len(arr1)\n\tn = len(arr2)\n\tsorted1 = [0] * (m + n)\n\ti = 0\n\tj = 0\n\td = 0\n\twhile (i < m and j < n):\n\t\tif (arr1[i] < arr2[j]):\n\t\t\tsorted1[d] = arr1[i]\n\t\t\ti += 1\n\t\telse:\n\t\t\tsorted1[d] = arr2[j]\n\t\t\tj += 1\n\t\td += 1\n\twhile (i < m):\n\t\tsorted1[d] = arr1[i]\n\t\td += 1\n\t\ti += 1\n\twhile (j < n):\n\t\tsorted1[d] = arr2[j]\n\t\td += 1\n\t\tj += 1\n\treturn sorted1[k - 1]\n    **Function Description: ** Write a function to find kth element from the given two sorted arrays.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be the k-th smallest element of the combined set of elements from arr1 and arr2.",
                "assert_statement": "assert result == sorted(arr1 + arr2)[k - 1]"
            },
            {
                "description": "The returned element must be present in the combined list of elements from arr1 and arr2.",
                "assert_statement": "assert result in (arr1 + arr2)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 609,
        "Function_ID": 305,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether the given number is armstrong or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned boolean value must accurately reflect the mathematical Armstrong property: the number equals the sum of its digits, each raised to the power of the total digit count.",
                "assert_statement": "result == (number == sum(int(digit)**len(str(number)) for digit in str(number)))"
            },
            {
                "description": "The final result returned by the function must be a boolean type.",
                "assert_statement": "isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 610,
        "Function_ID": 305,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def armstrong_number(number):\n sum = 0\n times = 0\n temp = number\n while temp > 0:\n           times = times + 1\n           temp = temp // 10\n temp = number\n while temp > 0:\n           reminder = temp % 10\n           sum = sum + (reminder ** times)\n           temp //= 10\n if number == sum:\n           return True\n else:\n           return False\n    **Function Description: ** Write a function to check whether the given number is armstrong or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must always return a boolean value (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the input is a known Armstrong number (e.g., 153), the function must return True.",
                "assert_statement": "assert armstrong_number(153) is True"
            },
            {
                "description": "If the input is a number that is not an Armstrong number (e.g., 10), the function must return False.",
                "assert_statement": "assert armstrong_number(10) is False"
            },
            {
                "description": "The function correctly identifies the 4-digit Armstrong number 9474.",
                "assert_statement": "assert armstrong_number(9474) is True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 611,
        "Function_ID": 306,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find sum and average of first n natural numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated sum must equal the mathematical formula for the sum of the first N natural numbers.",
                "assert_statement": "assert sum_result == (n * (n + 1)) / 2"
            },
            {
                "description": "The calculated average must equal the calculated sum divided by N (assuming n > 0).",
                "assert_statement": "assert avg_result == sum_result / n"
            },
            {
                "description": "The calculated average must satisfy the simplified mathematical formula for the average of the first N natural numbers (assuming n > 0).",
                "assert_statement": "assert avg_result == (n + 1) / 2"
            },
            {
                "description": "For any positive integer N, both the sum and the average must be positive.",
                "assert_statement": "assert sum_result > 0 and avg_result > 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 612,
        "Function_ID": 306,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sum_average(number):\n total = 0\n for value in range(1, number + 1):\n    total = total + value\n average = total / number\n return (total,average)\n    **Function Description: ** Write a function to find sum and average of first n natural numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple containing exactly two elements: the total sum and the calculated average.",
                "assert_statement": "assert isinstance(result, tuple) and len(result) == 2"
            },
            {
                "description": "The first element of the tuple (the sum) must be an integer equal to the mathematical sum of the first 'number' natural numbers, calculated as n*(n+1)/2.",
                "assert_statement": "assert isinstance(result[0], int) and result[0] == (number * (number + 1)) // 2"
            },
            {
                "description": "The second element of the tuple (the average) must be correctly derived by dividing the sum (result[0]) by the input 'number'.",
                "assert_statement": "assert result[1] == result[0] / number"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 613,
        "Function_ID": 307,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether the given number is even or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be True if the input number 'n' is divisible by 2 (even), and False otherwise.",
                "assert_statement": "assert result == (n % 2 == 0)"
            },
            {
                "description": "The returned value must always be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 614,
        "Function_ID": 307,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_Even(n) : \n    if (n^1 == n+1) :\n        return True; \n    else :\n        return False; \n    **Function Description: ** Write a python function to check whether the given number is even or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must always return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The return value must be True if and only if the input number 'n' is mathematically even (divisible by 2).",
                "assert_statement": "assert result == (n % 2 == 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 615,
        "Function_ID": 308,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the first repeated character in a given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the result is None, the input string must not contain any repeated characters (excluding the possibility of an empty string input).",
                "assert_statement": "if result is None and len(s) > 0: assert len(s) == len(set(s))"
            },
            {
                "description": "If a repeated character is found, the result must be a non-empty string containing exactly one character.",
                "assert_statement": "if result is not None: assert isinstance(result, str) and len(result) == 1"
            },
            {
                "description": "If a character is returned, it must appear at least twice in the input string.",
                "assert_statement": "if result is not None: assert s.count(result) > 1"
            },
            {
                "description": "If a character is returned, it must be the character whose second occurrence appears earliest in the string compared to any other repeating character.",
                "assert_statement": "if result is not None: second_occurrence_index = s.find(result, s.find(result) + 1); assert all(s.find(c, s.find(c) + 1) >= second_occurrence_index for c in set(s) if s.count(c) > 1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 616,
        "Function_ID": 308,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def first_repeated_char(str1):\n  for index,c in enumerate(str1):\n    if str1[:index+1].count(c) > 1:\n      return c\n    **Function Description: ** Write a python function to find the first repeated character in a given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns a character, it must be a single-character string whose second occurrence appears at the earliest index compared to the second occurrence of any other repeated character in the string.",
                "assert_statement": "if result is not None: assert isinstance(result, str) and len(result) == 1 and result in str1; i2_result = str1.find(result, str1.find(result) + 1); for c in set(str1): if str1.count(c) >= 2: i2_c = str1.find(c, str1.find(c) + 1); assert i2_result <= i2_c"
            },
            {
                "description": "If the input string contains only unique characters (no repeats), the function must return None.",
                "assert_statement": "if len(str1) == len(set(str1)): assert result is None"
            },
            {
                "description": "If the input string contains at least one repeated character, the function must return a non-None value.",
                "assert_statement": "if len(str1) > len(set(str1)): assert result is not None"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 617,
        "Function_ID": 309,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to get all lucid numbers smaller than or equal to a given integer.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is a list containing only unique positive integers.",
                "assert_statement": "isinstance(result, list) and all(isinstance(x, int) and x > 0 for x in result) and len(result) == len(set(result))"
            },
            {
                "description": "All numbers returned are less than or equal to the maximum input value N.",
                "assert_statement": "all(x <= N for x in result)"
            },
            {
                "description": "The resulting list is sorted in ascending order.",
                "assert_statement": "result == sorted(result)"
            },
            {
                "description": "Every number in the resulting list must satisfy the definition of a lucid number (requires an external helper function 'is_lucid').",
                "assert_statement": "all(is_lucid(x) for x in result)"
            },
            {
                "description": "The result list is complete, containing every lucid number between 1 and N (requires an external helper function 'is_lucid').",
                "assert_statement": "len(result) == sum(1 for i in range(1, N + 1) if is_lucid(i))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 618,
        "Function_ID": 309,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def get_ludic(n):\n\tludics = []\n\tfor i in range(1, n + 1):\n\t\tludics.append(i)\n\tindex = 1\n\twhile(index != len(ludics)):\n\t\tfirst_ludic = ludics[index]\n\t\tremove_index = index + first_ludic\n\t\twhile(remove_index < len(ludics)):\n\t\t\tludics.remove(ludics[remove_index])\n\t\t\tremove_index = remove_index + first_ludic - 1\n\t\tindex += 1\n\treturn ludics\n    **Function Description: ** Write a function to get all lucid numbers smaller than or equal to a given integer.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "Every element in the resulting list must be an integer between 1 and the input n, inclusive.",
                "assert_statement": "assert all(isinstance(x, int) and 1 <= x <= n for x in result)"
            },
            {
                "description": "The returned list must be sorted in strictly ascending order and contain no duplicates.",
                "assert_statement": "assert len(result) == 0 or all(result[i] < result[i+1] for i in range(len(result) - 1))"
            },
            {
                "description": "If the input n is 25, the returned list must match the canonical set of ludic numbers up to 25.",
                "assert_statement": "if n == 25: assert result == [1, 2, 3, 5, 7, 11, 13, 17, 25]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 619,
        "Function_ID": 310,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to reverse words seperated by spaces in a given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The sequence of words in the resulting string must be the exact reverse of the sequence of words found in the input string (assuming standard space splitting).",
                "assert_statement": "input_string.split()[::-1] == result.split()"
            },
            {
                "description": "The total count of words in the output must be equal to the total count of non-empty words found in the input.",
                "assert_statement": "len(input_string.split()) == len(result.split())"
            },
            {
                "description": "The function must return a string.",
                "assert_statement": "isinstance(result, str)"
            },
            {
                "description": "If multiple spaces are normalized during the process, the output string should not contain leading or trailing spaces.",
                "assert_statement": "result == result.strip()"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 620,
        "Function_ID": 310,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def reverse_words(s):\n        return ' '.join(reversed(s.split()))\n    **Function Description: ** Write a function to reverse words seperated by spaces in a given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The list of words in the output string must be the exact reverse of the list of words in the input string.",
                "assert_statement": "assert result.split() == list(reversed(s.split()))"
            },
            {
                "description": "The number of words in the returned string must be equal to the number of words in the input string.",
                "assert_statement": "assert len(result.split()) == len(s.split())"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 621,
        "Function_ID": 311,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check if the given integer is a prime number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a boolean type.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the input integer n is less than or equal to 1, the result must be False.",
                "assert_statement": "assert result == False if n <= 1 else True"
            },
            {
                "description": "If the integer is a known prime number (e.g., 17), the result must be True.",
                "assert_statement": "assert result == True if n == 17 else True"
            },
            {
                "description": "If the integer is a known composite number (e.g., 15), the result must be False.",
                "assert_statement": "assert result == False if n == 15 else True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 622,
        "Function_ID": 311,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def prime_num(num):\n  if num >=1:\n   for i in range(2, num//2):\n     if (num % i) == 0:\n                return False\n     else:\n                return True\n  else:\n          return False\n    **Function Description: ** Write a function to check if the given integer is a prime number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input number is less than 1 (including 0 or negatives), the return value is False.",
                "assert_statement": "assert prime_num(-1) is False and prime_num(0) is False"
            },
            {
                "description": "If the input number is between 1 and 5 inclusive, the function returns None because the iteration range (2, num//2) is empty and there is no return statement outside the loop block.",
                "assert_statement": "assert prime_num(5) is None and prime_num(2) is None"
            },
            {
                "description": "If the input is an even number greater than or equal to 6, the return value is False because the first iteration (i=2) finds a divisor.",
                "assert_statement": "assert prime_num(6) is False and prime_num(12) is False"
            },
            {
                "description": "If the input is an odd number greater than or equal to 7, the function returns True immediately after checking i=2 and finding no remainder, due to faulty placement of the return statement inside the loop's else block.",
                "assert_statement": "assert prime_num(9) is True and prime_num(15) is True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 623,
        "Function_ID": 312,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert degrees to radians.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The output (radians) must be zero if the input is zero degrees.",
                "assert_statement": "assert output_rad == 0.0"
            },
            {
                "description": "The output must adhere to the fundamental conversion formula, accounting for potential floating-point errors (assuming math.pi is available and input_deg is the argument passed).",
                "assert_statement": "assert math.isclose(output_rad, input_deg * (math.pi / 180))"
            },
            {
                "description": "If the input is 180 degrees, the output must be mathematically equivalent to pi.",
                "assert_statement": "assert math.isclose(output_rad, math.pi)"
            },
            {
                "description": "The data type of the output must be a float, even for integer inputs (unless the input is zero).",
                "assert_statement": "assert isinstance(output_rad, float)"
            },
            {
                "description": "If the input is 90 degrees, the output must be mathematically equivalent to pi/2.",
                "assert_statement": "assert math.isclose(output_rad, math.pi / 2)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 624,
        "Function_ID": 312,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math\ndef radian_degree(degree):\n radian = degree*(math.pi/180)\n return radian\n    **Function Description: ** Write a function to convert degrees to radians.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a floating-point number.",
                "assert_statement": "assert isinstance(radian_degree(10), float)"
            },
            {
                "description": "The conversion of 180 degrees must result in math.pi radians (allowing for floating-point tolerance).",
                "assert_statement": "import math; assert abs(radian_degree(180) - math.pi) < 1e-9"
            },
            {
                "description": "The conversion of 0 degrees must result in 0.0 radians.",
                "assert_statement": "assert radian_degree(0) == 0.0"
            },
            {
                "description": "The conversion of 90 degrees must result in math.pi / 2 radians (allowing for floating-point tolerance).",
                "assert_statement": "import math; assert abs(radian_degree(90) - (math.pi / 2)) < 1e-9"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 625,
        "Function_ID": 313,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If a match is found (match is non-empty), the start index must be non-negative.",
                "assert_statement": "match == '' or start_index >= 0"
            },
            {
                "description": "If a match is found, the end index must not exceed the length of the original string.",
                "assert_statement": "match == '' or end_index <= len(text)"
            },
            {
                "description": "If a match is found, the end index must be greater than or equal to the start index.",
                "assert_statement": "match == '' or end_index >= start_index"
            },
            {
                "description": "If a match is found, the returned substring must exactly correspond to the slice of the original text defined by the indices.",
                "assert_statement": "match == '' or match == text[start_index:end_index]"
            },
            {
                "description": "If a match is found, the length of the returned match must equal the difference between the end and start indices.",
                "assert_statement": "match == '' or len(match) == end_index - start_index"
            },
            {
                "description": "If no match is found (match is empty), the start index must be a negative sentinel value (e.g., -1).",
                "assert_statement": "match != '' or start_index == -1"
            },
            {
                "description": "If no match is found (match is empty), the end index must be a negative sentinel value (e.g., -1).",
                "assert_statement": "match != '' or end_index == -1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 626,
        "Function_ID": 313,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\n\ndef find_literals(text, pattern):\n  match = re.search(pattern, text)\n  s = match.start()\n  e = match.end()\n  return (match.re.pattern, s, e)\n    **Function Description: ** Write a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a tuple of length three, containing a string (the pattern) and two integers (start and end indices).",
                "assert_statement": "assert isinstance(result, tuple) and len(result) == 3 and isinstance(result[0], str) and isinstance(result[1], int) and isinstance(result[2], int)"
            },
            {
                "description": "The first element of the returned tuple is identical to the input search pattern.",
                "assert_statement": "assert result[0] == pattern"
            },
            {
                "description": "The returned indices (start and end) accurately delimit the first occurrence of the pattern found in the input text.",
                "assert_statement": "match = re.search(pattern, text); assert result[1] == match.start() and result[2] == match.end()"
            },
            {
                "description": "If the pattern does not match the text, the function raises an AttributeError because it attempts to call start() and end() on the None object returned by re.search.",
                "assert_statement": "import pytest; if re.search(pattern, text) is None: pytest.raises(AttributeError, find_literals, text, pattern)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 627,
        "Function_ID": 314,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find nth bell number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The result is a non-negative integer.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The 0-th Bell number is 1.",
                "assert_statement": "if n == 0: assert result == 1"
            },
            {
                "description": "The 1-st Bell number is 1.",
                "assert_statement": "if n == 1: assert result == 1"
            },
            {
                "description": "The 2-nd Bell number is 2.",
                "assert_statement": "if n == 2: assert result == 2"
            },
            {
                "description": "The 3-rd Bell number is 5.",
                "assert_statement": "if n == 3: assert result == 5"
            },
            {
                "description": "The 4-th Bell number is 15.",
                "assert_statement": "if n == 4: assert result == 15"
            },
            {
                "description": "The 5-th Bell number is 52.",
                "assert_statement": "if n == 5: assert result == 52"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 628,
        "Function_ID": 314,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def bell_Number(n): \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1] \n    return bell[n][0] \n    **Function Description: ** Write a python function to find nth bell number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer, as Bell numbers are counting numbers.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The calculated Bell number must be non-negative.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The function must return the mathematically correct Nth Bell number (e.g., B_4 = 15).",
                "assert_statement": "assert bell_Number(4) == 15"
            },
            {
                "description": "The function must correctly handle the base case N=0, returning 1.",
                "assert_statement": "assert bell_Number(0) == 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 629,
        "Function_ID": 315,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function which takes a list and returns a list with the same elements, but the k'th element removed.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting list (R) must be exactly one element shorter than the input list (L).",
                "assert_statement": "len(R) == len(L) - 1"
            },
            {
                "description": "The elements in the resulting list before index k must be identical to the corresponding elements in the input list.",
                "assert_statement": "R[:k] == L[:k]"
            },
            {
                "description": "The elements in the resulting list starting from index k must match the elements of the input list starting from index k+1 (i.e., the elements after the removed item).",
                "assert_statement": "R[k:] == L[k+1:]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 630,
        "Function_ID": 315,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def remove_kth_element(list1, L):\n    return  list1[:L-1] + list1[L:]\n    **Function Description: ** Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "If the index L is valid (1 <= L <= len(list1)), the length of the returned list must be exactly one less than the length of the input list.",
                "assert_statement": "assert len(result) == len(list1) - 1"
            },
            {
                "description": "The returned list must contain all elements of the input list in their original order, excluding the element that was located at the 0-based index L-1.",
                "assert_statement": "assert result == list1[:L-1] + list1[L:]"
            },
            {
                "description": "The function must not modify the original input list object `list1` (it must be non-mutating).",
                "assert_statement": "list1_snapshot = list(list1); remove_kth_element(list1_snapshot, L); assert list1_snapshot == list1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 631,
        "Function_ID": 316,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function which given a matrix represented as a list of lists returns the max of the n'th column.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must be equal to the true maximum of the values extracted from the specified column (N). This assert implicitly verifies both membership and the dominance property.",
                "assert_statement": "column_values = [row[n] for row in matrix if len(row) > n]; assert column_values and result == max(column_values)"
            },
            {
                "description": "The returned result must be greater than or equal to every element present in the specified column.",
                "assert_statement": "column_values = [row[n] for row in matrix if len(row) > n]; assert all(result >= val for val in column_values)"
            },
            {
                "description": "If the specified column contains values, the returned result must be one of those values (i.e., it must be a member of the column set).",
                "assert_statement": "column_values = [row[n] for row in matrix if len(row) > n]; assert not column_values or result in column_values"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 632,
        "Function_ID": 316,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_of_nth(test_list, N):\n  res = max([sub[N] for sub in test_list])\n  return (res) \n    **Function Description: ** Write a function which given a matrix represented as a list of lists returns the max of the n'th column.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be equal to the maximum element extracted from the Nth column of the input list of lists.",
                "assert_statement": "assert result == max(sub[N] for sub in test_list)"
            },
            {
                "description": "If the input list of lists is empty, a ValueError must be raised by the built-in max function.",
                "assert_statement": "assert pytest.raises(ValueError, max_of_nth, [], 0)"
            },
            {
                "description": "If the index N exceeds the length of any sublist, an IndexError must be raised during column element extraction.",
                "assert_statement": "assert pytest.raises(IndexError, max_of_nth, [[1, 2], [3]], 10)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 633,
        "Function_ID": 317,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a list containing exactly two sublists.",
                "assert_statement": "isinstance(result, list) and len(result) == 2 and all(isinstance(sublist, list) for sublist in result)"
            },
            {
                "description": "The first sublist of the result must contain all the first elements of the input sublists, maintaining order.",
                "assert_statement": "result[0] == [sublist[0] for sublist in input_list]"
            },
            {
                "description": "The second sublist of the result must contain all the second elements of the input sublists, maintaining order.",
                "assert_statement": "result[1] == [sublist[1] for sublist in input_list]"
            },
            {
                "description": "Both output sublists must have a length equal to the length of the original input list.",
                "assert_statement": "len(result[0]) == len(input_list) and len(result[1]) == len(input_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 634,
        "Function_ID": 317,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def merge(lst):  \n    return [list(ele) for ele in list(zip(*lst))] \n    **Function Description: ** Write a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input list is empty, the result must be an empty list. Otherwise, the result must be a list containing exactly two sublists (the transposed columns).",
                "assert_statement": "assert (len(lst) == 0 and len(result) == 0) or (len(lst) > 0 and len(result) == 2)"
            },
            {
                "description": "The first sublist of the result must contain all the first elements of the input sublists, maintaining the original order.",
                "assert_statement": "assert len(lst) == 0 or result[0] == [sublist[0] for sublist in lst]"
            },
            {
                "description": "The second sublist of the result must contain all the second elements of the input sublists, maintaining the original order.",
                "assert_statement": "assert len(lst) == 0 or result[1] == [sublist[1] for sublist in lst]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 635,
        "Function_ID": 318,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the cumulative sum of all the values that are present in the given tuple list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is a single numeric value (integer or float).",
                "assert_statement": "isinstance(result, (int, float))"
            },
            {
                "description": "The result must equal the cumulative sum of all individual numerical elements across all tuples in the input list.",
                "assert_statement": "result == sum(element for tup in tup_list for element in tup)"
            },
            {
                "description": "If the input list is empty or contains only empty tuples, the cumulative sum must be zero.",
                "assert_statement": "if not any(tup_list) or all(not tup for tup in tup_list): assert result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 636,
        "Function_ID": 318,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def cummulative_sum(test_list):\n  res = sum(map(sum, test_list))\n  return (res)\n    **Function Description: ** Write a function to find the cumulative sum of all the values that are present in the given tuple list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is the cumulative sum of all elements present in the nested iterables of the input list.",
                "assert_statement": "assert result == sum(item for sublist in test_list for item in sublist)"
            },
            {
                "description": "The returned value must be a numeric type (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "If the input list is empty or contains only empty iterables, the result must be 0.",
                "assert_statement": "if not any(test_list) and not test_list: assert result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 637,
        "Function_ID": 319,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function which takes a tuple of tuples and returns the average value for each tuple as a list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the resulting list must match the number of tuples in the input data.",
                "assert_statement": "assert len(result) == len(data)"
            },
            {
                "description": "If the input tuple of tuples is empty, the resulting list must also be empty.",
                "assert_statement": "assert len(result) == 0 if len(data) == 0 else True"
            },
            {
                "description": "Each element in the resulting list must accurately represent the average of the corresponding inner tuple (using a small epsilon for floating point comparison), provided the inner tuple is not empty.",
                "assert_statement": "assert all(abs(result[i] - (sum(data[i]) / len(data[i]))) < 1e-9 for i in range(len(data)) if len(data[i]) > 0)"
            },
            {
                "description": "All elements in the resulting list must be numeric (float or int).",
                "assert_statement": "assert all(isinstance(x, (float, int)) for x in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 638,
        "Function_ID": 319,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def average_tuple(nums):\n    result = [sum(x) / len(x) for x in zip(*nums)]\n    return result\n    **Function Description: ** Write a function which takes a tuple of tuples and returns the average value for each tuple as a list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list is equal to the number of elements in the shortest tuple in the input (since zip truncates), or 0 if the input tuple is empty.",
                "assert_statement": "assert len(result) == (min(len(t) for t in nums) if nums else 0)"
            },
            {
                "description": "Each element in the returned list is the correct arithmetic mean of the corresponding column elements, verified against the transposed input sums.",
                "assert_statement": "import math; expected = [sum(x) / len(x) for x in zip(*nums)]; assert all(math.isclose(result[i], expected[i], rel_tol=1e-9) for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 639,
        "Function_ID": 320,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function which takes two tuples of the same length and performs the element wise modulo.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting tuple must match the length of the input tuples.",
                "assert_statement": "len(result) == len(input_a)"
            },
            {
                "description": "Every element in the resulting tuple must be the modulo of the corresponding elements from the input tuples.",
                "assert_statement": "all(result[i] == input_a[i] % input_b[i] for i in range(len(input_a)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 640,
        "Function_ID": 320,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def tuple_modulo(test_tup1, test_tup2):\n  res = tuple(ele1 % ele2 for ele1, ele2 in zip(test_tup1, test_tup2)) \n  return (res) \n    **Function Description: ** Write a function which takes two tuples of the same length and performs the element wise modulo.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the returned tuple is equal to the length of the shortest input tuple, matching the behavior of element-wise zipping.",
                "assert_statement": "assert len(result) == min(len(test_tup1), len(test_tup2))"
            },
            {
                "description": "Each element in the returned tuple is the result of the modulo operation between the corresponding elements of test_tup1 and test_tup2.",
                "assert_statement": "assert all(result[i] == test_tup1[i] % test_tup2[i] for i in range(len(result)))"
            },
            {
                "description": "If any element in test_tup2 (the divisor) is zero, executing the function raises a ZeroDivisionError.",
                "assert_statement": "import pytest; with pytest.raises(ZeroDivisionError): tuple_modulo((1, 5), (2, 0))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 641,
        "Function_ID": 321,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a non-negative integer representing the minimum number of jumps.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the target distance (d) is an exact multiple of the jump length (L), the minimum number of jumps required is the quotient (d/L).",
                "assert_statement": "d > 0 and d % L == 0 and result == d / L"
            },
            {
                "description": "If the target distance (d) is not an exact multiple of the jump length (L), the minimum number of jumps required is two more than the number of full straight steps (floor(d/L)) since two final jumps are required to cover the remaining fractional distance.",
                "assert_statement": "d > 0 and d % L != 0 and result == (d // L) + 2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 642,
        "Function_ID": 321,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def min_Jumps(steps, d): \n    (a, b) = steps\n    temp = a \n    a = min(a, b) \n    b = max(temp, b) \n    if (d >= b): \n        return (d + b - 1) / b \n    if (d == 0): \n        return 0\n    if (d == a): \n        return 1\n    else:\n        return 2\n    **Function Description: ** Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the target distance d is greater than or equal to the maximum jump length B, the result equals the calculation (d + B - 1) / B, where B is max(steps).",
                "assert_statement": "B = max(steps); if d >= B: assert min_Jumps(steps, d) == (d + B - 1) / B"
            },
            {
                "description": "If the target distance d is exactly 0, the result is 0.",
                "assert_statement": "if d == 0: assert min_Jumps(steps, d) == 0"
            },
            {
                "description": "If the target distance d is equal to the minimum jump length A, and d is positive and less than the maximum jump length B, the result is 1.",
                "assert_statement": "A = min(steps); B = max(steps); if d == A and d > 0 and d < B: assert min_Jumps(steps, d) == 1"
            },
            {
                "description": "If the target distance d is positive, less than the maximum jump length B, and not equal to the minimum jump length A, the result is 2.",
                "assert_statement": "A = min(steps); B = max(steps); if d > 0 and d < B and d != A: assert min_Jumps(steps, d) == 2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 643,
        "Function_ID": 322,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to divide two lists element wise.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result returned by the function must be a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "The length of the resulting list must be equal to the length of the input lists (assuming input lists were of equal length).",
                "assert_statement": "len(result) == len(list1)"
            },
            {
                "description": "Each element in the result list must be the quotient of the corresponding elements from the two input lists.",
                "assert_statement": "all(result[i] == list1[i] / list2[i] for i in range(len(list1)))"
            },
            {
                "description": "All elements in the result list should be numerical (typically floats, as division in Python often promotes integers to floats).",
                "assert_statement": "all(isinstance(x, (float, int)) for x in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 644,
        "Function_ID": 322,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def div_list(nums1,nums2):\n  result = map(lambda x, y: x / y, nums1, nums2)\n  return list(result)\n    **Function Description: ** Write a function to divide two lists element wise.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "The length of the returned list is equal to the length of the shortest input list, as determined by the map function behavior.",
                "assert_statement": "len(result) == min(len(nums1), len(nums2))"
            },
            {
                "description": "Each element in the returned list is the result of the element-wise division (nums1[i] / nums2[i]).",
                "assert_statement": "all(result[i] == (nums1[i] / nums2[i]) for i in range(len(result)))"
            },
            {
                "description": "If any element in nums2 is zero, a ZeroDivisionError must be raised.",
                "assert_statement": "pytest.raises(ZeroDivisionError, div_list, [1, 2], [5, 0])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 645,
        "Function_ID": 323,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to move all the numbers to the end of the given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The relative order of all non-digit characters (letters, symbols, spaces, etc.) in the resulting string must be preserved from the input string.",
                "assert_statement": "filter(lambda c: not c.isdigit(), result) == filter(lambda c: not c.isdigit(), input_str)"
            },
            {
                "description": "The relative order of all digit characters (0-9) in the resulting string must be preserved from the input string.",
                "assert_statement": "filter(lambda c: c.isdigit(), result) == filter(lambda c: c.isdigit(), input_str)"
            },
            {
                "description": "The resulting string must be the concatenation of all non-digit characters (in order) followed immediately by all digit characters (in order).",
                "assert_statement": "result == filter(lambda c: not c.isdigit(), input_str) + filter(lambda c: c.isdigit(), input_str)"
            },
            {
                "description": "The length of the resulting string must be identical to the length of the input string, ensuring no characters were lost or added.",
                "assert_statement": "len(result) == len(input_str)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 646,
        "Function_ID": 323,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def move_num(test_str):\n  res = ''\n  dig = ''\n  for ele in test_str:\n    if ele.isdigit():\n      dig += ele\n    else:\n      res += ele\n  res += dig\n  return (res) \n    **Function Description: ** Write a function to move all the numbers to the end of the given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the returned string must equal the length of the input string.",
                "assert_statement": "assert len(result) == len(test_str)"
            },
            {
                "description": "The returned string must contain the exact same characters, with the same frequency, as the input string (content preservation).",
                "assert_statement": "assert sorted(result) == sorted(test_str)"
            },
            {
                "description": "The returned string must be structurally correct: all non-digit characters form the prefix, and all digit characters form the suffix, maintaining the total count of non-digits and digits.",
                "assert_statement": "assert all(not c.isdigit() for c in result[:sum(1 for char in test_str if not char.isdigit())]) and all(c.isdigit() for c in result[sum(1 for char in test_str if not char.isdigit()):])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 647,
        "Function_ID": 324,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the size of the largest subset of a list of numbers so that every pair is divisible.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result, representing the size of the subset, must be a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The size of the largest divisible subset cannot exceed the total number of elements in the original list (N).",
                "assert_statement": "result <= N"
            },
            {
                "description": "If the original list is not empty (N > 0), the result must be at least 1, as any single element forms a valid divisible subset.",
                "assert_statement": "(N > 0 and result >= 1) or (N == 0 and result == 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 648,
        "Function_ID": 324,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def largest_subset(a):\n\tn = len(a)\n\tdp = [0 for i in range(n)]\n\tdp[n - 1] = 1; \n\tfor i in range(n - 2, -1, -1):\n\t\tmxm = 0;\n\t\tfor j in range(i + 1, n):\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\n\t\t\t\tmxm = max(mxm, dp[j])\n\t\tdp[i] = 1 + mxm\n\treturn max(dp)\n    **Function Description: ** Write a function to find the size of the largest subset of a list of numbers so that every pair is divisible.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer, as it represents a count (size of a subset).",
                "assert_statement": "assert isinstance(__return__, int)"
            },
            {
                "description": "The size of the largest divisible subset must be non-negative and, given the function successfully runs (implying len(a) >= 1), must be at least 1.",
                "assert_statement": "assert __return__ >= 1"
            },
            {
                "description": "The calculated subset size cannot exceed the total number of elements in the input list 'a'.",
                "assert_statement": "assert __return__ <= len(a)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 649,
        "Function_ID": 325,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the median of two sorted lists of same size.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is a numeric value (integer or float).",
                "assert_statement": "isinstance(result, (int, float))"
            },
            {
                "description": "The median must be bounded by the minimum and maximum elements of the combined lists L1 and L2.",
                "assert_statement": "min(min(L1), min(L2)) <= result <= max(max(L1), max(L2))"
            },
            {
                "description": "The result must equal the true median, calculated as the average of the two middle elements (indices N-1 and N) of the merged and sorted array S, where N is the length of the input lists.",
                "assert_statement": "S = sorted(L1 + L2); N = len(L1); assert result == (S[N - 1] + S[N]) / 2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 650,
        "Function_ID": 325,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def get_median(arr1, arr2, n):\n  i = 0\n  j = 0\n  m1 = -1\n  m2 = -1\n  count = 0\n  while count < n + 1:\n    count += 1\n    if i == n:\n      m1 = m2\n      m2 = arr2[0]\n      break\n    elif j == n:\n      m1 = m2\n      m2 = arr1[0]\n      break\n    if arr1[i] <= arr2[j]:\n      m1 = m2\n      m2 = arr1[i]\n      i += 1\n    else:\n      m1 = m2\n      m2 = arr2[j]\n      j += 1\n  return (m1 + m2)/2\n    **Function Description: ** Write a function to find the median of two sorted lists of same size.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a floating-point number.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "The returned value must be equal to the median of the combined sorted arrays (the average of the n-th and (n+1)-th smallest elements).",
                "assert_statement": "expected_median = (sorted(arr1 + arr2)[n - 1] + sorted(arr1 + arr2)[n]) / 2.0; assert result == expected_median"
            },
            {
                "description": "The calculated median must lie between the smallest and largest elements of the combined input lists.",
                "assert_statement": "combined_sorted = sorted(arr1 + arr2); assert combined_sorted[0] <= result <= combined_sorted[-1]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 651,
        "Function_ID": 326,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to compute the n-th power of each number in a list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting list must be equal to the length of the input list.",
                "assert_statement": "len(result_list) == len(input_list)"
            },
            {
                "description": "Each element in the output list must be the result of raising the corresponding element in the input list to the power of n.",
                "assert_statement": "all(result_val == input_val ** n for input_val, result_val in zip(input_list, result_list))"
            },
            {
                "description": "The result list is a list (assuming input_list is a standard list of numerical types).",
                "assert_statement": "isinstance(result_list, list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 652,
        "Function_ID": 326,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def nth_nums(nums,n):\n nth_nums = list(map(lambda x: x ** n, nums))\n return nth_nums\n    **Function Description: ** Write a function to compute the n-th power of each number in a list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be equal to the length of the input list.",
                "assert_statement": "assert len(result) == len(nums)"
            },
            {
                "description": "Each element in the returned list must be the corresponding element of the input list raised to the power of n.",
                "assert_statement": "assert all(result[i] == nums[i] ** n for i in range(len(nums)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 653,
        "Function_ID": 327,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to convert a given string to uppercase.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned string must be the uppercase version of the input string.",
                "assert_statement": "result == s.upper()"
            },
            {
                "description": "The returned value must be of type string.",
                "assert_statement": "isinstance(result, str)"
            },
            {
                "description": "The length of the resulting string must be equal to the length of the input string.",
                "assert_statement": "len(result) == len(s)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 654,
        "Function_ID": 327,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_upper(string):\n  return (string.upper())\n    **Function Description: ** Write a python function to convert a given string to uppercase.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The return value must be equal to the expected uppercase representation of the input string.",
                "assert_statement": "assert result == string.upper()"
            },
            {
                "description": "The length of the returned string must be identical to the length of the input string, as capitalization does not alter length.",
                "assert_statement": "assert len(result) == len(string)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 655,
        "Function_ID": 328,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to interchange the first and last element in a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the list must remain unchanged.",
                "assert_statement": "assert len(result) == len(input_list)"
            },
            {
                "description": "The first element of the resulting list must be equal to the original last element (if the list is not empty).",
                "assert_statement": "if len(input_list) > 0: assert result[0] == input_list[-1]"
            },
            {
                "description": "The last element of the resulting list must be equal to the original first element (if the list is not empty).",
                "assert_statement": "if len(input_list) > 0: assert result[-1] == input_list[0]"
            },
            {
                "description": "All intermediate elements (between the first and last position) must remain in their original position and order.",
                "assert_statement": "if len(input_list) > 2: assert result[1:-1] == input_list[1:-1]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 656,
        "Function_ID": 328,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def swap_List(newList): \n    size = len(newList) \n    temp = newList[0] \n    newList[0] = newList[size - 1] \n    newList[size - 1] = temp   \n    return newList \n    **Function Description: ** Write a python function to interchange the first and last element in a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The element at index 0 of the returned list must be equal to the original last element of the input list.",
                "assert_statement": "assert result[0] == last_original"
            },
            {
                "description": "The element at the last index of the returned list must be equal to the original first element of the input list.",
                "assert_statement": "assert result[-1] == first_original"
            },
            {
                "description": "The length of the returned list must be the same as the length of the input list.",
                "assert_statement": "assert len(result) == original_length"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 657,
        "Function_ID": 329,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned area must be mathematically equal to the square of the input radius (R^2), which is the maximum possible area for a triangle inscribed in a semicircle of radius R.",
                "assert_statement": "area == radius ** 2"
            },
            {
                "description": "The calculated area must be a non-negative numerical value.",
                "assert_statement": "area >= 0 and isinstance(area, (int, float))"
            },
            {
                "description": "If the input radius is positive, the calculated area must also be positive.",
                "assert_statement": "if radius > 0: assert area > 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 658,
        "Function_ID": 329,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def triangle_area(r) :  \n    if r < 0 : \n        return None\n    return r * r \n    **Function Description: ** Write a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input radius r is less than zero, the function handles this invalid geometric input by returning None.",
                "assert_statement": "assert triangle_area(-1) is None"
            },
            {
                "description": "If the input radius r is non-negative, the returned value is equal to r squared (r*r), representing the maximum area.",
                "assert_statement": "assert triangle_area(4) == 16"
            },
            {
                "description": "For a valid radius (r >= 0), the returned area must be a numeric type (float or int) and non-negative.",
                "assert_statement": "area = triangle_area(3.0); assert isinstance(area, (float, int)) and area >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 659,
        "Function_ID": 330,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the smallest missing number from a sorted list of natural numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a positive integer (a natural number).",
                "assert_statement": "isinstance(result, int) and result > 0"
            },
            {
                "description": "The returned value is not present in the original list.",
                "assert_statement": "result not in arr"
            },
            {
                "description": "All natural numbers strictly smaller than the result must be present in the original list, ensuring the returned number is the smallest missing.",
                "assert_statement": "all(i in arr for i in range(1, result))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 660,
        "Function_ID": 330,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_First_Missing(array,start=0,end=None):\n    if end is None:\n      end = len(array) - 1   \n    if (start > end): \n        return end + 1\n    if (start != array[start]): \n        return start; \n    mid = int((start + end) / 2) \n    if (array[mid] == mid): \n        return find_First_Missing(array,mid+1,end) \n    return find_First_Missing(array,start,mid) \n    **Function Description: ** Write a python function to find the smallest missing number from a sorted list of natural numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is an integer, representing a non-negative number.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The returned value, which is the smallest missing number, must not be present in the input array.",
                "assert_statement": "assert result not in array"
            },
            {
                "description": "All non-negative integers strictly smaller than the returned value must be present in the input array.",
                "assert_statement": "assert all(i in array for i in range(result))"
            },
            {
                "description": "The smallest missing number must be between zero and the length of the array (inclusive, covering the case where the sequence is complete).",
                "assert_statement": "assert 0 <= result <= len(array)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 661,
        "Function_ID": 331,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to replace all spaces in the given string with '%20'.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned string is identical to the input string with all spaces replaced by '%20'.",
                "assert_statement": "result == input_string.replace(' ', '%20')"
            },
            {
                "description": "The returned string does not contain any space characters.",
                "assert_statement": "' ' not in result"
            },
            {
                "description": "The length of the returned string reflects the replacement of each space (1 character) with '%20' (3 characters).",
                "assert_statement": "len(result) == len(input_string) + (2 * input_string.count(' '))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 662,
        "Function_ID": 331,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def replace_spaces(string):\n  return string.replace(\" \", \"%20\")\n    **Function Description: ** Write a function to replace all spaces in the given string with '%20'.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be of type string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The resulting string must not contain any single space characters.",
                "assert_statement": "assert \" \" not in result"
            },
            {
                "description": "The count of the replacement subsequence '%20' in the output must exactly equal the count of spaces in the original input string.",
                "assert_statement": "assert result.count(\"%20\") == string.count(\" \")"
            },
            {
                "description": "The length of the resulting string must equal the original input length plus twice the number of spaces (since each space increases length by 2: 1 char replaced by 3 chars).",
                "assert_statement": "assert len(result) == len(string) + (string.count(\" \") * 2)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 663,
        "Function_ID": 332,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find even numbers from a list of numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting list must exactly match the list created by filtering the input to include only even numbers (comprehensive check).",
                "assert_statement": "result == [n for n in input_list if n % 2 == 0]"
            },
            {
                "description": "Every element remaining in the resulting list must be divisible by two (even).",
                "assert_statement": "all(n % 2 == 0 for n in result)"
            },
            {
                "description": "The length of the resulting list must equal the count of even numbers in the original input list.",
                "assert_statement": "len(result) == sum(1 for n in input_list if n % 2 == 0)"
            },
            {
                "description": "The returned object must be a list type.",
                "assert_statement": "isinstance(result, list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 664,
        "Function_ID": 332,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def Split(list): \n    return [num for num in list if num % 2 == 0]\n    **Function Description: ** Write a python function to find even numbers from a list of numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "All elements present in the returned list must be even numbers.",
                "assert_statement": "assert all(num % 2 == 0 for num in result)"
            },
            {
                "description": "The length of the returned list must be less than or equal to the length of the input list.",
                "assert_statement": "assert len(result) <= len(input_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 665,
        "Function_ID": 333,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to extract all the adjacent coordinates of the given coordinate tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return exactly 8 coordinates, representing the cardinal and diagonal neighbors.",
                "assert_statement": "len(result) == 8"
            },
            {
                "description": "The original input coordinate must not be included in the list of adjacent coordinates.",
                "assert_statement": "coord not in result"
            },
            {
                "description": "Every returned coordinate must be exactly one step away (in X, Y, or both dimensions) from the input coordinate.",
                "assert_statement": "all(abs(c[0] - coord[0]) <= 1 and abs(c[1] - coord[1]) <= 1 and c != coord for c in result)"
            },
            {
                "description": "The returned coordinates must be unique (i.e., if returned as a list, converting to a set should not change the count).",
                "assert_statement": "len(set(result)) == len(result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 666,
        "Function_ID": 333,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def adjac(ele, sub = []): \n  if not ele: \n     yield sub \n  else: \n     yield from [idx for j in range(ele[0] - 1, ele[0] + 2) \n                for idx in adjac(ele[1:], sub + [j])] \ndef get_coordinates(test_tup):\n  return list(adjac(test_tup))\n    **Function Description: ** Write a function to extract all the adjacent coordinates of the given coordinate tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a list of lists, where each inner list represents an adjacent coordinate.",
                "assert_statement": "test_tup = (1, 2, 3); result = get_coordinates(test_tup); assert isinstance(result, list) and all(isinstance(coord, list) for coord in result)"
            },
            {
                "description": "The total number of adjacent coordinates generated is 3 raised to the power of the dimensionality (D) of the input coordinate (3^D).",
                "assert_statement": "test_tup = (5, 5, 5); result = get_coordinates(test_tup); assert len(result) == 3 ** len(test_tup)"
            },
            {
                "description": "For every generated coordinate, each component must be within one unit distance (inclusive) of the corresponding component in the input tuple.",
                "assert_statement": "test_tup = (10, -5); result = get_coordinates(test_tup); D = len(test_tup); assert all(len(coord) == D for coord in result) and all(all(abs(c_out - c_in) <= 1 for c_out, c_in in zip(coord, test_tup)) for coord in result)"
            },
            {
                "description": "The input tuple itself must be included in the list of returned adjacent coordinates.",
                "assert_statement": "test_tup = (0, 0); result = get_coordinates(test_tup); assert list(test_tup) in result"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 667,
        "Function_ID": 334,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to replace whitespaces with an underscore and vice versa in a given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting string must be the same as the length of the input string.",
                "assert_statement": "len(result) == len(input_str)"
            },
            {
                "description": "All spaces (' ') present in the input string must be replaced by underscores ('_') in the output string.",
                "assert_statement": "all(result[i] == '_' for i, char in enumerate(input_str) if char == ' ')"
            },
            {
                "description": "All underscores ('_') present in the input string must be replaced by spaces (' ') in the output string.",
                "assert_statement": "all(result[i] == ' ' for i, char in enumerate(input_str) if char == '_')"
            },
            {
                "description": "Any character that is not a space or an underscore must remain unchanged.",
                "assert_statement": "all(result[i] == input_str[i] for i in range(len(input_str)) if input_str[i] not in (' ', '_'))"
            },
            {
                "description": "Applying the replacement function twice (transforming the result back) should yield the original input string (inverse property).",
                "assert_statement": "transform(result) == input_str"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 668,
        "Function_ID": 334,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def replace_spaces(text):\n  return \"\".join(\" \" if c == \"_\" else (\"_\" if c == \" \" else c) for c in text)\n    **Function Description: ** Write a function to replace whitespaces with an underscore and vice versa in a given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The length of the returned string must be identical to the length of the input string.",
                "assert_statement": "assert len(result) == len(text)"
            },
            {
                "description": "Applying the replacement function twice must return the original input string, confirming the inversion of spaces and underscores.",
                "assert_statement": "assert replace_spaces(result) == text"
            },
            {
                "description": "The total number of spaces in the output string must equal the total number of underscores present in the input string.",
                "assert_statement": "assert result.count(' ') == text.count('_')"
            },
            {
                "description": "The total number of underscores in the output string must equal the total number of spaces present in the input string.",
                "assert_statement": "assert result.count('_') == text.count(' ')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 669,
        "Function_ID": 335,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to move all zeroes to the end of the given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The relative order of all non-zero elements is preserved in the resulting list.",
                "assert_statement": "assert [x for x in result if x != 0] == [x for x in original_list if x != 0]"
            },
            {
                "description": "All zero elements are grouped at the very end of the list.",
                "assert_statement": "assert all(x == 0 for x in result[len(original_list) - original_list.count(0):])"
            },
            {
                "description": "The total number of zero elements remains the same after the operation.",
                "assert_statement": "assert result.count(0) == original_list.count(0)"
            },
            {
                "description": "The length of the list remains unchanged.",
                "assert_statement": "assert len(result) == len(original_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 670,
        "Function_ID": 335,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def move_zero(num_list):\n    a = [0 for i in range(num_list.count(0))]\n    x = [i for i in num_list if i != 0]\n    return x + a\n    **Function Description: ** Write a python function to move all zeroes to the end of the given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the returned list must be equal to the length of the input list, ensuring no element is lost or added.",
                "assert_statement": "len(result) == len(num_list)"
            },
            {
                "description": "The returned list contains the same count of zero elements as the input list, and these zero elements occupy the final positions in the list.",
                "assert_statement": "num_zeros = num_list.count(0); assert result.count(0) == num_zeros and all(x == 0 for x in result[len(result) - num_zeros:])"
            },
            {
                "description": "The relative order of all non-zero elements in the returned list is maintained from the input list.",
                "assert_statement": "[x for x in result if x != 0] == [x for x in num_list if x != 0]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 671,
        "Function_ID": 336,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the sum of xor of all pairs of numbers in the given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must equal the sum of the XOR operation (^) calculated for every unique pair of numbers (i, j) where i is not equal to j.",
                "assert_statement": "result == sum(nums[i] ^ nums[j] for i in range(len(nums)) for j in range(i + 1, len(nums)))"
            },
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "If the input list contains fewer than two numbers, the sum of XOR pairs must be zero.",
                "assert_statement": "len(nums) < 2 and result == 0"
            },
            {
                "description": "The result (being a sum of non-negative XOR operations) must be non-negative.",
                "assert_statement": "result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 672,
        "Function_ID": 336,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def pair_xor_Sum(arr,n) : \n    ans = 0 \n    for i in range(0,n) :    \n        for j in range(i + 1,n) :   \n            ans = ans + (arr[i] ^ arr[j])          \n    return ans \n    **Function Description: ** Write a python function to find the sum of xor of all pairs of numbers in the given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return 0 if the input list has fewer than two elements (n=0 or n=1).",
                "assert_statement": "assert pair_xor_Sum([], 0) == 0 and pair_xor_Sum([10], 1) == 0"
            },
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(pair_xor_Sum([1, 5, 10], 3), int)"
            },
            {
                "description": "Verify the core calculation logic against a standard input [1, 2, 3]. 1^2=3, 1^3=2, 2^3=1. Sum = 6.",
                "assert_statement": "assert pair_xor_Sum([1, 2, 3], 3) == 6"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 673,
        "Function_ID": 337,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to sort the given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting list must be sorted in non-decreasing order.",
                "assert_statement": "all(result[i] <= result[i+1] for i in range(len(result) - 1))"
            },
            {
                "description": "The resulting list must be a permutation of the original list, meaning it contains the exact same elements and counts.",
                "assert_statement": "sorted(result) == sorted(original_list)"
            },
            {
                "description": "The length of the list must remain unchanged.",
                "assert_statement": "len(result) == len(original_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 674,
        "Function_ID": 337,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import heapq as hq\ndef heap_sort(iterable):\n    h = []\n    for value in iterable:\n        hq.heappush(h, value)\n    return [hq.heappop(h) for i in range(len(h))]\n    **Function Description: ** Write a function to sort the given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The returned list must be the sorted equivalent of the original input iterable.",
                "assert_statement": "assert result == sorted(_input)"
            },
            {
                "description": "The length of the returned list must equal the length of the original input iterable.",
                "assert_statement": "assert len(result) == len(_input)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 675,
        "Function_ID": 338,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether the given amount has no profit and no loss",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns True if and only if the initial amount is exactly equal to the final amount.",
                "assert_statement": "assert result == (initial_amount == final_amount)"
            },
            {
                "description": "If the final amount is strictly greater than the initial amount (profit), the function must return False.",
                "assert_statement": "assert not result if final_amount > initial_amount else True"
            },
            {
                "description": "If the final amount is strictly less than the initial amount (loss), the function must return False.",
                "assert_statement": "assert not result if final_amount < initial_amount else True"
            },
            {
                "description": "The absolute difference between the final amount and initial amount must be zero for the result to be True.",
                "assert_statement": "assert result == (abs(final_amount - initial_amount) == 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 676,
        "Function_ID": 338,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def noprofit_noloss(actual_cost,sale_amount): \n  if(sale_amount == actual_cost):\n    return True\n  else:\n    return False\n    **Function Description: ** Write a function to check whether the given amount has no profit and no loss",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the sale amount is exactly equal to the actual cost, the function must return True, indicating no profit and no loss.",
                "assert_statement": "assert noprofit_noloss(150.0, 150.0) == True"
            },
            {
                "description": "If the sale amount is greater than the actual cost (profit case), the function must return False.",
                "assert_statement": "assert noprofit_noloss(100, 120) == False"
            },
            {
                "description": "If the sale amount is less than the actual cost (loss case), the function must return False.",
                "assert_statement": "assert noprofit_noloss(200, 199) == False"
            },
            {
                "description": "The function must always return a boolean value.",
                "assert_statement": "assert isinstance(noprofit_noloss(10, 5), bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 677,
        "Function_ID": 339,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must equal the ceiling (rounded up to the next integer) of the standard wind chill index formula derived from Environment Canada/NWS, using temperature (T) in Celsius and wind speed (V) in km/h.",
                "assert_statement": "result == math.ceil(13.12 + 0.6215 * T - 11.37 * (V ** 0.16) + 0.3965 * T * (V ** 0.16))"
            },
            {
                "description": "The calculated wind chill index must be of type integer, confirming the rounding to the next whole number requirement.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "If the temperature T is 10 degrees Celsius or lower (where wind chill is relevant), the wind chill index must be less than or equal to the actual temperature.",
                "assert_statement": "T > 10 or result <= T"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 678,
        "Function_ID": 339,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math\ndef wind_chill(v,t):\n windchill = 13.12 + 0.6215*t -  11.37*math.pow(v, 0.16) + 0.3965*t*math.pow(v, 0.16)\n return int(round(windchill, 0))\n    **Function Description: ** Write a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer, as specified by the function's final conversion step.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned value must be the calculated wind chill index derived from the formula (13.12 + 0.6215*t - 11.37*v^0.16 + 0.3965*t*v^0.16), rounded to the nearest integer.",
                "assert_statement": "import math; expected_w = 13.12 + 0.6215 * t - 11.37 * math.pow(v, 0.16) + 0.3965 * t * math.pow(v, 0.16); assert result == int(round(expected_w, 0))"
            },
            {
                "description": "If the wind velocity (v) is zero, the calculation simplifies to 13.12 + 0.6215*t, rounded to the nearest integer.",
                "assert_statement": "if v == 0: expected = 13.12 + 0.6215 * t; assert result == int(round(expected, 0))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 679,
        "Function_ID": 340,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result returned by the function must be a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The result must equal the sum of the lengths of all names in the input list that do not start with a lowercase letter.",
                "assert_statement": "result == sum(len(name) for name in names if name and not name[0].islower())"
            },
            {
                "description": "If the filtered list contains no names (i.e., the input list was empty or all names started with a lowercase letter), the result must be zero.",
                "assert_statement": "not any(name for name in names if name and not name[0].islower()) and result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 680,
        "Function_ID": 340,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sample_nam(sample_names):\n  sample_names=list(filter(lambda el:el[0].isupper() and el[1:].islower(),sample_names))\n  return len(''.join(sample_names))\n    **Function Description: ** Write a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer, representing the combined length of the filtered names.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The returned length must equal the sum of the lengths of all input strings 'name' such that the first character is uppercase (name[0].isupper()) and the rest of the string is lowercase (name[1:].islower()).",
                "assert_statement": "expected_len = sum(len(name) for name in sample_names if name and name[0].isupper() and name[1:].islower()); assert result == expected_len"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 681,
        "Function_ID": 341,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to remove the parenthesis and what is inbetween them from a string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting string must not contain any opening parentheses.",
                "assert_statement": "assert '(' not in result"
            },
            {
                "description": "The resulting string must not contain any closing parentheses.",
                "assert_statement": "assert ')' not in result"
            },
            {
                "description": "If the input string contains no parentheses, the output string must be identical to the input.",
                "assert_statement": "assert remove_parenthesis('This has no parens') == 'This has no parens'"
            },
            {
                "description": "All content, including the parentheses, from multiple simple blocks is correctly removed.",
                "assert_statement": "assert remove_parenthesis('start(middle)end(last)') == 'startend'"
            },
            {
                "description": "All content, including the parentheses, from nested blocks is correctly removed (assuming removal of the entire outermost structure).",
                "assert_statement": "assert remove_parenthesis('text(inner(stuff)more)here') == 'texthere'"
            },
            {
                "description": "Removal of empty parenthesis blocks results in the concatenation of surrounding text without extra spaces.",
                "assert_statement": "assert remove_parenthesis('prefix()suffix') == 'prefixsuffix'"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 682,
        "Function_ID": 341,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef remove_parenthesis(items):\n for item in items:\n    return (re.sub(r\" ?\\([^)]+\\)\", \"\", item))\n    **Function Description: ** Write a function to remove the parenthesis and what is inbetween them from a string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input iterable `items` is non-empty, the returned value is a string derived from the first element, as the function returns immediately after processing the first item.",
                "assert_statement": "result = remove_parenthesis(['Text (to remove)', 'ignored']); assert isinstance(result, str)"
            },
            {
                "description": "If the input iterable `items` is non-empty, the returned string must not contain any parentheses or the content inside them (including an optional preceding space), verifying the core transformation logic.",
                "assert_statement": "import re; result = remove_parenthesis(['A (B C) D']); assert result == 'A D'"
            },
            {
                "description": "If the input iterable `items` is empty, the function returns None because the loop is never entered.",
                "assert_statement": "assert remove_parenthesis([]) is None"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 683,
        "Function_ID": 342,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the nth nonagonal number.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is the correct n-th nonagonal number, calculated using the formula (7n^2 - 5n) / 2.",
                "assert_statement": "result == (7 * n * n - 5 * n) // 2"
            },
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "For any valid input (n >= 1), the nonagonal number must be positive.",
                "assert_statement": "result > 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 684,
        "Function_ID": 342,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_nonagonal(n): \n\treturn int(n * (7 * n - 5) / 2) \n    **Function Description: ** Write a function to find the nth nonagonal number.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be of type integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned value must satisfy the mathematical definition of the nth nonagonal number: 2 * result = n * (7n - 5).",
                "assert_statement": "assert 2 * result == n * (7 * n - 5)"
            },
            {
                "description": "When calculating the first nonagonal number (n=1), the result must be 1.",
                "assert_statement": "assert is_nonagonal(1) == 1"
            },
            {
                "description": "When calculating the third nonagonal number (n=3), the result must be 24.",
                "assert_statement": "assert is_nonagonal(3) == 24"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 685,
        "Function_ID": 343,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that checks if a strings contains 'z', except at the start and end of the word.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns True if 'z' is present strictly between the first and last characters.",
                "assert_statement": "assert check_z_position(\"aBzCd\") == True"
            },
            {
                "description": "The function returns False if 'z' is only present at the start of the string.",
                "assert_statement": "assert check_z_position(\"Zabcd\") == False"
            },
            {
                "description": "The function returns False if 'z' is only present at the end of the string.",
                "assert_statement": "assert check_z_position(\"abcdZ\") == False"
            },
            {
                "description": "The function returns False if 'z' is present at both start and end, but nowhere internally.",
                "assert_statement": "assert check_z_position(\"ZaBceZ\") == False"
            },
            {
                "description": "The function returns False if 'z' is not present in the string at all.",
                "assert_statement": "assert check_z_position(\"abcde\") == False"
            },
            {
                "description": "The function returns False for strings too short (length < 3) to have an internal 'z', even if 'z' is present.",
                "assert_statement": "assert check_z_position(\"az\") == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 686,
        "Function_ID": 343,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef text_match_wordz_middle(text):\n        return bool(re.search(r'\\Bz\\B',  text))\n    **Function Description: ** Write a function that checks if a strings contains 'z', except at the start and end of the word.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean type.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, the input string must contain at least one instance of 'z' that is surrounded by word characters, confirming it is internal to a word segment.",
                "assert_statement": "if result: assert re.search(r'\\wz\\w', text) is not None"
            },
            {
                "description": "The function must return False for strings where 'z' only appears at word boundaries, such as the start or end of the string/word.",
                "assert_statement": "assert text_match_wordz_middle(\"zebra fuzz\") is False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 687,
        "Function_ID": 344,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to reverse an array upto a given position.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the resulting array must match the length of the input array.",
                "assert_statement": "len(result) == len(arr)"
            },
            {
                "description": "The prefix of the array (from index 0 up to position k) must be the reverse of the corresponding prefix of the original input.",
                "assert_statement": "result[:k] == arr[:k][::-1]"
            },
            {
                "description": "The suffix of the array (from position k onwards) must remain identical to the original input suffix.",
                "assert_statement": "result[k:] == arr[k:]"
            },
            {
                "description": "The type of the returned value must be the same as the input array (assuming list input).",
                "assert_statement": "isinstance(result, list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 688,
        "Function_ID": 344,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def reverse_Array_Upto_K(input, k): \n  return (input[k-1::-1] + input[k:]) \n    **Function Description: ** Write a python function to reverse an array upto a given position.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the returned array must be equal to the length of the original input array.",
                "assert_statement": "assert len(result) == len(input)"
            },
            {
                "description": "The first k elements of the resulting array must be the reversed version of the first k elements of the input array.",
                "assert_statement": "assert result[:k] == input[:k][::-1]"
            },
            {
                "description": "The elements from position k onwards in the resulting array must be identical to the corresponding elements in the input array.",
                "assert_statement": "assert result[k:] == input[k:]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 689,
        "Function_ID": 345,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to add a dictionary to the tuple. The output should be a tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The output (result) must be of type tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting tuple must be exactly one greater than the length of the input tuple.",
                "assert_statement": "assert len(result) == len(input_tuple) + 1"
            },
            {
                "description": "All elements of the original input tuple must be preserved in the resulting tuple, maintaining their order (occupying the sequence except for the last position).",
                "assert_statement": "assert result[:-1] == input_tuple"
            },
            {
                "description": "The dictionary that was added must be the final element of the resulting tuple.",
                "assert_statement": "assert result[-1] is new_dict"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 690,
        "Function_ID": 345,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def add_dict_to_tuple(test_tup, test_dict):\n  test_tup = list(test_tup)\n  test_tup.append(test_dict)\n  test_tup = tuple(test_tup)\n  return (test_tup) \n    **Function Description: ** Write a function to add a dictionary to the tuple. The output should be a tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting tuple must be exactly one greater than the length of the input tuple `test_tup`.",
                "assert_statement": "assert len(result) == len(test_tup) + 1"
            },
            {
                "description": "The last element of the resulting tuple must be the input dictionary `test_dict`.",
                "assert_statement": "assert result[-1] is test_dict"
            },
            {
                "description": "All elements of the resulting tuple, excluding the last element, must be identical to the original input tuple `test_tup`.",
                "assert_statement": "assert result[:-1] == test_tup"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 691,
        "Function_ID": 346,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value (max_average) must equal the highest possible total cost found among all valid paths, divided by the fixed path length (2N - 1).",
                "assert_statement": "N = len(matrix); path_length = 2 * N - 1; max_total_cost = compute_max_cost_dp(matrix); assert max_average == max_total_cost / path_length"
            },
            {
                "description": "The maximum average must be non-negative, assuming matrix costs are real numbers (or costs are non-negative, standard for optimization problems).",
                "assert_statement": "assert max_average >= 0"
            },
            {
                "description": "The returned maximum average must be greater than or equal to the average cost calculated for any specific suboptimal path (e.g., the path moving only right then only down).",
                "assert_statement": "N = len(matrix); path_length = 2 * N - 1; suboptimal_cost = sum(matrix[0][j] for j in range(N)) + sum(matrix[i][N-1] for i in range(1, N)); assert max_average >= suboptimal_cost / path_length"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 692,
        "Function_ID": 346,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def maxAverageOfPath(cost):\n  N = len(cost)\n  dp = [[0 for i in range(N + 1)] for j in range(N + 1)]\n  dp[0][0] = cost[0][0]\n  for i in range(1, N):\n    dp[i][0] = dp[i - 1][0] + cost[i][0]\n  for j in range(1, N):\n    dp[0][j] = dp[0][j - 1] + cost[0][j]\n  for i in range(1, N):\n    for j in range(1, N):\n      dp[i][j] = max(dp[i - 1][j],\n                     dp[i][j - 1]) + cost[i][j]\n  return dp[N - 1][N - 1] / (2 * N - 1)\n    **Function Description: ** Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a floating-point number, reflecting the average cost calculation.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "The calculated maximum average cost must be bounded by the minimum and maximum cost values present in the input matrix, as it is an average of a subset of those values.",
                "assert_statement": "N = len(cost); flat_cost = [c for row in cost for c in row]; assert min(flat_cost) <= result <= max(flat_cost)"
            },
            {
                "description": "If the matrix size N is 1 (a single cell), the path length is 1, and the maximum average must equal the single element cost.",
                "assert_statement": "N = len(cost); if N == 1: assert result == cost[0][0]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 693,
        "Function_ID": 347,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toThe input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight.  filter students that have height and weight above the minimum.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "Every student remaining in the resulting dictionary must satisfy both the minimum height and the minimum weight conditions.",
                "assert_statement": "all(h >= min_height and w >= min_weight for h, w in result.values())"
            },
            {
                "description": "The set of keys (student names) in the resulting dictionary must be exactly the set of keys from the input data that meet the filtering criteria (verifies both inclusion and completeness).",
                "assert_statement": "set(result.keys()) == {name for name, (h, w) in students_data.items() if h >= min_height and w >= min_weight}"
            },
            {
                "description": "The data integrity is maintained: the height and weight tuple for any student in the result must be identical to the original input data.",
                "assert_statement": "all(students_data[name] == result[name] for name in result)"
            },
            {
                "description": "The resulting object must be a dictionary.",
                "assert_statement": "isinstance(result, dict)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 694,
        "Function_ID": 347,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def filter_data(students,h,w):\n    result = {k: s for k, s in students.items() if s[0] >=h and s[1] >=w}\n    return result    \n    **Function Description: ** The input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight above the minimum.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is always a dictionary.",
                "assert_statement": "assert isinstance(result, dict)"
            },
            {
                "description": "Every student included in the result must satisfy the filter criteria: height must be greater than or equal to 'h', and weight must be greater than or equal to 'w'.",
                "assert_statement": "assert all(student_data[0] >= h and student_data[1] >= w for student_data in result.values())"
            },
            {
                "description": "All keys present in the result must originate from the input 'students' dictionary, and the values (height/weight tuples) must be identical to their source values.",
                "assert_statement": "assert all(k in students and result[k] == students[k] for k in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 695,
        "Function_ID": 348,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toThe input is defined as two lists of the same length.  count indices where the lists have the same values.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned count must be a non-negative integer.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned count cannot exceed the length of the input lists.",
                "assert_statement": "result <= len(list1)"
            },
            {
                "description": "The returned value must exactly equal the number of indices where list1[i] equals list2[i].",
                "assert_statement": "result == sum(1 for i in range(len(list1)) if list1[i] == list2[i])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 696,
        "Function_ID": 348,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from operator import eq\ndef count_same_pair(nums1, nums2):\n    result = sum(map(eq, nums1, nums2))\n    return result\n    **Function Description: ** The input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned count must be non-negative and less than or equal to the length of the input lists.",
                "assert_statement": "assert 0 <= result <= len(nums1)"
            },
            {
                "description": "The returned count must equal the actual number of positions where corresponding elements in nums1 and nums2 are equal.",
                "assert_statement": "assert result == sum(1 for a, b in zip(nums1, nums2) if a == b)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 697,
        "Function_ID": 349,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result, which is the sum of digits, must be a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "Verification against a simple known test case (2^3 = 8, sum=8).",
                "assert_statement": "sum_of_digits_of_power(2, 3) == 8"
            },
            {
                "description": "Verification against a known complex test case (2^15 = 32768, sum of digits = 26).",
                "assert_statement": "sum_of_digits_of_power(2, 15) == 26"
            },
            {
                "description": "The result must equal the sum of the digits of the exponential calculation (base**power).",
                "assert_statement": "result == sum(int(digit) for digit in str(base ** power))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 698,
        "Function_ID": 349,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def power_base_sum(base, power):\n    return sum([int(i) for i in str(pow(base, power))])\n    **Function Description: ** Write a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer greater than or equal to zero, as it represents a sum of non-negative digits.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the base is 2 and the power is 10 (2^10 = 1024), the sum of the digits must be 7.",
                "assert_statement": "if base == 2 and power == 10: assert result == 7"
            },
            {
                "description": "The calculated result must be exactly equal to the sum of the digits of (base raised to power), validating the core logic.",
                "assert_statement": "assert result == sum(int(d) for d in str(pow(base, power)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 699,
        "Function_ID": 350,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to extract values between quotation marks \" \" of the given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a list of strings containing the content found between matched pairs of double quotation marks.",
                "assert_statement": "isinstance(result, list) and all(isinstance(item, str) for item in result)"
            },
            {
                "description": "If the input string contains text enclosed in one set of quotes, the result list must contain that single extracted value.",
                "assert_statement": "result == ['extracted content']"
            },
            {
                "description": "If the input string contains multiple sets of quoted text, the result must contain all corresponding extracted values in the order they appeared.",
                "assert_statement": "result == ['first', 'middle', 'last']"
            },
            {
                "description": "If the input string contains no double quotation marks, the function must return an empty list.",
                "assert_statement": "result == []"
            },
            {
                "description": "If two quotation marks are adjacent ('\"\"'), representing empty content, an empty string must be included in the result list.",
                "assert_statement": "result == ['']"
            },
            {
                "description": "The extracted value must preserve whitespace, numbers, and special characters present between the quotes.",
                "assert_statement": "result == ['value 1.23!@#']"
            },
            {
                "description": "If the input string is empty, the function must return an empty list.",
                "assert_statement": "result == []"
            },
            {
                "description": "The function must handle input where quotes appear at the very start and end of the string.",
                "assert_statement": "result == ['entire string content']"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 700,
        "Function_ID": 350,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef extract_quotation(text1):\n  return (re.findall(r'\"(.*?)\"', text1))\n    **Function Description: ** Write a function to extract values between quotation marks \" \" of the given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "If the input contains quoted substrings, the returned list must contain those substrings, excluding the quotation marks themselves.",
                "assert_statement": "assert extract_quotation('This is a \"test\" with \"multiple\" quoted sections.') == ['test', 'multiple']"
            },
            {
                "description": "If the input string contains no text enclosed in double quotes, the function must return an empty list.",
                "assert_statement": "assert extract_quotation('No quoted text here.') == []"
            },
            {
                "description": "The function must correctly handle quoted sections adjacent to each other.",
                "assert_statement": "assert extract_quotation('\"A\"\"B\"') == ['A', 'B']"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 701,
        "Function_ID": 351,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that takes as input a tuple of numbers (t_1,...,t_{N+1}) and returns a tuple of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting tuple must be N, which is one less than the length of the input tuple (N+1).",
                "assert_statement": "len(result) == len(input_tuple) - 1"
            },
            {
                "description": "Each element 'i' in the resulting tuple must be equal to the product of input_tuple[i] and input_tuple[i+1].",
                "assert_statement": "all(result[i] == input_tuple[i] * input_tuple[i+1] for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 702,
        "Function_ID": 351,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def multiply_elements(test_tup):\n  res = tuple(i * j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) \n    **Function Description: ** Write a function that takes as input a tuple of numbers (t_1,...,t_{N+1}) and returns a tuple of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting tuple must be equal to the length of the input tuple minus one (or zero if the input length is less than 2).",
                "assert_statement": "assert len(result) == max(0, len(test_tup) - 1)"
            },
            {
                "description": "Each element in the result tuple is the product of the current element and the next element in the input tuple.",
                "assert_statement": "assert all(result[i] == test_tup[i] * test_tup[i+1] for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 703,
        "Function_ID": 352,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is a list.",
                "assert_statement": "isinstance(result, list)"
            },
            {
                "description": "The length of the resulting list must be equal to the length of the input lists.",
                "assert_statement": "len(result) == len(list_a)"
            },
            {
                "description": "Every element in the resulting list is the sum of the corresponding elements from the input lists.",
                "assert_statement": "all(result[i] == list_a[i] + list_b[i] for i in range(len(list_a)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 704,
        "Function_ID": 352,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sum_list(lst1,lst2):\n  res_list = [lst1[i] + lst2[i] for i in range(len(lst1))] \n  return res_list\n    **Function Description: ** Write a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be equal to the length of the first input list.",
                "assert_statement": "assert len(result) == len(lst1)"
            },
            {
                "description": "Each element in the returned list must equal the sum of the corresponding elements from the input lists.",
                "assert_statement": "assert all(result[i] == lst1[i] + lst2[i] for i in range(len(lst1)))"
            },
            {
                "description": "If the second list is shorter than the first list, an IndexError must be raised.",
                "assert_statement": "if len(lst2) < len(lst1): with pytest.raises(IndexError): sum_list(lst1, lst2)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 705,
        "Function_ID": 353,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to remove consecutive duplicates of a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting list contains no consecutive duplicate elements.",
                "assert_statement": "all(result[i] != result[i+1] for i in range(len(result) - 1))"
            },
            {
                "description": "The length of the resulting list must be less than or equal to the length of the input list.",
                "assert_statement": "len(result) <= len(input_list)"
            },
            {
                "description": "The set of unique elements in the result must match the set of unique elements in the original input (no elements are lost or introduced).",
                "assert_statement": "set(result) == set(input_list)"
            },
            {
                "description": "The first element of the result must match the first element of the input (if the input is not empty), ensuring the process starts correctly.",
                "assert_statement": "if input_list: assert result[0] == input_list[0]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 706,
        "Function_ID": 353,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from itertools import groupby\ndef consecutive_duplicates(nums):\n    return [key for key, group in groupby(nums)] \n    **Function Description: ** Write a function to remove consecutive duplicates of a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be less than or equal to the length of the input list (since elements are only removed, never added).",
                "assert_statement": "assert len(result) <= len(nums)"
            },
            {
                "description": "The returned list contains no consecutive identical elements, fulfilling the core function requirement.",
                "assert_statement": "assert all(result[i] != result[i+1] for i in range(len(result) - 1))"
            },
            {
                "description": "The returned list must match the sequence of elements derived by only keeping the first element of every consecutive block in the input list.",
                "assert_statement": "assert result == [nums[i] for i in range(len(nums)) if i == 0 or nums[i] != nums[i-1]]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 707,
        "Function_ID": 354,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the lateral surface area of a cone given radius r and the height h.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated lateral surface area (result) must be numerically close to the mathematically correct value: pi * r * sqrt(r^2 + h^2).",
                "assert_statement": "math.isclose(result, math.pi * r * math.sqrt(r**2 + h**2))"
            },
            {
                "description": "The calculated lateral surface area must be a non-negative value.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "If the radius (r) and height (h) are both positive, the lateral surface area must be greater than zero.",
                "assert_statement": "if r > 0 and h > 0: assert result > 0"
            },
            {
                "description": "If either the radius (r) or the height (h) is zero, the lateral surface area must be zero.",
                "assert_statement": "if r == 0 or h == 0: assert math.isclose(result, 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 708,
        "Function_ID": 354,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math\ndef lateralsurface_cone(r,h):\n  l = math.sqrt(r * r + h * h)\n  LSA = math.pi * r  * l\n  return LSA\n    **Function Description: ** Write a function to find the lateral surface area of a cone given radius r and the height h.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a floating-point number.",
                "assert_statement": "assert isinstance(result, float)"
            },
            {
                "description": "The calculated lateral surface area must be non-negative.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The returned value correctly implements the geometric formula LSA = pi * r * sqrt(r^2 + h^2), accounting for potential floating point errors.",
                "assert_statement": "assert math.isclose(result, math.pi * r * math.sqrt(r**2 + h**2))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 709,
        "Function_ID": 355,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to replace all occurrences of spaces, commas, or dots with a colon.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the output string must be identical to the length of the input string, as replacement does not change size.",
                "assert_statement": "len(result) == len(input_string)"
            },
            {
                "description": "The output string must not contain any of the original delimiters (spaces, commas, or dots).",
                "assert_statement": "all(c not in ' .,' for c in result)"
            },
            {
                "description": "The count of the replacement character (colon) in the output string must equal the total count of all target delimiters in the input string.",
                "assert_statement": "result.count(':') == sum(input_string.count(d) for d in ' .,')"
            },
            {
                "description": "Any character in the input that was not a space, comma, or dot must remain unchanged in the output.",
                "assert_statement": "all(result[i] == input_string[i] for i in range(len(input_string)) if input_string[i] not in ' .,')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 710,
        "Function_ID": 355,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef replace_specialchar(text):\n return (re.sub(\"[ ,.]\", \":\", text))\n\n    **Function Description: ** Write a function to replace all occurrences of spaces, commas, or dots with a colon.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The length of the returned string must be equal to the length of the input string, as substitution is 1:1.",
                "assert_statement": "assert len(result) == len(text)"
            },
            {
                "description": "The returned string must not contain any spaces, commas, or dots, assuming successful replacement.",
                "assert_statement": "import re; assert not re.search('[ ,.]', result)"
            },
            {
                "description": "The presence of original special characters (space, comma, dot) implies the presence of the replacement character (colon) in the output, and vice versa.",
                "assert_statement": "assert (any(c in text for c in [' ', ',', '.'])) == (':' in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 711,
        "Function_ID": 356,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the index of the first occurrence of a given number in a sorted array.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the result is a valid index (not -1), the element at that index must equal the target.",
                "assert_statement": "result == -1 or arr[result] == target"
            },
            {
                "description": "If the result is a valid index greater than 0, the element immediately preceding it must not equal the target, ensuring it is the first occurrence.",
                "assert_statement": "result <= 0 or arr[result - 1] != target"
            },
            {
                "description": "If the function returns -1 (not found), the target element must not exist anywhere in the array.",
                "assert_statement": "result != -1 or target not in arr"
            },
            {
                "description": "The returned index must be within the valid bounds of the array length, or -1.",
                "assert_statement": "-1 <= result < len(arr)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 712,
        "Function_ID": 356,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_first_occurrence(A, x):\n    (left, right) = (0, len(A) - 1)\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if x == A[mid]:\n            result = mid\n            right = mid - 1\n        elif x < A[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return result\n    **Function Description: ** Write a function to find the index of the first occurrence of a given number in a sorted array.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If a valid index is returned (not -1), the index must be within the array bounds and the element at that index must equal the target x.",
                "assert_statement": "assert result == -1 or (0 <= result < len(A) and A[result] == x)"
            },
            {
                "description": "If the result is non-negative, it must represent the first occurrence, meaning the element immediately preceding it (if one exists) must not equal x.",
                "assert_statement": "if result != -1: assert result == 0 or A[result - 1] != x"
            },
            {
                "description": "If the element x is present anywhere in the array A, the returned index must not be -1.",
                "assert_statement": "assert (x not in A) or (result != -1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 713,
        "Function_ID": 357,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a numeric type (integer or float).",
                "assert_statement": "isinstance(result, (int, float))"
            },
            {
                "description": "If the input list contains only non-negative numbers (e.g., 0 and positive numbers), the sum of products must be non-negative.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The function must return 0 if the input list is empty.",
                "assert_statement": "if len(input_list) == 0: assert result == 0"
            },
            {
                "description": "The result must match the known output for a simple validation case, ensuring the logic holds (e.g., for [1, 2], the sum of products is 5: [1]->1, [2]->2, [1, 2]->2).",
                "assert_statement": "if input_list == [1, 2]: assert result == 5"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 714,
        "Function_ID": 357,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sum_Of_Subarray_Prod(arr):\n    ans = 0\n    res = 0\n    i = len(arr) - 1\n    while (i >= 0):\n        incr = arr[i]*(1 + res)\n        ans += incr\n        res = incr\n        i -= 1\n    return (ans)\n    **Function Description: ** Write a python function to find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input array is empty, the sum of products must be zero.",
                "assert_statement": "sum_Of_Subarray_Prod([]) == 0"
            },
            {
                "description": "For a standard positive input array, the return value must equal the sum of products of all contiguous subarrays (e.g., [1, 2, 3] results in 20).",
                "assert_statement": "sum_Of_Subarray_Prod([1, 2, 3]) == 20"
            },
            {
                "description": "The function must correctly handle arrays containing negative numbers and zero.",
                "assert_statement": "sum_Of_Subarray_Prod([-1, 0, 2]) == 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 715,
        "Function_ID": 358,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The least significant bit (LSB), which is bit 0, must remain unchanged compared to the input N.",
                "assert_statement": "(result & 1) == (N & 1)"
            },
            {
                "description": "For numbers requiring 2 or more bits (K >= 2), the most significant bit (MSB), which is bit K-1, must remain unchanged.",
                "assert_statement": "K = N.bit_length(); K <= 1 or ((result >> (K - 1)) & 1) == ((N >> (K - 1)) & 1)"
            },
            {
                "description": "The result must equal the expected output calculated by XORing N with a mask that contains 1s only for the bits between the LSB and MSB (bits 1 through K-2).",
                "assert_statement": "K = N.bit_length(); if K < 2: expected = N; else: Mask_Full = (1 << K) - 1; Mask_Toggling = (Mask_Full ^ 1) & ~(1 << (K - 1)); expected = N ^ Mask_Toggling; assert result == expected"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 716,
        "Function_ID": 358,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def set_middle_bits(n):  \n    n |= n >> 1; \n    n |= n >> 2; \n    n |= n >> 4; \n    n |= n >> 8; \n    n |= n >> 16;  \n    return (n >> 1) ^ 1\ndef toggle_middle_bits(n): \n    if (n == 1): \n        return 1\n    return n ^ set_middle_bits(n) \n    **Function Description: ** Write a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input integer n is 1, the result is 1 (edge case where no middle bits exist).",
                "assert_statement": "if n == 1: assert R == 1"
            },
            {
                "description": "For inputs n > 1, the highest set bit position (MSB) must remain unchanged after the operation.",
                "assert_statement": "if n > 1: assert R.bit_length() == n.bit_length()"
            },
            {
                "description": "For inputs n > 1, the lowest bit (Bit 0) value must remain unchanged.",
                "assert_statement": "if n > 1: assert (R & 1) == (n & 1)"
            },
            {
                "description": "The number of bits toggled (the count of set bits in the XOR difference) must equal the number of middle bits, which is (bit_length - 2) for n >= 2.",
                "assert_statement": "if n >= 2: assert (n ^ R).bit_count() == n.bit_length() - 2"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 717,
        "Function_ID": 359,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-data-structure-exercise-24.php",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned index (i) must be within the valid bounds, ranging from 0 to the length of the list (inclusive).",
                "assert_statement": "0 <= i <= len(a)"
            },
            {
                "description": "All elements in the original list before the returned index must be strictly less than the target value (x).",
                "assert_statement": "all(a[k] < x for k in range(i))"
            },
            {
                "description": "All elements in the original list starting from the returned index must be greater than or equal to the target value (x).",
                "assert_statement": "all(a[k] >= x for k in range(i, len(a)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 718,
        "Function_ID": 359,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import bisect\ndef left_insertion(a, x):\n    i = bisect.bisect_left(a, x)\n    return i\n    **Function Description: ** Write a function to locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-data-structure-exercise-24.php",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer between 0 and the length of the list 'a', inclusive, representing a valid insertion point.",
                "assert_statement": "assert isinstance(result, int) and 0 <= result <= len(a)"
            },
            {
                "description": "If the insertion index is greater than 0, the element immediately preceding the index must be strictly less than the search value 'x' (defining the 'left' nature of the insertion).",
                "assert_statement": "if result > 0: assert a[result - 1] < x"
            },
            {
                "description": "If the insertion index is not the length of the list, the element at that index must be greater than or equal to the search value 'x'.",
                "assert_statement": "if result < len(a): assert a[result] >= x"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 719,
        "Function_ID": 360,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether the given string is starting with a vowel or not using regex.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "Returns True when the string begins with a lowercase English vowel (a, e, i, o, u).",
                "assert_statement": "assert starts_with_vowel('apple') == True"
            },
            {
                "description": "Returns True when the string begins with an uppercase English vowel (A, E, I, O, U).",
                "assert_statement": "assert starts_with_vowel('Umbrella') == True"
            },
            {
                "description": "Returns False when the string begins with a consonant.",
                "assert_statement": "assert starts_with_vowel('Book') == False"
            },
            {
                "description": "Returns False when the string is empty.",
                "assert_statement": "assert starts_with_vowel('') == False"
            },
            {
                "description": "Returns False when the string starts with a non-alphabetic character (e.g., a number or symbol).",
                "assert_statement": "assert starts_with_vowel('123hello') == False"
            },
            {
                "description": "The return value must be a boolean type.",
                "assert_statement": "assert isinstance(starts_with_vowel('Test'), bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 720,
        "Function_ID": 360,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re \nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\ndef check_str(string): \n\treturn re.search(regex, string)\n    **Function Description: ** Write a function to check whether the given string is starting with a vowel or not using regex.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input string starts with a vowel (case-insensitive) and subsequent characters adhere to the pattern [A-Za-z0-9_]*, the function returns a valid re.Match object.",
                "assert_statement": "result = check_str('Orange_fruit'); assert result is not None and isinstance(result, re.Match)"
            },
            {
                "description": "If the input string does not start with a vowel, the function returns None.",
                "assert_statement": "result = check_str('Test_case'); assert result is None"
            },
            {
                "description": "The return value is always either None (if no match is found) or an instance of re.Match (if a match is found).",
                "assert_statement": "result = check_str('E'); assert result is None or isinstance(result, re.Match)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 721,
        "Function_ID": 361,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to calculate the geometric sum of n-1. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-recursion-exercise-9.php",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the common ratio (r) is not equal to 1, the calculated result must be mathematically equivalent to the closed-form formula for the geometric sum: (r^n - 1) / (r - 1). (Note: using a tolerance for floating point comparison is necessary for precision).",
                "assert_statement": "if r != 1: assert abs(result - ((r**n - 1) / (r - 1))) < 1e-9"
            },
            {
                "description": "If the common ratio (r) is exactly 1, the sum of n terms (1 + 1 + ... + 1) must equal n.",
                "assert_statement": "if r == 1: assert result == n"
            },
            {
                "description": "If n is 0, the sum of zero terms must be 0.",
                "assert_statement": "if n == 0: assert result == 0"
            },
            {
                "description": "The result for a specific integer example (r=2, n=4, which sums 1 + 2 + 4 + 8) must equal 15.",
                "assert_statement": "assert geometric_sum(2, 4) == 15"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 722,
        "Function_ID": 361,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def geometric_sum(n):\n  if n < 0:\n    return 0\n  else:\n    return 1 / (pow(2, n)) + geometric_sum(n - 1)\n    **Function Description: ** Write a function to calculate the geometric sum of n-1. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-recursion-exercise-9.php",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input integer n is negative, the function returns 0.",
                "assert_statement": "assert geometric_sum(-1) == 0"
            },
            {
                "description": "For any non-negative input n, the result must be a float type, as the calculation involves division.",
                "assert_statement": "assert isinstance(geometric_sum(5), float)"
            },
            {
                "description": "For a specific non-negative input n=3, the result must equal the closed-form geometric sum: 2 - (1/2^3) = 1.875.",
                "assert_statement": "assert abs(geometric_sum(3) - 1.875) < 1e-9"
            },
            {
                "description": "For any non-negative input n, the return value must be strictly less than 2 (the limit of the infinite series).",
                "assert_statement": "assert geometric_sum(10) < 2.0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 723,
        "Function_ID": 362,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting index 'k' must generate a triangular number (T_k) that is greater than or equal to the smallest N-digit number (10^(N-1)).",
                "assert_statement": "(result * (result + 1) // 2) >= (10 ** (n - 1))"
            },
            {
                "description": "The resulting index 'k' must generate a triangular number (T_k) that is strictly less than the smallest (N+1)-digit number (10^N).",
                "assert_statement": "(result * (result + 1) // 2) < (10 ** n)"
            },
            {
                "description": "The index 'k' must be the smallest index. Therefore, the preceding triangular number (T_(k-1)) must be strictly less than the smallest N-digit number (10^(N-1)).",
                "assert_statement": "result == 1 or (((result - 1) * result) // 2) < (10 ** (n - 1))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 724,
        "Function_ID": 362,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math \ndef find_Index(n): \n    x = math.sqrt(2 * math.pow(10,(n - 1)))\n    return round(x)\n    **Function Description: ** Write a python function to find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer, representing the index.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The returned index is calculated by rounding the theoretical approximation $\\sqrt{2 \\cdot 10^{n-1}}$ to the nearest integer.",
                "assert_statement": "import math; expected = round(math.sqrt(2 * math.pow(10, n - 1))); assert result == expected"
            },
            {
                "description": "The triangular number corresponding to the returned index ($T_{result}$) must be large enough to have at least $n$ digits.",
                "assert_statement": "import math; T_result = result * (result + 1) // 2; assert T_result >= math.pow(10, n - 1)"
            },
            {
                "description": "The triangular number corresponding to the preceding index ($T_{result-1}$) must have fewer than $n$ digits, ensuring minimality.",
                "assert_statement": "import math; T_prev = (result - 1) * result // 2; assert T_prev < math.pow(10, n - 1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 725,
        "Function_ID": 363,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert the given tuple to a key-value dictionary using adjacent elements. https://www.geeksforgeeks.org/python-convert-tuple-to-adjacent-pair-dictionary/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function output must be a dictionary.",
                "assert_statement": "isinstance(result, dict)"
            },
            {
                "description": "The length of the resulting dictionary must be exactly half the length of the input tuple (assuming an even length input).",
                "assert_statement": "len(result) == len(input_tuple) // 2"
            },
            {
                "description": "The first element of the input tuple must be a key in the resulting dictionary.",
                "assert_statement": "input_tuple[0] in result"
            },
            {
                "description": "The value corresponding to the key at index 2n (the key) must equal the element at index 2n+1 (the value) in the original tuple.",
                "assert_statement": "result[input_tuple[2]] == input_tuple[3]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 726,
        "Function_ID": 363,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def tuple_to_dict(test_tup):\n  res = dict(test_tup[idx : idx + 2] for idx in range(0, len(test_tup), 2))\n  return (res) \n    **Function Description: ** Write a function to convert the given tuple to a key-value dictionary using adjacent elements. https://www.geeksforgeeks.org/python-convert-tuple-to-adjacent-pair-dictionary/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned object must be a dictionary.",
                "assert_statement": "assert isinstance(result, dict)"
            },
            {
                "description": "The resulting dictionary must be identical to one constructed by iterating through adjacent elements of the tuple, using the element at index 2*i as the key and 2*i + 1 as the value, respecting dictionary overwrite rules for duplicate keys.",
                "assert_statement": "expected = {}; for i in range(0, len(test_tup) // 2 * 2, 2): expected[test_tup[i]] = test_tup[i+1]; assert result == expected"
            },
            {
                "description": "If the input tuple has an odd length, a ValueError must be raised, as the last element cannot form a complete key-value pair used by the dict() constructor.",
                "assert_statement": "if len(test_tup) % 2 != 0: import pytest; pytest.raises(ValueError, tuple_to_dict, test_tup)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 727,
        "Function_ID": 364,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether all the characters are same or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns True when the input string contains two or more identical characters.",
                "assert_statement": "assert check_same_chars('xxxx') == True"
            },
            {
                "description": "The function returns True when the input string contains exactly one character.",
                "assert_statement": "assert check_same_chars('a') == True"
            },
            {
                "description": "The function returns True when the input string is empty.",
                "assert_statement": "assert check_same_chars('') == True"
            },
            {
                "description": "The function returns False when the input string contains different characters.",
                "assert_statement": "assert check_same_chars('abcde') == False"
            },
            {
                "description": "The function returns False when identical characters are separated by a different character.",
                "assert_statement": "assert check_same_chars('aaabaaa') == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 728,
        "Function_ID": 364,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def all_Characters_Same(s) :\n    n = len(s)\n    for i in range(1,n) :\n        if s[i] != s[0] :\n            return False\n    return True\n    **Function Description: ** Write a python function to check whether all the characters are same or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, the input string s must contain at most one unique character (all characters are the same, including empty and single-character strings).",
                "assert_statement": "if result: assert len(set(s)) <= 1"
            },
            {
                "description": "If the function returns False, the input string s must contain at least two unique characters.",
                "assert_statement": "if not result: assert len(set(s)) > 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 729,
        "Function_ID": 365,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to caluclate the area of a tetrahedron.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The calculated surface area must be a non-negative numerical value.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The calculated surface area must equal the sum of the areas of the four triangular faces (where A, B, C, D are the four vertices).",
                "assert_statement": "result == area_of_triangle(A, B, C) + area_of_triangle(A, B, D) + area_of_triangle(A, C, D) + area_of_triangle(B, C, D)"
            },
            {
                "description": "If the four input vertices are coplanar or collinear (resulting in a degenerate tetrahedron), the surface area must be zero.",
                "assert_statement": "if is_degenerate_tetrahedron(A, B, C, D): assert result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 730,
        "Function_ID": 365,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math\ndef area_tetrahedron(side):\n  area = math.sqrt(3)*(side*side)\n  return area\n    **Function Description: ** Write a function to caluclate the area of a tetrahedron.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a floating-point number, as the calculation involves math.sqrt(3).",
                "assert_statement": "assert isinstance(area_tetrahedron(5), float)"
            },
            {
                "description": "The returned area must equal the mathematical formula for the surface area of a regular tetrahedron: sqrt(3) * side^2.",
                "assert_statement": "s = 4.0; expected = math.sqrt(3) * s * s; assert abs(area_tetrahedron(s) - expected) < 1e-9"
            },
            {
                "description": "The calculated area must be non-negative (greater than or equal to zero).",
                "assert_statement": "assert area_tetrahedron(10) >= 0"
            },
            {
                "description": "If the side length is zero, the area must be zero.",
                "assert_statement": "assert area_tetrahedron(0) == 0.0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 731,
        "Function_ID": 366,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/python-program-right-rotate-list-n/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the list remains unchanged after rotation.",
                "assert_statement": "len(original_list) == len(rotated_list)"
            },
            {
                "description": "All elements from the original list are present in the rotated list, maintaining count (checked via sorted comparison to handle duplicates).",
                "assert_statement": "sorted(original_list) == sorted(rotated_list)"
            },
            {
                "description": "The rotation is correct: the rotated list equals the concatenation of the last 'k' elements and the first 'length - k' elements of the original list, where 'k' is the effective rotation count (N mod length).",
                "assert_statement": "k = N % len(original_list); assert rotated_list == original_list[-k:] + original_list[:-k]"
            },
            {
                "description": "If the list is rotated by zero (or a multiple of the length), the list must be identical to the original.",
                "assert_statement": "if N % len(original_list) == 0: assert original_list == rotated_list"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 732,
        "Function_ID": 366,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def rotate_right(list, m):\n  result =  list[-m:] + list[:-m]\n  return result\n    **Function Description: ** Write a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/python-program-right-rotate-list-n/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned object is a list that maintains the same length and element composition (permutation) as the original input list.",
                "assert_statement": "assert isinstance(result, list) and len(result) == len(L) and sorted(result) == sorted(L)"
            },
            {
                "description": "The returned list is correctly rotated `m` positions to the right. The rotation is verified by checking that the segments match based on the effective rotation amount (m % len(L)).",
                "assert_statement": "assert len(L) == 0 or (result[:m % len(L)] == L[len(L) - m % len(L):] and result[m % len(L):] == L[:len(L) - m % len(L)])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 733,
        "Function_ID": 367,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check if the given tuple has any none value or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return True if the input tuple contains at least one None value.",
                "assert_statement": "result is True"
            },
            {
                "description": "The function must return False if the input tuple contains only non-None values.",
                "assert_statement": "result is False"
            },
            {
                "description": "The function must return False if the input tuple is empty.",
                "assert_statement": "result is False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 734,
        "Function_ID": 367,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_none(test_tup):\n  res = any(map(lambda ele: ele is None, test_tup))\n  return res \n    **Function Description: ** Write a function to check if the given tuple has any none value or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the input tuple contains the value None, the function must return True.",
                "assert_statement": "assert check_none(('a', 5, None, 'b')) == True"
            },
            {
                "description": "If the input tuple does not contain the value None, the function must return False.",
                "assert_statement": "assert check_none((1, 2, 3, 'four')) == False"
            },
            {
                "description": "If the input tuple is empty, the function must return False.",
                "assert_statement": "assert check_none(()) == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 735,
        "Function_ID": 368,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/python-exercises/lambda/python-lambda-exercise-24.php",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a list containing only integers.",
                "assert_statement": "isinstance(result, list) and all(isinstance(n, int) for n in result)"
            },
            {
                "description": "Every number in the returned list must fall within the inclusive range defined by 'startnum' and 'endnum'.",
                "assert_statement": "all(startnum <= n <= endnum for n in result)"
            },
            {
                "description": "Every number returned must not contain the digit zero, as division by zero is undefined in this context.",
                "assert_statement": "all('0' not in str(n) for n in result)"
            },
            {
                "description": "Every number in the result list must be perfectly divisible by every single digit it contains.",
                "assert_statement": "all(all(n % int(d) == 0 for d in str(n)) for n in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 736,
        "Function_ID": 368,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def divisible_by_digits(startnum, endnum):\n    return [n for n in range(startnum, endnum+1) \\\n                if not any(map(lambda x: int(x) == 0 or n%int(x) != 0, str(n)))]\n    **Function Description: ** Write a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/python-exercises/lambda/python-lambda-exercise-24.php",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "Every number 'n' contained in the resulting list must fall within the inclusive input range [startnum, endnum].",
                "assert_statement": "assert all(startnum <= n <= endnum for n in result)"
            },
            {
                "description": "Every number 'n' in the resulting list must not contain the digit zero, and must be perfectly divisible by every digit it contains.",
                "assert_statement": "assert all(all(int(d) != 0 and n % int(d) == 0 for d in str(n)) for n in result)"
            },
            {
                "description": "The returned list must be complete, containing all numbers within the range [startnum, endnum] that satisfy the divisibility criteria.",
                "assert_statement": "assert sorted(result) == sorted([n for n in range(startnum, endnum + 1) if all(int(d) != 0 and n % int(d) == 0 for d in str(n))])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 737,
        "Function_ID": 369,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the input angle is greater than 360 degrees, the function must return None.",
                "assert_statement": "angle > 360 and return_value is None"
            },
            {
                "description": "If the angle is valid (less than or equal to 360), the return value must match the calculated area using the formula (angle/360) * pi * r^2.",
                "assert_statement": "angle <= 360 and return_value == (angle / 360.0) * math.pi * (radius ** 2)"
            },
            {
                "description": "The returned value, if not None, must be a non-negative number.",
                "assert_statement": "return_value is None or return_value >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 738,
        "Function_ID": 369,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math\ndef sector_area(r,a):\n    if a > 360:\n        return None\n    return (math.pi*r**2) * (a/360)\n    **Function Description: ** Write a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the angle 'a' is greater than 360 degrees, the function must return None.",
                "assert_statement": "if a > 360: assert result is None"
            },
            {
                "description": "If the angle 'a' is less than or equal to 360 degrees, the returned value must equal the sector area calculated by the formula (math.pi * r**2) * (a/360).",
                "assert_statement": "if a <= 360: assert abs(result - (math.pi * r**2) * (a/360)) < 1e-9"
            },
            {
                "description": "If a calculation is performed (i.e., the result is not None), the returned value must be a floating-point number.",
                "assert_statement": "if result is not None: assert isinstance(result, (float, int))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 739,
        "Function_ID": 370,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting string must be a valid subsequence of the first input string (S1).",
                "assert_statement": "is_subsequence(result, S1)"
            },
            {
                "description": "The resulting string must be a valid subsequence of the second input string (S2).",
                "assert_statement": "is_subsequence(result, S2)"
            },
            {
                "description": "The resulting string must be a valid subsequence of the third input string (S3).",
                "assert_statement": "is_subsequence(result, S3)"
            },
            {
                "description": "The length of the resulting LCS must be greater than or equal to the length of any other common subsequence of S1, S2, and S3 (verifying maximality against a known correct length).",
                "assert_statement": "assert len(result) == calculate_lcs_length_of_three(S1, S2, S3)"
            },
            {
                "description": "If all input strings are empty, the result must be an empty string.",
                "assert_statement": "if not S1 and not S2 and not S3: assert result == ''"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 740,
        "Function_ID": 370,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def lcs_of_three(X, Y, Z): \n  m = len(X)\n  n = len(Y)\n  o = len(Z)\n  L = [[[0 for i in range(o+1)] for j in range(n+1)] for k in range(m+1)]\n  for i in range(m+1): \n\t  for j in range(n+1): \n\t\t  for k in range(o+1): \n\t\t\t  if (i == 0 or j == 0 or k == 0): \n\t\t\t\t  L[i][j][k] = 0\n\t\t\t  elif (X[i-1] == Y[j-1] and X[i-1] == Z[k-1]): \n\t\t\t\t  L[i][j][k] = L[i-1][j-1][k-1] + 1\n\t\t\t  else: \n\t\t\t\t  L[i][j][k] = max(max(L[i-1][j][k], L[i][j-1][k]), L[i][j][k-1]) \n  return L[m][n][o]\n    **Function Description: ** Write a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer, representing a length.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The length of the LCS cannot exceed the length of the shortest input string.",
                "assert_statement": "assert result <= min(len(X), len(Y), len(Z))"
            },
            {
                "description": "If all input strings are empty, the LCS length must be zero.",
                "assert_statement": "if len(X) == 0 and len(Y) == 0 and len(Z) == 0: assert result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 741,
        "Function_ID": 371,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to put spaces between words starting with capital letters in a given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a string type.",
                "assert_statement": "isinstance(result, str)"
            },
            {
                "description": "The function must successfully insert a space before a capital letter that immediately follows a lowercase letter (camelCase splitting).",
                "assert_statement": "transform('startWordEnd') == 'start Word End'"
            },
            {
                "description": "If the input string is empty, the output string must also be empty.",
                "assert_statement": "transform('') == ''"
            },
            {
                "description": "Strings that are already spaced or contain no internal capitalization should remain unchanged.",
                "assert_statement": "transform('already spaced input') == 'already spaced input'"
            },
            {
                "description": "The first character of the string, if capitalized, should not be preceded by a space.",
                "assert_statement": "not result.startswith(' ')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 742,
        "Function_ID": 371,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef capital_words_spaces(str1):\n  return re.sub(r\"(\\w)([A-Z])\", r\"\\1 \\2\", str1)\n    **Function Description: ** Write a function to put spaces between words starting with capital letters in a given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The function must successfully insert a space before every capital letter that immediately follows a word character.",
                "assert_statement": "assert capital_words_spaces(\"HelloWorldExample\") == \"Hello World Example\""
            },
            {
                "description": "If the input string does not contain a pattern where an uppercase letter follows a word character, the output string must be identical to the input string.",
                "assert_statement": "assert capital_words_spaces(\"hello world 123\") == \"hello world 123\""
            },
            {
                "description": "If the input string is empty, the output string must also be empty.",
                "assert_statement": "assert capital_words_spaces(\"\") == \"\""
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 743,
        "Function_ID": 372,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to sort a given list of strings of numbers numerically. https://www.geeksforgeeks.org/python-sort-numeric-strings-in-a-list/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting list must be sorted numerically in ascending order.",
                "assert_statement": "all(int(result_list[i]) <= int(result_list[i+1]) for i in range(len(result_list) - 1))"
            },
            {
                "description": "The length of the resulting list must be the same as the length of the original input list.",
                "assert_statement": "len(result_list) == len(input_list)"
            },
            {
                "description": "The resulting list must be a permutation of the input list (it contains the exact same elements, ensuring no elements were lost or added).",
                "assert_statement": "sorted(result_list) == sorted(input_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 744,
        "Function_ID": 372,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sort_numeric_strings(nums_str):\n    result = [int(x) for x in nums_str]\n    result.sort()\n    return result\n    **Function Description: ** Write a function to sort a given list of strings of numbers numerically. https://www.geeksforgeeks.org/python-sort-numeric-strings-in-a-list/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is a list and all its elements are integers.",
                "assert_statement": "assert isinstance(return_value, list) and all(isinstance(x, int) for x in return_value)"
            },
            {
                "description": "The length of the returned list must be equal to the length of the input list, ensuring no elements were lost or added.",
                "assert_statement": "assert len(return_value) == len(nums_str)"
            },
            {
                "description": "The returned list is numerically sorted in ascending order.",
                "assert_statement": "assert all(return_value[i] <= return_value[i+1] for i in range(len(return_value) - 1))"
            },
            {
                "description": "The returned list contains exactly the same set of numerical values as the input list, preserving content integrity (order is checked separately).",
                "assert_statement": "assert sorted([int(x) for x in nums_str]) == return_value"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 745,
        "Function_ID": 373,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to add the given tuple to the given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the list is increased by exactly one.",
                "assert_statement": "len(final_list) == len(original_list) + 1"
            },
            {
                "description": "The input tuple is present in the resulting list.",
                "assert_statement": "input_tuple in final_list"
            },
            {
                "description": "The input tuple is placed as the last element (assuming standard append behavior).",
                "assert_statement": "final_list[-1] == input_tuple"
            },
            {
                "description": "The original elements of the list are preserved and maintain their relative order.",
                "assert_statement": "final_list[:-1] == original_list"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 746,
        "Function_ID": 373,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def add_tuple(test_list, test_tup):\n  test_list += test_tup\n  return test_list\n    **Function Description: ** Write a function to add the given tuple to the given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(return_value, list)"
            },
            {
                "description": "The operation modifies the input list in place; therefore, the returned object reference must be the exact same object as the input 'test_list'.",
                "assert_statement": "assert return_value is test_list"
            },
            {
                "description": "The length of the resulting list must equal the length of the initial list plus the length of the input tuple.",
                "assert_statement": "assert len(return_value) == len(_pre_test_list) + len(test_tup)"
            },
            {
                "description": "The content of the resulting list must be the concatenation of the original list content followed by the tuple elements.",
                "assert_statement": "assert return_value == _pre_test_list + list(test_tup)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 747,
        "Function_ID": 374,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check if the given array represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the array must satisfy the min-heap property: every parent node is less than or equal to both its children.",
                "assert_statement": "result == True ==> for all i in [0, (len(A)//2) - 1]: (A[i] <= A[2*i + 1]) AND ((2*i + 2 >= len(A)) OR (A[i] <= A[2*i + 2]))"
            },
            {
                "description": "If the function returns False, there must be at least one parent node that violates the min-heap property (i.e., is strictly greater than one of its children).",
                "assert_statement": "result == False ==> exists i in [0, (len(A)//2) - 1]: (A[i] > A[2*i + 1]) OR ((2*i + 2 < len(A)) AND (A[i] > A[2*i + 2]))"
            },
            {
                "description": "The input array must remain unchanged, as the function is a non-modifying verification check.",
                "assert_statement": "A == A_pre"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 748,
        "Function_ID": 374,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_min_heap_helper(arr, i):\n    if 2 * i + 2 > len(arr):\n        return True\n    left_child = (arr[i] <= arr[2 * i + 1]) and check_min_heap_helper(arr, 2 * i + 1)\n    right_child = (2 * i + 2 == len(arr)) or (arr[i] <= arr[2 * i + 2] \n                                      and check_min_heap_helper(arr, 2 * i + 2))\n    return left_child and right_child\n\ndef check_min_heap(arr):\n  return check_min_heap_helper(arr, 0)\n    **Function Description: ** Write a function to check if the given array represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a boolean indicating whether the input array represents a min-heap.",
                "assert_statement": "assert isinstance(RETVAL, bool)"
            },
            {
                "description": "The return value must be True if and only if the array satisfies the min-heap property (every parent is less than or equal to its children).",
                "assert_statement": "N = len(arr); assert (RETVAL) == all(arr[i] <= arr[2 * i + 1] and (2 * i + 2 >= N or arr[i] <= arr[2 * i + 2]) for i in range(N // 2))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 749,
        "Function_ID": 375,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a non-negative integer.",
                "assert_statement": "result >= 0 and isinstance(result, int)"
            },
            {
                "description": "The 0th Jacobsthal number (J_0) must be 0.",
                "assert_statement": "(n == 0) ==> (result == 0)"
            },
            {
                "description": "The 1st Jacobsthal number (J_1) must be 1.",
                "assert_statement": "(n == 1) ==> (result == 1)"
            },
            {
                "description": "The result must conform to the closed-form identity J_n = (2^n - (-1)^n) / 3.",
                "assert_statement": "result == (2**n - (-1)**n) // 3"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 750,
        "Function_ID": 375,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def jacobsthal_num(n): \n\tdp = [0] * (n + 1) \n\tdp[0] = 0\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2] \n\treturn dp[n]\n    **Function Description: ** Write a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input n is 0, the result must be the 0th Jacobsthal number, J(0) = 0.",
                "assert_statement": "if n == 0: assert result == 0"
            },
            {
                "description": "If the input n is 1, the result must be the 1st Jacobsthal number, J(1) = 1.",
                "assert_statement": "if n == 1: assert result == 1"
            },
            {
                "description": "The returned value must satisfy the closed-form formula for Jacobsthal numbers: J(n) = (2^n - (-1)^n) / 3, provided n is non-negative.",
                "assert_statement": "if n >= 0: assert result == (2**n - (-1)**n) // 3"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 751,
        "Function_ID": 376,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "Verify the output for the primary test case (K=3) matches the expected list of three records with the smallest corresponding integer values, sorted correctly.",
                "assert_statement": "assert res == [('geeks', 1), ('best', 2), ('Gfg', 3)]"
            },
            {
                "description": "Verify the function returns the correct single record when K is set to the minimum (K=1).",
                "assert_statement": "assert res == [('geeks', 1)]"
            },
            {
                "description": "Verify the function correctly returns the minimum K=5 records (covering most of the input list).",
                "assert_statement": "assert res == [('geeks', 1), ('best', 2), ('Gfg', 3), ('CS', 6), ('is', 7)]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 752,
        "Function_ID": 376,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def min_k(test_list, K):\n  res = sorted(test_list, key = lambda x: x[1])[:K]\n  return (res) \n    **Function Description: ** Write a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list must be less than or equal to K and also less than or equal to the length of the input list.",
                "assert_statement": "assert len(result) <= K and len(result) <= len(test_list)"
            },
            {
                "description": "The returned list contains exactly the K elements from test_list that have the minimum values at index 1, and these elements are correctly sorted according to index 1.",
                "assert_statement": "assert result == sorted(test_list, key=lambda x: x[1])[:K]"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 753,
        "Function_ID": 377,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWe say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.  find common elements from three lists. The function should return a list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned list must contain all unique elements that are present at the same index across all three input lists (l1, l2, and l3), and no elements that do not meet this criteria. The comparison is constrained by the length of the shortest list.",
                "assert_statement": "assert set(result) == {l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] and l2[i] == l3[i]}"
            },
            {
                "description": "The return value must be a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "Every element returned in the result must have been found at a valid synchronized index.",
                "assert_statement": "for element in result: assert any(l1[i] == element and l2[i] == element and l3[i] == element for i in range(min(len(l1), len(l2), len(l3))))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 754,
        "Function_ID": 377,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def extract_index_list(l1, l2, l3):\n    result = []\n    for m, n, o in zip(l1, l2, l3):\n        if (m == n == o):\n            result.append(m)\n    return result\n    **Function Description: ** We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. Write a function to find common elements from three lists. The function should return a list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is a list.",
                "assert_statement": "assert isinstance(ret, list)"
            },
            {
                "description": "The returned list contains exactly the elements that appeared at the same index across all three input lists.",
                "assert_statement": "expected = [m for m, n, o in zip(l1, l2, l3) if m == n == o]; assert ret == expected"
            },
            {
                "description": "The length of the result list cannot exceed the length of the shortest input list.",
                "assert_statement": "assert len(ret) <= min(len(l1), len(l2), len(l3))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 755,
        "Function_ID": 378,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the second smallest number in a list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an element present in the original input list.",
                "assert_statement": "result in L"
            },
            {
                "description": "If the list contains at least two distinct elements, the returned value must be the second smallest unique value. This is verified by ensuring that exactly one unique element is strictly smaller than the result.",
                "assert_statement": "len(set(L)) < 2 or len([x for x in set(L) if x < result]) == 1"
            },
            {
                "description": "The returned value must be greater than or equal to the absolute minimum element of the list.",
                "assert_statement": "result >= min(L)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 756,
        "Function_ID": 378,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def second_smallest(numbers):\n  unique_numbers = list(set(numbers))\n  unique_numbers.sort()\n  if len(unique_numbers) < 2:\n    return None\n  else:\n    return unique_numbers[1]\n    **Function Description: ** Write a function to find the second smallest number in a list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input list contains two or more unique numbers, the returned value must be the second smallest element found in the unique set of the input list.",
                "assert_statement": "unique_sorted = sorted(list(set(numbers))); if len(unique_sorted) >= 2: assert result == unique_sorted[1]"
            },
            {
                "description": "If the input list contains fewer than two unique numbers (i.e., zero or one unique number), the function must return None.",
                "assert_statement": "if len(list(set(numbers))) < 2: assert result is None"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 757,
        "Function_ID": 379,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the input string successfully matches the pattern ('a' followed by one or more 'b's), the result is a valid match object (not None).",
                "assert_statement": "assert result is not None"
            },
            {
                "description": "If the input string contains 'a' but is not followed by at least one 'b', the result must be None.",
                "assert_statement": "assert result is None"
            },
            {
                "description": "If the input string does not start with 'a' followed by 'b's (assuming re.match is used), the result must be None.",
                "assert_statement": "assert result is None"
            },
            {
                "description": "If a match object is returned, the matched string must start with 'a' and have a length of at least 2 (representing 'a' and one 'b').",
                "assert_statement": "assert result is None or (result.group(0).startswith('a') and len(result.group(0)) >= 2)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 758,
        "Function_ID": 379,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef text_match_zero_one(text):\n        patterns = 'ab+?'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n    **Function Description: ** Write a function that matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input string contains 'a' followed by exactly one 'b', the function returns True.",
                "assert_statement": "assert text_match_zero_one(\"The quick ab brown fox\") is True"
            },
            {
                "description": "If the input string contains 'a' followed by multiple 'b's (e.g., 'abbb'), the function returns True.",
                "assert_statement": "assert text_match_zero_one(\"abbb test\") is True"
            },
            {
                "description": "If the input string contains 'a' but it is not immediately followed by at least one 'b', the function returns False.",
                "assert_statement": "assert text_match_zero_one(\"axc\") is False"
            },
            {
                "description": "If the required sequence ('a' followed by one or more 'b's) is not present anywhere, the function returns False.",
                "assert_statement": "assert text_match_zero_one(\"zxy\") is False"
            },
            {
                "description": "The function must always return a boolean value.",
                "assert_statement": "assert isinstance(text_match_zero_one(\"ab\"), bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 759,
        "Function_ID": 380,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The function must correctly identify and count distinct reverse pairs when they exist.",
                "assert_statement": "assert count_reverse_pairs(['ab', 'ba', 'cd', 'dc', 'xyz']) == 2"
            },
            {
                "description": "If the input list is empty, the count of reverse pairs must be zero.",
                "assert_statement": "assert count_reverse_pairs([]) == 0"
            },
            {
                "description": "If the list contains duplicates of strings that are their own reverse, each pair of duplicates must be counted once.",
                "assert_statement": "assert count_reverse_pairs(['level', 'radar', 'level']) == 1"
            },
            {
                "description": "The function must correctly handle lists containing strings that are the reverse of one another mixed with non-paired strings.",
                "assert_statement": "assert count_reverse_pairs(['apple', 'elppa', 'orange', 'banana']) == 1"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 760,
        "Function_ID": 380,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_reverse_pairs(test_list):\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \n  return res\n    **Function Description: ** Write a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "result = count_reverse_pairs(['a', 'b']); assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the input list is empty, the function must return 0.",
                "assert_statement": "assert count_reverse_pairs([]) == 0"
            },
            {
                "description": "The count correctly identifies all pairs (i, j) where i <= j such that list[j] is the reverse of list[i], including self-reverse (palindromes).",
                "assert_statement": "assert count_reverse_pairs([\"listen\", \"netsil\", \"listen\", \"abba\"]) == 3"
            },
            {
                "description": "For a list containing two unique elements, where one is the reverse of the other, the function counts exactly one pair, assuming the reverse element appears later in the list.",
                "assert_statement": "assert count_reverse_pairs([\"racecar\", \"car race\"]) == 0"
            },
            {
                "description": "If the list contains only unique non-palindrome strings with no reverse pairs, the count must be 0.",
                "assert_statement": "assert count_reverse_pairs([\"apple\", \"banana\", \"cherry\"]) == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 761,
        "Function_ID": 381,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to count lists within a list. The function should return a dictionary where every list is converted to a tuple and the value of such tuple is the number of its occurencies in the original list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a dictionary where all keys are tuples (representing the lists found) and all values are positive integers (the counts).",
                "assert_statement": "isinstance(result, dict) and all(isinstance(k, tuple) for k in result.keys()) and all(isinstance(v, int) and v > 0 for v in result.values())"
            },
            {
                "description": "The keys of the resulting dictionary must only correspond to items in the input_list that were lists.",
                "assert_statement": "all(k == tuple(i) for k in result.keys() for i in input_list if isinstance(i, list) and k == tuple(i))"
            },
            {
                "description": "The counts stored in the result must exactly match the actual number of occurrences for every list found in the input.",
                "assert_statement": "expected_counts = {}; [expected_counts.update({tuple(item): expected_counts.get(tuple(item), 0) + 1}) for item in input_list if isinstance(item, list)]; assert result == expected_counts"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 762,
        "Function_ID": 381,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def unique_sublists(list1):\n    result ={}\n    for l in  list1: \n        result.setdefault(tuple(l), list()).append(1) \n    for a, b in result.items(): \n        result[a] = sum(b)\n    return result\n    **Function Description: ** Write a function to count lists within a list. The function should return a dictionary where every list is converted to a tuple and the value of such tuple is the number of its occurencies in the original list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a dictionary where all keys are tuples (representing the unique sublists) and all values are positive integers (representing the counts).",
                "assert_statement": "assert isinstance(result, dict) and all(isinstance(k, tuple) and isinstance(v, int) and v >= 1 for k, v in result.items()) or (not list1 and result == {})"
            },
            {
                "description": "The total sum of the counts in the returned dictionary must equal the total number of elements in the input list.",
                "assert_statement": "assert sum(result.values()) == len(list1)"
            },
            {
                "description": "The returned dictionary accurately maps every unique sublist (converted to a tuple) to its correct frequency count in the original input list.",
                "assert_statement": "from collections import Counter; expected = Counter(tuple(x) for x in list1); assert result == expected"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 763,
        "Function_ID": 382,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether a given string is a decimal number with a precision of 2.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the input string must strictly conform to the format of a signed or unsigned decimal number with exactly two digits after the decimal point (e.g., '12.34', '0.00').",
                "assert_statement": "if result: assert re.fullmatch(r'^[-+]?\\d*\\.\\d{2}$', s)"
            },
            {
                "description": "If the input string contains more than two digits of precision (e.g., '1.234'), the function must return False.",
                "assert_statement": "if re.search(r'\\.\\d{3}', s): assert result == False"
            },
            {
                "description": "If the input string contains exactly one digit of precision (e.g., '1.2'), the function must return False.",
                "assert_statement": "if re.fullmatch(r'^[-+]?\\d*\\.\\d{1}$', s): assert result == False"
            },
            {
                "description": "If the input string is a valid integer without a decimal point (e.g., '123'), the function must return False.",
                "assert_statement": "if re.fullmatch(r'^[-+]?\\d+$', s) and '.' not in s: assert result == False"
            },
            {
                "description": "If the input string contains non-numeric characters (excluding a leading sign or the single decimal point), the function must return False.",
                "assert_statement": "if not re.match(r'^[-+]?\\d*\\.?\\d*$', s): assert result == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 764,
        "Function_ID": 382,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_decimal(num):\n    import re\n    dnumre = re.compile(r\"\"\"^[0-9]+(\\.[0-9]{1,2})?$\"\"\")\n    result = dnumre.search(num)\n    return bool(result)\n    **Function Description: ** Write a function to check whether a given string is a decimal number with a precision of 2.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean type.",
                "assert_statement": "assert isinstance(ret_val, bool)"
            },
            {
                "description": "If the input is a valid integer string (meeting the definition requirements), the function must return True.",
                "assert_statement": "assert is_decimal('1234') == True"
            },
            {
                "description": "If the input is a valid decimal string with exactly 1 or 2 digits of precision, the function must return True.",
                "assert_statement": "assert is_decimal('5.6') == True and is_decimal('5.67') == True"
            },
            {
                "description": "If the input string violates the 2-digit precision limit (having three or more digits after the decimal), the function must return False.",
                "assert_statement": "assert is_decimal('1.234') == False"
            },
            {
                "description": "The function must reject strings that begin with a decimal point or strings where the decimal component is present but lacks digits.",
                "assert_statement": "assert is_decimal('.5') == False and is_decimal('1.') == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 765,
        "Function_ID": 383,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether a list of numbers contains only one distinct element or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns True if and only if the number of distinct elements in the list (the length of the set conversion) is exactly one.",
                "assert_statement": "result == (len(set(number_list)) == 1)"
            },
            {
                "description": "If the input list is empty, the function must return False.",
                "assert_statement": "if not number_list: assert result is False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 766,
        "Function_ID": 383,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def unique_Element(arr):\n    s = set(arr)\n    return len(s) == 1\n    **Function Description: ** Write a python function to check whether a list of numbers contains only one distinct element or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the number of unique elements in the input array 'arr' is exactly 1, the function must return True.",
                "assert_statement": "assert (len(set(arr)) == 1) == result"
            },
            {
                "description": "If the input array 'arr' is empty (0 unique elements) or contains more than one unique element, the function must return False.",
                "assert_statement": "assert (len(set(arr)) != 1) == (not result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 767,
        "Function_ID": 384,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the input month is April (4), June (6), September (9), or November (11), the function must return True.",
                "assert_statement": "assert check_30_days(9) is True"
            },
            {
                "description": "If the input month is a 31-day month (1, 3, 5, 7, 8, 10, 12), the function must return False.",
                "assert_statement": "assert check_30_days(12) is False"
            },
            {
                "description": "If the input month is February (2), the function must return False.",
                "assert_statement": "assert check_30_days(2) is False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 768,
        "Function_ID": 384,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_monthnumber_number(monthnum3):\n  return monthnum3==4 or monthnum3==6 or monthnum3==9 or monthnum3==11\n    **Function Description: ** Write a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input month number corresponds to a month with 30 days (e.g., 4, 6, 9, 11), the function must return True.",
                "assert_statement": "assert check_monthnumber_number(9) is True"
            },
            {
                "description": "If the input month number corresponds to a month that does not have 30 days (e.g., 1, 2, 3, 5, 7, 8, 10, 12), the function must return False.",
                "assert_statement": "assert check_monthnumber_number(1) is False"
            },
            {
                "description": "The function must return a boolean value.",
                "assert_statement": "assert isinstance(check_monthnumber_number(5), bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 769,
        "Function_ID": 385,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a non-negative integer, as it represents an absolute difference.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The returned result must be the minimum possible difference; therefore, no pair's absolute difference in the input array (arr) can be strictly smaller than the result.",
                "assert_statement": "all(abs(arr[i] - arr[j]) >= result for i in range(len(arr)) for j in range(i + 1, len(arr)))"
            },
            {
                "description": "The minimum difference must actually exist in the input array; there must be at least one pair whose absolute difference equals the returned result.",
                "assert_statement": "any(abs(arr[i] - arr[j]) == result for i in range(len(arr)) for j in range(i + 1, len(arr)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 770,
        "Function_ID": 385,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_min_diff(arr,n): \n    arr = sorted(arr) \n    diff = 10**20 \n    for i in range(n-1): \n        if arr[i+1] - arr[i] < diff: \n            diff = arr[i+1] - arr[i]  \n    return diff \n    **Function Description: ** Write a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value, representing a minimum absolute difference or a positive sentinel, must be a non-negative numeric type (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float)) and result >= 0"
            },
            {
                "description": "The returned value must verify the intended calculation path: if the input size 'n' is less than 2, the result must be the sentinel value (10**20); otherwise, a valid minimum difference was found, making the result strictly less than 10**20.",
                "assert_statement": "assert (result == 10**20 and n < 2) or (result < 10**20 and n >= 2)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 771,
        "Function_ID": 386,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count number of digits in a given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value (result) must be an integer and cannot be negative, as it represents a count.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The return value must exactly match the number of digit characters found in the input string (s).",
                "assert_statement": "result == sum(1 for char in s if char.isdigit())"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 772,
        "Function_ID": 386,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def number_ctr(str):\n      number_ctr= 0\n      for i in range(len(str)):\n          if str[i] >= '0' and str[i] <= '9': number_ctr += 1     \n      return  number_ctr\n    **Function Description: ** Write a python function to count number of digits in a given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a non-negative integer.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The count of digits returned cannot exceed the total length of the input string.",
                "assert_statement": "result <= len(input_str)"
            },
            {
                "description": "The return value accurately represents the total number of numeric characters (0-9) present in the input string.",
                "assert_statement": "result == sum(1 for char in input_str if '0' <= char <= '9')"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 773,
        "Function_ID": 387,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find nth polite number. geeksforgeeks.org/n-th-polite-number/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a positive integer.",
                "assert_statement": "isinstance(result, int) and result > 0"
            },
            {
                "description": "The result must be a polite number, meaning it cannot be a power of 2. A positive number K is a power of 2 if K & (K-1) == 0.",
                "assert_statement": "(result & (result - 1)) != 0"
            },
            {
                "description": "For n=1, the function must return the 1st polite number, which is 3.",
                "assert_statement": "if n == 1: assert result == 3"
            },
            {
                "description": "For n=5, the function must return the 5th polite number, which is 9.",
                "assert_statement": "if n == 5: assert result == 9"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 774,
        "Function_ID": 387,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math \ndef is_polite(n): \n\tn = n + 1\n\treturn (int)(n+(math.log((n + math.log(n, 2)), 2))) \n    **Function Description: ** Write a function to find nth polite number. geeksforgeeks.org/n-th-polite-number/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a value of type integer, resulting from the explicit cast.",
                "assert_statement": "assert isinstance(is_polite(2), int)"
            },
            {
                "description": "If the input N is positive (N>=1), the calculated result must be a positive integer.",
                "assert_statement": "assert is_polite(5) > 0"
            },
            {
                "description": "Based on the internal formula, the result for input N=1 must be 3.",
                "assert_statement": "assert is_polite(1) == 3"
            },
            {
                "description": "Based on the internal formula, the result for input N=3 must be 6.",
                "assert_statement": "assert is_polite(3) == 6"
            },
            {
                "description": "Based on the internal formula, the result for input N=10 must be 14.",
                "assert_statement": "assert is_polite(10) == 14"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 775,
        "Function_ID": 388,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to return a list of all pairs of consecutive items in a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The length of the result list must be zero if the input list has less than two elements, otherwise it must be one less than the length of the input list.",
                "assert_statement": "len(result) == max(0, len(input_list) - 1)"
            },
            {
                "description": "Every element in the resulting list must be a pair (a list of length 2).",
                "assert_statement": "all(isinstance(pair, list) and len(pair) == 2 for pair in result)"
            },
            {
                "description": "Each returned pair must correctly represent two consecutive elements from the input list in the original order.",
                "assert_statement": "all(result[i] == [input_list[i], input_list[i+1]] for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 776,
        "Function_ID": 388,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def pair_wise(l1):\n    temp = []\n    for i in range(len(l1) - 1):\n        current_element, next_element = l1[i], l1[i + 1]\n        x = (current_element, next_element)\n        temp.append(x)\n    return temp\n    **Function Description: ** Write a function to return a list of all pairs of consecutive items in a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value is a list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The length of the returned list is calculated as max(0, len(l1) - 1), representing the number of consecutive pairs.",
                "assert_statement": "assert len(result) == max(0, len(l1) - 1)"
            },
            {
                "description": "Every element in the returned list is a tuple of length 2.",
                "assert_statement": "assert all(isinstance(pair, tuple) and len(pair) == 2 for pair in result)"
            },
            {
                "description": "The i-th element of the result is a tuple pairing the i-th element and the (i+1)-th element of the input list l1.",
                "assert_statement": "assert all(result[i] == (l1[i], l1[i+1]) for i in range(len(result)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 777,
        "Function_ID": 389,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count the number of pairs whose sum is equal to sum. The funtion gets as input a list of numbers and the sum,",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned result must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The count of pairs must be non-negative.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The returned count must match the actual number of unique pairs (i, j where i < j) in the input list whose sum equals the target sum.",
                "assert_statement": "result == sum(1 for i in range(len(data_list)) for j in range(i + 1, len(data_list)) if data_list[i] + data_list[j] == target_sum)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 778,
        "Function_ID": 389,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def get_pairs_count(arr, sum):\n    count = 0  \n    for i in range(len(arr)):\n        for j in range(i + 1,len(arr)):\n            if arr[i] + arr[j] == sum:\n                count += 1\n    return count\n    **Function Description: ** Write a python function to count the number of pairs whose sum is equal to sum. The funtion gets as input a list of numbers and the sum,",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the length of the input array is less than two, the count of pairs must be zero.",
                "assert_statement": "if len(arr) < 2: assert result == 0"
            },
            {
                "description": "The returned count must exactly match the number of unique index pairs (i, j) such that i < j and arr[i] + arr[j] equals the target sum.",
                "assert_statement": "expected_count = 0; N = len(arr); for i in range(N): for j in range(i + 1, N): if arr[i] + arr[j] == sum: expected_count += 1; assert result == expected_count"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 779,
        "Function_ID": 390,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to get the difference between two lists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be of type list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The set of elements in the result must be equivalent to the set difference between the first list and the second list (list1 - list2).",
                "assert_statement": "assert set(result) == set(list1) - set(list2)"
            },
            {
                "description": "All elements present in the resulting list must have originated in the first list (list1).",
                "assert_statement": "assert all(item in list1 for item in result)"
            },
            {
                "description": "No element present in the resulting list should be present in the second list (list2).",
                "assert_statement": "assert all(item not in list2 for item in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 780,
        "Function_ID": 390,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def Diff(li1,li2):\n    return list(set(li1)-set(li2)) + list(set(li2)-set(li1))\n \n    **Function Description: ** Write a python function to get the difference between two lists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be of type list.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The set of elements in the returned list must equal the symmetric difference between the elements of the two input lists.",
                "assert_statement": "assert set(result) == set(li1) ^ set(li2)"
            },
            {
                "description": "The returned list contains only unique elements, reflecting the nature of the symmetric difference operation.",
                "assert_statement": "assert len(result) == len(set(result))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 781,
        "Function_ID": 391,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the sum of fourth power of first n odd natural numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a non-negative integer, as the function calculates the sum of positive powers of positive numbers.",
                "assert_statement": "isinstance(result, int) and result >= 0"
            },
            {
                "description": "The calculated sum must equal the explicit mathematical summation of the fourth power of the first n odd numbers.",
                "assert_statement": "result == sum([(2 * k - 1) ** 4 for k in range(1, n + 1)])"
            },
            {
                "description": "If n is 0, the sum must be 0 (the empty sum).",
                "assert_statement": "n == 0 implies result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 782,
        "Function_ID": 391,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def odd_num_sum(n) : \n    j = 0\n    sm = 0\n    for i in range(1,n + 1) : \n        j = (2*i-1) \n        sm = sm + (j*j*j*j)   \n    return sm \n    **Function Description: ** Write a python function to find the sum of fourth power of first n odd natural numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer type.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned sum must be non-negative, as it calculates the sum of positive integers raised to the fourth power.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The function correctly handles the edge case where n is 0, returning 0 (sum of an empty set).",
                "assert_statement": "assert odd_num_sum(0) == 0"
            },
            {
                "description": "For n=2, the sum should be 1^4 + 3^4 = 1 + 81 = 82.",
                "assert_statement": "assert odd_num_sum(2) == 82"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 783,
        "Function_ID": 392,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the expression is validly balanced (all opening brackets have a corresponding, correctly sequenced closing bracket), the function must return True.",
                "assert_statement": "result == True"
            },
            {
                "description": "If the expression contains unmatched, incorrectly sequenced, or mismatched type of brackets, the function must return False.",
                "assert_statement": "result == False"
            },
            {
                "description": "The returned value must strictly be a boolean type.",
                "assert_statement": "isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 784,
        "Function_ID": 392,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from collections import deque\ndef check_expression(exp):\n    if len(exp) & 1:\n        return False\n    stack = deque()\n    for ch in exp:\n        if ch == '(' or ch == '{' or ch == '[':\n            stack.append(ch)\n        if ch == ')' or ch == '}' or ch == ']':\n            if not stack:\n                return False\n            top = stack.pop()\n            if (top == '(' and ch != ')') or (top == '{' and ch != '}' or (top == '[' and ch != ']')):\n                return False\n    return not stack\n    **Function Description: ** Write a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must always return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the expression contains correctly matched and nested parentheses, braces, and brackets, the function returns True.",
                "assert_statement": "assert check_expression('([{}])') is True"
            },
            {
                "description": "If the expression is unbalanced due to a type mismatch between an opening and closing bracket, the function returns False.",
                "assert_statement": "assert check_expression('{[}]') is False"
            },
            {
                "description": "If the expression is unbalanced because of an unmatched opening bracket remaining in the stack at the end, the function returns False.",
                "assert_statement": "assert check_expression('([)') is False"
            },
            {
                "description": "If the expression length is odd (guaranteeing imbalance), the function returns False.",
                "assert_statement": "assert check_expression('abc(') is False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 785,
        "Function_ID": 393,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to remove all the words with k length in the given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting output is a string.",
                "assert_statement": "isinstance(result, str)"
            },
            {
                "description": "No word token remaining in the resulting string has a length equal to k.",
                "assert_statement": "all(len(word) != k for word in result.split())"
            },
            {
                "description": "The set of unique words present in the result must exactly match the set of unique words from the original input ('text') that did not have length k.",
                "assert_statement": "set(result.split()) == set(word for word in text.split() if len(word) != k)"
            },
            {
                "description": "If the original string contained only words of length k (or was empty), the resulting string should contain no word tokens.",
                "assert_statement": "if not [word for word in text.split() if len(word) != k]: assert not result.split()"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 786,
        "Function_ID": 393,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def remove_length(test_str, K):\n  temp = test_str.split()\n  res = [ele for ele in temp if len(ele) != K]\n  res = ' '.join(res)\n  return (res) \n    **Function Description: ** Write a function to remove all the words with k length in the given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "No word remaining in the resulting string should have a length equal to K.",
                "assert_statement": "assert all(len(word) != K for word in result.split())"
            },
            {
                "description": "The number of words in the returned string is exactly the number of words from the original input string whose length was not K.",
                "assert_statement": "assert len(result.split()) == len([w for w in test_str.split() if len(w) != K])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 787,
        "Function_ID": 394,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the occurrence and position of the substrings within a string. Return None if there is no match.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the substring does not occur in the main string, the result must be None.",
                "assert_statement": "result is None if main_string.count(substring) == 0 else result is not None"
            },
            {
                "description": "If occurrences are found, the result must be a list (or iterable) of indices.",
                "assert_statement": "isinstance(result, list) if result is not None else True"
            },
            {
                "description": "The number of indices returned must exactly match the number of non-overlapping occurrences of the substring.",
                "assert_statement": "len(result) == main_string.count(substring) if result is not None else main_string.count(substring) == 0"
            },
            {
                "description": "Every index in the result list must accurately mark the starting position of the substring within the main string.",
                "assert_statement": "all(main_string[i:i + len(substring)] == substring for i in result) if result is not None else True"
            },
            {
                "description": "The indices returned must be integers and must be within the valid bounds of the main string.",
                "assert_statement": "all(isinstance(i, int) and 0 <= i < len(main_string) for i in result) if result is not None else True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 788,
        "Function_ID": 394,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef occurance_substring(text,pattern):\n for match in re.finditer(pattern, text):\n    s = match.start()\n    e = match.end()\n    return (text[s:e], s, e)\n    **Function Description: ** Write a function to find the occurrence and position of the substrings within a string. Return None if there is no match.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If a match is found, the return value is a tuple of length 3 consisting of the matched substring, the start index, and the end index.",
                "assert_statement": "assert isinstance(result, tuple) and len(result) == 3 and isinstance(result[0], str) and isinstance(result[1], int) and isinstance(result[2], int)"
            },
            {
                "description": "If a match is found, the returned substring must exactly match the slice of the input text defined by the start and end indices, and the indices must be valid.",
                "assert_statement": "assert result[0] == text[result[1]:result[2]] and 0 <= result[1] and result[1] < result[2] and result[2] <= len(text)"
            },
            {
                "description": "If the regex pattern is not found in the text, the function must return None.",
                "assert_statement": "if re.search(pattern, text) is None: assert result is None"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 789,
        "Function_ID": 395,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether every odd index contains odd numbers of a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function must return a boolean value (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The function returns True if and only if every element at an odd index (i=1, 3, 5, ...) in the input list is an odd number.",
                "assert_statement": "assert result == all(input_list[i] % 2 != 0 for i in range(1, len(input_list), 2))"
            },
            {
                "description": "If the function returns False, then at least one odd index contains an even number.",
                "assert_statement": "assert not result or any(input_list[i] % 2 == 0 for i in range(1, len(input_list), 2))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 790,
        "Function_ID": 395,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def odd_position(nums):\n\treturn all(nums[i]%2==i%2 for i in range(len(nums)))\n    **Function Description: ** Write a python function to check whether every odd index contains odd numbers of a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be a boolean (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, it guarantees that for every index i in the list, the parity of the element nums[i] is identical to the parity of the index i.",
                "assert_statement": "if result: assert all(nums[i] % 2 == i % 2 for i in range(len(nums)))"
            },
            {
                "description": "If the function returns False, it guarantees that there is at least one index i where the parity of the element nums[i] does not match the parity of the index i.",
                "assert_statement": "if not result: assert any(nums[i] % 2 != i % 2 for i in range(len(nums)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 791,
        "Function_ID": 396,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to count those characters which have vowels as their neighbors in the given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be zero if the string is too short (fewer than three characters) to have any internal character with two neighbors.",
                "assert_statement": "len(s) < 3 and result == 0"
            },
            {
                "description": "The returned count must be non-negative and cannot exceed the maximum possible number of characters that could satisfy the condition (which is the length of the string minus 2, excluding the boundary elements).",
                "assert_statement": "0 <= result <= max(0, len(s) - 2)"
            },
            {
                "description": "The result is equal to the total count of characters s[i] (where 0 < i < len(s) - 1) such that both its preceding character s[i-1] and its succeeding character s[i+1] are vowels (case-insensitive).",
                "assert_statement": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}; expected = sum(1 for i in range(1, len(s) - 1) if s[i-1] in vowels and s[i+1] in vowels); result == expected"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 792,
        "Function_ID": 396,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_vowels(test_str):\n  res = 0\n  vow_list = ['a', 'e', 'i', 'o', 'u']\n  for idx in range(1, len(test_str) - 1):\n    if test_str[idx] not in vow_list and (test_str[idx - 1] in vow_list or test_str[idx + 1] in vow_list):\n      res += 1\n  if test_str[0] not in vow_list and test_str[1] in vow_list:\n    res += 1\n  if test_str[-1] not in vow_list and test_str[-2] in vow_list:\n    res += 1\n  return (res) \n    **Function Description: ** Write a function to count those characters which have vowels as their neighbors in the given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "assert isinstance(RETURN_VALUE, int) and RETURN_VALUE >= 0"
            },
            {
                "description": "The returned count cannot exceed the total number of characters in the input string.",
                "assert_statement": "assert RETURN_VALUE <= len(test_str)"
            },
            {
                "description": "The return value must equal the count of all characters (case-sensitive) that are not 'a', 'e', 'i', 'o', or 'u', but have at least one adjacent neighbor (immediately preceding or succeeding) that is a vowel.",
                "assert_statement": "vowels = {'a', 'e', 'i', 'o', 'u'}; N = len(test_str); expected_count = 0; for i in range(N): if test_str[i] not in vowels: is_neighbor_vowel = (i > 0 and test_str[i-1] in vowels) or (i < N - 1 and test_str[i+1] in vowels); if is_neighbor_vowel: expected_count += 1; assert RETURN_VALUE == expected_count"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 793,
        "Function_ID": 397,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the sum of non-repeated elements in a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned sum must equal the sum of elements that appear exactly once in the input list. (Requires counting frequencies of elements).",
                "assert_statement": "import collections; expected_sum = sum(x for x, count in collections.Counter(input_list).items() if count == 1); result == expected_sum"
            },
            {
                "description": "If the input list is empty, the resulting sum must be zero.",
                "assert_statement": "not input_list or result == 0"
            },
            {
                "description": "The returned value must be a numeric type (integer or float).",
                "assert_statement": "isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 794,
        "Function_ID": 397,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def find_sum(arr): \n    arr.sort() \n    sum = arr[0] \n    for i in range(len(arr)-1): \n        if (arr[i] != arr[i+1]): \n            sum = sum + arr[i+1]   \n    return sum\n    **Function Description: ** Write a python function to find the sum of non-repeated elements in a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must equal the sum of all unique numerical values present in the original input list.",
                "assert_statement": "assert result == sum(set(original_arr_copy))"
            },
            {
                "description": "The input list is mutated in place and must be sorted after the function execution.",
                "assert_statement": "assert arr == sorted(arr)"
            },
            {
                "description": "If the input list is empty, an IndexError is raised when attempting to access the first element.",
                "assert_statement": "pytest.raises(IndexError, find_sum, [])"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 795,
        "Function_ID": 398,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to pack consecutive duplicates of a given list elements into sublists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The total sequence of elements, when the sublists are flattened, must exactly match the input list, preserving order.",
                "assert_statement": "[item for sublist in result for item in sublist] == input_list"
            },
            {
                "description": "Every sublist in the result must be homogeneous (all elements within the sublist must be identical).",
                "assert_statement": "all(all(e == sublist[0] for e in sublist) for sublist in result if sublist)"
            },
            {
                "description": "The grouping must be maximal; no two adjacent sublists can contain elements of the same value.",
                "assert_statement": "all(result[i][0] != result[i+1][0] for i in range(len(result) - 1))"
            },
            {
                "description": "The result must be a list containing sublists.",
                "assert_statement": "isinstance(result, list) and all(isinstance(sublist, list) for sublist in result)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 796,
        "Function_ID": 398,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from itertools import groupby\ndef pack_consecutive_duplicates(list1):\n    return [list(group) for key, group in groupby(list1)]\n    **Function Description: ** Write a function to pack consecutive duplicates of a given list elements into sublists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a list of lists.",
                "assert_statement": "assert isinstance(result, list) and all(isinstance(sublist, list) for sublist in result)"
            },
            {
                "description": "The total number of elements in all sublists must equal the length of the input list, ensuring no elements were lost or added.",
                "assert_statement": "assert sum(len(sublist) for sublist in result) == len(list1)"
            },
            {
                "description": "All elements within any single sublist must be identical, reflecting the grouping of duplicates.",
                "assert_statement": "assert all(all(item == sublist[0] for item in sublist) for sublist in result)"
            },
            {
                "description": "No two adjacent sublists should contain elements of the same value, confirming that consecutive duplicates were fully packed.",
                "assert_statement": "assert len(result) <= 1 or all(result[i][0] != result[i+1][0] for i in range(len(result) - 1))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 797,
        "Function_ID": 399,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to count the number of lists within a list. The function should return a dictionary, where every list is turned to a tuple, and the value of the tuple is the number of its occurrences.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a dictionary.",
                "assert_statement": "isinstance(result, dict)"
            },
            {
                "description": "All keys in the resulting dictionary must be tuples (representing the lists converted for hashing).",
                "assert_statement": "all(isinstance(key, tuple) for key in result.keys())"
            },
            {
                "description": "All values in the resulting dictionary must be positive integers, representing the counts.",
                "assert_statement": "all(isinstance(value, int) and value > 0 for value in result.values())"
            },
            {
                "description": "The sum of the counts in the result must equal the total number of lists found in the input.",
                "assert_statement": "sum(result.values()) == sum(1 for item in input_list if isinstance(item, list))"
            },
            {
                "description": "The set of keys in the result must exactly match the set of unique lists (converted to tuples) found in the input.",
                "assert_statement": "set(result.keys()) == {tuple(item) for item in input_list if isinstance(item, list)}"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 798,
        "Function_ID": 399,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def unique_sublists(list1):\n    result ={}\n    for l in list1: \n        result.setdefault(tuple(l), list()).append(1) \n    for a, b in result.items(): \n        result[a] = sum(b)\n    return result\n    **Function Description: ** Write a function to count the number of lists within a list. The function should return a dictionary, where every list is turned to a tuple, and the value of the tuple is the number of its occurrences.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a dictionary.",
                "assert_statement": "assert isinstance(result, dict)"
            },
            {
                "description": "All keys in the resulting dictionary are tuples, and all values are positive integers representing counts.",
                "assert_statement": "assert all(isinstance(k, tuple) and isinstance(v, int) and v > 0 for k, v in result.items())"
            },
            {
                "description": "The sum of all occurrence counts (dictionary values) must equal the total number of sublists in the input list.",
                "assert_statement": "assert sum(result.values()) == len(list1)"
            },
            {
                "description": "Every sublist present in the input (converted to a tuple) must be represented as a key in the output dictionary.",
                "assert_statement": "assert all(tuple(item) in result for item in list1)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 799,
        "Function_ID": 400,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is a list containing the computed combination sums.",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "All elements within the resulting list must be tuples.",
                "assert_statement": "assert all(isinstance(item, tuple) for item in result)"
            },
            {
                "description": "Assuming non-empty input tuples, the length of every resulting sum tuple must match the length of the input tuples.",
                "assert_statement": "assert not input_list or all(len(t) == len(input_list[0]) for t in result)"
            },
            {
                "description": "Every element in the resulting tuples must be a numeric value (the result of a sum).",
                "assert_statement": "assert all(isinstance(v, (int, float)) for t in result for v in t)"
            },
            {
                "description": "The total count of generated combinations must match the calculated total number of permutations of elements across the input tuples (e.g., if there are N input tuples of length M, the count is related to M!).",
                "assert_statement": "assert len(result) == len(input_list[0]) ** len(input_list)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 800,
        "Function_ID": 400,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** from itertools import combinations \ndef find_combinations(test_list):\n  res = [(b1 + a1, b2 + a2) for (a1, a2), (b1, b2) in combinations(test_list, 2)]\n  return (res) \n    **Function Description: ** Write a function to find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a list, and every element in that list is a tuple containing exactly two elements.",
                "assert_statement": "assert isinstance(result, list) and all(isinstance(item, tuple) and len(item) == 2 for item in result)"
            },
            {
                "description": "The length of the resulting list is equal to the number of unique combinations of size 2 that can be chosen from the input list (N * (N-1) / 2).",
                "assert_statement": "N = len(test_list); expected_len = N * (N - 1) // 2 if N >= 2 else 0; assert len(result) == expected_len"
            },
            {
                "description": "For a known input, the returned list contains the correctly calculated summed tuples corresponding to all unique pairs.",
                "assert_statement": "if test_list == [(1, 2), (3, 4), (5, 6)]: assert set(result) == {(4, 6), (6, 8), (8, 10)}"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 801,
        "Function_ID": 401,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether the count of divisors is even. https://www.w3resource.com/python-exercises/basic/python-basic-1-exercise-24.php",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the input number is a perfect square (e.g., 4, 9, 16), the count of its divisors is odd, and the function must return False.",
                "assert_statement": "assert result is False if n > 0 and (int(n**0.5) ** 2) == n"
            },
            {
                "description": "If the input number is NOT a perfect square (e.g., 2, 3, 5), the count of its divisors is even, and the function must return True.",
                "assert_statement": "assert result is True if n > 0 and (int(n**0.5) ** 2) != n"
            },
            {
                "description": "The function must always return a boolean value.",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 802,
        "Function_ID": 401,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import math \ndef count_divisors(n) : \n    count = 0\n    for i in range(1, (int)(math.sqrt(n)) + 2) : \n        if (n % i == 0) : \n            if( n // i == i) : \n                count = count + 1\n            else : \n                count = count + 2\n    return count % 2 == 0\n    **Function Description: ** Write a python function to check whether the count of divisors is even. https://www.w3resource.com/python-exercises/basic/python-basic-1-exercise-24.php",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the input positive integer 'n' is a perfect square (implying an odd number of divisors), the function returns False.",
                "assert_statement": "import math; if n >= 1 and int(math.sqrt(n))**2 == n: assert result is False"
            },
            {
                "description": "If the input positive integer 'n' is not a perfect square (implying an even number of divisors), the function returns True.",
                "assert_statement": "import math; if n >= 1 and int(math.sqrt(n))**2 != n: assert result is True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 803,
        "Function_ID": 402,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the sum of all odd length subarrays. https://www.geeksforgeeks.org/sum-of-all-odd-length-subarrays/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "If the input array contains only one element, the result must be equal to that element (since it forms one odd-length subarray).",
                "assert_statement": "len(arr) != 1 or result == arr[0]"
            },
            {
                "description": "The calculated total sum must match the analytically derived sum based on the contribution of each element to odd-length subarrays.",
                "assert_statement": "len(arr) == 0 or result == sum(arr[i] * ((((i + 1) * (len(arr) - i)) + 1) // 2) for i in range(len(arr)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 804,
        "Function_ID": 402,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def odd_length_sum(arr):\n    Sum = 0\n    l = len(arr)\n    for i in range(l):\n        Sum += ((((i + 1) *(l - i) + 1) // 2) * arr[i])\n    return Sum\n    **Function Description: ** Write a python function to find the sum of all odd length subarrays. https://www.geeksforgeeks.org/sum-of-all-odd-length-subarrays/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input array contains only integers, the return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "If the input array is empty, the returned sum must be 0.",
                "assert_statement": "assert odd_length_sum([]) == 0"
            },
            {
                "description": "The result must correctly calculate the sum of odd length subarrays for a known input, such as [1, 4, 2, 5, 3] which equals 58.",
                "assert_statement": "assert odd_length_sum([1, 4, 2, 5, 3]) == 58"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 805,
        "Function_ID": 403,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert rgb color to hsv color. https://www.geeksforgeeks.org/program-change-rgb-color-model-hsv-color-model/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The Hue (H) component must be within the standard range of 0 (inclusive) to 360 (exclusive) degrees.",
                "assert_statement": "0 <= result.H < 360"
            },
            {
                "description": "The Saturation (S) component must be normalized, ranging from 0.0 to 1.0.",
                "assert_statement": "0.0 <= result.S <= 1.0"
            },
            {
                "description": "The Value (V) component must be normalized, ranging from 0.0 to 1.0.",
                "assert_statement": "0.0 <= result.V <= 1.0"
            },
            {
                "description": "The Value (V) component must be equal to the maximum of the input R, G, and B components (assuming R, G, B are normalized to 0-1).",
                "assert_statement": "result.V == max(input.R, input.G, input.B)"
            },
            {
                "description": "If the input R, G, and B values are identical (grayscale/achromatic), the Saturation (S) must be zero.",
                "assert_statement": "if input.R == input.G and input.R == input.B: result.S == 0.0"
            },
            {
                "description": "If the Value (V) is zero (black), the Saturation (S) must also be zero.",
                "assert_statement": "if result.V == 0.0: result.S == 0.0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 806,
        "Function_ID": 403,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def rgb_to_hsv(r, g, b):\n    r, g, b = r/255.0, g/255.0, b/255.0\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx-mn\n    if mx == mn:\n        h = 0\n    elif mx == r:\n        h = (60 * ((g-b)/df) + 360) % 360\n    elif mx == g:\n        h = (60 * ((b-r)/df) + 120) % 360\n    elif mx == b:\n        h = (60 * ((r-g)/df) + 240) % 360\n    if mx == 0:\n        s = 0\n    else:\n        s = (df/mx)*100\n    v = mx*100\n    return h, s, v\n    **Function Description: ** Write a function to convert rgb color to hsv color. https://www.geeksforgeeks.org/program-change-rgb-color-model-hsv-color-model/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns a tuple containing exactly three numeric values (H, S, V).",
                "assert_statement": "assert isinstance(result, tuple) and len(result) == 3 and all(isinstance(x, (int, float)) for x in result)"
            },
            {
                "description": "The Hue (H) component must be non-negative and strictly less than 360 degrees.",
                "assert_statement": "assert 0 <= result[0] < 360"
            },
            {
                "description": "The Saturation (S) component must be represented as a percentage between 0 and 100, inclusive.",
                "assert_statement": "assert 0 <= result[1] <= 100"
            },
            {
                "description": "The Value (V) component must be represented as a percentage between 0 and 100, inclusive.",
                "assert_statement": "assert 0 <= result[2] <= 100"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 807,
        "Function_ID": 404,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find the product of first even and odd number of a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If both a first even number (E) and a first odd number (O) exist in the list, the result must be the product of E and O.",
                "assert_statement": "(next((e for e in input_list if e % 2 == 0), None) is not None and next((o for o in input_list if o % 2 != 0), None) is not None) and (result == next(e for e in input_list if e % 2 == 0) * next(o for o in input_list if o % 2 != 0))"
            },
            {
                "description": "If either the first even number or the first odd number cannot be found (or the list is empty), the result must indicate failure, typically 0.",
                "assert_statement": "(next((e for e in input_list if e % 2 == 0), None) is None or next((o for o in input_list if o % 2 != 0), None) is None) and (result == 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 808,
        "Function_ID": 404,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def mul_even_odd(list1):\n    first_even = next((el for el in list1 if el%2==0),-1)\n    first_odd = next((el for el in list1 if el%2!=0),-1)\n    return (first_even*first_odd)\n    **Function Description: ** Write a function to find the product of first even and odd number of a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The returned value is the product of the first even element found in the list (or -1 if no even element exists) and the first odd element found in the list (or -1 if no odd element exists).",
                "assert_statement": "_fe = next((el for el in list1 if el % 2 == 0), -1);_fo = next((el for el in list1 if el % 2 != 0), -1);assert result == (_fe * _fo)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 809,
        "Function_ID": 405,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to convert tuple string to integer tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The type of the converted result must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "All elements in the resulting tuple must be of type integer.",
                "assert_statement": "assert all(isinstance(x, int) for x in result)"
            },
            {
                "description": "If the input string represented an empty tuple ('()'), the result must be an empty tuple.",
                "assert_statement": "assert input_str != '()' or result == ()"
            },
            {
                "description": "The number of elements in the resulting tuple must equal the number of elements parsed from the string.",
                "assert_statement": "assert len(result) == expected_count"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 810,
        "Function_ID": 405,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def tuple_str_int(test_str):\n  res = tuple(int(num) for num in test_str.replace('(', '').replace(')', '').replace('...', '').split(', '))\n  return (res) \n    **Function Description: ** Write a function to convert tuple string to integer tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "All elements in the returned tuple must be integers.",
                "assert_statement": "assert all(isinstance(x, int) for x in result)"
            },
            {
                "description": "The length of the resulting tuple must equal the number of valid comma-space separated numerical elements found in the input string after cleaning.",
                "assert_statement": "cleaned_str = test_str.replace('(', '').replace(')', '').replace('...', ''); assert len(result) == len(cleaned_str.split(', ')) if cleaned_str.strip() else len(result) == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 811,
        "Function_ID": 406,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to locate the right insertion point for a specified value in sorted order.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned index must be non-negative.",
                "assert_statement": "i >= 0"
            },
            {
                "description": "The returned index must be less than or equal to the length of the input sequence.",
                "assert_statement": "i <= len(a)"
            },
            {
                "description": "If the index is not zero, the element immediately preceding the index must be less than or equal to the value being inserted (guaranteeing that all preceding elements satisfy the condition).",
                "assert_statement": "i == 0 or a[i - 1] <= x"
            },
            {
                "description": "If the index is less than the length of the sequence, the element at that index must be strictly greater than the value being inserted (guaranteeing that all subsequent elements satisfy the condition).",
                "assert_statement": "i == len(a) or a[i] > x"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 812,
        "Function_ID": 406,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import bisect\ndef right_insertion(a, x):\n    return bisect.bisect_right(a, x)\n    **Function Description: ** Write a function to locate the right insertion point for a specified value in sorted order.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value is a valid index, an integer between 0 and the length of the input list 'a', inclusive.",
                "assert_statement": "isinstance(result, int) and 0 <= result <= len(a)"
            },
            {
                "description": "The element immediately preceding the insertion index (if it exists) must be less than or equal to x.",
                "assert_statement": "result == 0 or a[result - 1] <= x"
            },
            {
                "description": "The element immediately following the insertion index (if it exists) must be strictly greater than x, consistent with a 'right' insertion.",
                "assert_statement": "result == len(a) or a[result] > x"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 813,
        "Function_ID": 407,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that matches a string that has an a followed by three 'b'.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The function returns True when the input string is exactly 'abbb'.",
                "assert_statement": "assert match_function('abbb') == True"
            },
            {
                "description": "The function returns False when the string has fewer than three 'b's (e.g., 'abb').",
                "assert_statement": "assert match_function('abb') == False"
            },
            {
                "description": "The function returns False when the string has more than three 'b's (e.g., 'abbbb').",
                "assert_statement": "assert match_function('abbbb') == False"
            },
            {
                "description": "The function returns False when the string contains extra characters before the pattern (assuming full string match is required).",
                "assert_statement": "assert match_function('cabbb') == False"
            },
            {
                "description": "The function returns False when the pattern is missing the required 'a'.",
                "assert_statement": "assert match_function('bbb') == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 814,
        "Function_ID": 407,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef text_match_three(text):\n        patterns = 'ab{3}?'\n        return re.search(patterns,  text)\n    **Function Description: ** Write a function that matches a string that has an a followed by three 'b'.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the pattern 'abbb' is present in the text, the function returns a re.Match object (not None).",
                "assert_statement": "import re; result = text_match_three('XabbbY'); assert result is not None and isinstance(result, type(re.search('', '')))"
            },
            {
                "description": "If the required pattern 'abbb' is not present in the text, the function returns None.",
                "assert_statement": "assert text_match_three('ababa') is None and text_match_three('abb') is None and text_match_three('abbbb') is None"
            },
            {
                "description": "When a match is found, the matched substring (group 0) must be exactly 'abbb'.",
                "assert_statement": "result = text_match_three('cabbbdz'); assert result is not None and result.group(0) == 'abbb'"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 815,
        "Function_ID": 408,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to create a new tuple from the given string and list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned object must be a tuple.",
                "assert_statement": "isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting tuple is equal to the length of the original list plus one (for the string element).",
                "assert_statement": "len(result) == len(lst) + 1"
            },
            {
                "description": "The original string is the first element of the new tuple.",
                "assert_statement": "result[0] == s"
            },
            {
                "description": "The remaining elements of the tuple match the elements of the original list in order.",
                "assert_statement": "result[1:] == tuple(lst)"
            },
            {
                "description": "The string element 's' is contained within the resulting tuple.",
                "assert_statement": "s in result"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 816,
        "Function_ID": 408,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def new_tuple(test_list, test_str):\n  return tuple(test_list + [test_str])\n    **Function Description: ** Write a function to create a new tuple from the given string and list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "The length of the resulting tuple must be one greater than the length of the input list, accounting for the added string element.",
                "assert_statement": "assert len(result) == len(test_list) + 1"
            },
            {
                "description": "The elements of the resulting tuple, excluding the last element, must match the elements of the original input list in order.",
                "assert_statement": "assert list(result[:-1]) == test_list"
            },
            {
                "description": "The last element of the resulting tuple must be the input string.",
                "assert_statement": "assert result[-1] == test_str"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 817,
        "Function_ID": 409,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to check whether every even index contains even numbers of a given list.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a boolean (True or False).",
                "assert_statement": "isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, every number at an even index must be even.",
                "assert_statement": "if result: assert all(lst[i] % 2 == 0 for i in range(0, len(lst), 2))"
            },
            {
                "description": "If the function returns False, there must be at least one odd number located at an even index.",
                "assert_statement": "if not result: assert any(lst[i] % 2 != 0 for i in range(0, len(lst), 2))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 818,
        "Function_ID": 409,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def even_position(nums):\n\treturn all(nums[i]%2==i%2 for i in range(len(nums)))\n    **Function Description: ** Write a python function to check whether every even index contains even numbers of a given list.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, it implies that the parity (evenness or oddness) of every element matches the parity of its index.",
                "assert_statement": "if result: assert all(nums[i] % 2 == i % 2 for i in range(len(nums)))"
            },
            {
                "description": "If the function returns False, there must be at least one index i where the parity of nums[i] is different from the parity of i.",
                "assert_statement": "if not result: assert any(nums[i] % 2 != i % 2 for i in range(len(nums)))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 819,
        "Function_ID": 410,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to remove tuples from the given tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a tuple.",
                "assert_statement": "isinstance(result, tuple)"
            },
            {
                "description": "No element in the resulting tuple should be a tuple.",
                "assert_statement": "all(not isinstance(item, tuple) for item in result)"
            },
            {
                "description": "The resulting tuple must be strictly composed of only the non-tuple elements found in the input tuple, preserving their original order.",
                "assert_statement": "result == tuple(item for item in input_tuple if not isinstance(item, tuple))"
            },
            {
                "description": "The length of the resulting tuple must be less than or equal to the length of the input tuple.",
                "assert_statement": "len(result) <= len(input_tuple)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 820,
        "Function_ID": 410,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def remove_nested(test_tup):\n  res = tuple()\n  for count, ele in enumerate(test_tup):\n    if not isinstance(ele, tuple):\n      res = res + (ele, )\n  return (res) \n    **Function Description: ** Write a function to remove tuples from the given tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a tuple.",
                "assert_statement": "assert isinstance(result, tuple)"
            },
            {
                "description": "No element in the resulting tuple is itself a tuple.",
                "assert_statement": "assert all(not isinstance(ele, tuple) for ele in result)"
            },
            {
                "description": "The length of the resulting tuple equals the count of non-tuple elements in the input tuple.",
                "assert_statement": "assert len(result) == sum(1 for ele in test_tup if not isinstance(ele, tuple))"
            },
            {
                "description": "The length of the resulting tuple is less than or equal to the length of the input tuple.",
                "assert_statement": "assert len(result) <= len(test_tup)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 821,
        "Function_ID": 411,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count the number of lists in a given number of lists.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer type.",
                "assert_statement": "isinstance(result, int)"
            },
            {
                "description": "The count of lists must be non-negative.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The count of lists cannot exceed the total number of elements in the input list.",
                "assert_statement": "result <= len(input_list)"
            },
            {
                "description": "If the input list is empty, the count of lists must be zero.",
                "assert_statement": "len(input_list) == 0 and result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 822,
        "Function_ID": 411,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_list(input_list): \n    return len(input_list)\n    **Function Description: ** Write a python function to count the number of lists in a given number of lists.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The return value must be equal to the length of the input list.",
                "assert_statement": "assert result == len(input_list)"
            },
            {
                "description": "The return value must be non-negative.",
                "assert_statement": "assert result >= 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 823,
        "Function_ID": 412,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the last position of an element in a sorted array.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the target element is not present in the array, the function must return -1.",
                "assert_statement": "target not in arr and result == -1"
            },
            {
                "description": "If the target element is found, the element at the returned index must equal the target.",
                "assert_statement": "result != -1 and arr[result] == target"
            },
            {
                "description": "If the target is found, the returned index must be the maximum valid index (the 'last position') where the element matches the target.",
                "assert_statement": "result != -1 and all(arr[i] != target for i in range(result + 1, len(arr)))"
            },
            {
                "description": "If the target is found, the index immediately following the returned index (if it exists) must contain an element different from the target, confirming the returned position is the last occurrence.",
                "assert_statement": "result != -1 and (result == len(arr) - 1 or arr[result + 1] != target)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 824,
        "Function_ID": 412,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def last(arr,x):\n    n = len(arr)\n    low = 0\n    high = n - 1\n    res = -1  \n    while (low <= high):\n        mid = (low + high) // 2 \n        if arr[mid] > x:\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            res = mid\n            low = mid + 1\n    return res\n    **Function Description: ** Write a python function to find the last position of an element in a sorted array.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the element is found (res != -1), the returned index must be a valid index within the bounds of the array.",
                "assert_statement": "if res != -1: assert 0 <= res < len(arr)"
            },
            {
                "description": "If the element is found (res != -1), the value at the returned index must equal the target element x.",
                "assert_statement": "if res != -1: assert arr[res] == x"
            },
            {
                "description": "If the element is found, the returned index 'res' must be the last occurrence, meaning the element immediately following it (if it exists) must not be equal to x.",
                "assert_statement": "if res != -1 and res < len(arr) - 1: assert arr[res + 1] != x"
            },
            {
                "description": "If the returned index is -1, the element 'x' must not be present anywhere in the input array.",
                "assert_statement": "if res == -1: assert x not in arr"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 825,
        "Function_ID": 413,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that matches a string that has an 'a' followed by anything, ending in 'b'.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "Returns True for a string that starts with 'a' and ends with 'b', having content in between.",
                "assert_statement": "match_function('a_test_string_b') == True"
            },
            {
                "description": "Returns True for the minimal matching string 'ab'.",
                "assert_statement": "match_function('ab') == True"
            },
            {
                "description": "Returns False if the string contains 'a' and 'b' but does not start with 'a'.",
                "assert_statement": "match_function('caub') == False"
            },
            {
                "description": "Returns False if the string starts with 'a' but does not end with 'b'.",
                "assert_statement": "match_function('a_test_c') == False"
            },
            {
                "description": "Returns False for an empty string.",
                "assert_statement": "match_function('') == False"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 826,
        "Function_ID": 413,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef text_starta_endb(text):\n        patterns = 'a.*?b$'\n        return re.search(patterns,  text)\n    **Function Description: ** Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If a match object is returned, the matched substring must correctly start with 'a' and end with 'b'.",
                "assert_statement": "if result is not None: assert result.group(0).startswith('a') and result.group(0).endswith('b')"
            },
            {
                "description": "If a match object is returned, the match must anchor to the end of the input string, meaning the match's end index must equal the length of the input string.",
                "assert_statement": "if result is not None: assert result.end() == len(text)"
            },
            {
                "description": "If the input string does not end in 'b', the function must return None, as required by the '$' anchor in the regex.",
                "assert_statement": "if not text.endswith('b'): assert result is None"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 827,
        "Function_ID": 414,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite function to find the sum of all items in the given dictionary.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must equal the mathematical sum of all values (not keys) contained within the input dictionary.",
                "assert_statement": "result == sum(data_dict.values())"
            },
            {
                "description": "If the input dictionary is empty, the calculated sum must be zero.",
                "assert_statement": "len(data_dict) == 0 and result == 0"
            },
            {
                "description": "The return type must be a numeric value (integer or float).",
                "assert_statement": "isinstance(result, (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 828,
        "Function_ID": 414,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def return_sum(dict):\n  sum = 0\n  for i in dict.values():\n    sum = sum + i\n  return sum\n    **Function Description: ** Write function to find the sum of all items in the given dictionary.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be equal to the mathematical sum of all values in the input dictionary.",
                "assert_statement": "assert result == sum(input_dict.values())"
            },
            {
                "description": "The returned value must be a numeric type (integer or float).",
                "assert_statement": "assert isinstance(result, (int, float))"
            },
            {
                "description": "If the input dictionary is empty, the returned sum must be zero.",
                "assert_statement": "assert len(input_dict) == 0 and result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 829,
        "Function_ID": 415,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the sum of all odd natural numbers within the range l and r.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The sum of natural numbers (positive integers) must be non-negative.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The returned sum must exactly equal the sum of all positive odd numbers within the defined range [l, r].",
                "assert_statement": "assert result == sum(i for i in range(l, r + 1) if i > 0 and i % 2 != 0)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 830,
        "Function_ID": 415,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def sum_odd(n): \n    terms = (n + 1)//2\n    sum1 = terms * terms \n    return sum1  \ndef sum_in_range(l,r): \n    return sum_odd(r) - sum_odd(l - 1)\n    **Function Description: ** Write a python function to find the sum of all odd natural numbers within the range l and r.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer, as it represents the sum of natural numbers.",
                "assert_statement": "assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "If the range [l, r] contains only even numbers (e.g., l=4, r=4), the resulting sum of odd numbers must be zero.",
                "assert_statement": "assert sum_in_range(4, 4) == 0"
            },
            {
                "description": "The function correctly calculates the sum for a range starting at 1 (e.g., [1, 5]), which is 1 + 3 + 5 = 9.",
                "assert_statement": "assert sum_in_range(1, 5) == 9"
            },
            {
                "description": "The function correctly calculates the sum for a large range (e.g., [10, 20]), yielding 11 + 13 + 15 + 17 + 19 = 75.",
                "assert_statement": "assert sum_in_range(10, 20) == 75"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 831,
        "Function_ID": 416,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the sum of an array.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must equal the mathematical sum of all elements in the input array.",
                "assert_statement": "result == sum(input_array)"
            },
            {
                "description": "The returned value must be a numeric type (integer or float).",
                "assert_statement": "isinstance(result, (int, float))"
            },
            {
                "description": "If the input array is empty, the result must be zero.",
                "assert_statement": "len(input_array) == 0 and result == 0"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 832,
        "Function_ID": 416,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def _sum(arr):  \n    sum=0\n    for i in arr: \n        sum = sum + i      \n    return(sum)  \n    **Function Description: ** Write a python function to find the sum of an array.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned sum is 0 when the input array is empty.",
                "assert_statement": "assert _sum([]) == 0"
            },
            {
                "description": "The returned value is numerically equal to the sum calculated by Python's built-in sum function, verified using a sample list including floats and negative numbers.",
                "assert_statement": "test_arr = [10, -5, 2.5, 0]; assert _sum(test_arr) == sum(test_arr)"
            },
            {
                "description": "The return value must be of a standard numeric type (integer or float).",
                "assert_statement": "assert isinstance(_sum([1, 2, 3.0]), (int, float))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 833,
        "Function_ID": 417,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must equal the standard 32-bit left rotation formula. The effective shift amount (d mod 32) is used, and the operation must wrap around 32 bits.",
                "assert_statement": "d_eff = d % 32; assert result == (((n << d_eff) | (n >> (32 - d_eff))) & 0xFFFFFFFF)"
            },
            {
                "description": "The result must remain within the bounds of a 32-bit unsigned integer.",
                "assert_statement": "assert 0 <= result < (1 << 32)"
            },
            {
                "description": "If d is 0, the number remains unchanged (identity property).",
                "assert_statement": "if d % 32 == 0: assert result == n"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 834,
        "Function_ID": 417,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def left_rotate(n,d):   \n    INT_BITS = 32\n    return (n << d)|(n >> (INT_BITS - d))  \n    **Function Description: ** Write a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must always be an integer.",
                "assert_statement": "assert isinstance(left_rotate(10, 5), int)"
            },
            {
                "description": "The returned integer matches the exact bitwise combination (n << d) | (n >> (32 - d)). Testing a case where the result exceeds 2^32 (n = 2^31, d=1).",
                "assert_statement": "assert left_rotate(2147483648, 1) == 4294967297"
            },
            {
                "description": "When the result is masked to 32 bits (0xFFFFFFFF), it correctly represents the intended circular left rotation for a general 32-bit number.",
                "assert_statement": "N = 0xCAFEBAB0; D = 12; expected_masked = 0xFEBAB0CA; assert (left_rotate(N, D) & 0xFFFFFFFF) == expected_masked"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 835,
        "Function_ID": 418,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to remove all whitespaces from a string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The resulting string must contain no whitespace characters.",
                "assert_statement": "all(not char.isspace() for char in result)"
            },
            {
                "description": "The length of the resulting string must equal the count of non-whitespace characters in the original input.",
                "assert_statement": "len(result) == sum(1 for char in input_string if not char.isspace())"
            },
            {
                "description": "The content of the resulting string must consist only of the non-whitespace characters from the input, preserving their original order.",
                "assert_statement": "result == ''.join(char for char in input_string if not char.isspace())"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 836,
        "Function_ID": 418,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** import re\ndef remove_all_spaces(text):\n return (re.sub(r'\\s+', '',text))\n    **Function Description: ** Write a function to remove all whitespaces from a string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be a string.",
                "assert_statement": "assert isinstance(result, str)"
            },
            {
                "description": "The returned string must not contain any whitespace characters (space, tab, newline, etc.).",
                "assert_statement": "import re; assert re.search(r'\\s', result) is None"
            },
            {
                "description": "The length of the resulting string must be less than or equal to the length of the input string.",
                "assert_statement": "assert len(result) <= len(text)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 837,
        "Function_ID": 419,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count the number of equal numbers from three given integers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result is 3 if all three input numbers (a, b, c) are identical.",
                "assert_statement": "(a == b and b == c) and result == 3"
            },
            {
                "description": "The result is 2 if exactly two of the input numbers are identical and the third is different.",
                "assert_statement": "((a == b and a != c) or (a == c and a != b) or (b == c and b != a)) and result == 2"
            },
            {
                "description": "The result is 0 if all three input numbers are distinct.",
                "assert_statement": "(a != b and b != c and a != c) and result == 0"
            },
            {
                "description": "The result must be an integer (0, 2, or 3).",
                "assert_statement": "result in [0, 2, 3] and isinstance(result, int)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 838,
        "Function_ID": 419,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def test_three_equal(x,y,z):\n  result = set([x,y,z])\n  if len(result)==3:\n    return 0\n  else:\n    return 4-len(result)\n    **Function Description: ** Write a python function to count the number of equal numbers from three given integers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If all three inputs (x, y, z) are distinct, the function must return 0.",
                "assert_statement": "assert ret_val == 0 if len(set([x, y, z])) == 3 else True"
            },
            {
                "description": "If exactly two of the inputs are equal (two unique values), the function must return 2.",
                "assert_statement": "assert ret_val == 2 if len(set([x, y, z])) == 2 else True"
            },
            {
                "description": "If all three inputs (x, y, z) are equal (one unique value), the function must return 3.",
                "assert_statement": "assert ret_val == 3 if len(set([x, y, z])) == 1 else True"
            },
            {
                "description": "The return value must be an integer and must be one of {0, 2, 3}.",
                "assert_statement": "assert isinstance(ret_val, int) and ret_val in {0, 2, 3}"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 839,
        "Function_ID": 420,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to count the number of rotations required to generate a sorted array. https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-array/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The number of rotations must be non-negative.",
                "assert_statement": "result >= 0"
            },
            {
                "description": "The number of rotations cannot exceed the length of the array (N-1 being the maximum possible rotation count for a standard array).",
                "assert_statement": "len(arr) == 0 or result < len(arr)"
            },
            {
                "description": "The resulting count must be equal to the index of the minimum element in the array (which represents the starting point of the sorted sequence).",
                "assert_statement": "result == arr.index(min(arr))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 840,
        "Function_ID": 420,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def count_rotation(arr):   \n    for i in range (1,len(arr)): \n        if (arr[i] < arr[i - 1]): \n            return i  \n    return 0\n    **Function Description: ** Write a python function to count the number of rotations required to generate a sorted array. https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-array/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a non-negative integer.",
                "assert_statement": "result = count_rotation([5, 1, 2, 3, 4]); assert isinstance(result, int) and result >= 0"
            },
            {
                "description": "The calculated rotation count must be strictly less than the length of the input array.",
                "assert_statement": "arr = [10, 20, 30]; result = count_rotation(arr); assert result < len(arr)"
            },
            {
                "description": "If the array is already sorted (zero rotations), the function must return 0.",
                "assert_statement": "assert count_rotation([1, 2, 3, 4, 5]) == 0"
            },
            {
                "description": "If the array is rotated 'k' times, the function must return 'k' (the index of the minimum element).",
                "assert_statement": "assert count_rotation([3, 4, 5, 1, 2]) == 3"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 841,
        "Function_ID": 421,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns true, the input number must be a non-negative integer that is the square of some other integer.",
                "assert_statement": "if result: assert N >= 0 and int(N**0.5) * int(N**0.5) == N"
            },
            {
                "description": "If the function returns false, the input number must not satisfy the perfect square property (it is negative, or no integer squared equals N).",
                "assert_statement": "if not result: assert N < 0 or int(N**0.5) * int(N**0.5) != N"
            },
            {
                "description": "The result must be mathematically equivalent to checking if N is non-negative and the difference between N and the square of its integer root is zero.",
                "assert_statement": "result == (N >= 0 and (int(N**0.5)**2 == N))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 842,
        "Function_ID": 421,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_perfect_square(n) :\n    i = 1\n    while (i * i<= n):\n        if ((n % i == 0) and (n / i == i)):\n            return True     \n        i = i + 1\n    return False\n    **Function Description: ** Write a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The function must always return a boolean value (True or False).",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "If the function returns True, the input number n must mathematically be a perfect square (i.e., the square root of n must be an integer).",
                "assert_statement": "if result: import math; assert math.isclose(math.sqrt(n) % 1, 0) or n == 0"
            },
            {
                "description": "If the function returns False for a positive input n, then n is not a perfect square.",
                "assert_statement": "if not result and n > 0: import math; k = int(math.sqrt(n)); assert k * k != n"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 843,
        "Function_ID": 422,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check whether the product of numbers in a list is even or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The product is determined to be even (result is True) if and only if the input list contains at least one even number.",
                "assert_statement": "result == any(n % 2 == 0 for n in input_list)"
            },
            {
                "description": "The result is False (product is odd) if and only if every number in the input list is odd.",
                "assert_statement": "result == False if all(n % 2 != 0 for n in input_list) and len(input_list) > 0 else result"
            },
            {
                "description": "The function must return a boolean value.",
                "assert_statement": "isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 844,
        "Function_ID": 422,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def is_product_even(arr): \n    for i in range(len(arr)): \n        if (arr[i] & 1) == 0: \n            return True\n    return False\n    **Function Description: ** Write a function to check whether the product of numbers in a list is even or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be True if the input list contains at least one even integer.",
                "assert_statement": "assert is_product_even([1, 3, 10, 5]) == True"
            },
            {
                "description": "The return value must be False if all integers in the input list are odd.",
                "assert_statement": "assert is_product_even([1, 3, 5, 7]) == False"
            },
            {
                "description": "The function correctly handles the case of an empty list, returning False (as the product is multiplicatively 1, which is odd).",
                "assert_statement": "assert is_product_even([]) == False"
            },
            {
                "description": "The return value must always be a boolean type.",
                "assert_statement": "assert isinstance(is_product_even([4, 5]), bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 0.0
    },
    {
        "Prompt_ID": 845,
        "Function_ID": 423,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a function that returns the list in a list of lists whose sum of elements is the highest.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The sum of the elements in the returned list must equal the maximum sum found among all input lists.",
                "assert_statement": "assert sum(result) == max(sum(lst) for lst in input_lists if input_lists)"
            },
            {
                "description": "The returned result must be a list (assuming the input list is not empty, otherwise the function behavior for empty input is defined separately).",
                "assert_statement": "assert isinstance(result, list)"
            },
            {
                "description": "The returned list must be an exact member of the original list of lists.",
                "assert_statement": "assert result in input_lists"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 846,
        "Function_ID": 423,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_sum_list(lists):\n return max(lists, key=sum)\n    **Function Description: ** Write a function that returns the list in a list of lists whose sum of elements is the highest.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be one of the lists provided in the input list of lists.",
                "assert_statement": "assert result in lists"
            },
            {
                "description": "The sum of the elements in the returned list must be greater than or equal to the sum of every other list present in the input.",
                "assert_statement": "assert all(sum(result) >= sum(l) for l in lists)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 847,
        "Function_ID": 424,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to find maximum run of uppercase characters in the given string.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "The result must be a non-negative integer and cannot exceed the length of the input string.",
                "assert_statement": "isinstance(result, int) and 0 <= result <= len(s)"
            },
            {
                "description": "If the input string contains no uppercase characters, the result must be zero.",
                "assert_statement": "result == 0 if all(not c.isupper() for c in s) else True"
            },
            {
                "description": "No substring of length 'result + 1' in the input string should consist entirely of uppercase characters (ensuring maximality).",
                "assert_statement": "all(not s[i:i+result+1].isupper() for i in range(len(s) - result))"
            },
            {
                "description": "If the result is greater than zero, there must exist at least one substring of length 'result' composed entirely of uppercase characters.",
                "assert_statement": "any(s[i:i+result].isupper() for i in range(len(s) - result + 1)) if result > 0 else True"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 848,
        "Function_ID": 424,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def max_run_uppercase(test_str):\n  cnt = 0\n  res = 0\n  for idx in range(0, len(test_str)):\n    if test_str[idx].isupper():\n      cnt += 1\n    else:\n      res = cnt\n      cnt = 0\n  if test_str[len(test_str) - 1].isupper():\n    res = cnt\n  return (res)\n    **Function Description: ** Write a function to find maximum run of uppercase characters in the given string.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value must be an integer.",
                "assert_statement": "assert isinstance(result, int)"
            },
            {
                "description": "The maximum run length must be non-negative.",
                "assert_statement": "assert result >= 0"
            },
            {
                "description": "The maximum run length cannot exceed the total length of the input string.",
                "assert_statement": "assert result <= len(test_str)"
            },
            {
                "description": "The return value equals the maximum number of consecutive uppercase characters found in the string, assuming the implementation successfully computes the requirement.",
                "assert_statement": "assert result == (lambda s: max([sum(1 for _ in g) for k, g in __import__('itertools').groupby(s, key=str.isupper) if k], default=0))(test_str)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 849,
        "Function_ID": 425,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function toWrite a python function to find the first odd number in a given list of numbers.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns a value (not None), that value must be an odd number.",
                "assert_statement": "if result is not None: assert result % 2 != 0"
            },
            {
                "description": "If a number is returned, all numbers preceding it in the original input list must be even (guaranteeing it is the first odd number found).",
                "assert_statement": "if result is not None: assert all(num % 2 == 0 for num in numbers[:numbers.index(result)])"
            },
            {
                "description": "If the function returns None (indicating no odd number was found), then every number in the input list must be even.",
                "assert_statement": "if result is None: assert all(num % 2 == 0 for num in numbers)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 850,
        "Function_ID": 425,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def first_odd(nums):\n  first_odd = next((el for el in nums if el%2!=0),-1)\n  return first_odd\n    **Function Description: ** Write a python function to find the first odd number in a given list of numbers.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "If the input list contains at least one odd number, the returned value must be odd.",
                "assert_statement": "if result != -1: assert result % 2 != 0"
            },
            {
                "description": "If the input list contains no odd numbers (or is empty), the return value must be -1.",
                "assert_statement": "if not any(n % 2 != 0 for n in nums): assert result == -1"
            },
            {
                "description": "If an odd number is returned, it must be the first odd number in the sequence, meaning all elements preceding it must be even.",
                "assert_statement": "if result != -1: assert all(x % 2 == 0 for i, x in enumerate(nums) if i < nums.index(result))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 851,
        "Function_ID": 426,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check if the given tuples contain the k or not.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the function returns True, the element k must be present in at least one tuple within the input list.",
                "assert_statement": "if result: assert any(k in tup for tup in list_of_tuples)"
            },
            {
                "description": "If the function returns False, the element k must not be present in any tuple within the input list.",
                "assert_statement": "if not result: assert not any(k in tup for tup in list_of_tuples)"
            },
            {
                "description": "The return value must always be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 852,
        "Function_ID": 426,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_K(test_tup, K):\n  res = False\n  for ele in test_tup:\n    if ele == K:\n      res = True\n      break\n  return res \n    **Function Description: ** Write a function to check if the given tuples contain the k or not.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The returned value accurately reflects whether the element K exists within the input iterable (test_tup).",
                "assert_statement": "assert result == (K in test_tup)"
            },
            {
                "description": "The function must always return a value of boolean type.",
                "assert_statement": "assert isinstance(result, bool)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 853,
        "Function_ID": 427,
        "Prompt_Text": "provide the assert statements of the postconditions (in JSON format with the description and assert statement only) for a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.",
        "Prompt_Strategy": "Naive_strategy",
        "Post_Conditions": [
            {
                "description": "If the tuples have the same length and every element in the second tuple (tuple_b) is strictly smaller than the corresponding element in the first tuple (tuple_a), the function returns True.",
                "assert_statement": "result is True and len(tuple_a) == len(tuple_b) and all(b < a for a, b in zip(tuple_a, tuple_b))"
            },
            {
                "description": "If the tuples have the same length but at least one element in the second tuple is greater than or equal to its corresponding element in the first tuple, the function returns False.",
                "assert_statement": "result is False and len(tuple_a) == len(tuple_b) and any(b >= a for a, b in zip(tuple_a, tuple_b))"
            },
            {
                "description": "If the lengths of the two tuples are unequal, the function returns False.",
                "assert_statement": "result is False and len(tuple_a) != len(tuple_b)"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    },
    {
        "Prompt_ID": 854,
        "Function_ID": 427,
        "Prompt_Text": "You are an expert software engineer tasked with generating verifiable postconditions for a given Python function. \n    **Task:**\n    1. **Analyze** the provided function code and its docstring. \n    2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n    3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state. \n    **Required JSON Output Format:** \n    The final output must be a single JSON object with a key `postconditions`. Each element in the list must have two keys: \n       - `description`: A plain language statement of the condition (e.g., \"The return value is an integer greater than 0.\"). \n       - `assert_statement`: The exact Python `assert` or `pytest.raises` statement needed to verify the condition.\n    **Python Function:** def check_smaller(test_tup1, test_tup2):\n  return all(x > y for x, y in zip(test_tup1, test_tup2))\n    **Function Description: ** Write a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.",
        "Prompt_Strategy": "ChainOfThought_strategy",
        "Post_Conditions": [
            {
                "description": "The return value must be a boolean.",
                "assert_statement": "assert isinstance(result, bool)"
            },
            {
                "description": "The return value is True if and only if every element in the first tuple (test_tup1) is strictly greater than its corresponding element in the second tuple (test_tup2), considering only pairs up to the length of the shorter input.",
                "assert_statement": "assert result == all(x > y for x, y in zip(test_tup1, test_tup2))"
            }
        ],
        "Correctness_Score": 0.0,
        "Mutation_Score": 0.0,
        "Hallucination_Score": 1.0
    }
]