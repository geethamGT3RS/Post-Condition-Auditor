[{
  "_id": {
    "$oid": "692721745ac066c866d58c93"
  },
  "Function_ID": 1,
  "Function_Description": "Write a function to find the shared elements from the given two lists.",
  "Function_Code": "def similar_elements(test_tup1, test_tup2):\n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert set(similar_elements((3, 4, 5, 6),(5, 7, 4, 10))) == set((4, 5))",
    "assert set(similar_elements((1, 2, 3, 4),(5, 4, 3, 7))) == set((3, 4))",
    "assert set(similar_elements((11, 12, 14, 13),(17, 15, 14, 13))) == set((13, 14))"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 1,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the shared elements from the given two lists to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 2,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def similar_elements(test_tup1, test_tup2):\n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) \n        **Function Description: ** Write a function to find the shared elements from the given two lists.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_1.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58c94"
  },
  "Function_ID": 2,
  "Function_Description": "Write a python function to identify non-prime numbers.",
  "Function_Code": "import math\ndef is_not_prime(n):\n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert is_not_prime(2) == False",
    "assert is_not_prime(10) == True",
    "assert is_not_prime(35) == True",
    "assert is_not_prime(37) == False"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 3,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   identify non-prime numbers to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 4,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** import math\ndef is_not_prime(n):\n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result\n        **Function Description: ** Write a python function to identify non-prime numbers.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_2.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58c95"
  },
  "Function_ID": 3,
  "Function_Description": "Write a function to find the n largest integers from a given list of numbers, returned in descending order.",
  "Function_Code": "import heapq as hq\ndef heap_queue_largest(nums,n):\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65]",
    "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],2)==[85, 75]",
    "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[85, 75, 65, 58, 35]"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 5,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the n largest integers from a given list of numbers, returned in descending order to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 6,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** import heapq as hq\ndef heap_queue_largest(nums,n):\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums\n        **Function Description: ** Write a function to find the n largest integers from a given list of numbers, returned in descending order.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_3.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58c96"
  },
  "Function_ID": 4,
  "Function_Description": "Write a python function to check whether the two numbers differ at one bit position only or not.",
  "Function_Code": "def is_Power_Of_Two (x): \n    return x and (not(x & (x - 1))) \ndef differ_At_One_Bit_Pos(a,b): \n    return is_Power_Of_Two(a ^ b)",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert differ_At_One_Bit_Pos(13,9) == True",
    "assert differ_At_One_Bit_Pos(15,8) == False",
    "assert differ_At_One_Bit_Pos(2,4) == False",
    "assert differ_At_One_Bit_Pos(2, 3) == True",
    "assert differ_At_One_Bit_Pos(5, 1) == True",
    "assert differ_At_One_Bit_Pos(1, 5) == True"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 7,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check whether the two numbers differ at one bit position only or not to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 8,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def is_Power_Of_Two (x): \n    return x and (not(x & (x - 1))) \ndef differ_At_One_Bit_Pos(a,b): \n    return is_Power_Of_Two(a ^ b)\n        **Function Description: ** Write a python function to check whether the two numbers differ at one bit position only or not.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_4.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58c97"
  },
  "Function_ID": 5,
  "Function_Description": "Write a function to find all words which are at least 4 characters long in a string.",
  "Function_Code": "import re\ndef find_char_long(text):\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert set(find_char_long('Please move back to stream')) == set(['Please', 'move', 'back', 'stream'])",
    "assert set(find_char_long('Jing Eco and Tech')) == set(['Jing', 'Tech'])",
    "assert set(find_char_long('Jhingai wulu road Zone 3')) == set(['Jhingai', 'wulu', 'road', 'Zone'])"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 9,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find all words which are at least 4 characters long in a string to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 10,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** import re\ndef find_char_long(text):\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))\n        **Function Description: ** Write a function to find all words which are at least 4 characters long in a string.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_5.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58c98"
  },
  "Function_ID": 6,
  "Function_Description": "Write a function to find squares of individual elements in a list.",
  "Function_Code": "def square_nums(nums):\n square_nums = list(map(lambda x: x ** 2, nums))\n return square_nums",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]",
    "assert square_nums([10,20,30])==([100,400,900])",
    "assert square_nums([12,15])==([144,225])"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 11,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find squares of individual elements in a list to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 12,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def square_nums(nums):\n square_nums = list(map(lambda x: x ** 2, nums))\n return square_nums\n        **Function Description: ** Write a function to find squares of individual elements in a list.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_6.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58c99"
  },
  "Function_ID": 7,
  "Function_Description": "Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.",
  "Function_Code": "def find_Rotations(str): \n    tmp = str + str\n    n = len(str) \n    for i in range(1,n + 1): \n        substring = tmp[i: i+n] \n        if (str == substring): \n            return i \n    return n ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert find_Rotations(\"aaaa\") == 1",
    "assert find_Rotations(\"ab\") == 2",
    "assert find_Rotations(\"abc\") == 3"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 13,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the minimum number of rotations (greater than 0) required to get the same string to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 14,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def find_Rotations(str): \n    tmp = str + str\n    n = len(str) \n    for i in range(1,n + 1): \n        substring = tmp[i: i+n] \n        if (str == substring): \n            return i \n    return n \n        **Function Description: ** Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_7.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58c9a"
  },
  "Function_ID": 8,
  "Function_Description": "Write a python function to remove first and last occurrence of a given character from the string.",
  "Function_Code": "def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert remove_Occ(\"hello\",\"l\") == \"heo\"",
    "assert remove_Occ(\"abcda\",\"a\") == \"bcd\"",
    "assert remove_Occ(\"PHP\",\"P\") == \"H\""
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 15,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   remove first and last occurrence of a given character from the string to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 16,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s \n        **Function Description: ** Write a python function to remove first and last occurrence of a given character from the string.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_8.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58c9b"
  },
  "Function_ID": 9,
  "Function_Description": "Write a function to sort a given matrix in ascending order according to the sum of its rows.",
  "Function_Code": "def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
    "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
    "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 17,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   sort a given matrix in ascending order according to the sum of its rows to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 18,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result\n        **Function Description: ** Write a function to sort a given matrix in ascending order according to the sum of its rows.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_9.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58c9c"
  },
  "Function_ID": 10,
  "Function_Description": "Write a python function to find the volume of a triangular prism.",
  "Function_Code": "def find_Volume(l,b,h) : \n    return ((l * b * h) / 2) ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert find_Volume(10,8,6) == 240",
    "assert find_Volume(3,2,2) == 6",
    "assert find_Volume(1,2,1) == 1"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 19,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the volume of a triangular prism to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 20,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def find_Volume(l,b,h) : \n    return ((l * b * h) / 2) \n        **Function Description: ** Write a python function to find the volume of a triangular prism.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_10.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58c9d"
  },
  "Function_ID": 11,
  "Function_Description": "Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.",
  "Function_Code": "import re\ndef text_lowercase_underscore(text):\n        patterns = '^[a-z]+_[a-z]+$'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert text_lowercase_underscore(\"aab_cbbbc\")==(True)",
    "assert text_lowercase_underscore(\"aab_Abbbc\")==(False)",
    "assert text_lowercase_underscore(\"Aaab_abbbc\")==(False)"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 21,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 22,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** import re\ndef text_lowercase_underscore(text):\n        patterns = '^[a-z]+_[a-z]+$'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n        **Function Description: ** Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_11.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58c9e"
  },
  "Function_ID": 12,
  "Function_Description": "Write a function that returns the perimeter of a square given its side length as input.",
  "Function_Code": "def square_perimeter(a):\n  perimeter=4*a\n  return perimeter",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert square_perimeter(10)==40",
    "assert square_perimeter(5)==20",
    "assert square_perimeter(4)==16"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 23,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to Write a function that returns the perimeter of a square given its side length as input to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 24,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def square_perimeter(a):\n  perimeter=4*a\n  return perimeter\n        **Function Description: ** Write a function that returns the perimeter of a square given its side length as input.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_12.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58c9f"
  },
  "Function_ID": 13,
  "Function_Description": "Write a function to remove characters from the first string which are present in the second string.",
  "Function_Code": "NO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
    "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
    "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles'"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 25,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   remove characters from the first string which are present in the second string to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 26,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** NO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) \n        **Function Description: ** Write a function to remove characters from the first string which are present in the second string.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_13.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ca0"
  },
  "Function_ID": 14,
  "Function_Description": "Write a function to find whether a given array of integers contains any duplicate element.",
  "Function_Code": "def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert test_duplicate(([1,2,3,4,5]))==False",
    "assert test_duplicate(([1,2,3,4, 4]))==True",
    "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 27,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find whether a given array of integers contains any duplicate element to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 28,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     \n        **Function Description: ** Write a function to find whether a given array of integers contains any duplicate element.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_14.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ca1"
  },
  "Function_ID": 15,
  "Function_Description": "Write a function to check if the given number is woodball or not.",
  "Function_Code": "def is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert is_woodall(383) == True",
    "assert is_woodall(254) == False",
    "assert is_woodall(200) == False"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 29,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check if the given number is woodball or not to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 30,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False\n        **Function Description: ** Write a function to check if the given number is woodball or not.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_15.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ca2"
  },
  "Function_ID": 16,
  "Function_Description": "Write a python function to check if a given number is one less than twice its reverse.",
  "Function_Code": "def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert check(70) == False",
    "assert check(23) == False",
    "assert check(73) == True"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 31,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check if a given number is one less than twice its reverse to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 32,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  \n        **Function Description: ** Write a python function to check if a given number is one less than twice its reverse.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_16.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ca3"
  },
  "Function_ID": 17,
  "Function_Description": "Write a python function to find the largest number that can be formed with the given list of digits.",
  "Function_Code": "def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert find_Max_Num([1,2,3]) == 321",
    "assert find_Max_Num([4,5,6,1]) == 6541",
    "assert find_Max_Num([1,2,3,9]) == 9321"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 33,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the largest number that can be formed with the given list of digits to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 34,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num \n        **Function Description: ** Write a python function to find the largest number that can be formed with the given list of digits.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_17.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ca4"
  },
  "Function_ID": 18,
  "Function_Description": "Write a python function to check whether the given two integers have opposite sign or not.",
  "Function_Code": "def opposite_Signs(x,y): \n    return ((x ^ y) < 0); ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert opposite_Signs(1,-2) == True",
    "assert opposite_Signs(3,2) == False",
    "assert opposite_Signs(-10,-10) == False",
    "assert opposite_Signs(-2,2) == True"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 35,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check whether the given two integers have opposite sign or not to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 36,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def opposite_Signs(x,y): \n    return ((x ^ y) < 0); \n        **Function Description: ** Write a python function to check whether the given two integers have opposite sign or not.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_18.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ca5"
  },
  "Function_ID": 19,
  "Function_Description": "Write a function to find the nth octagonal number.",
  "Function_Code": "def is_octagonal(n): \n\treturn 3 * n * n - 2 * n ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert is_octagonal(5) == 65",
    "assert is_octagonal(10) == 280",
    "assert is_octagonal(15) == 645"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 37,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the nth octagonal number to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 38,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def is_octagonal(n): \n\treturn 3 * n * n - 2 * n \n        **Function Description: ** Write a function to find the nth octagonal number.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_19.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ca6"
  },
  "Function_ID": 20,
  "Function_Description": "Write a python function to count the number of substrings with the sum of digits equal to their length.",
  "Function_Code": "from collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert count_Substrings('112112') == 6",
    "assert count_Substrings('111') == 6",
    "assert count_Substrings('1101112') == 12"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 39,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   count the number of substrings with the sum of digits equal to their length to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 40,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** from collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count\n        **Function Description: ** Write a python function to count the number of substrings with the sum of digits equal to their length.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_20.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ca7"
  },
  "Function_ID": 21,
  "Function_Description": "Write a python function to find smallest number in a list.",
  "Function_Code": "def smallest_num(xs):\n  return min(xs)\n",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert smallest_num([10, 20, 1, 45, 99]) == 1",
    "assert smallest_num([1, 2, 3]) == 1",
    "assert smallest_num([45, 46, 50, 60]) == 45"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 41,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find smallest number in a list to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 42,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def smallest_num(xs):\n  return min(xs)\n\n        **Function Description: ** Write a python function to find smallest number in a list.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_21.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ca8"
  },
  "Function_ID": 22,
  "Function_Description": "Write a function to find the maximum difference between available pairs in the given tuple list.",
  "Function_Code": "def max_difference(test_list):\n  temp = [abs(b - a) for a, b in test_list]\n  res = max(temp)\n  return (res) ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7",
    "assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15",
    "assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 43,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the maximum difference between available pairs in the given tuple list to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 44,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def max_difference(test_list):\n  temp = [abs(b - a) for a, b in test_list]\n  res = max(temp)\n  return (res) \n        **Function Description: ** Write a function to find the maximum difference between available pairs in the given tuple list.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_22.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ca9"
  },
  "Function_ID": 23,
  "Function_Description": "Write a function to sort a list of tuples using the second value of each tuple.",
  "Function_Code": "def subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]",
    "assert subject_marks([('Telugu',49),('Hindhi',54),('Social',33)])==([('Social',33),('Telugu',49),('Hindhi',54)])",
    "assert subject_marks([('Physics',96),('Chemistry',97),('Biology',45)])==([('Biology',45),('Physics',96),('Chemistry',97)])"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 45,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   sort a list of tuples using the second value of each tuple to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 46,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks\n        **Function Description: ** Write a function to sort a list of tuples using the second value of each tuple.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_23.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58caa"
  },
  "Function_ID": 24,
  "Function_Description": "Write a function to flatten a list and sum all of its elements.",
  "Function_Code": "def recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert recursive_list_sum(([1, 2, [3,4],[5,6]]))==21",
    "assert recursive_list_sum(([7, 10, [15,14],[19,41]]))==106",
    "assert recursive_list_sum(([10, 20, [30,40],[50,60]]))==210"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 47,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   flatten a list and sum all of its elements to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 48,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total\n        **Function Description: ** Write a function to flatten a list and sum all of its elements.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_24.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cab"
  },
  "Function_ID": 25,
  "Function_Description": "Write a python function to count the number of positive numbers in a list.",
  "Function_Code": "def pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert pos_count([1,-2,3,-4]) == 2",
    "assert pos_count([3,4,5,-1]) == 3",
    "assert pos_count([1,2,3,4]) == 4"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 49,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   count the number of positive numbers in a list to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 50,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count \n        **Function Description: ** Write a python function to count the number of positive numbers in a list.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_25.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cac"
  },
  "Function_ID": 26,
  "Function_Description": "Write a function to find the number of ways to partition a set of Bell numbers.",
  "Function_Code": "def bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert bell_number(2)==2",
    "assert bell_number(10)==115975",
    "assert bell_number(56)==6775685320645824322581483068371419745979053216268760300"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 51,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the number of ways to partition a set of Bell numbers to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 52,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \n        **Function Description: ** Write a function to find the number of ways to partition a set of Bell numbers.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_26.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cad"
  },
  "Function_ID": 27,
  "Function_Description": "Write a python function to check whether the given array is monotonic or not.",
  "Function_Code": "def is_Monotonic(A): \n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert is_Monotonic([6, 5, 4, 4]) == True",
    "assert is_Monotonic([1, 2, 2, 3]) == True",
    "assert is_Monotonic([1, 3, 2]) == False"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 53,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check whether the given array is monotonic or not to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 54,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def is_Monotonic(A): \n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) \n        **Function Description: ** Write a python function to check whether the given array is monotonic or not.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_27.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cae"
  },
  "Function_ID": 28,
  "Function_Description": "Write a function to check whether a list contains the given sublist or not.",
  "Function_Code": "def is_sublist(l, s):\n\tsub_set = False\n\tif s == []:\n\t\tsub_set = True\n\telif s == l:\n\t\tsub_set = True\n\telif len(s) > len(l):\n\t\tsub_set = False\n\telse:\n\t\tfor i in range(len(l)):\n\t\t\tif l[i] == s[0]:\n\t\t\t\tn = 1\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\n\t\t\t\t\tn += 1\t\t\t\t\n\t\t\t\tif n == len(s):\n\t\t\t\t\tsub_set = True\n\treturn sub_set",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert is_sublist([2,4,3,5,7],[3,7])==False",
    "assert is_sublist([2,4,3,5,7],[4,3])==True",
    "assert is_sublist([2,4,3,5,7],[1,6])==False"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 55,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check whether a list contains the given sublist or not to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 56,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def is_sublist(l, s):\n\tsub_set = False\n\tif s == []:\n\t\tsub_set = True\n\telif s == l:\n\t\tsub_set = True\n\telif len(s) > len(l):\n\t\tsub_set = False\n\telse:\n\t\tfor i in range(len(l)):\n\t\t\tif l[i] == s[0]:\n\t\t\t\tn = 1\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\n\t\t\t\t\tn += 1\t\t\t\t\n\t\t\t\tif n == len(s):\n\t\t\t\t\tsub_set = True\n\treturn sub_set\n        **Function Description: ** Write a function to check whether a list contains the given sublist or not.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_28.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58caf"
  },
  "Function_ID": 29,
  "Function_Description": "Write a function to find whether all the given tuples have equal length or not.",
  "Function_Code": "def find_equal_tuple(Input):\n  k = 0 if not Input else len(Input[0])\n  flag = 1\n  for tuple in Input:\n    if len(tuple) != k:\n      flag = 0\n      break\n  return flag\ndef get_equal(Input):\n  return find_equal_tuple(Input) == 1",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert get_equal([(11, 22, 33), (44, 55, 66)]) == True",
    "assert get_equal([(1, 2, 3), (4, 5, 6, 7)]) == False",
    "assert get_equal([(1, 2), (3, 4)]) == True"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 57,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find whether all the given tuples have equal length or not to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 58,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def find_equal_tuple(Input):\n  k = 0 if not Input else len(Input[0])\n  flag = 1\n  for tuple in Input:\n    if len(tuple) != k:\n      flag = 0\n      break\n  return flag\ndef get_equal(Input):\n  return find_equal_tuple(Input) == 1\n        **Function Description: ** Write a function to find whether all the given tuples have equal length or not.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_29.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cb0"
  },
  "Function_ID": 30,
  "Function_Description": "Write a function to sort a list of elements.",
  "Function_Code": "def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]",
    "assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]",
    "assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 59,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   sort a list of elements to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 60,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums\n        **Function Description: ** Write a function to sort a list of elements.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_30.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cb1"
  },
  "Function_ID": 31,
  "Function_Description": "Write a python function to check whether the given number can be represented as the difference of two squares or not.",
  "Function_Code": "def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert dif_Square(5) == True",
    "assert dif_Square(10) == False",
    "assert dif_Square(15) == True"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 61,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check whether the given number can be represented as the difference of two squares or not to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 62,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False\n        **Function Description: ** Write a python function to check whether the given number can be represented as the difference of two squares or not.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_31.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cb2"
  },
  "Function_ID": 32,
  "Function_Description": "Write a function to check whether it follows the sequence given in the patterns array.",
  "Function_Code": "def is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False   \n\n    for values in sdict.values():\n\n        for i in range(len(values) - 1):\n            if values[i] != values[i+1]:\n                return False\n\n    return True",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert is_samepatterns([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True",
    "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False",
    "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 63,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check whether it follows the sequence given in the patterns array to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 64,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False   \n\n    for values in sdict.values():\n\n        for i in range(len(values) - 1):\n            if values[i] != values[i+1]:\n                return False\n\n    return True\n        **Function Description: ** Write a function to check whether it follows the sequence given in the patterns array.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_32.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cb3"
  },
  "Function_ID": 33,
  "Function_Description": "Write a function to find tuples which have all elements divisible by k from the given list of tuples.",
  "Function_Code": "def find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]",
    "assert find_tuples([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == [(5, 25, 30)]",
    "assert find_tuples([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == [(8, 16, 4)]"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 65,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find tuples which have all elements divisible by k from the given list of tuples to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 66,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res\n        **Function Description: ** Write a function to find tuples which have all elements divisible by k from the given list of tuples.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_33.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cb4"
  },
  "Function_ID": 34,
  "Function_Description": "Write a python function to find whether a number is divisible by 11.",
  "Function_Code": "def is_Diff(n): \n    return (n % 11 == 0) ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert is_Diff (12345) == False",
    "assert is_Diff(1212112) == True",
    "assert is_Diff(1212) == False"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 67,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find whether a number is divisible by 11 to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 68,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def is_Diff(n): \n    return (n % 11 == 0) \n        **Function Description: ** Write a python function to find whether a number is divisible by 11.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_34.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cb5"
  },
  "Function_ID": 35,
  "Function_Description": "Write a python function to check whether the length of the word is odd or not.",
  "Function_Code": "def word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert word_len(\"Hadoop\") == False",
    "assert word_len(\"great\") == True",
    "assert word_len(\"structure\") == True"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 69,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check whether the length of the word is odd or not to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 70,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False\n        **Function Description: ** Write a python function to check whether the length of the word is odd or not.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_35.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cb6"
  },
  "Function_ID": 36,
  "Function_Description": "Write a function to find the nth tetrahedral number.",
  "Function_Code": "def tetrahedral_number(n): \n\treturn (n * (n + 1) * (n + 2)) / 6",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert tetrahedral_number(5) == 35",
    "assert tetrahedral_number(6) == 56",
    "assert tetrahedral_number(7) == 84"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 71,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the nth tetrahedral number to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 72,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def tetrahedral_number(n): \n\treturn (n * (n + 1) * (n + 2)) / 6\n        **Function Description: ** Write a function to find the nth tetrahedral number.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_36.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cb7"
  },
  "Function_ID": 37,
  "Function_Description": "Write a function to find the volume of a sphere.",
  "Function_Code": "import math\ndef volume_sphere(r):\n  volume=(4/3)*math.pi*r*r*r\n  return volume",
  "Function_Imports": [
    "import math"
  ],
  "Function_Test_Cases": [
    "assert math.isclose(volume_sphere(10), 4188.790204786391, rel_tol=0.001)",
    "assert math.isclose(volume_sphere(25), 65449.84694978735, rel_tol=0.001)",
    "assert math.isclose(volume_sphere(20), 33510.32163829113, rel_tol=0.001)"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 73,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the volume of a sphere to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 74,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** import math\ndef volume_sphere(r):\n  volume=(4/3)*math.pi*r*r*r\n  return volume\n        **Function Description: ** Write a function to find the volume of a sphere.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_37.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cb8"
  },
  "Function_ID": 38,
  "Function_Description": "Write a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.",
  "Function_Code": "def get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert get_Char(\"abc\") == \"f\"",
    "assert get_Char(\"gfg\") == \"t\"",
    "assert get_Char(\"ab\") == \"c\""
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 75,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the character made by adding the ASCII value of all the characters of the given string modulo 26 to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 76,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)\n        **Function Description: ** Write a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_38.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cb9"
  },
  "Function_ID": 39,
  "Function_Description": "Write a function to find the nth number in the newman conway sequence.",
  "Function_Code": "def sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert sequence(10) == 6",
    "assert sequence(2) == 1",
    "assert sequence(3) == 2"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 77,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the nth number in the newman conway sequence to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 78,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))\n        **Function Description: ** Write a function to find the nth number in the newman conway sequence.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_39.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cba"
  },
  "Function_ID": 40,
  "Function_Description": "Write a function to find the surface area of a sphere.",
  "Function_Code": "import math\ndef surfacearea_sphere(r):\n  surfacearea=4*math.pi*r*r\n  return surfacearea",
  "Function_Imports": [
    "import math"
  ],
  "Function_Test_Cases": [
    "assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)",
    "assert math.isclose(surfacearea_sphere(15), 2827.4333882308138, rel_tol=0.001)",
    "assert math.isclose(surfacearea_sphere(20), 5026.548245743669, rel_tol=0.001)"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 79,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the surface area of a sphere to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 80,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** import math\ndef surfacearea_sphere(r):\n  surfacearea=4*math.pi*r*r\n  return surfacearea\n        **Function Description: ** Write a function to find the surface area of a sphere.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_40.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cbb"
  },
  "Function_ID": 41,
  "Function_Description": "Write a function to find nth centered hexagonal number.",
  "Function_Code": "def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert centered_hexagonal_number(10) == 271",
    "assert centered_hexagonal_number(2) == 7",
    "assert centered_hexagonal_number(9) == 217"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 81,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find nth centered hexagonal number to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 82,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1\n        **Function Description: ** Write a function to find nth centered hexagonal number.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_41.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cbc"
  },
  "Function_ID": 42,
  "Function_Description": "Write a function to merge three dictionaries into a single dictionary.",
  "Function_Code": "import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}",
    "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}",
    "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 83,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   merge three dictionaries into a single dictionary to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 84,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\n        **Function Description: ** Write a function to merge three dictionaries into a single dictionary.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_42.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cbd"
  },
  "Function_ID": 43,
  "Function_Description": "Write a function to get the frequency of all the elements in a list, returned as a dictionary.",
  "Function_Code": "import collections\ndef freq_count(list1):\n  freq_count= collections.Counter(list1)\n  return freq_count",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1})",
    "assert freq_count([1,2,3,4,3,2,4,1,3,1,4])==({1:3, 2:2,3:3,4:3})",
    "assert freq_count([5,6,7,4,9,10,4,5,6,7,9,5])==({10:1,5:3,6:2,7:2,4:2,9:2})"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 85,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   get the frequency of all the elements in a list, returned as a dictionary to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 86,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** import collections\ndef freq_count(list1):\n  freq_count= collections.Counter(list1)\n  return freq_count\n        **Function Description: ** Write a function to get the frequency of all the elements in a list, returned as a dictionary.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_43.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cbe"
  },
  "Function_ID": 44,
  "Function_Description": "Write a function to find the closest smaller number than n.",
  "Function_Code": "def closest_num(N):\n  return (N - 1)",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert closest_num(11) == 10",
    "assert closest_num(7) == 6",
    "assert closest_num(12) == 11"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 87,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the closest smaller number than n to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 88,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def closest_num(N):\n  return (N - 1)\n        **Function Description: ** Write a function to find the closest smaller number than n.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_44.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cbf"
  },
  "Function_ID": 45,
  "Function_Description": "Write a python function to find the length of the longest word.",
  "Function_Code": "def len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7",
    "assert len_log([\"a\",\"ab\",\"abc\"]) == 3",
    "assert len_log([\"small\",\"big\",\"tall\"]) == 5"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 89,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the length of the longest word to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 90,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max\n        **Function Description: ** Write a python function to find the length of the longest word.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_45.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cc0"
  },
  "Function_ID": 46,
  "Function_Description": "Write a function to check if a string is present as a substring in a given list of string values.",
  "Function_Code": "def find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ack\")==True",
    "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"abc\")==False",
    "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ange\")==True"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 91,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check if a string is present as a substring in a given list of string values to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 92,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False\n        **Function Description: ** Write a function to check if a string is present as a substring in a given list of string values.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_46.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cc1"
  },
  "Function_ID": 47,
  "Function_Description": "Write a function to check whether the given number is undulating or not.",
  "Function_Code": "def is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert is_undulating(1212121) == True",
    "assert is_undulating(1991) == False",
    "assert is_undulating(121) == True"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 93,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check whether the given number is undulating or not to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 94,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True\n        **Function Description: ** Write a function to check whether the given number is undulating or not.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_47.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cc2"
  },
  "Function_ID": 48,
  "Function_Description": "Write a function to calculate the value of 'a' to the power 'b'.",
  "Function_Code": "def power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert power(3,4) == 81",
    "assert power(2,3) == 8",
    "assert power(5,5) == 3125"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 95,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   calculate the value of 'a' to the power 'b' to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 96,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)\n        **Function Description: ** Write a function to calculate the value of 'a' to the power 'b'.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_48.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cc3"
  },
  "Function_ID": 49,
  "Function_Description": "Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.",
  "Function_Code": "from operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'",
    "assert index_minimum([('Yash', 185), ('Dawood', 125), ('Sanya', 175)]) == 'Dawood'",
    "assert index_minimum([('Sai', 345), ('Salman', 145), ('Ayesha', 96)]) == 'Ayesha'"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 97,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 98,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** from operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) \n        **Function Description: ** Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_49.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cc4"
  },
  "Function_ID": 50,
  "Function_Description": "Write a python function to find the length of the smallest list in a list of lists.",
  "Function_Code": "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert Find_Min_Length([[1],[1,2]]) == 1",
    "assert Find_Min_Length([[1,2],[1,2,3],[1,2,3,4]]) == 2",
    "assert Find_Min_Length([[3,3,3],[4,4,4,4]]) == 3"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 99,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the length of the smallest list in a list of lists to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 100,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n        **Function Description: ** Write a python function to find the length of the smallest list in a list of lists.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_50.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cc5"
  },
  "Function_ID": 51,
  "Function_Description": "Write a python function to find the number of divisors of a given integer.",
  "Function_Code": "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert divisor(15) == 4",
    "assert divisor(12) == 6",
    "assert divisor(9) == 3"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 101,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the number of divisors of a given integer to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 102,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x\n        **Function Description: ** Write a python function to find the number of divisors of a given integer.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_51.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cc6"
  },
  "Function_ID": 52,
  "Function_Description": "Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.",
  "Function_Code": "def frequency_lists(list1):\n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        if num in dic_data.keys():\n            dic_data[num] += 1\n        else:\n            key = num\n            value = 1\n            dic_data[key] = value\n    return dic_data\n",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}",
    "assert frequency_lists([[1,2,3,4],[5,6,7,8],[9,10,11,12]])=={1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1,10:1,11:1,12:1}",
    "assert frequency_lists([[20,30,40,17],[18,16,14,13],[10,20,30,40]])=={20:2,30:2,40:2,17: 1,18:1, 16: 1,14: 1,13: 1, 10: 1}"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 103,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find frequency of each element in a flattened list of lists, returned in a dictionary to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 104,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def frequency_lists(list1):\n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        if num in dic_data.keys():\n            dic_data[num] += 1\n        else:\n            key = num\n            value = 1\n            dic_data[key] = value\n    return dic_data\n\n        **Function Description: ** Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_52.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cc7"
  },
  "Function_ID": 53,
  "Function_Description": "Write a function to multiply all the numbers in a list and divide with the length of the list.",
  "Function_Code": "def multiply_num(numbers):  \n    total = 1\n    for x in numbers:\n        total *= x  \n    return total/len(numbers) ",
  "Function_Imports": [
    "import math"
  ],
  "Function_Test_Cases": [
    "assert math.isclose(multiply_num((8, 2, 3, -1, 7)), -67.2, rel_tol=0.001)",
    "assert math.isclose(multiply_num((-10,-20,-30)), -2000.0, rel_tol=0.001)",
    "assert math.isclose(multiply_num((19,15,18)), 1710.0, rel_tol=0.001)"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 105,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   multiply all the numbers in a list and divide with the length of the list to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 106,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def multiply_num(numbers):  \n    total = 1\n    for x in numbers:\n        total *= x  \n    return total/len(numbers) \n        **Function Description: ** Write a function to multiply all the numbers in a list and divide with the length of the list.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_53.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cc8"
  },
  "Function_ID": 54,
  "Function_Description": "Write a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.",
  "Function_Code": "def decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert decimal_to_binary(8) == '1000'",
    "assert decimal_to_binary(18) == '10010'",
    "assert decimal_to_binary(7) == '111'"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 107,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   convert the given decimal number to its binary equivalent, represented as a string with no leading zeros to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 108,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") \n        **Function Description: ** Write a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_54.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cc9"
  },
  "Function_ID": 55,
  "Function_Description": "Write a function to find the next smallest palindrome of a specified integer, returned as an integer.",
  "Function_Code": "import sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert next_smallest_palindrome(99)==101",
    "assert next_smallest_palindrome(1221)==1331",
    "assert next_smallest_palindrome(120)==121"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 109,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the next smallest palindrome of a specified integer, returned as an integer to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 110,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** import sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i\n        **Function Description: ** Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_55.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cca"
  },
  "Function_ID": 56,
  "Function_Description": "Write a function to find the kth element in the given array using 1-based indexing.",
  "Function_Code": "def kth_element(arr, k):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] == arr[j+1], arr[j]\n  return arr[k-1]",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert kth_element([12,3,5,7,19], 2) == 3",
    "assert kth_element([17,24,8,23], 3) == 8",
    "assert kth_element([16,21,25,36,4], 4) == 36"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 111,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the kth element in the given array using 1-based indexing to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 112,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def kth_element(arr, k):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] == arr[j+1], arr[j]\n  return arr[k-1]\n        **Function Description: ** Write a function to find the kth element in the given array using 1-based indexing.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_56.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ccb"
  },
  "Function_ID": 57,
  "Function_Description": "Write a function to convert a snake case string to camel case string.",
  "Function_Code": "def snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert snake_to_camel('python_program')=='PythonProgram'",
    "assert snake_to_camel('python_language')==('PythonLanguage')",
    "assert snake_to_camel('programming_language')==('ProgrammingLanguage')"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 113,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   convert a snake case string to camel case string to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 114,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))\n        **Function Description: ** Write a function to convert a snake case string to camel case string.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_57.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ccc"
  },
  "Function_ID": 58,
  "Function_Description": "Write a function to find the Eulerian number a(n, m).",
  "Function_Code": "def eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert eulerian_num(3, 1) == 4",
    "assert eulerian_num(4, 1) == 11",
    "assert eulerian_num(5, 3) == 26"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 115,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the Eulerian number a(n, m) to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 116,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))\n        **Function Description: ** Write a function to find the Eulerian number a(n, m).\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_58.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ccd"
  },
  "Function_ID": 59,
  "Function_Description": "Write a function to sort each sublist of strings in a given list of lists.",
  "Function_Code": "def sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert sort_sublists(([\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]))==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]",
    "assert sort_sublists(([\" red \",\"green\" ],[\"blue \",\" black\"],[\" orange\",\"brown\"]))==[[' red ', 'green'], [' black', 'blue '], [' orange', 'brown']]",
    "assert sort_sublists(([\"zilver\",\"gold\"], [\"magnesium\",\"aluminium\"], [\"steel\", \"bronze\"]))==[['gold', 'zilver'],['aluminium', 'magnesium'], ['bronze', 'steel']]"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 117,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   sort each sublist of strings in a given list of lists to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 118,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n\n        **Function Description: ** Write a function to sort each sublist of strings in a given list of lists.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_59.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cce"
  },
  "Function_ID": 60,
  "Function_Description": "Write a python function to count true booleans in the given list.",
  "Function_Code": "def count(lst):   \n    return sum(lst) ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert count([True,False,True]) == 2",
    "assert count([False,False]) == 0",
    "assert count([True,True,True]) == 3"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 119,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   count true booleans in the given list to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 120,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def count(lst):   \n    return sum(lst) \n        **Function Description: ** Write a python function to count true booleans in the given list.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_60.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ccf"
  },
  "Function_ID": 61,
  "Function_Description": "Write a function to append the given list to the given tuples.",
  "Function_Code": "def add_lists(test_list, test_tup):\n  res = tuple(list(test_tup) + test_list)\n  return (res) ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)",
    "assert add_lists([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)",
    "assert add_lists([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 121,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   append the given list to the given tuples to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 122,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def add_lists(test_list, test_tup):\n  res = tuple(list(test_tup) + test_list)\n  return (res) \n        **Function Description: ** Write a function to append the given list to the given tuples.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_61.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cd0"
  },
  "Function_ID": 62,
  "Function_Description": "Write a function to merge three lists into a single sorted list.",
  "Function_Code": "import heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]",
    "assert merge_sorted_list([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12])==[1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]",
    "assert merge_sorted_list([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1],[25, 35, 22, 85, 14, 65, 75, 25, 58],[12, 74, 9, 50, 61, 41])==[1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 123,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   merge three lists into a single sorted list to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 124,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** import heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)\n        **Function Description: ** Write a function to merge three lists into a single sorted list.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_62.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cd1"
  },
  "Function_ID": 63,
  "Function_Description": "Write a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.",
  "Function_Code": "def odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert odd_Equivalent(\"011001\",6) == 3",
    "assert odd_Equivalent(\"11011\",5) == 4",
    "assert odd_Equivalent(\"1010\",4) == 2"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 125,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the number of numbers with an odd value when rotating a binary string the given number of times to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 126,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count \n        **Function Description: ** Write a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_63.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cd2"
  },
  "Function_ID": 64,
  "Function_Description": "Write a function to find the common elements in given nested lists.",
  "Function_Code": "def common_in_nested_lists(nestedlist):\n    result = list(set.intersection(*map(set, nestedlist)))\n    return result",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]))==set([18, 12])",
    "assert set(common_in_nested_lists([[12, 5, 23, 25, 45], [7, 11, 5, 23, 28], [1, 5, 8, 18, 23, 16]]))==set([5,23])",
    "assert set(common_in_nested_lists([[2, 3,4, 1], [4, 5], [6,4, 8],[4, 5], [6, 8,4]]))==set([4])"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 127,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the common elements in given nested lists to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 128,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def common_in_nested_lists(nestedlist):\n    result = list(set.intersection(*map(set, nestedlist)))\n    return result\n        **Function Description: ** Write a function to find the common elements in given nested lists.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_64.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cd3"
  },
  "Function_ID": 65,
  "Function_Description": "Write a function to check if a string represents an integer or not.",
  "Function_Code": "def check_integer(text):\n text = text.strip()\n if len(text) < 1:\n    return None\n else:\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\n          return True\n     elif (text[0] in \"+-\") and \\\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\n         return True\n     else:\n        return False",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert check_integer(\"python\")==False",
    "assert check_integer(\"1\")==True",
    "assert check_integer(\"12345\")==True"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 129,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check if a string represents an integer or not to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 130,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def check_integer(text):\n text = text.strip()\n if len(text) < 1:\n    return None\n else:\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\n          return True\n     elif (text[0] in \"+-\") and \\\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\n         return True\n     else:\n        return False\n        **Function Description: ** Write a function to check if a string represents an integer or not.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_65.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cd4"
  },
  "Function_ID": 66,
  "Function_Description": "Write a function to check whether all dictionaries in a list are empty or not.",
  "Function_Code": "def empty_dit(list1):\n empty_dit=all(not d for d in list1)\n return empty_dit",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert empty_dit([{},{},{}])==True",
    "assert empty_dit([{1,2},{},{}])==False",
    "assert empty_dit({})==True"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 131,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check whether all dictionaries in a list are empty or not to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 132,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def empty_dit(list1):\n empty_dit=all(not d for d in list1)\n return empty_dit\n        **Function Description: ** Write a function to check whether all dictionaries in a list are empty or not.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_66.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cd5"
  },
  "Function_ID": 67,
  "Function_Description": "Write a function to convert a given tuple of positive integers into a single integer.",
  "Function_Code": "def tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert tuple_to_int((1,2,3))==123",
    "assert tuple_to_int((4,5,6))==456",
    "assert tuple_to_int((5,6,7))==567"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 133,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   convert a given tuple of positive integers into a single integer to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 134,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result\n        **Function Description: ** Write a function to convert a given tuple of positive integers into a single integer.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_67.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cd6"
  },
  "Function_ID": 68,
  "Function_Description": "Write a function to convert all possible convertible elements in a list of lists to floats.",
  "Function_Code": "def list_to_float(test_list):\n  res = []\n  for tup in test_list:\n    temp = []\n    for ele in tup:\n      if ele.isalpha():\n        temp.append(ele)\n      else:\n        temp.append(float(ele))\n    res.append((temp[0],temp[1])) \n  return res",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert list_to_float( [(\"3\", \"4\"), (\"1\", \"26.45\"), (\"7.32\", \"8\"), (\"4\", \"8\")] ) == [(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]",
    "assert list_to_float( [(\"4\", \"4\"), (\"2\", \"27\"), (\"4.12\", \"9\"), (\"7\", \"11\")] ) == [(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]",
    "assert list_to_float( [(\"6\", \"78\"), (\"5\", \"26.45\"), (\"1.33\", \"4\"), (\"82\", \"13\")] ) == [(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 135,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   convert all possible convertible elements in a list of lists to floats to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 136,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def list_to_float(test_list):\n  res = []\n  for tup in test_list:\n    temp = []\n    for ele in tup:\n      if ele.isalpha():\n        temp.append(ele)\n      else:\n        temp.append(float(ele))\n    res.append((temp[0],temp[1])) \n  return res\n        **Function Description: ** Write a function to convert all possible convertible elements in a list of lists to floats.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_68.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cd7"
  },
  "Function_ID": 69,
  "Function_Description": "Write a function to convert a string to a list of strings split on the space character.",
  "Function_Code": "def string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert string_to_list(\"python programming\")==['python','programming']",
    "assert string_to_list(\"lists tuples strings\")==['lists','tuples','strings']",
    "assert string_to_list(\"write a program\")==['write','a','program']"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 137,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   convert a string to a list of strings split on the space character to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 138,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst\n        **Function Description: ** Write a function to convert a string to a list of strings split on the space character.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_69.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cd8"
  },
  "Function_ID": 70,
  "Function_Description": "Write a python function to find the element that appears only once in a sorted array.",
  "Function_Code": "def search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert search([1,1,2,2,3]) == 3",
    "assert search([1,1,3,3,4,4,5,5,7,7,8]) == 8",
    "assert search([1,2,2,3,3,4,4]) == 1"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 139,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the element that appears only once in a sorted array to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 140,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)\n        **Function Description: ** Write a python function to find the element that appears only once in a sorted array.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_70.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cd9"
  },
  "Function_ID": 71,
  "Function_Description": "Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.",
  "Function_Code": "def max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36",
    "assert max_product_tuple([(10,20), (15,2), (5,10)] )==200",
    "assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 141,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the maximum absolute product between numbers in pairs of tuples within a given list to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 142,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max\n        **Function Description: ** Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_71.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cda"
  },
  "Function_ID": 72,
  "Function_Description": "Write a function to sum all amicable numbers from 1 to a specified number.",
  "Function_Code": "def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert amicable_numbers_sum(999)==504",
    "assert amicable_numbers_sum(9999)==31626",
    "assert amicable_numbers_sum(99)==0"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 143,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   sum all amicable numbers from 1 to a specified number to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 144,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)\n        **Function Description: ** Write a function to sum all amicable numbers from 1 to a specified number.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_72.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cdb"
  },
  "Function_ID": 73,
  "Function_Description": "Write a function to get the angle of a complex number.",
  "Function_Code": "import cmath\ndef angle_complex(a,b):\n  cn=complex(a,b)\n  angle=cmath.phase(a+b)\n  return angle",
  "Function_Imports": [
    "import math"
  ],
  "Function_Test_Cases": [
    "assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)",
    "assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)",
    "assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 145,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   get the angle of a complex number to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 146,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** import cmath\ndef angle_complex(a,b):\n  cn=complex(a,b)\n  angle=cmath.phase(a+b)\n  return angle\n        **Function Description: ** Write a function to get the angle of a complex number.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_73.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cdc"
  },
  "Function_ID": 74,
  "Function_Description": "Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.",
  "Function_Code": "def find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert find_length(\"11000010001\") == 6",
    "assert find_length(\"10111\") == 1",
    "assert find_length(\"11011101100101\") == 2"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 147,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 148,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0\n        **Function Description: ** Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_74.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cde"
  },
  "Function_ID": 76,
  "Function_Description": "Write a function to multiply two integers.",
  "Function_Code": "def multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert multiply_int(10,20)==200",
    "assert multiply_int(5,10)==50",
    "assert multiply_int(4,8)==32"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 151,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   multiply two integers to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 152,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)\n        **Function Description: ** Write a function to multiply two integers.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_76.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cdf"
  },
  "Function_ID": 77,
  "Function_Description": "Write a function to find words that are longer than n characters from a given list of words.",
  "Function_Code": "def long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert long_words(3,\"python is a programming language\")==['python','programming','language']",
    "assert long_words(2,\"writing a program\")==['writing','program']",
    "assert long_words(5,\"sorting list\")==['sorting']"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 153,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find words that are longer than n characters from a given list of words to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 154,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t\n        **Function Description: ** Write a function to find words that are longer than n characters from a given list of words.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_77.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ce0"
  },
  "Function_ID": 78,
  "Function_Description": "Write a function to calculate whether the matrix is a magic square.",
  "Function_Code": "def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True",
    "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]])==True",
    "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 7]])==False"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 155,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   calculate whether the matrix is a magic square to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 156,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True\n        **Function Description: ** Write a function to calculate whether the matrix is a magic square.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_78.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ce1"
  },
  "Function_ID": 79,
  "Function_Description": "Write a function to find the item with maximum frequency in a given list.",
  "Function_Code": "from collections import defaultdict\ndef max_occurrences(nums):\n    dict = defaultdict(int)\n    for i in nums:\n        dict[i] += 1\n    result = max(dict.items(), key=lambda x: x[1]) \n    return result[0]",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2",
    "assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8",
    "assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 157,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the item with maximum frequency in a given list to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 158,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** from collections import defaultdict\ndef max_occurrences(nums):\n    dict = defaultdict(int)\n    for i in nums:\n        dict[i] += 1\n    result = max(dict.items(), key=lambda x: x[1]) \n    return result[0]\n        **Function Description: ** Write a function to find the item with maximum frequency in a given list.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_79.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ce2"
  },
  "Function_ID": 80,
  "Function_Description": "Write a python function to reverse only the vowels of a given string (where y is not a vowel).",
  "Function_Code": "def reverse_vowels(str1):\n\tvowels = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tvowels += char\n\tresult_string = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tresult_string += vowels[-1]\n\t\t\tvowels = vowels[:-1]\n\t\telse:\n\t\t\tresult_string += char\n\treturn result_string",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert reverse_vowels(\"Python\") == \"Python\"",
    "assert reverse_vowels(\"USA\") == \"ASU\"",
    "assert reverse_vowels(\"ab\") == \"ab\""
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 159,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   reverse only the vowels of a given string (where y is not a vowel) to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 160,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def reverse_vowels(str1):\n\tvowels = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tvowels += char\n\tresult_string = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tresult_string += vowels[-1]\n\t\t\tvowels = vowels[:-1]\n\t\telse:\n\t\t\tresult_string += char\n\treturn result_string\n        **Function Description: ** Write a python function to reverse only the vowels of a given string (where y is not a vowel).\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_80.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ce3"
  },
  "Function_ID": 81,
  "Function_Description": "Write a function to convert a tuple to a string.",
  "Function_Code": "def tup_string(tup1):\n  str =  ''.join(tup1)\n  return str",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'))==(\"exercises\")",
    "assert tup_string(('p','y','t','h','o','n'))==(\"python\")",
    "assert tup_string(('p','r','o','g','r','a','m'))==(\"program\")"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 161,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   convert a tuple to a string to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 162,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def tup_string(tup1):\n  str =  ''.join(tup1)\n  return str\n        **Function Description: ** Write a function to convert a tuple to a string.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_81.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ce4"
  },
  "Function_ID": 82,
  "Function_Description": "Write a function to calculate the sum of the negative numbers of a given list of numbers.",
  "Function_Code": "def sum_negativenum(nums):\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\n  return sum(sum_negativenum)",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==-32",
    "assert sum_negativenum([10,15,-14,13,-18,12,-20])==-52",
    "assert sum_negativenum([19, -65, 57, 39, 152,-639, 121, 44, 90, -190])==-894"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 163,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   calculate the sum of the negative numbers of a given list of numbers to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 164,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def sum_negativenum(nums):\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\n  return sum(sum_negativenum)\n        **Function Description: ** Write a function to calculate the sum of the negative numbers of a given list of numbers.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_82.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ce5"
  },
  "Function_ID": 83,
  "Function_Description": "Write a function to find the nth hexagonal number.",
  "Function_Code": "def hexagonal_num(n): \n\treturn n*(2*n - 1) ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert hexagonal_num(10) == 190",
    "assert hexagonal_num(5) == 45",
    "assert hexagonal_num(7) == 91"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 165,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the nth hexagonal number to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 166,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def hexagonal_num(n): \n\treturn n*(2*n - 1) \n        **Function Description: ** Write a function to find the nth hexagonal number.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_83.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ce6"
  },
  "Function_ID": 84,
  "Function_Description": "Write a function to find the ratio of zeroes to non-zeroes in an array of integers.",
  "Function_Code": "from array import array\ndef zero_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x == 0:\n            n1 += 1\n        else:\n          None\n    return n1/(n-n1)",
  "Function_Imports": [
    "import math"
  ],
  "Function_Test_Cases": [
    "assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)",
    "assert math.isclose(zero_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.00, rel_tol=0.001)",
    "assert math.isclose(zero_count([2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.00, rel_tol=0.001)"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 167,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the ratio of zeroes to non-zeroes in an array of integers to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 168,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** from array import array\ndef zero_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x == 0:\n            n1 += 1\n        else:\n          None\n    return n1/(n-n1)\n        **Function Description: ** Write a function to find the ratio of zeroes to non-zeroes in an array of integers.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_84.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ce7"
  },
  "Function_ID": 85,
  "Function_Description": "Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.",
  "Function_Code": "def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert is_Sum_Of_Powers_Of_Two(10) == True",
    "assert is_Sum_Of_Powers_Of_Two(7) == False",
    "assert is_Sum_Of_Powers_Of_Two(14) == True"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 169,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   check whether the given number can be represented as sum of non-zero powers of 2 or not to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 170,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True\n        **Function Description: ** Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_85.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ce8"
  },
  "Function_ID": 86,
  "Function_Description": "Write a function to find the circumference of a circle.",
  "Function_Code": "def circle_circumference(r):\n  perimeter=2*3.1415*r\n  return perimeter",
  "Function_Imports": [
    "import math"
  ],
  "Function_Test_Cases": [
    "assert math.isclose(circle_circumference(10), 62.830000000000005, rel_tol=0.001)",
    "assert math.isclose(circle_circumference(5), 31.415000000000003, rel_tol=0.001)",
    "assert math.isclose(circle_circumference(4), 25.132, rel_tol=0.001)"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 171,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the circumference of a circle to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 172,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def circle_circumference(r):\n  perimeter=2*3.1415*r\n  return perimeter\n        **Function Description: ** Write a function to find the circumference of a circle.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_86.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ce9"
  },
  "Function_ID": 87,
  "Function_Description": "Write a function to flatten the list of lists into a single set of numbers.",
  "Function_Code": "def extract_singly(test_list):\n  res = []\n  temp = set()\n  for inner in test_list:\n    for ele in inner:\n      if not ele in temp:\n        temp.add(ele)\n        res.append(ele)\n  return (res) ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])",
    "assert set(extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)])) == set([1, 2, 3, 4, 7, 8])",
    "assert set(extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)])) == set([7, 8, 9, 10, 11, 12])"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 173,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   flatten the list of lists into a single set of numbers to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 174,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def extract_singly(test_list):\n  res = []\n  temp = set()\n  for inner in test_list:\n    for ele in inner:\n      if not ele in temp:\n        temp.add(ele)\n        res.append(ele)\n  return (res) \n        **Function Description: ** Write a function to flatten the list of lists into a single set of numbers.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_87.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cea"
  },
  "Function_ID": 88,
  "Function_Description": "Write a function to sort a list of elements.",
  "Function_Code": "def pancake_sort(nums):\n    arr_len = len(nums)\n    while arr_len > 1:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]",
    "assert pancake_sort([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]",
    "assert pancake_sort([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 175,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   sort a list of elements to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 176,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def pancake_sort(nums):\n    arr_len = len(nums)\n    while arr_len > 1:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums\n        **Function Description: ** Write a function to sort a list of elements.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_88.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ceb"
  },
  "Function_ID": 89,
  "Function_Description": "Write a function to count number items that are identical in the same position of three given lists.",
  "Function_Code": "def count_samepair(list1,list2,list3):\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\n    return result",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])==3",
    "assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==4",
    "assert count_samepair([1,2,3,4,2,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==5"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 177,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   count number items that are identical in the same position of three given lists to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 178,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def count_samepair(list1,list2,list3):\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\n    return result\n        **Function Description: ** Write a function to count number items that are identical in the same position of three given lists.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_89.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cec"
  },
  "Function_ID": 90,
  "Function_Description": "Write a function to find number of lists present in the given tuple.",
  "Function_Code": "def find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2",
    "assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3",
    "assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 179,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find number of lists present in the given tuple to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 180,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) \n        **Function Description: ** Write a function to find number of lists present in the given tuple.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_90.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58ced"
  },
  "Function_ID": 91,
  "Function_Description": "Write a python function to find the maximum difference between any two elements in a given array.",
  "Function_Code": "def max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert max_Abs_Diff((2,1,5,3)) == 4",
    "assert max_Abs_Diff((9,3,2,5,1)) == 8",
    "assert max_Abs_Diff((3,2,1)) == 2"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 181,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the maximum difference between any two elements in a given array to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 182,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) \n        **Function Description: ** Write a python function to find the maximum difference between any two elements in a given array.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_91.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cee"
  },
  "Function_ID": 92,
  "Function_Description": "Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.",
  "Function_Code": "def find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert find_solution(2, 3, 7) == (2, 1)",
    "assert find_solution(4, 2, 7) == None",
    "assert find_solution(1, 13, 17) == (4, 1)"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 183,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 184,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None\n        **Function Description: ** Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_92.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cef"
  },
  "Function_ID": 93,
  "Function_Description": "Write a function to remove all elements from a given list present in another list.",
  "Function_Code": "def remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]",
    "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7]) == [2, 4, 6, 8, 9, 10]",
    "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5, 7]) == [1, 2, 3, 4, 6, 8, 9, 10]"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 185,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   remove all elements from a given list present in another list to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 186,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result\n        **Function Description: ** Write a function to remove all elements from a given list present in another list.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_93.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cf0"
  },
  "Function_ID": 94,
  "Function_Description": "Write a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).",
  "Function_Code": "def sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert sum_series(6) == 12",
    "assert sum_series(10) == 30",
    "assert sum_series(9) == 25"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 187,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0) to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 188,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)\n        **Function Description: ** Write a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_94.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cf1"
  },
  "Function_ID": 95,
  "Function_Description": "Write a function to calculate the area of a regular polygon given the length and number of its sides.",
  "Function_Code": "from math import tan, pi\ndef area_polygon(s, l):\n  area = s * (l ** 2) / (4 * tan(pi / s))\n  return area",
  "Function_Imports": [
    "import math"
  ],
  "Function_Test_Cases": [
    "assert math.isclose(area_polygon(4, 20), 400., rel_tol=0.001)",
    "assert math.isclose(area_polygon(10, 15), 1731.197, rel_tol=0.001)",
    "assert math.isclose(area_polygon(9, 7), 302.909, rel_tol=0.001)"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 189,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   calculate the area of a regular polygon given the length and number of its sides to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 190,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** from math import tan, pi\ndef area_polygon(s, l):\n  area = s * (l ** 2) / (4 * tan(pi / s))\n  return area\n        **Function Description: ** Write a function to calculate the area of a regular polygon given the length and number of its sides.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_95.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cf2"
  },
  "Function_ID": 96,
  "Function_Description": "Write a function to determine if the sum of the divisors of two integers are the same.",
  "Function_Code": "import math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert are_equivalent(36, 57) == False",
    "assert are_equivalent(2, 4) == False",
    "assert are_equivalent(23, 47) == True"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 191,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   determine if the sum of the divisors of two integers are the same to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 192,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** import math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); \n        **Function Description: ** Write a function to determine if the sum of the divisors of two integers are the same.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_96.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cf3"
  },
  "Function_ID": 97,
  "Function_Description": "Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).",
  "Function_Code": "def count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert count_char_position(\"xbcefg\") == 2",
    "assert count_char_position(\"ABcED\") == 3",
    "assert count_char_position(\"AbgdeF\") == 5"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 193,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive) to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 194,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars \n        **Function Description: ** Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_97.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cf4"
  },
  "Function_ID": 98,
  "Function_Description": "Write a function that counts the number of pairs of integers in a list that xor to an even number.",
  "Function_Code": "def find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert find_even_pair([5, 4, 7, 2, 1]) == 4",
    "assert find_even_pair([7, 2, 8, 1, 0, 5, 11]) == 9",
    "assert find_even_pair([1, 2, 3]) == 1"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 195,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to Write a function that counts the number of pairs of integers in a list that xor to an even number to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 196,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count\n        **Function Description: ** Write a function that counts the number of pairs of integers in a list that xor to an even number.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_98.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cf5"
  },
  "Function_ID": 99,
  "Function_Description": "Write a python function to find the smallest power of 2 greater than or equal to n.",
  "Function_Code": "def next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert next_power_of_2(0) == 1",
    "assert next_power_of_2(5) == 8",
    "assert next_power_of_2(17) == 32"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 197,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   find the smallest power of 2 greater than or equal to n to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 198,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; \n        **Function Description: ** Write a python function to find the smallest power of 2 greater than or equal to n.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_99.py"
},
{
  "_id": {
    "$oid": "692721745ac066c866d58cf6"
  },
  "Function_ID": 100,
  "Function_Description": "Write a function to count the number of occurrences of a number in a given list.",
  "Function_Code": "def frequency(a,x): \n    count = 0  \n    for i in a: \n      if i == x: \n        count += 1\n\n    return count ",
  "Function_Imports": [],
  "Function_Test_Cases": [
    "assert frequency([1,2,3], 4) == 0",
    "assert frequency([1,2,2,3,3,3,4], 3) == 3",
    "assert frequency([0,1,2,3,1,2], 1) == 2"
  ],
  "Function_Prompts": [
    {
      "Prompt_Strategy": "Naive_strategy",
      "Prompt_ID": 199,
      "Prompt_Text": "Provide the set of preconditions and postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a function to   count the number of occurrences of a number in a given list to test this function fully using a set of diverse test strategies like boundary testing, edge case testing, invariant testing, and typical case testing.\n    **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    Minimize whitespace. \n    Do not include long explanations. Ensure JSON is complete"
    },
    {
      "Prompt_Strategy": "ChainOfThought_strategy",
      "Prompt_ID": 200,
      "Prompt_Text": "\n    **Role**: You are an expert QA engineer tasked with generating verifiable postconditions for **Property-Based Testing (PBT)** using the Hypothesis library for a \n    given Python function to test it holistically using diverse testing strategies including boundary testing, edge case testing, invariant testing, and typical case testing.\n    **Objective:**\n        Analyze the provided Python function and generate a comprehensive JSON test suite covering:\n        1. Basic Functionality (Happy Path)\n        2. Edge Cases (Empty inputs, Zeros, None)\n        3. Boundary Values (Min/Max integers, Large lists)\n        4. Invariants (Properties that always hold true)\n    **Task:**\n        1. **Analyze** the provided function code and its docstring. \n        2. **Apply Chain-of-Thought (CoT):** First , generate the intermediate analysis (Steps 1, 2, and 3 below). \n        3. **Final Output:** Output ONLY a JSON object containing the `postconditions` list. Do NOT include the CoT steps in the final output. \n    **CoT Steps (for internal reasoning only):** \n    ** 1. **Analyze Inputs/Preconditions:** Identify parameter types and necessary input conditions. \n    2. **Trace Logic/Side Effects:** Describe the main calculation, control flow (if/else), and any external changes (side effects). \n    3. **Formulate Postconditions:** Draft the high-level facts about the return value and program state following the below logic rules.\n    **LOGIC RULES FOR FORMULATING POSTCONDITIONS:**\n    - For numeric returns, consider ranges, sign (positive/negative), and special values (zero).\n    - For collections (lists, dicts), consider length, emptiness, and content properties.\n    - For boolean returns, consider both True and False outcomes.\n    - For functions with side effects, include conditions on modified global state or external systems.\n    - Ensure postconditions are testable via assert statements.\n    - **GOLDEN RULE OF PBT**: Do not use 'assumptions' to filter for low-probability events (like specific substrings 'password' or random list overlaps). If you cannot guarantee a condition using `input_constraints` (ranges/patterns), **DO NOT TEST IT**. Rely on the test engine to find edge cases naturally.\n    **Provided Information:**\n        **Python Function:** def frequency(a,x): \n    count = 0  \n    for i in a: \n      if i == x: \n        count += 1\n\n    return count \n        **Function Description: ** Write a function to count the number of occurrences of a number in a given list.\n    **Final Output Requirements:**\n    Minimize whitespace. Do not include long explanations. Ensure the response is complete"
    }
  ],
  "file_path": "py_files\\func_100.py"
}]