{"_id":{"$oid":"692adffe1b18223597bc6054"},"test_cases":[{"id":"pc_1","description":"Typical case with overlapping elements.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":5,"max_len":20,"min_val":-100,"max_val":100},"test_tup2":{"min_len":5,"max_len":20,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_2","description":"One empty tuple.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":0,"max_len":0},"test_tup2":{"min_len":5,"max_len":20,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_3","description":"Both empty tuples.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":0,"max_len":0},"test_tup2":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_4","description":"No common elements.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":5,"max_len":20,"min_val":0,"max_val":50},"test_tup2":{"min_len":5,"max_len":20,"min_val":51,"max_val":100}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_5","description":"All elements are common (identical tuples).","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":0,"max_len":10,"min_val":-50,"max_val":25}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":["test_tup2 == test_tup1"]},{"id":"pc_6","description":"Tuples with duplicate elements.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":10,"max_len":30,"min_val":-20,"max_val":20},"test_tup2":{"min_len":10,"max_len":30,"min_val":-20,"max_val":20}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_7","description":"Boundary values (min/max integers).","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":0,"max_len":2,"min_val":-100,"max_val":50},"test_tup2":{"min_len":0,"max_len":2,"min_val":-100,"max_val":50}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":["test_tup1 == (-100, 100) or test_tup1 == (100, -100) or test_tup1 == (-100,) or test_tup1 == (100,)","test_tup2 == (-100, 100) or test_tup2 == (100, -100) or test_tup2 == (-100,) or test_tup2 == (100,)"]},{"id":"pc_8","description":"Mixed list sizes.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":1,"max_len":5,"min_val":-100,"max_val":100,"is_mixed":true},"test_tup2":{"min_len":10,"max_len":30,"min_val":-100,"max_val":100,"is_mixed":true}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_9","description":"Large number of elements with overlap.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":50,"max_len":100,"min_val":-1000,"max_val":1000},"test_tup2":{"min_len":50,"max_len":100,"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_10","description":"Tuples with negative numbers.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":5,"max_len":20,"min_val":-100,"max_val":-1},"test_tup2":{"min_len":5,"max_len":20,"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_11","description":"Tuples with zero.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":5,"max_len":20,"min_val":-10,"max_val":10},"test_tup2":{"min_len":5,"max_len":20,"min_val":-10,"max_val":10}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":["0 in test_tup1 or 0 in test_tup2"]},{"id":"pc_12","description":"One tuple contains only unique elements, the other has duplicates.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":5,"max_len":20,"unique":true,"min_val":-100,"max_val":100},"test_tup2":{"min_len":5,"max_len":20,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_13","description":"Both tuples contain only unique elements.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":5,"max_len":20,"unique":true,"min_val":-100,"max_val":100},"test_tup2":{"min_len":5,"max_len":20,"unique":true,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_14","description":"Test with a very small range of numbers.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":5,"max_len":20,"min_val":1,"max_val":5},"test_tup2":{"min_len":5,"max_len":20,"min_val":1,"max_val":5}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_15","description":"Test with a large range of numbers.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":5,"max_len":20,"min_val":-10000,"max_val":10000},"test_tup2":{"min_len":5,"max_len":20,"min_val":-10000,"max_val":10000}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_16","description":"Test with tuples of maximum allowed length.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":100,"max_len":100,"min_val":-100,"max_val":100},"test_tup2":{"min_len":100,"max_len":100,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_17","description":"Test with tuples of minimum allowed length (greater than 0).","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":5,"max_len":5,"min_val":-100,"max_val":100},"test_tup2":{"min_len":5,"max_len":5,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_18","description":"Test with tuples containing only one distinct element, repeated.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":10,"max_len":20,"min_val":5,"max_val":5},"test_tup2":{"min_len":10,"max_len":20,"min_val":5,"max_val":5}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_19","description":"Test with tuples where one has the single element repeated, the other has it once.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":10,"max_len":20,"min_val":7,"max_val":7},"test_tup2":{"min_len":1,"max_len":1,"min_val":7,"max_val":7}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]},{"id":"pc_20","description":"Test with tuples containing large integers.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":5,"max_len":20,"min_val":1000000,"max_val":2000000},"test_tup2":{"min_len":5,"max_len":20,"min_val":1000000,"max_val":2000000}},"postconditions":[{"assertion":"set(result) == set(test_tup1) & set(test_tup2)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6055"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic intersection of two tuples.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":1,"max_len":10},"test_tup2":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"result == tuple(set(test_tup1) & set(test_tup2))"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: One tuple is empty.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":0,"max_len":0},"test_tup2":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"result == ()"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: The other tuple is empty.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":1,"max_len":10},"test_tup2":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == ()"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Both tuples are empty.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":0,"max_len":0},"test_tup2":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == ()"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: Resulting tuple should not contain duplicates.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":1,"max_len":20},"test_tup2":{"min_len":1,"max_len":20}},"postconditions":[{"assertion":"len(result) == len(set(result))"}],"assumptions":[]},{"id":"pc_6","description":"Invariant: All elements in the result must be present in at least one of the input tuples.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":1,"max_len":20},"test_tup2":{"min_len":1,"max_len":20}},"postconditions":[{"assertion":"all(elem in test_tup1 or elem in test_tup2 for elem in result)"}],"assumptions":[]},{"id":"pc_7","description":"Typical Case: Tuples with some overlapping elements.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_val":1,"max_val":100,"min_len":5,"max_len":15},"test_tup2":{"min_val":50,"max_val":150,"min_len":5,"max_len":15}},"postconditions":[{"assertion":"result == tuple(set(test_tup1) & set(test_tup2))"}],"assumptions":["any(x in test_tup2 for x in test_tup1)"]},{"id":"pc_8","description":"Boundary Case: Large tuples with potential overlap.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":50,"max_len":100},"test_tup2":{"min_len":50,"max_len":100}},"postconditions":[{"assertion":"result == tuple(set(test_tup1) & set(test_tup2))"}],"assumptions":[]},{"id":"pc_9","description":"Case: Tuples with no overlapping elements.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_val":1,"max_val":50,"min_len":5,"max_len":10},"test_tup2":{"min_val":51,"max_val":100,"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result == ()"}],"assumptions":["not any(x in test_tup2 for x in test_tup1)"]},{"id":"pc_10","description":"Mixed Types: Tuples with strings and integers.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[Union[int, str]]","test_tup2":"tuple[Union[int, str]]"},"input_constraints":{"test_tup1":{"min_len":1,"max_len":10,"is_mixed":true,"max_codepoint":127},"test_tup2":{"min_len":1,"max_len":10,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"result == tuple(set(test_tup1) & set(test_tup2))"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: First argument is not a tuple (int).","execution_statement":"try: result = similar_elements(test_tup1, test_tup2) except Exception as e: result = e","input_types":{"test_tup1":"int","test_tup2":"tuple[int]"},"input_constraints":{"test_tup2":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Second argument is not a tuple (float).","execution_statement":"try: result = similar_elements(test_tup1, test_tup2) except Exception as e: result = e","input_types":{"test_tup1":"tuple[int]","test_tup2":"float"},"input_constraints":{"test_tup1":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: First argument is None.","execution_statement":"try: result = similar_elements(test_tup1, test_tup2) except Exception as e: result = e","input_types":{"test_tup1":"None","test_tup2":"tuple[int]"},"input_constraints":{"test_tup2":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Second argument is None.","execution_statement":"try: result = similar_elements(test_tup1, test_tup2) except Exception as e: result = e","input_types":{"test_tup1":"tuple[int]","test_tup2":"None"},"input_constraints":{"test_tup1":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Case: Tuples with duplicate elements within themselves.","execution_statement":"result = similar_elements(test_tup1, test_tup2)","input_types":{"test_tup1":"tuple[int]","test_tup2":"tuple[int]"},"input_constraints":{"test_tup1":{"min_len":5,"max_len":15,"unique":false},"test_tup2":{"min_len":5,"max_len":15,"unique":false}},"postconditions":[{"assertion":"result == tuple(set(test_tup1) & set(test_tup2))"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6056"},"test_cases":[{"id":"pc_1","description":"Test with input 0. 0 is not prime.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Test with input 1. 1 is not prime.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_3","description":"Test with input 2. 2 is prime, so is_not_prime should be False.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"Test with a small prime number (e.g., 3). Should return False.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"Test with a small non-prime number (e.g., 4). Should return True.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":4,"max_val":4}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Test with a larger prime number (e.g., 17). Should return False.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":17,"max_val":17}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Test with a larger non-prime number (e.g., 18). Should return True.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":18,"max_val":18}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_8","description":"Test with a perfect square that is non-prime (e.g., 9). Should return True.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":9,"max_val":9}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_9","description":"Test with a large prime number (e.g., 997). Should return False.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":997,"max_val":997}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"Test with a large non-prime number (e.g., 1000). Should return True.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":1000,"max_val":1000}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_11","description":"Test with a large integer near the typical integer limit (e.g., 1000000).","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":1000000,"max_val":1000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_12","description":"Test with an even number greater than 2 (e.g., 10). Should return True.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":10,"max_val":10}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_13","description":"Test with an odd composite number (e.g., 15). Should return True.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":15,"max_val":15}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_14","description":"Test a number where its smallest prime factor is just above its square root (e.g., 121 = 11*11). Should return True.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":121,"max_val":121}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_15","description":"Test a number with a large prime factor (e.g., 2 * 997 = 1994). Should return True.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":1994,"max_val":1994}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_16","description":"Test a prime number within a larger range (e.g., 7919). Should return False.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":7919,"max_val":7919}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_17","description":"Test a non-prime number within a larger range (e.g., 7921 = 89*89). Should return True.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":7921,"max_val":7921}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_18","description":"Test with a negative input. The function's loop range will be empty, returning False. This is an edge case to consider based on function logic.","execution_statement":"result = is_not_prime(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":-10,"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_19","description":"Test with a float input. Expecting TypeError.","execution_statement":"try: result = is_not_prime(number) except Exception as e: result = e","input_types":{"number":"float"},"input_constraints":{"number":{"min_val":10.0,"max_val":10.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_20","description":"Test with a string input. Expecting TypeError.","execution_statement":"try: result = is_not_prime(number) except Exception as e: result = e","input_types":{"number":"str"},"input_constraints":{"number":{"pattern":"^\\d+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6057"},"test_cases":[{"id":"pc_1","description":"Happy Path: Composite numbers","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":4,"max_val":1000}},"postconditions":[{"assertion":"result is True"}],"assumptions":["any(n % i == 0 for i in range(2, int(math.sqrt(n)) + 1))"]},{"id":"pc_2","description":"Edge Case: Prime numbers","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1000}},"postconditions":[{"assertion":"result is False"}],"assumptions":["not any(n % i == 0 for i in range(2, int(math.sqrt(n)) + 1))"]},{"id":"pc_3","description":"Edge Case: 0 and 1 (not prime, not composite)","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: 2 and 3 (prime)","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":3}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Value: Smallest composite number (4)","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"value":4}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Value: Large composite number","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":999900,"max_val":1000000}},"postconditions":[{"assertion":"result is True"}],"assumptions":["any(n % i == 0 for i in range(2, int(math.sqrt(n)) + 1))"]},{"id":"pc_7","description":"Boundary Value: Large prime number","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":999900,"max_val":1000000}},"postconditions":[{"assertion":"result is False"}],"assumptions":["not any(n % i == 0 for i in range(2, int(math.sqrt(n)) + 1))"]},{"id":"pc_8","description":"Invariant: Output is always boolean","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":10000}},"postconditions":[{"assertion":"isinstance(result, bool)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Non-integer input (float)","execution_statement":"try: result = is_not_prime(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Non-integer input (string)","execution_statement":"try: result = is_not_prime(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-integer input (None)","execution_statement":"try: result = is_not_prime(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Test with a perfect square composite number","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":4,"max_val":1000}},"postconditions":[{"assertion":"result is True"}],"assumptions":["int(math.sqrt(n))**2 == n and n > 1"]},{"id":"pc_13","description":"Test with a large number where sqrt is close to an integer","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":999999,"max_val":1000000}},"postconditions":[{"assertion":"result is True"}],"assumptions":["any(n % i == 0 for i in range(2, int(math.sqrt(n)) + 1))"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6058"},"test_cases":[{"id":"pc_1","description":"Typical case: Find 3 largest from a list of 10 integers.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-1000,"max_val":1000,"min_len":10,"max_len":10},"n":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_2","description":"Edge case: Find 1 largest from a list of 1 integer.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-1000,"max_val":1000,"min_len":1,"max_len":1},"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_3","description":"Boundary case: n equals list length.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-1000,"max_val":1000,"min_len":5,"max_len":5},"n":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_4","description":"Boundary case: n is greater than list length.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-1000,"max_val":1000,"min_len":3,"max_len":3},"n":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_5","description":"Edge case: List with all same elements.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":5,"max_val":5,"min_len":7,"max_len":7},"n":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_6","description":"Edge case: List with negative numbers.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-1000,"max_val":-1,"min_len":8,"max_len":8},"n":{"min_val":4,"max_val":4}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_7","description":"Edge case: List with mixed positive and negative numbers.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-500,"max_val":500,"min_len":12,"max_len":12,"is_mixed":true},"n":{"min_val":6,"max_val":6,"is_mixed":true}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_8","description":"Large list, small n.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-10000,"max_val":10000,"min_len":100,"max_len":100},"n":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_9","description":"Small list, large n (n > len(list)).","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-100,"max_val":100,"min_len":2,"max_len":2},"n":{"min_val":10,"max_val":10}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_10","description":"List with duplicate values, n requests some duplicates.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":10,"max_val":20,"min_len":15,"max_len":15,"unique":false},"n":{"min_val":7,"max_val":7}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_11","description":"List with duplicate values, n requests more than available unique values.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":10,"max_val":10,"min_len":5,"max_len":5,"unique":false},"n":{"min_val":7,"max_val":7}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_12","description":"List with zero.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-100,"max_val":100,"min_len":10,"max_len":10},"n":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":["0 in nums"]},{"id":"pc_13","description":"List with large numbers.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":1000000,"max_val":10000000,"min_len":10,"max_len":10},"n":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_14","description":"List with small numbers (close to zero).","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-10,"max_val":10,"min_len":10,"max_len":10},"n":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_15","description":"List with a single large value and many small values.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-1000,"max_val":1000,"min_len":10,"max_len":10},"n":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":["1000 in nums"]},{"id":"pc_16","description":"List with a single small value and many large values.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-1000,"max_val":1000,"min_len":10,"max_len":10},"n":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":["-1000 in nums"]},{"id":"pc_17","description":"Test with n=1 and a list of many elements.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-500,"max_val":500,"min_len":50,"max_len":50},"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_18","description":"Test with n equal to list length and all elements are unique.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-1000,"max_val":1000,"min_len":10,"max_len":10,"unique":true},"n":{"min_val":10,"max_val":10}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_19","description":"Test with n greater than list length and all elements are unique.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":-1000,"max_val":1000,"min_len":5,"max_len":5,"unique":true},"n":{"min_val":10,"max_val":10}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]},{"id":"pc_20","description":"Test with a list containing only one distinct value, repeated.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"List[int]","n":"int"},"input_constraints":{"nums":{"min_val":7,"max_val":7,"min_len":20,"max_len":20},"n":{"min_val":10,"max_val":10}},"postconditions":[{"assertion":"len(result) <= n and len(result) <= len(nums)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"all(elem in nums for elem in result)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6059"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with typical inputs.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":5,"max_len":20},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)[:n]"},{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"}],"assumptions":["n <= len(nums)"]},{"id":"pc_2","description":"Edge Case: Empty input list.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":0,"max_len":0},"n":{"min_val":0,"max_val":5}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: n is 0.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":5,"max_len":20},"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: n is negative.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":5,"max_len":20},"n":{"min_val":-10,"max_val":-1}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Case: n is equal to the length of the list.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":5,"max_len":10},"n":{}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)"},{"assertion":"len(result) == len(nums)"}],"assumptions":["n == len(nums)"]},{"id":"pc_6","description":"Boundary Case: n is greater than the length of the list.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":5,"max_len":10},"n":{"min_val":11,"max_val":20}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)"},{"assertion":"len(result) == len(nums)"}],"assumptions":["n > len(nums)"]},{"id":"pc_7","description":"Invariant: All elements in the result must be from the original list.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":5,"max_len":20},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"all(item in nums for item in result)"}],"assumptions":["n <= len(nums)"]},{"id":"pc_8","description":"Invariant: The result list should be sorted in descending order.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":5,"max_len":20},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"}],"assumptions":["n <= len(nums)"]},{"id":"pc_9","description":"Invariant: The length of the result should be min(n, len(nums)) for non-negative n.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":0,"max_len":20},"n":{"min_val":0,"max_val":20}},"postconditions":[{"assertion":"len(result) == min(n, len(nums))"}],"assumptions":[]},{"id":"pc_10","description":"Case: List with duplicate numbers.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":5,"max_len":20,"unique":false},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)[:n]"}],"assumptions":["n <= len(nums)"]},{"id":"pc_11","description":"Case: List with negative numbers.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":5,"max_len":20,"max_val":-1},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)[:n]"}],"assumptions":["n <= len(nums)"]},{"id":"pc_12","description":"Case: List with mixed positive and negative numbers.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":5,"max_len":20,"is_mixed":true},"n":{"min_val":1,"max_val":5,"is_mixed":true}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)[:n]"}],"assumptions":["n <= len(nums)"]},{"id":"pc_13","description":"Case: Large list, small n.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":1000,"max_len":2000},"n":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)[:n]"}],"assumptions":["n <= len(nums)"]},{"id":"pc_14","description":"Case: Large list, large n (close to list size).","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":1000,"max_len":2000},"n":{"min_val":900,"max_val":1000}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)[:n]"}],"assumptions":["n <= len(nums)"]},{"id":"pc_15","description":"Negative Test: Invalid input type for nums (int).","execution_statement":"try: result = heap_queue_largest(nums, n) except Exception as e: result = e","input_types":{"nums":"int","n":"int"},"input_constraints":{"nums":{},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: Invalid input type for n (str).","execution_statement":"try: result = heap_queue_largest(nums, n) except Exception as e: result = e","input_types":{"nums":"list[int]","n":"str"},"input_constraints":{"nums":{"min_len":5,"max_len":20},"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Case: List contains zero.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":5,"max_len":20},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)[:n]"}],"assumptions":["0 in nums","n <= len(nums)"]},{"id":"pc_18","description":"Case: List contains only zeros.","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_len":5,"max_len":20,"max_val":0,"min_val":0},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"result == [0] * min(n, len(nums))"}],"assumptions":["n <= len(nums)"]}]}
{"_id":{"$oid":"692adffe1b18223597bc605a"},"test_cases":[{"id":"pc_1","description":"Test with two numbers that differ by exactly one bit (positive integers).","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1,"max_val":2147483647},"b":{"min_val":1,"max_val":2147483647}},"postconditions":[{"assertion":"result == True"}],"assumptions":["(a ^ b).bit_count() == 1"]},{"id":"pc_2","description":"Test with two identical numbers (positive integers).","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0,"max_val":2147483647},"b":{"min_val":0,"max_val":2147483647}},"postconditions":[{"assertion":"result == False"}],"assumptions":["a == b"]},{"id":"pc_3","description":"Test with two numbers that differ by more than one bit (positive integers).","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0,"max_val":2147483647},"b":{"min_val":0,"max_val":2147483647}},"postconditions":[{"assertion":"result == False"}],"assumptions":["(a ^ b).bit_count() > 1"]},{"id":"pc_4","description":"Test with zero and a number differing by one bit.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0},"b":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_5","description":"Test with zero and a number differing by more than one bit.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0},"b":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_6","description":"Test with zero and zero.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0},"b":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Test with negative numbers differing by one bit.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-2147483648,"max_val":-1},"b":{"min_val":-2147483648,"max_val":-1}},"postconditions":[{"assertion":"result == True"}],"assumptions":["(a ^ b).bit_count() == 1"]},{"id":"pc_8","description":"Test with negative numbers differing by more than one bit.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-2147483648,"max_val":-1},"b":{"min_val":-2147483648,"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":["(a ^ b).bit_count() > 1"]},{"id":"pc_9","description":"Test with negative numbers that are identical.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-2147483648,"max_val":-1},"b":{"min_val":-2147483648,"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":["a == b"]},{"id":"pc_10","description":"Test with a mix of positive and negative numbers differing by one bit.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-2147483648,"max_val":2147483647},"b":{"min_val":-2147483648,"max_val":2147483647}},"postconditions":[{"assertion":"result == True"}],"assumptions":["(a ^ b).bit_count() == 1"]},{"id":"pc_11","description":"Test with a mix of positive and negative numbers differing by more than one bit.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-2147483648,"max_val":2147483647},"b":{"min_val":-2147483648,"max_val":2147483647}},"postconditions":[{"assertion":"result == False"}],"assumptions":["(a ^ b).bit_count() > 1"]},{"id":"pc_12","description":"Test with large integers differing by one bit.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1000000000,"max_val":2147483647},"b":{"min_val":1000000000,"max_val":2147483647}},"postconditions":[{"assertion":"result == True"}],"assumptions":["(a ^ b).bit_count() == 1"]},{"id":"pc_13","description":"Test with small integers differing by one bit.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == True"}],"assumptions":["(a ^ b).bit_count() == 1"]},{"id":"pc_14","description":"Test with numbers that are powers of two and differ by one bit (e.g., 2 and 3).","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1,"max_val":2147483647},"b":{"min_val":1,"max_val":2147483647}},"postconditions":[{"assertion":"result == True"}],"assumptions":["is_Power_Of_Two(a) or is_Power_Of_Two(b)","(a ^ b).bit_count() == 1"]},{"id":"pc_15","description":"Test with numbers that are powers of two and differ by more than one bit.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1,"max_val":2147483647},"b":{"min_val":1,"max_val":2147483647}},"postconditions":[{"assertion":"result == False"}],"assumptions":["is_Power_Of_Two(a) or is_Power_Of_Two(b)","(a ^ b).bit_count() > 1"]},{"id":"pc_16","description":"Test with numbers that are powers of two and are identical.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1,"max_val":2147483647},"b":{"min_val":1,"max_val":2147483647}},"postconditions":[{"assertion":"result == False"}],"assumptions":["a == b","is_Power_Of_Two(a)"]},{"id":"pc_17","description":"Test with maximum integer value and a value differing by one bit.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":2147483647,"max_val":2147483647},"b":{"min_val":2147483646,"max_val":2147483646}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_18","description":"Test with minimum integer value and a value differing by one bit.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-2147483648,"max_val":-2147483648},"b":{"min_val":-2147483647,"max_val":-2147483647}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_19","description":"Test with maximum integer value and itself.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":2147483647,"max_val":2147483647},"b":{"min_val":2147483647,"max_val":2147483647}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_20","description":"Test with minimum integer value and itself.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-2147483648,"max_val":-2147483648},"b":{"min_val":-2147483648,"max_val":-2147483648}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc605b"},"test_cases":[{"id":"pc_1","description":"Happy Path: Numbers differing at one bit position.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1},"b":{"min_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":["differ_At_One_Bit_Pos(a, b) is True"]},{"id":"pc_2","description":"Happy Path: Numbers not differing at one bit position.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0},"b":{"min_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":["differ_At_One_Bit_Pos(a, b) is False"]},{"id":"pc_3","description":"Edge Case: Identical numbers.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0},"b":{"min_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":["a == b"]},{"id":"pc_4","description":"Edge Case: Zero and a power of two.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0},"b":{"min_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":["is_Power_Of_Two(b)"]},{"id":"pc_5","description":"Edge Case: Power of two and zero.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1},"b":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":["is_Power_Of_Two(a)"]},{"id":"pc_6","description":"Boundary: Large numbers differing at one bit position.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1073741824,"max_val":2147483647},"b":{"min_val":1073741824,"max_val":2147483647}},"postconditions":[{"assertion":"result == True"}],"assumptions":["differ_At_One_Bit_Pos(a, b) is True"]},{"id":"pc_7","description":"Boundary: Large numbers not differing at one bit position.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1073741824,"max_val":2147483647},"b":{"min_val":1073741824,"max_val":2147483647}},"postconditions":[{"assertion":"result == False"}],"assumptions":["differ_At_One_Bit_Pos(a, b) is False"]},{"id":"pc_8","description":"Invariant: XOR of numbers differing at one bit must be a power of two.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0},"b":{"min_val":0}},"postconditions":[{"assertion":"is_Power_Of_Two(a ^ b) == True"}],"assumptions":["differ_At_One_Bit_Pos(a, b) is True"]},{"id":"pc_9","description":"Invariant: XOR of numbers not differing at one bit must not be a power of two.","execution_statement":"result = differ_At_One_Bit_Pos(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0},"b":{"min_val":0}},"postconditions":[{"assertion":"is_Power_Of_Two(a ^ b) == False"}],"assumptions":["differ_At_One_Bit_Pos(a, b) is False"]},{"id":"pc_10","description":"Negative Test: Non-integer input for 'a'.","execution_statement":"try: result = differ_At_One_Bit_Pos(a, b) except Exception as e: result = e","input_types":{"a":"str","b":"int"},"input_constraints":{"a":{"min_len":1,"max_codepoint":255},"b":{"min_val":0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-integer input for 'b'.","execution_statement":"try: result = differ_At_One_Bit_Pos(a, b) except Exception as e: result = e","input_types":{"a":"int","b":"str"},"input_constraints":{"a":{"min_val":0},"b":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: null input for 'a'.","execution_statement":"try: result = differ_At_One_Bit_Pos(a, b) except Exception as e: result = e","input_types":{"a":"Optional[int]","b":"int"},"input_constraints":{"a":{"allow_none":true},"b":{"min_val":0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["a is None"]},{"id":"pc_13","description":"Negative Test: null input for 'b'.","execution_statement":"try: result = differ_At_One_Bit_Pos(a, b) except Exception as e: result = e","input_types":{"a":"int","b":"Optional[int]"},"input_constraints":{"a":{"min_val":0},"b":{"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["b is None"]}]}
{"_id":{"$oid":"692adffe1b18223597bc605c"},"test_cases":[{"id":"TC1","description":"Typical case with mixed word lengths and punctuation.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"pattern":"^[\\w\\s.,!?-]{10,100}$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC2","description":"String with only short words (less than 4 characters).","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]{1,3}(\\s[a-z]{1,3})*$","min_len":5,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == []"}]},{"id":"TC3","description":"String with only long words (4 or more characters).","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]{4}(\\s[a-z]{4})*$","min_len":5,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC4","description":"Empty string input.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == []"}]},{"id":"TC5","description":"String with only punctuation and symbols.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[^\\w\\s]+$","min_len":5,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == []"}]},{"id":"TC6","description":"String with numbers and words.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[\\w\\s\\d]+$","min_len":10,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC7","description":"String with leading/trailing spaces and multiple spaces between words.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^\\s*[\\w\\s]{4}\\s*$","min_len":10,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC8","description":"String with words exactly 4 characters long.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]{4}(\\s[a-z]{4})*$","min_len":4,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) == 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC9","description":"String with words exactly 3 characters long.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]{1,3}(\\s[a-z]{1,3})*$","min_len":3,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == []"}]},{"id":"TC10","description":"Very long string with mixed content.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":500,"max_len":2000,"pattern":"^[\\w\\s.,!?-]{500,2000}$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC11","description":"String with Unicode characters.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"pattern":"^[\\w\\s.,!?----]{10,100}$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC12","description":"String with repeated words.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"pattern":"^(word{4}\\s)+word{4}$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC13","description":"String with words separated by tabs and newlines.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"pattern":"^[\\w\\t\\n]{10,100}$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC14","description":"String with hyphenated words.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"pattern":"^[\\w-]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC15","description":"String with apostrophes within words.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"pattern":"^[\\w']+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC16","description":"String with only numbers, some longer than 4 digits.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^\\d{1,3}(\\s\\d{4})*$","min_len":5,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC17","description":"String with mixed case words.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"pattern":"^[\\w\\s]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC18","description":"String with words at the boundary of 4 characters.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":8,"max_len":50,"pattern":"^([a-z]{3}\\s)?[a-z]{4}(\\s[a-z]{3})?(\\s[a-z]{4})*([a-z]{3}\\s)?$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC19","description":"String with only one word, longer than 4 characters.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]{4}$","min_len":4,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"set(result) == set(re.findall(r'\\b\\w{4}\\b', text))"}]},{"id":"TC20","description":"String with only one word, shorter than 4 characters.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]{1,3}$","min_len":1,"max_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"result == []"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc605d"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical sentence with multiple long words","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-zA-Z-9 ]+$","min_len":10,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"result == re.findall(r'\\b\\w{4}\\b', text)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string input","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String with only short words","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z ]+$","min_len":5,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":["not any(len(w) >= 4 for w in text.split())"]},{"id":"pc_4","description":"Edge Case: String with words exactly 4 characters long","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z ]+$","min_len":10,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == re.findall(r'\\b\\w{4}\\b', text)"}],"assumptions":["all(len(w) == 4 for w in text.split())"]},{"id":"pc_5","description":"Edge Case: String with punctuation and numbers","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"result == re.findall(r'\\b\\w{4}\\b', text)"}],"assumptions":[]},{"id":"pc_6","description":"Invariant: All returned words are at least 4 characters long","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":1,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"}],"assumptions":[]},{"id":"pc_7","description":"Invariant: No duplicates in the result","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":1,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"len(result) == len(set(result))"}],"assumptions":[]},{"id":"pc_8","description":"Boundary: Very long string with many long words","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":1000,"max_len":5000,"max_codepoint":255}},"postconditions":[{"assertion":"result == re.findall(r'\\b\\w{4}\\b', text)"}],"assumptions":[]},{"id":"pc_9","description":"Edge Case: String with only spaces","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[ ]+$","min_len":5,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_10","description":"Edge Case: String with special characters and no words","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[^a-zA-Z-9 ]+$","min_len":5,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_11","description":"Happy Path: Sentence with mixed case words","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == re.findall(r'\\b\\w{4}\\b', text)"}],"assumptions":[]},{"id":"pc_12","description":"Edge Case: String with only one long word","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+$","min_len":4,"max_len":4,"max_codepoint":255}},"postconditions":[{"assertion":"result == [text]"}],"assumptions":[]},{"id":"pc_13","description":"Edge Case: String with numbers as words","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[-9 ]+$","min_len":5,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == re.findall(r'\\b\\w{4}\\b', text)"}],"assumptions":[]},{"id":"pc_14","description":"Invariant: All returned words consist of alphanumeric characters","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":1,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"all(word.isalnum() for word in result)"}],"assumptions":[]},{"id":"pc_15","description":"Edge Case: String with words separated by multiple spaces","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-zA-Z-9 ]+$","min_len":10,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"result == re.findall(r'\\b\\w{4}\\b', text)"}],"assumptions":["'  ' in text"]},{"id":"pc_16","description":"Edge Case: String with words separated by tabs and newlines","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"result == re.findall(r'\\b\\w{4}\\b', text)"}],"assumptions":["'\\t' in text or '\\n' in text"]},{"id":"pc_17","description":"Edge Case: String with leading/trailing spaces","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"result == re.findall(r'\\b\\w{4}\\b', text)"}],"assumptions":["text.startswith(' ') or text.endswith(' ')"]},{"id":"pc_18","description":"Edge Case: String with only punctuation","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[!@#$%^&*()_+={}\\[\\]:;\"'<>?,./|\\~`-]+$","min_len":5,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_19","description":"Happy Path: Sentence with hyphenated words (treated as single words by \\w)","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"result == re.findall(r'\\b\\w{4}\\b', text)"}],"assumptions":["'-' in text"]},{"id":"pc_20","description":"Edge Case: String with apostrophes in words","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"result == re.findall(r'\\b\\w{4}\\b', text)"}],"assumptions":["\"'\" in text"]}]}
{"_id":{"$oid":"692adffe1b18223597bc605e"},"test_cases":[{"id":"pc_1","description":"Typical case with positive integers.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":100,"min_len":1,"max_len":10}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_2","description":"Typical case with negative integers.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":10}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_3","description":"Typical case with mixed positive and negative integers.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":100,"min_len":1,"max_len":10,"is_mixed":true}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_4","description":"Boundary case: zero.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":0,"max_val":0,"min_len":1,"max_len":5}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_5","description":"Boundary case: one.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":1,"min_len":1,"max_len":5}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_6","description":"Boundary case: minus one.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-1,"max_val":-1,"min_len":1,"max_len":5}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_7","description":"Edge case: empty list.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_8","description":"Large integers.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":10000,"max_val":100000,"min_len":1,"max_len":5}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_9","description":"Floats: typical case.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[float]"},"input_constraints":{"nums":{"min_val":0.1,"max_val":10.0,"min_len":1,"max_len":10,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(abs(result[i] - nums[i] ** 2) < 1e-9 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_10","description":"Floats: negative values.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[float]"},"input_constraints":{"nums":{"min_val":-10.0,"max_val":-0.1,"min_len":1,"max_len":10,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(abs(result[i] - nums[i] ** 2) < 1e-9 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_11","description":"Floats: zero.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[float]"},"input_constraints":{"nums":{"min_val":0.0,"max_val":0.0,"min_len":1,"max_len":5,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == 0.0 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_12","description":"Floats: small values close to zero.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[float]"},"input_constraints":{"nums":{"min_val":1E-09,"max_val":0.001,"min_len":1,"max_len":10,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(abs(result[i] - nums[i] ** 2) < 1e-18 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_13","description":"Floats: large values.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[float]"},"input_constraints":{"nums":{"min_val":1E+06,"max_val":1E+09,"min_len":1,"max_len":5,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(abs(result[i] - nums[i] ** 2) < 1e-9 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_14","description":"Mixed types: integers and floats.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[Union[int, float]]"},"input_constraints":{"nums":{"min_val":-100,"max_val":100,"min_len":1,"max_len":10,"allow_nan":false,"allow_infinity":false,"is_mixed":true}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(abs(result[i] - nums[i] ** 2) < 1e-9 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_15","description":"Large list of integers.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":1000,"min_len":100,"max_len":1000}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_16","description":"Large list of floats.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[float]"},"input_constraints":{"nums":{"min_val":0.001,"max_val":1000.0,"min_len":100,"max_len":1000,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(abs(result[i] - nums[i] ** 2) < 1e-9 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_17","description":"List with only one element (integer).","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-50,"max_val":50,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_18","description":"List with only one element (float).","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[float]"},"input_constraints":{"nums":{"min_val":-50.0,"max_val":50.0,"min_len":1,"max_len":1,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(abs(result[i] - nums[i] ** 2) < 1e-9 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_19","description":"List with duplicate integers.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":10,"min_len":5,"max_len":15,"unique":false}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_20","description":"List with duplicate floats.","execution_statement":"result = square_nums(nums)","input_types":{"nums":"List[float]"},"input_constraints":{"nums":{"min_val":1.0,"max_val":10.0,"min_len":5,"max_len":15,"allow_nan":false,"allow_infinity":false,"unique":false}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(abs(result[i] - nums[i] ** 2) < 1e-9 for i in range(len(nums)))"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc605f"},"test_cases":[{"id":"pc_1","description":"Happy Path: List of positive integers","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":1,"min_len":1,"max_len":100}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"},{"assertion":"all(x > 0 for x in result)"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: List of negative integers","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"max_val":-1,"min_len":1,"max_len":100}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"},{"assertion":"all(x > 0 for x in result)"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: List with mixed positive, negative, and zero integers","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":100,"is_mixed":true}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"},{"assertion":"all(x >= 0 for x in result)"}],"assumptions":["0 in nums or any(n > 0 for n in nums) or any(n < 0 for n in nums)"]},{"id":"pc_4","description":"Edge Case: Empty list","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"len(result) == 0"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: List containing only zero","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":0,"max_val":0,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == [0]"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Value: List with 1 and -1","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":2}},"postconditions":[{"assertion":"result == [1, 1]"}],"assumptions":["nums == [1, -1] or nums == [-1, 1]"]},{"id":"pc_7","description":"Happy Path: List of floating-point numbers","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[float]"},"input_constraints":{"nums":{"min_len":1,"max_len":100}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(abs(result[i] - nums[i] ** 2) < 1e-9 for i in range(len(nums)))"},{"assertion":"all(x >= 0 for x in result)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Input is not a list (e.g., integer)","execution_statement":"try: result = square_nums(nums) except Exception as e: result = e","input_types":{"nums":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Input is not a list (e.g., string)","execution_statement":"try: result = square_nums(nums) except Exception as e: result = e","input_types":{"nums":"str"},"input_constraints":{"nums":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: List contains non-numeric type (string)","execution_statement":"try: result = square_nums(nums) except Exception as e: result = e","input_types":{"nums":"list[Any]"},"input_constraints":{"nums":{"min_len":0,"max_len":2,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["any(isinstance(x, str) for x in nums)"]},{"id":"pc_11","description":"Negative Test: List contains None","execution_statement":"try: result = square_nums(nums) except Exception as e: result = e","input_types":{"nums":"list[Optional[int]]"},"input_constraints":{"nums":{"min_len":1,"max_len":10,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["any(x is None for x in nums)"]},{"id":"pc_12","description":"Large numbers: Positive","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":1000000000,"max_val":9999999999,"min_len":1,"max_len":5}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"}],"assumptions":[]},{"id":"pc_13","description":"Large numbers: Negative","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-9999999999,"max_val":-1000000000,"min_len":1,"max_len":5}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"},{"assertion":"all(x > 0 for x in result)"}],"assumptions":[]},{"id":"pc_14","description":"List with large number of elements","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":100,"min_len":1000,"max_len":1000}},"postconditions":[{"assertion":"len(result) == len(nums)"},{"assertion":"all(result[i] == nums[i] ** 2 for i in range(len(nums)))"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6060"},"test_cases":[{"id":"pc_1","description":"Typical case with a string that requires rotations.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":2,"max_len":50,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 1 and result <= len(input_str)"}],"assumptions":["input_str != input_str[::-1]"]},{"id":"pc_2","description":"Edge case: String with all same characters.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":1,"max_len":50,"pattern":"^(.)\\1+$","max_codepoint":255}},"postconditions":[{"assertion":"result == len(input_str)"}],"assumptions":[]},{"id":"pc_3","description":"Edge case: String with two alternating characters.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":2,"max_len":50,"pattern":"^([a-zA-Z])([a-zA-Z])\\1\\2.*$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 1 and result <= len(input_str)"}],"assumptions":["len(set(input_str)) == 2"]},{"id":"pc_4","description":"Edge case: String with all unique characters.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":2,"max_len":50,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == len(input_str)"}],"assumptions":["len(set(input_str)) == len(input_str)"]},{"id":"pc_5","description":"Boundary case: Minimum length string.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_6","description":"Boundary case: String of length 2.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":2,"max_len":2,"pattern":"^[a-zA-Z]{2}$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 1 and result <= 2"}],"assumptions":[]},{"id":"pc_7","description":"Long string to test performance and correctness.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":100,"max_len":200,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 1 and result <= len(input_str)"}],"assumptions":[]},{"id":"pc_8","description":"String that is a palindrome (should require full rotation).","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":2,"max_len":50,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == len(input_str)"}],"assumptions":["input_str == input_str[::-1]"]},{"id":"pc_9","description":"String with numbers and letters.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":2,"max_len":50,"pattern":"^[a-zA-Z-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 1 and result <= len(input_str)"}],"assumptions":[]},{"id":"pc_10","description":"String with special characters.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":2,"max_len":50,"pattern":"^[^a-zA-Z-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 1 and result <= len(input_str)"}],"assumptions":[]},{"id":"pc_11","description":"String with mixed alphanumeric and special characters.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":2,"max_len":50,"pattern":"^[a-zA-Z-9!@#$%^&*()_+-=]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 1 and result <= len(input_str)"}],"assumptions":[]},{"id":"pc_12","description":"String where the rotation is exactly half the length.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":4,"max_len":50,"pattern":"^([a-zA-Z-9])\\1*([a-zA-Z-9])\\2*$","max_codepoint":255}},"postconditions":[{"assertion":"result == len(input_str) // 2"}],"assumptions":["len(input_str) % 2 == 0","input_str[:len(input_str)//2] == input_str[len(input_str)//2:]"]},{"id":"pc_13","description":"String with unicode characters.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":2,"max_len":50,"max_codepoint":1114111}},"postconditions":[{"assertion":"result >= 1 and result <= len(input_str)"}],"assumptions":[]},{"id":"pc_14","description":"String with repeated patterns that are not full rotations.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":6,"max_len":50,"pattern":"^([a-zA-Z-9])([a-zA-Z-9])([a-zA-Z-9])\\1\\2\\3.*$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 1 and result <= len(input_str)"}],"assumptions":["len(set(input_str)) > 1","input_str != input_str[1:] + input_str[0]"]},{"id":"pc_15","description":"String with a very short repeating unit.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":10,"max_len":50,"pattern":"^(.)\\1+$","max_codepoint":255}},"postconditions":[{"assertion":"result == len(input_str)"}],"assumptions":["len(input_str) > 1"]},{"id":"pc_16","description":"String with a repeating pattern that is not the full string.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":6,"max_len":50,"pattern":"^([a-zA-Z])([a-zA-Z])\\1\\2.*$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 1 and result <= len(input_str)"}],"assumptions":["len(set(input_str)) == 2","input_str != input_str[2:] + input_str[:2]"]},{"id":"pc_17","description":"String with a single character repeated many times.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":100,"max_len":200,"pattern":"^(.)\\1+$","max_codepoint":255}},"postconditions":[{"assertion":"result == len(input_str)"}],"assumptions":[]},{"id":"pc_18","description":"String with two distinct characters alternating.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":10,"max_len":50,"pattern":"^([a-zA-Z])([a-zA-Z])\\1\\2.*$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 1 and result <= len(input_str)"}],"assumptions":["len(set(input_str)) == 2"]},{"id":"pc_19","description":"String with a repeating pattern of length 3.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":9,"max_len":50,"pattern":"^([a-zA-Z])([a-zA-Z])([a-zA-Z])\\1\\2\\3.*$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 1 and result <= len(input_str)"}],"assumptions":["len(set(input_str)) == 3"]},{"id":"pc_20","description":"String with a repeating pattern of length 4.","execution_statement":"result = find_Rotations(input_str)","input_types":{"input_str":"str"},"input_constraints":{"input_str":{"min_len":8,"max_len":50,"pattern":"^([a-zA-Z])([a-zA-Z])([a-zA-Z])([a-zA-Z])\\1\\2\\3\\4.*$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 1 and result <= len(input_str)"}],"assumptions":["len(set(input_str)) == 4"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6061"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical string with rotations","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":2,"max_len":50,"pattern":"^[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 1"},{"assertion":"result <= len(str)"},{"assertion":"str + str[result:] + str[:result] == str"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: String with no rotations (e.g., 'abcde')","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":2,"max_len":50,"pattern":"^[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == len(str)"},{"assertion":"isinstance(result, int)"}],"assumptions":["len(set(str)) == len(str)"]},{"id":"pc_3","description":"Happy Path: String with all same characters (e.g., 'aaaaa')","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":2,"max_len":50,"pattern":"^(.)\\1+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"},{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Empty string","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"},{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Single character string","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":1,"max_len":1,"pattern":"^[a-z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"},{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_6","description":"Boundary: Max length string","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":50,"max_len":50,"pattern":"^[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 1"},{"assertion":"result <= len(str)"},{"assertion":"str + str[result:] + str[:result] == str"}],"assumptions":[]},{"id":"pc_7","description":"String with repeating pattern at different intervals","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":4,"max_len":50,"pattern":"^(ab)+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 2"},{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_8","description":"String with a longer repeating pattern","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":6,"max_len":50,"pattern":"^(abc)+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 3"},{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_9","description":"String with a complex repeating pattern","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":8,"max_len":50,"pattern":"^(abab)+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 2"},{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_10","description":"String with a pattern that is a prefix of itself","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":4,"max_len":50,"pattern":"^(a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z){1,5}(a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z){1,5}$","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"},{"assertion":"isinstance(result, int)"}],"assumptions":["len(str) > 1 and str == str[1:] + str[0]"]},{"id":"pc_11","description":"String with a pattern that is a prefix of itself (longer rotation)","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":4,"max_len":50,"pattern":"^[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 2"},{"assertion":"isinstance(result, int)"}],"assumptions":["len(str) > 1 and str == str[2:] + str[:2]"]},{"id":"pc_12","description":"String with a pattern that is a prefix of itself (even longer rotation)","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":6,"max_len":50,"pattern":"^[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 3"},{"assertion":"isinstance(result, int)"}],"assumptions":["len(str) > 1 and str == str[3:] + str[:3]"]},{"id":"pc_13","description":"String with mixed case characters","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":2,"max_len":50,"pattern":"^[a-zA-Z]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 1"},{"assertion":"result <= len(str)"},{"assertion":"str + str[result:] + str[:result] == str"}],"assumptions":[]},{"id":"pc_14","description":"String with numbers and special characters","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":2,"max_len":50,"pattern":"^[a-zA-Z-9!@#$%^&*()_+=-]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 1"},{"assertion":"result <= len(str)"},{"assertion":"str + str[result:] + str[:result] == str"}],"assumptions":[]},{"id":"pc_15","description":"String with unicode characters","execution_statement":"result = find_Rotations(str)","input_types":{"str":"str"},"input_constraints":{"str":{"min_len":2,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 1"},{"assertion":"result <= len(str)"},{"assertion":"str + str[result:] + str[:result] == str"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: Non-string input (integer)","execution_statement":"try: result = find_Rotations(str) except Exception as e: result = e","input_types":{"str":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Negative Test: Non-string input (None)","execution_statement":"try: result = find_Rotations(str) except Exception as e: result = e","input_types":{"str":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_18","description":"Negative Test: Non-string input (list)","execution_statement":"try: result = find_Rotations(str) except Exception as e: result = e","input_types":{"str":"list"},"input_constraints":{"str":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6062"},"test_cases":[{"id":"pc_1","description":"Typical case: character present multiple times.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":50,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255}},"postconditions":[{"assertion":"input_string.count(char_to_remove) >= 2 and result == input_string[:input_string.find(char_to_remove)] + input_string[input_string.find(char_to_remove)+1:input_string.rfind(char_to_remove)] + input_string[input_string.rfind(char_to_remove)+1:]"}],"assumptions":["input_string.count(char_to_remove) >= 2"]},{"id":"pc_2","description":"Edge case: character present only once.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":1,"max_len":50,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255}},"postconditions":[{"assertion":"input_string.count(char_to_remove) == 1 and result == input_string.replace(char_to_remove, '', 1)"}],"assumptions":["input_string.count(char_to_remove) == 1"]},{"id":"pc_3","description":"Edge case: character not present.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":1,"max_len":50,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255}},"postconditions":[{"assertion":"char_to_remove not in input_string and result == input_string"}],"assumptions":["char_to_remove not in input_string"]},{"id":"pc_4","description":"Boundary case: empty string.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":0,"max_len":0,"max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":[]},{"id":"pc_5","description":"Boundary case: string with only the character to remove, repeated.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":5,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(c == char_to_remove for c in input_string) and len(input_string) >= 2 and result == input_string[1:-1]"}],"assumptions":["all(c == char_to_remove for c in input_string)"]},{"id":"pc_6","description":"Edge case: string with only the character to remove, once.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":1,"max_len":1,"max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"input_string == char_to_remove and result == ''"}],"assumptions":["input_string == char_to_remove"]},{"id":"pc_7","description":"Typical case: character at the beginning and end.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":50,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255}},"postconditions":[{"assertion":"input_string.startswith(char_to_remove) and input_string.endswith(char_to_remove) and input_string.count(char_to_remove) >= 2 and result == input_string[1:-1]"}],"assumptions":["input_string.startswith(char_to_remove) and input_string.endswith(char_to_remove) and input_string.count(char_to_remove) >= 2"]},{"id":"pc_8","description":"Typical case: character at the beginning and middle.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":50,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255}},"postconditions":[{"assertion":"input_string.startswith(char_to_remove) and input_string.find(char_to_remove, 1) != -1 and input_string.count(char_to_remove) >= 2 and result == input_string[1:input_string.rfind(char_to_remove)] + input_string[input_string.rfind(char_to_remove)+1:]"}],"assumptions":["input_string.startswith(char_to_remove) and input_string.find(char_to_remove, 1) != -1 and input_string.count(char_to_remove) >= 2"]},{"id":"pc_9","description":"Typical case: character at the middle and end.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":50,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255}},"postconditions":[{"assertion":"input_string.find(char_to_remove) != -1 and input_string.rfind(char_to_remove) != input_string.find(char_to_remove) and input_string.count(char_to_remove) >= 2 and result == input_string[:input_string.find(char_to_remove)] + input_string[input_string.find(char_to_remove)+1:input_string.rfind(char_to_remove)] + input_string[input_string.rfind(char_to_remove)+1:]"}],"assumptions":["input_string.find(char_to_remove) != -1 and input_string.rfind(char_to_remove) != input_string.find(char_to_remove) and input_string.count(char_to_remove) >= 2"]},{"id":"pc_10","description":"Edge case: string with special characters.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":50,"pattern":"^[!@#$%^&*()_+=-`~{}\\[\\]:;\"'|,.<>/?\\ ]+$","max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"pattern":"^[!@#$%^&*()_+=-`~{}\\[\\]:;\"'|,.<>/?\\ ]+$","max_codepoint":255}},"postconditions":[{"assertion":"input_string.count(char_to_remove) >= 2 and result == input_string[:input_string.find(char_to_remove)] + input_string[input_string.find(char_to_remove)+1:input_string.rfind(char_to_remove)] + input_string[input_string.rfind(char_to_remove)+1:]"}],"assumptions":["input_string.count(char_to_remove) >= 2"]},{"id":"pc_11","description":"Edge case: string with unicode characters.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":50,"max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"input_string.count(char_to_remove) >= 2 and result == input_string[:input_string.find(char_to_remove)] + input_string[input_string.find(char_to_remove)+1:input_string.rfind(char_to_remove)] + input_string[input_string.rfind(char_to_remove)+1:]"}],"assumptions":["input_string.count(char_to_remove) >= 2"]},{"id":"pc_12","description":"Invariant test: length of string decreases by 2 if char appears at least twice.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":50,"max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"input_string.count(char_to_remove) >= 2 and len(result) == len(input_string) - 2"}],"assumptions":["input_string.count(char_to_remove) >= 2"]},{"id":"pc_13","description":"Invariant test: length of string decreases by 1 if char appears exactly once.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":1,"max_len":50,"max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"input_string.count(char_to_remove) == 1 and len(result) == len(input_string) - 1"}],"assumptions":["input_string.count(char_to_remove) == 1"]},{"id":"pc_14","description":"Invariant test: length of string remains the same if char does not appear.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":0,"max_len":50,"max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"char_to_remove not in input_string and len(result) == len(input_string)"}],"assumptions":["char_to_remove not in input_string"]},{"id":"pc_15","description":"Case sensitivity: removing lowercase when uppercase is present.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":50,"max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"input_string.lower().count(char_to_remove.lower()) >= 2 and char_to_remove.islower() and result == input_string[:input_string.find(char_to_remove)] + input_string[input_string.find(char_to_remove)+1:input_string.rfind(char_to_remove)] + input_string[input_string.rfind(char_to_remove)+1:]"}],"assumptions":["input_string.lower().count(char_to_remove.lower()) >= 2","char_to_remove.islower()"]},{"id":"pc_16","description":"Case sensitivity: removing uppercase when lowercase is present.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":50,"max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"input_string.upper().count(char_to_remove.upper()) >= 2 and char_to_remove.isupper() and result == input_string[:input_string.find(char_to_remove)] + input_string[input_string.find(char_to_remove)+1:input_string.rfind(char_to_remove)] + input_string[input_string.rfind(char_to_remove)+1:]"}],"assumptions":["input_string.upper().count(char_to_remove.upper()) >= 2","char_to_remove.isupper()"]},{"id":"pc_17","description":"String with mixed case characters, removing a specific case.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":50,"is_mixed":true,"max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"input_string.count(char_to_remove) >= 2 and result == input_string[:input_string.find(char_to_remove)] + input_string[input_string.find(char_to_remove)+1:input_string.rfind(char_to_remove)] + input_string[input_string.rfind(char_to_remove)+1:]"}],"assumptions":["input_string.count(char_to_remove) >= 2"]},{"id":"pc_18","description":"String with numbers and characters, removing a number.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":50,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"pattern":"^[-9]$","max_codepoint":255}},"postconditions":[{"assertion":"input_string.count(char_to_remove) >= 2 and result == input_string[:input_string.find(char_to_remove)] + input_string[input_string.find(char_to_remove)+1:input_string.rfind(char_to_remove)] + input_string[input_string.rfind(char_to_remove)+1:]"}],"assumptions":["input_string.count(char_to_remove) >= 2"]},{"id":"pc_19","description":"String with spaces, removing a space.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":50,"pattern":"^[ ]+$","max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"pattern":"^ $","max_codepoint":255}},"postconditions":[{"assertion":"input_string.count(char_to_remove) >= 2 and result == input_string[:input_string.find(char_to_remove)] + input_string[input_string.find(char_to_remove)+1:input_string.rfind(char_to_remove)] + input_string[input_string.rfind(char_to_remove)+1:]"}],"assumptions":["input_string.count(char_to_remove) >= 2"]},{"id":"pc_20","description":"String with repeated characters, removing a character that appears consecutively.","execution_statement":"result = remove_Occ(input_string, char_to_remove)","input_types":{"input_string":"str","char_to_remove":"str"},"input_constraints":{"input_string":{"min_len":2,"max_len":50,"max_codepoint":255},"char_to_remove":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"input_string.count(char_to_remove) >= 2 and result == input_string[:input_string.find(char_to_remove)] + input_string[input_string.find(char_to_remove)+1:input_string.rfind(char_to_remove)] + input_string[input_string.rfind(char_to_remove)+1:]"}],"assumptions":["input_string.count(char_to_remove) >= 2"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6063"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic removal of first and last character.","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":2,"pattern":"^[a-zA-Z]+$","max_codepoint":255},"ch":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == s.replace(ch, '', 1).replace(ch, '')"}],"assumptions":["s.count(ch) >= 2"]},{"id":"pc_2","description":"Edge Case: Character appears only once.","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":1,"pattern":"^[a-zA-Z]+$","max_codepoint":255},"ch":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == s.replace(ch, '')"}],"assumptions":["s.count(ch) == 1"]},{"id":"pc_3","description":"Edge Case: Character not present in the string.","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":1,"pattern":"^[a-zA-Z]+$","max_codepoint":255},"ch":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == s"}],"assumptions":["s.count(ch) == 0"]},{"id":"pc_4","description":"Edge Case: Empty input string.","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":0,"max_len":0,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: String consists only of the character to be removed (length > 2).","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":3,"pattern":"^[a-zA-Z]+$","max_codepoint":255},"ch":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == s[1:-1]"}],"assumptions":["s.count(ch) == len(s)"]},{"id":"pc_6","description":"Edge Case: String consists of two characters, both are the character to be removed.","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":2,"max_len":2,"pattern":"^[a-zA-Z]+$","max_codepoint":255},"ch":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":["s.count(ch) == 2"]},{"id":"pc_7","description":"Character to remove is at the beginning and end.","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":0,"pattern":"^[a-zA-Z]+$","max_codepoint":255},"ch":{"min_len":0,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == s[1:-1]"}],"assumptions":["s.startswith(ch)","s.endswith(ch)","s.count(ch) >= 2"]},{"id":"pc_8","description":"Character to remove is at the beginning only (and appears multiple times).","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":2,"pattern":"^[a-zA-Z]+$","max_codepoint":255},"ch":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == s.replace(ch, '', 1)"}],"assumptions":["s.startswith(ch)","not s.endswith(ch)","s.count(ch) >= 1"]},{"id":"pc_9","description":"Character to remove is at the end only (and appears multiple times).","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":2,"pattern":"^[a-zA-Z]+$","max_codepoint":255},"ch":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == s.replace(ch, '')"}],"assumptions":["not s.startswith(ch)","s.endswith(ch)","s.count(ch) >= 1"]},{"id":"pc_10","description":"Long string with multiple occurrences of the character.","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":100,"max_len":200,"pattern":"^[a-zA-Z]+$","max_codepoint":255},"ch":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == s.replace(ch, '', 1).replace(ch, '')"}],"assumptions":["s.count(ch) >= 2"]},{"id":"pc_11","description":"Invariant: Length of the output string is less than or equal to the input string.","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":0,"max_len":50,"pattern":"^[a-zA-Z]*$","max_codepoint":255},"ch":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"len(result) <= len(s)"}],"assumptions":[]},{"id":"pc_12","description":"Invariant: Relative order of remaining characters is preserved.","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":0,"max_len":50,"pattern":"^[a-zA-Z]*$","max_codepoint":255},"ch":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(c for c in s if c != ch) or s.count(ch) < 2 or result == s.replace(ch, '', 1).replace(ch, '')"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Invalid type for string 's' (integer).","execution_statement":"try: result = remove_Occ(s, ch) except Exception as e: result = e","input_types":{"s":"int","ch":"str"},"input_constraints":{"ch":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Invalid type for character 'ch' (integer).","execution_statement":"try: result = remove_Occ(s, ch) except Exception as e: result = e","input_types":{"s":"str","ch":"int"},"input_constraints":{"s":{"min_len":1,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Edge Case: Character to remove is a special character.","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":2,"pattern":"^[a-zA-Z!@#$%^&*()_+=-]+$","max_codepoint":255},"ch":{"min_len":1,"max_len":1,"pattern":"^[!@#$%^&*()_+=-]$","max_codepoint":255}},"postconditions":[{"assertion":"result == s.replace(ch, '', 1).replace(ch, '')"}],"assumptions":["s.count(ch) >= 2"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6064"},"test_cases":[{"id":"test_typical_case_1","description":"Typical case: matrix with positive integers.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":1,"max_val":100}}}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_typical_case_2","description":"Typical case: matrix with mixed positive and negative integers.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100}},"is_mixed":true}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_boundary_case_large_numbers","description":"Boundary case: matrix with large integers.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":10000,"max_val":100000}}}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_boundary_case_small_numbers","description":"Boundary case: matrix with small (negative) integers.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":-10000,"max_val":-1000}}}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_edge_case_single_row","description":"Edge case: matrix with a single row.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":1,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":-50,"max_val":50}}}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_edge_case_single_column","description":"Edge case: matrix with a single column.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":1,"elements":{"min_val":-50,"max_val":50}}}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_edge_case_all_zeros","description":"Edge case: matrix with all zero elements.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":0,"max_val":0}}}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_edge_case_identical_rows","description":"Edge case: matrix with identical rows.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":10}}}},"assumptions":["len(set(tuple(row) for row in M)) == 1"],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_invariant_case_row_sums_ordered","description":"Invariant case: matrix where row sums are already ordered.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":20}}}},"assumptions":["all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_invariant_case_row_sums_reverse_ordered","description":"Invariant case: matrix where row sums are in reverse order.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":20}}}},"assumptions":["all(sum(M[i]) >= sum(M[i+1]) for i in range(len(M)-1))"],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_typical_case_empty_rows_within_matrix","description":"Typical case: matrix containing empty rows (should sum to 0).","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":10,"elements":{"min_len":0,"max_len":10,"elements":{"min_val":-10,"max_val":10}}}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_edge_case_matrix_with_one_empty_row","description":"Edge case: matrix with only one empty row.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":1,"elements":{"min_len":0,"max_len":0}}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_typical_case_rows_with_same_sum","description":"Typical case: matrix with rows having the same sum.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":-10,"max_val":10}}}},"assumptions":["len(set(sum(row) for row in M)) < len(M)"],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_typical_case_large_matrix","description":"Typical case: larger matrix.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":10,"max_len":20,"elements":{"min_len":10,"max_len":20,"elements":{"min_val":-50,"max_val":50}}}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_edge_case_all_negative_same_sum","description":"Edge case: all rows have the same negative sum.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":-10,"max_val":-1}}}},"assumptions":["len(set(sum(row) for row in M)) == 1","sum(M[0]) < 0"],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_typical_case_mixed_row_lengths","description":"Typical case: matrix with rows of different lengths.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":-20,"max_val":20}}}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_edge_case_single_element_matrix","description":"Edge case: matrix with a single element.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":1,"elements":{"min_len":1,"max_len":1,"elements":{"min_val":-100,"max_val":100}}}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_typical_case_zeros_and_negatives","description":"Typical case: matrix with zeros and negative numbers.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":-50,"max_val":0}}}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]},{"id":"test_invariant_case_all_elements_same","description":"Invariant case: matrix where all elements are the same.","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":5,"max_val":5}}}},"assumptions":[],"postconditions":[{"assertion":"all(sum(M[i]) <= sum(M[i+1]) for i in range(len(M)-1))"},{"assertion":"sorted(original_M, key=sum) == result"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6065"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic matrix sorting","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"all(sum(result[i]) <= sum(result[i+1]) for i in range(len(result) - 1))"},{"assertion":"sorted([sorted(row) for row in M]) == sorted([sorted(row) for row in result])"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty matrix","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Matrix with empty rows","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":5,"elements":{"min_len":0,"max_len":3}}},"postconditions":[{"assertion":"all(sum(result[i]) <= sum(result[i+1]) for i in range(len(result) - 1))"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Matrix with a single row","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":1,"elements":{"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"result == M"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Value: Matrix with negative numbers","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":-100,"max_val":100}}}},"postconditions":[{"assertion":"all(sum(result[i]) <= sum(result[i+1]) for i in range(len(result) - 1))"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Value: Matrix with zeros","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"all(sum(result[i]) <= sum(result[i+1]) for i in range(len(result) - 1))"}],"assumptions":[]},{"id":"pc_7","description":"Invariant: Row sums are non-decreasing","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"all(sum(result[i]) <= sum(result[i+1]) for i in range(len(result) - 1))"}],"assumptions":[]},{"id":"pc_8","description":"Invariant: All original rows are preserved","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"sorted([sorted(row) for row in M]) == sorted([sorted(row) for row in result])"}],"assumptions":[]},{"id":"pc_9","description":"Large Matrix: Many rows and columns","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":50,"max_len":100,"elements":{"min_len":50,"max_len":100}}},"postconditions":[{"assertion":"all(sum(result[i]) <= sum(result[i+1]) for i in range(len(result) - 1))"}],"assumptions":[]},{"id":"pc_10","description":"Matrix with rows of varying lengths","execution_statement":"result = sort_matrix(M)","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"all(sum(result[i]) <= sum(result[i+1]) for i in range(len(result) - 1))"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6066"},"test_cases":[{"id":"TC001","description":"Typical case with positive dimensions.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"float","h":"float"},"input_constraints":{"l":{"min_val":0.1,"max_val":1000.0},"b":{"min_val":0.1,"max_val":1000.0},"h":{"min_val":0.1,"max_val":1000.0}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC002","description":"Edge case: zero length.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"float","h":"float"},"input_constraints":{"l":{"min_val":0.0,"max_val":0.0},"b":{"min_val":0.1,"max_val":1000.0},"h":{"min_val":0.1,"max_val":1000.0}},"postconditions":[{"assertion":"result == 0.0"}]},{"id":"TC003","description":"Edge case: zero breadth.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"float","h":"float"},"input_constraints":{"l":{"min_val":0.1,"max_val":1000.0},"b":{"min_val":0.0,"max_val":0.0},"h":{"min_val":0.1,"max_val":1000.0}},"postconditions":[{"assertion":"result == 0.0"}]},{"id":"TC004","description":"Edge case: zero height.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"float","h":"float"},"input_constraints":{"l":{"min_val":0.1,"max_val":1000.0},"b":{"min_val":0.1,"max_val":1000.0},"h":{"min_val":0.0,"max_val":0.0}},"postconditions":[{"assertion":"result == 0.0"}]},{"id":"TC005","description":"Boundary case: very small positive dimensions.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"float","h":"float"},"input_constraints":{"l":{"min_val":1E-09,"max_val":1E-05},"b":{"min_val":1E-09,"max_val":1E-05},"h":{"min_val":1E-09,"max_val":1E-05}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC006","description":"Boundary case: very large dimensions.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"float","h":"float"},"input_constraints":{"l":{"min_val":1E+09,"max_val":1E+09},"b":{"min_val":1E+09,"max_val":1E+09},"h":{"min_val":1E+09,"max_val":1E+09}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC007","description":"Invariant test: Volume scales linearly with height.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"float","h":"float"},"input_constraints":{"l":{"min_val":1.0,"max_val":100.0},"b":{"min_val":1.0,"max_val":100.0},"h":{"min_val":1.0,"max_val":500.0}},"assumptions":["h * 2 <= 1000.0"],"postconditions":[{"assertion":"find_Volume(l, b, h * 2) == 2 * result"}]},{"id":"TC008","description":"Invariant test: Volume scales with length (keeping b, h constant).","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"float","h":"float"},"input_constraints":{"l":{"min_val":1.0,"max_val":500.0},"b":{"min_val":10.0,"max_val":10.0},"h":{"min_val":10.0,"max_val":10.0}},"assumptions":["h * 2 <= 1000.0"],"postconditions":[{"assertion":"find_Volume(l * 2, b, h) == 2 * result"}]},{"id":"TC009","description":"Invariant test: Volume scales with breadth (keeping l, h constant).","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"float","h":"float"},"input_constraints":{"l":{"min_val":10.0,"max_val":10.0},"b":{"min_val":1.0,"max_val":500.0},"h":{"min_val":10.0,"max_val":10.0}},"assumptions":["h * 2 <= 1000.0"],"postconditions":[{"assertion":"find_Volume(l, b * 2, h) == 2 * result"}]},{"id":"TC010","description":"Negative test: non-numeric type for length.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"str","b":"float","h":"float"},"input_constraints":{"l":{"min_val":"a","max_val":"z","max_codepoint":255},"b":{"min_val":1.0,"max_val":100.0},"h":{"min_val":1.0,"max_val":100.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC011","description":"Negative test: non-numeric type for breadth.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"str","h":"float"},"input_constraints":{"l":{"min_val":1.0,"max_val":100.0},"b":{"min_val":"a","max_val":"z","max_codepoint":255},"h":{"min_val":1.0,"max_val":100.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC012","description":"Negative test: non-numeric type for height.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"float","h":"str"},"input_constraints":{"l":{"min_val":1.0,"max_val":100.0},"b":{"min_val":1.0,"max_val":100.0},"h":{"min_val":"a","max_val":"z","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC013","description":"Negative test: null for length.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"Optional[float]","b":"float","h":"float"},"input_constraints":{"l":{"allow_none":true},"b":{"min_val":1.0,"max_val":100.0},"h":{"min_val":1.0,"max_val":100.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC014","description":"Negative test: null for breadth.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"Optional[float]","h":"float"},"input_constraints":{"l":{"min_val":1.0,"max_val":100.0},"b":{"allow_none":true},"h":{"min_val":1.0,"max_val":100.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC015","description":"Negative test: null for height.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"float","h":"Optional[float]"},"input_constraints":{"l":{"min_val":1.0,"max_val":100.0},"b":{"min_val":1.0,"max_val":100.0},"h":{"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC016","description":"Typical case with integer inputs.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":1,"max_val":1000},"b":{"min_val":1,"max_val":1000},"h":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC017","description":"Edge case: zero length with integer inputs.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":0,"max_val":0},"b":{"min_val":1,"max_val":1000},"h":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == 0"}]},{"id":"TC018","description":"Invariant test: Volume scales linearly with height (integer inputs).","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"h":{"min_val":1,"max_val":500}},"assumptions":["h * 2 <= 1000"],"postconditions":[{"assertion":"find_Volume(l, b, h * 2) == 2 * result"}]},{"id":"TC019","description":"Boundary case: very small positive integer dimensions.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":1,"max_val":1},"b":{"min_val":1,"max_val":1},"h":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 0.5"}]},{"id":"TC020","description":"Boundary case: very large integer dimensions.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":1000000,"max_val":1000000},"b":{"min_val":1000000,"max_val":1000000},"h":{"min_val":1000000,"max_val":1000000}},"postconditions":[{"assertion":"result > 0"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6067"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic positive dimensions","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"h":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == (l * b * h) / 2"},{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Zero dimension for length","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":0,"max_val":0},"b":{"min_val":1,"max_val":100},"h":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Zero dimension for breadth","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":1,"max_val":100},"b":{"min_val":0,"max_val":0},"h":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Zero dimension for height","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"h":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: All dimensions are zero","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":0,"max_val":0},"b":{"min_val":0,"max_val":0},"h":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Value: Large positive dimensions","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":10000,"max_val":100000},"b":{"min_val":10000,"max_val":100000},"h":{"min_val":10000,"max_val":100000}},"postconditions":[{"assertion":"result == (l * b * h) / 2"}],"assumptions":[]},{"id":"pc_7","description":"Invariant: Volume is non-negative for non-negative dimensions","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":0,"max_val":1000},"b":{"min_val":0,"max_val":1000},"h":{"min_val":0,"max_val":1000}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":["l >= 0","b >= 0","h >= 0"]},{"id":"pc_8","description":"Invariant: Doubling length doubles volume","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":1,"max_val":1000},"b":{"min_val":1,"max_val":1000},"h":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == (l * b * h) / 2"},{"assertion":"find_Volume(l * 2, b, h) == result * 2"}],"assumptions":["l > 0","b > 0","h > 0"]},{"id":"pc_9","description":"Invariant: Doubling breadth doubles volume","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":1,"max_val":1000},"b":{"min_val":1,"max_val":1000},"h":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == (l * b * h) / 2"},{"assertion":"find_Volume(l, b * 2, h) == result * 2"}],"assumptions":["l > 0","b > 0","h > 0"]},{"id":"pc_10","description":"Invariant: Doubling height doubles volume","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":1,"max_val":1000},"b":{"min_val":1,"max_val":1000},"h":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == (l * b * h) / 2"},{"assertion":"find_Volume(l, b, h * 2) == result * 2"}],"assumptions":["l > 0","b > 0","h > 0"]},{"id":"pc_11","description":"Negative Test: Non-numeric input for length (float)","execution_statement":"try: result = find_Volume(l, b, h) except Exception as e: result = e","input_types":{"l":"float","b":"int","h":"int"},"input_constraints":{"l":{},"b":{"min_val":1,"max_val":100},"h":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Non-numeric input for breadth (string)","execution_statement":"try: result = find_Volume(l, b, h) except Exception as e: result = e","input_types":{"l":"int","b":"str","h":"int"},"input_constraints":{"l":{"min_val":1,"max_val":100},"b":{"min_len":1,"max_codepoint":255},"h":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Non-numeric input for height (None)","execution_statement":"try: result = find_Volume(l, b, h) except Exception as e: result = e","input_types":{"l":"int","b":"int","h":"Optional[int]"},"input_constraints":{"l":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"h":{"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["h is None"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6068"},"test_cases":[{"id":"pc_1","description":"Valid sequence of lowercase letters joined by underscore.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+_[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Empty string.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_3","description":"String with only lowercase letters, no underscore.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"String with only underscores.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^_+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"String with underscore at the beginning.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^_[a-z]+$","min_len":2,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_6","description":"String with underscore at the end.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+_$","min_len":2,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"String with consecutive underscores.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+__+[a-z]+$","min_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_8","description":"String with uppercase letters.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-zA-Z]+_[a-zA-Z]+$","min_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_9","description":"String with digits.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z-9]+_[a-z-9]+$","min_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"String with special characters.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z\\W]+_[a-z\\W]+$","min_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_11","description":"Valid sequence with longer parts.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]{5,10}_[a-z]{5,10}$","min_len":11,"max_len":21,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_12","description":"Valid sequence with minimal parts (a_b).","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]_[a-z]$","min_len":3,"max_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_13","description":"String with valid sequence and other characters before.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^.*[a-z]+_[a-z]+$","min_len":4,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"String with valid sequence and other characters after.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+_[a-z]+.*$","min_len":4,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_15","description":"String with valid sequence and other characters before and after.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^.*[a-z]+_[a-z]+.*$","min_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_16","description":"Multiple valid sequences (should still be false as pattern is ^[a-z]+_[a-z]+$).","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^([a-z]+_[a-z]+)+$","min_len":6,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_17","description":"String with a single letter and underscore.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]_$","min_len":2,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_18","description":"String with underscore and a single letter.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^_[a-z]$","min_len":2,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_19","description":"String with only one lowercase letter.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]$","min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_20","description":"String with only one underscore.","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^_$","min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6069"},"test_cases":[{"id":"pc_1","description":"Happy Path: Valid lowercase_underscore format","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+_[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String with only an underscore","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^_$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: String with underscore but no preceding lowercase letters","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^_[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: String with underscore but no succeeding lowercase letters","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+_$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: String with multiple underscores","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+_[a-z]+_.*$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: String with uppercase letters","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-zA-Z]+_[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_8","description":"Edge Case: String with numbers","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+_[a-z-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_9","description":"Edge Case: String with special characters","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+_[a-z!@#$%^&*()]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_10","description":"Typical Case: Longer valid string","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]{5,10}_[a-z]{5,10}$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-string input (integer)","execution_statement":"try: result = text_lowercase_underscore(text) except Exception as e: result = e","input_types":{"text":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Non-string input (None)","execution_statement":"try: result = text_lowercase_underscore(text) except Exception as e: result = e","input_types":{"text":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: String with only lowercase letters, no underscore","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: String with underscore but no lowercase letters","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[_]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: String with mixed case and underscore","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-zA-Z]+_[a-zA-Z]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc606a"},"test_cases":[{"id":"pc_1","description":"Test with a typical positive floating-point side length.","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"float"},"input_constraints":{"side_length":{"min_val":0.1,"max_val":100.0}},"postconditions":[{"assertion":"result == 4 * side_length"}],"assumptions":[]},{"id":"pc_2","description":"Test with a side length of zero.","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"float"},"input_constraints":{"side_length":{"min_val":0.0,"max_val":0.0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_3","description":"Test with a very small positive floating-point side length.","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"float"},"input_constraints":{"side_length":{"min_val":1E-09,"max_val":0.001}},"postconditions":[{"assertion":"result == 4 * side_length"}],"assumptions":[]},{"id":"pc_4","description":"Test with a large floating-point side length.","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"float"},"input_constraints":{"side_length":{"min_val":1E+06,"max_val":1E+09}},"postconditions":[{"assertion":"result == 4 * side_length"}],"assumptions":[]},{"id":"pc_5","description":"Test floating-point precision edge cases.","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"float"},"input_constraints":{"side_length":{"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"abs(result - (4 * side_length)) < 1e-9"}],"assumptions":[]},{"id":"pc_6","description":"Test with a typical positive integer side length.","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"int"},"input_constraints":{"side_length":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == 4 * side_length"}],"assumptions":[]},{"id":"pc_7","description":"Test with an integer side length of zero.","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"int"},"input_constraints":{"side_length":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_8","description":"Test with a large integer side length.","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"int"},"input_constraints":{"side_length":{"min_val":1000000,"max_val":1000000000}},"postconditions":[{"assertion":"result == 4 * side_length"}],"assumptions":[]},{"id":"pc_9","description":"Test with a negative floating-point side length (expecting TypeError or similar if handled, but per rules, we constrain to non-negative).","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"float"},"input_constraints":{"side_length":{"min_val":-100.0,"max_val":-0.1}},"postconditions":[{"assertion":"result == 4 * side_length"}],"assumptions":[]},{"id":"pc_10","description":"Test with a negative integer side length (expecting TypeError or similar if handled, but per rules, we constrain to non-negative).","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"int"},"input_constraints":{"side_length":{"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result == 4 * side_length"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc606b"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive integer side length","execution_statement":"result = square_perimeter(a)","input_types":{"a":"int"},"input_constraints":{"a":{"min_val":1}},"postconditions":[{"assertion":"result == 4 * a"},{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Zero side length","execution_statement":"result = square_perimeter(a)","input_types":{"a":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: Positive float side length","execution_statement":"result = square_perimeter(a)","input_types":{"a":"float"},"input_constraints":{"a":{"min_val":0.1}},"postconditions":[{"assertion":"result == 4 * a"},{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Zero float side length","execution_statement":"result = square_perimeter(a)","input_types":{"a":"float"},"input_constraints":{"a":{"min_val":0.0,"max_val":0.0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Case: Large integer side length","execution_statement":"result = square_perimeter(a)","input_types":{"a":"int"},"input_constraints":{"a":{"min_val":1000000}},"postconditions":[{"assertion":"result == 4 * a"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Case: Large float side length","execution_statement":"result = square_perimeter(a)","input_types":{"a":"float"},"input_constraints":{"a":{"min_val":1E+06}},"postconditions":[{"assertion":"result == 4 * a"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: null input","execution_statement":"try: result = square_perimeter(a) except Exception as e: result = e","input_types":{"a":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: String input","execution_statement":"try: result = square_perimeter(a) except Exception as e: result = e","input_types":{"a":"str"},"input_constraints":{"a":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Invariant: Perimeter is always non-negative","execution_statement":"result = square_perimeter(a)","input_types":{"a":"float"},"input_constraints":{"a":{"min_val":-1000.0,"max_val":1000.0}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_10","description":"Invariant: Perimeter is always a multiple of 4 for integer input","execution_statement":"result = square_perimeter(a)","input_types":{"a":"int"},"input_constraints":{"a":{"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"result % 4 == 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc606c"},"test_cases":[{"id":"TC1","description":"Typical case: Remove some common characters.","execution_statement":"result = remove_dirty_chars(string='hello world', second_string='lo')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == 'he wrd'"}]},{"id":"TC2","description":"Edge case: Empty first string.","execution_statement":"result = remove_dirty_chars(string='', second_string='abc')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}]},{"id":"TC3","description":"Edge case: Empty second string.","execution_statement":"result = remove_dirty_chars(string='hello world', second_string='')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == 'hello world'"}]},{"id":"TC4","description":"Edge case: Both strings are empty.","execution_statement":"result = remove_dirty_chars(string='', second_string='')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}]},{"id":"TC5","description":"All characters in the first string are present in the second string.","execution_statement":"result = remove_dirty_chars(string='abcdef', second_string='abcdef')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}]},{"id":"TC6","description":"No characters in the first string are present in the second string.","execution_statement":"result = remove_dirty_chars(string='abcdef', second_string='ghijkl')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == 'abcdef'"}]},{"id":"TC7","description":"First string with special characters, second string with common characters.","execution_statement":"result = remove_dirty_chars(string='!@#$%^&*()', second_string='aeiou')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == '!@#$%^&*()'"}]},{"id":"TC8","description":"First string with numbers, second string with letters.","execution_statement":"result = remove_dirty_chars(string='1234567890', second_string='abcdef')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == '1234567890'"}]},{"id":"TC9","description":"First string with letters, second string with numbers.","execution_statement":"result = remove_dirty_chars(string='abcdef', second_string='12345')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == 'abcdef'"}]},{"id":"TC10","description":"First string with mixed characters, second string with mixed characters.","execution_statement":"result = remove_dirty_chars(string='a1B2c3D4e5', second_string='13579')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == 'aBceD'"}]},{"id":"TC11","description":"First string with repeated characters, second string with some of those characters.","execution_statement":"result = remove_dirty_chars(string='aaaaabbbbbccccc', second_string='abc')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}]},{"id":"TC12","description":"First string with repeated characters, second string with none of those characters.","execution_statement":"result = remove_dirty_chars(string='aaaaabbbbbccccc', second_string='xyz')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == 'aaaaabbbbbccccc'"}]},{"id":"TC13","description":"Unicode characters in first string, ASCII in second.","execution_statement":"result = remove_dirty_chars(string='', second_string='')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}]},{"id":"TC14","description":"ASCII characters in first string, Unicode in second.","execution_statement":"result = remove_dirty_chars(string='hello', second_string='')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == 'hello'"}]},{"id":"TC15","description":"Long strings with overlapping characters.","execution_statement":"result = remove_dirty_chars(string='this is a very long string with many characters to test removal', second_string='aeiou')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == 'ths s  vry lng strng wth mny chrctrs t tst rmvl'"}]},{"id":"TC16","description":"Long strings with no overlapping characters.","execution_statement":"result = remove_dirty_chars(string='this is a very long string with many characters to test removal', second_string='xyz')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == 'this is a very long string with many characters to test removal'"}]},{"id":"TC17","description":"String with only spaces, second string with spaces.","execution_statement":"result = remove_dirty_chars(string='   ', second_string=' ')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}]},{"id":"TC18","description":"String with only spaces, second string without spaces.","execution_statement":"result = remove_dirty_chars(string='   ', second_string='abc')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == '   '"}]},{"id":"TC19","description":"Second string contains all possible characters (effectively empty result).","execution_statement":"result = remove_dirty_chars(string='abcdef', second_string='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+=-`~[]{}|\\;:'\",.<>/?')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}]},{"id":"TC20","description":"First string contains characters not in the second string, and vice versa.","execution_statement":"result = remove_dirty_chars(string='programming', second_string='python')","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"max_codepoint":255},"second_string":{"max_codepoint":255}},"postconditions":[{"assertion":"result == 'rgrammig'"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc606d"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic character removal","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"max_codepoint":255},"second_string":{"min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"all(char not in result for char in second_string)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty first string","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":0,"max_len":0,"max_codepoint":255},"second_string":{"min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Empty second string","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"max_codepoint":255},"second_string":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == string"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Both strings empty","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":0,"max_len":0,"max_codepoint":255},"second_string":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Case: All characters in first string are in second string","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":20,"pattern":"^[abc]+$","max_codepoint":255},"second_string":{"min_len":1,"max_len":20,"pattern":"^[abc]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":["set(string).issubset(set(second_string))"]},{"id":"pc_6","description":"Invariant: Result contains only characters from original string not in second string","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"max_codepoint":255},"second_string":{"min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"all(char in string for char in result)"},{"assertion":"all(char not in second_string for char in result)"}],"assumptions":[]},{"id":"pc_7","description":"Typical Case: Mixed characters, some removed","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z-9 ]+$","is_mixed":true,"max_codepoint":255},"second_string":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"all(char not in result for char in second_string)"},{"assertion":"all(char in string for char in result)"}],"assumptions":[]},{"id":"pc_8","description":"Case Sensitivity: Ensure removal is case-sensitive","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z]+$","max_codepoint":255},"second_string":{"min_len":1,"max_len":20,"pattern":"^[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"'A' in result"},{"assertion":"all(char not in result for char in second_string)"}],"assumptions":["'A' in string and 'a' in second_string"]},{"id":"pc_9","description":"Special Characters: Removal of punctuation and spaces","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z-9 .,!?]+$","max_codepoint":255},"second_string":{"min_len":1,"max_len":20,"pattern":"^[ .,!?]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(char not in result for char in second_string)"}],"assumptions":[]},{"id":"pc_10","description":"Large Input Strings: Test performance and correctness with longer strings","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":100,"max_len":500,"max_codepoint":255},"second_string":{"min_len":10,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"all(char not in result for char in second_string)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc606e"},"test_cases":[{"id":"pc_1","description":"Typical case with duplicates.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":2,"max_len":10,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Typical case with no duplicates.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":2,"max_len":10,"unique":true}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_3","description":"Edge case: empty list.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"Edge case: list with one element.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"Boundary case: list with two identical elements.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":2,"max_len":2,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Boundary case: list with two different elements.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":2,"max_len":2,"unique":true}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"List with negative numbers and duplicates.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-100,"max_val":-1,"min_len":5,"max_len":15,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_8","description":"List with negative numbers and no duplicates.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-100,"max_val":-1,"min_len":5,"max_len":15,"unique":true}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_9","description":"List with zero and duplicates.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-5,"max_val":5,"min_len":3,"max_len":10,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["0 in arraynums"]},{"id":"pc_10","description":"List with zero and no duplicates.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-5,"max_val":5,"min_len":3,"max_len":10,"unique":true}},"postconditions":[{"assertion":"result == False"}],"assumptions":["0 in arraynums"]},{"id":"pc_11","description":"List with large integers and duplicates.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":1000000,"max_val":2000000,"min_len":5,"max_len":20,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_12","description":"List with large integers and no duplicates.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":1000000,"max_val":2000000,"min_len":5,"max_len":20,"unique":true}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_13","description":"List with small integers and duplicates.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-2000000,"max_val":-1000000,"min_len":5,"max_len":20,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_14","description":"List with small integers and no duplicates.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-2000000,"max_val":-1000000,"min_len":5,"max_len":20,"unique":true}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_15","description":"List with mixed positive and negative numbers and duplicates.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-50,"max_val":50,"min_len":10,"max_len":30,"unique":false,"is_mixed":true}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_16","description":"List with mixed positive and negative numbers and no duplicates.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-50,"max_val":50,"min_len":10,"max_len":30,"unique":true,"is_mixed":true}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_17","description":"List with all elements being the same duplicate.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(arraynums)) == 1"]},{"id":"pc_18","description":"List with a large number of unique elements.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":100,"max_len":200,"unique":true}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_19","description":"List with a large number of elements with duplicates.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":100,"max_len":200,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_20","description":"List with duplicates at the beginning and end.","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":5,"max_len":15,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["arraynums[0] == arraynums[1] or arraynums[0] == arraynums[-1] or arraynums[-1] == arraynums[-2]"]}]}
{"_id":{"$oid":"692adffe1b18223597bc606f"},"test_cases":[{"id":"pc_1","description":"Happy Path: Array with no duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":1,"unique":true}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Array with duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":2,"unique":false}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Empty array","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Array with a single element","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: Length of array is always >= length of set","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":0}},"postconditions":[{"assertion":"len(arraynums) >= len(set(arraynums))"}],"assumptions":[]},{"id":"pc_6","description":"Typical Case: All elements are duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":2,"unique":false}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(set(arraynums)) == 1"]},{"id":"pc_7","description":"Typical Case: Mixed unique and duplicate elements","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":2,"unique":false,"is_mixed":true}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_8","description":"Boundary Case: Large array with no duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":0,"unique":false}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_9","description":"Boundary Case: Large array with duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":1000,"unique":false}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = test_duplicate(arraynums) except Exception as e: result = e","input_types":{"arraynums":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = test_duplicate(arraynums) except Exception as e: result = e","input_types":{"arraynums":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Test with negative numbers and duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-1000,"max_val":-1,"min_len":2,"unique":false}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_13","description":"Test with negative numbers and no duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-1000,"max_val":-1,"min_len":1,"unique":true}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_14","description":"Test with mixed positive and negative numbers with duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-100,"max_val":100,"min_len":2,"unique":false,"is_mixed":true}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_15","description":"Test with mixed positive and negative numbers with no duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-100,"max_val":100,"min_len":1,"unique":true,"is_mixed":true}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_16","description":"Test with zero and duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":0,"max_val":10,"min_len":2,"unique":false}},"postconditions":[{"assertion":"result is True"}],"assumptions":["0 in arraynums"]},{"id":"pc_17","description":"Test with zero and no duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":0,"max_val":10,"min_len":1,"unique":true}},"postconditions":[{"assertion":"result is False"}],"assumptions":["0 in arraynums"]},{"id":"pc_18","description":"Test with duplicate zeros","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":2,"unique":false}},"postconditions":[{"assertion":"result is True"}],"assumptions":["arraynums.count(0) >= 2"]},{"id":"pc_19","description":"Test with large numbers and duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":1000000,"max_val":2000000,"min_len":2,"unique":false}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_20","description":"Test with large numbers and no duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":1000000,"max_val":2000000,"min_len":1,"unique":true}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6070"},"test_cases":[{"id":"pc_1","description":"Test with a small odd number that is not 1.","execution_statement":"result = is_woodall(x=3)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":3,"max_val":10}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_2","description":"Test with the number 1 (edge case).","execution_statement":"result = is_woodall(x=1)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_3","description":"Test with a small even number.","execution_statement":"result = is_woodall(x=4)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":2,"max_val":10,"step":2}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"Test with a larger odd number where p == x condition might be met.","execution_statement":"result = is_woodall(x=7)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":11,"max_val":100}},"postconditions":[{"assertion":"result == False"}],"assumptions":["x % 2 != 0"]},{"id":"pc_5","description":"Test with a number that might satisfy p == x after increment.","execution_statement":"result = is_woodall(x=1)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Test with a larger even number.","execution_statement":"result = is_woodall(x=100)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":100,"max_val":1000,"step":2}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Test with a larger odd number.","execution_statement":"result = is_woodall(x=101)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":101,"max_val":1000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["x % 2 != 0"]},{"id":"pc_8","description":"Test with a number that becomes 1 after increment and division.","execution_statement":"result = is_woodall(x=0)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_9","description":"Test with a number that might lead to p == x.","execution_statement":"result = is_woodall(x=1)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_10","description":"Test with a number that results in a large p value.","execution_statement":"result = is_woodall(x=3)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":3,"max_val":1000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["x % 2 != 0"]},{"id":"pc_11","description":"Test with a number that might cause infinite loop if logic is flawed (though unlikely with current logic).","execution_statement":"result = is_woodall(x=1000)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":1000,"max_val":10000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["x % 2 != 0"]},{"id":"pc_12","description":"Test with a number that becomes even after increment.","execution_statement":"result = is_woodall(x=1)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_13","description":"Test with a number that becomes odd after increment.","execution_statement":"result = is_woodall(x=2)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"Test with a number that results in x/2 being equal to p.","execution_statement":"result = is_woodall(x=1)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_15","description":"Test with a number that does not satisfy p == x.","execution_statement":"result = is_woodall(x=5)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_16","description":"Test with a large odd number.","execution_statement":"result = is_woodall(x=999)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":999,"max_val":999}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_17","description":"Test with a large even number.","execution_statement":"result = is_woodall(x=1000)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":1000,"max_val":1000}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_18","description":"Test with a number that results in x=1 after increment and division.","execution_statement":"result = is_woodall(x=1)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_19","description":"Test with a number that results in p=1 after increment and division.","execution_statement":"result = is_woodall(x=1)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_20","description":"Test with a number that does not satisfy the p == x condition.","execution_statement":"result = is_woodall(x=9)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":9,"max_val":9}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6071"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic Woodall Number (1)","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"assert result is True"}]},{"id":"pc_2","description":"Happy Path: Basic Woodall Number (7)","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":7,"max_val":7}},"postconditions":[{"assertion":"assert result is True"}]},{"id":"pc_3","description":"Happy Path: Larger Woodall Number (23)","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":23,"max_val":23}},"postconditions":[{"assertion":"assert result is True"}]},{"id":"pc_4","description":"Happy Path: Larger Woodall Number (63)","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":63,"max_val":63}},"postconditions":[{"assertion":"assert result is True"}]},{"id":"pc_5","description":"Edge Case: Input is 0","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"assert result is False"}]},{"id":"pc_6","description":"Edge Case: Smallest Even Positive Number (2)","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"assert result is False"}]},{"id":"pc_7","description":"Edge Case: Smallest Odd Non-Woodall Number (3)","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"assert result is False"}]},{"id":"pc_8","description":"Edge Case: Smallest Odd Non-Woodall Number (5)","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"assert result is False"}]},{"id":"pc_9","description":"Negative Input: -1 (potential infinite loop)","execution_statement":"try: result = is_woodall(x) except Exception as e: result = e","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":-1,"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, RecursionError) or isinstance(result, RuntimeError) or result is False"}]},{"id":"pc_10","description":"Negative Input: -2 (Even)","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":-2,"max_val":-2}},"postconditions":[{"assertion":"assert result is False"}]},{"id":"pc_11","description":"Negative Input: -3 (Odd Non-Woodall)","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":-3,"max_val":-3}},"postconditions":[{"assertion":"assert result is False"}]},{"id":"pc_12","description":"Boundary: Large Even Number","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":1000000,"max_val":1000000}},"postconditions":[{"assertion":"assert result is False"}]},{"id":"pc_13","description":"Boundary: Large Odd Non-Woodall Number","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":999999,"max_val":999999}},"postconditions":[{"assertion":"assert result is False"}]},{"id":"pc_14","description":"General Case: Positive Even Number","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":4,"max_val":100,"step":2}},"postconditions":[{"assertion":"assert result is False"}]},{"id":"pc_15","description":"General Case: Positive Odd Non-Woodall Number","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":5,"max_val":101,"step":2}},"assumptions":["x != 7 and x != 23 and x != 63"],"postconditions":[{"assertion":"assert result is False"}]},{"id":"pc_16","description":"General Case: Positive Odd Woodall Number","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1000}},"assumptions":["x == 1 or x == 7 or x == 23 or x == 63 or x == 159 or x == 383 or x == 895"],"postconditions":[{"assertion":"assert result is True"}]},{"id":"pc_17","description":"Invariant Check: Return type is always boolean","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":10000}},"postconditions":[{"assertion":"assert isinstance(result, bool)"}]},{"id":"pc_18","description":"Invariant Check: true result implies positive odd input","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":10000}},"postconditions":[{"assertion":"if result is True: assert x >= 1 and x % 2 != 0"}]},{"id":"pc_19","description":"Invariant Check: true result implies Woodall form (p*2^p)","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":1,"max_val":10000}},"postconditions":[{"assertion":"if result is True: y = x + 1; p = 0; found = False; while y % 2 == 0: y //= 2; p += 1; if p == y: found = True; break; assert found"}]},{"id":"pc_20","description":"Large Woodall Number (159)","execution_statement":"result = is_woodall(x)","input_types":{"x":"int"},"input_constraints":{"x":{"min_val":159,"max_val":159}},"postconditions":[{"assertion":"assert result is True"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6072"},"test_cases":[{"id":"pc_1","description":"Typical case: number satisfies the condition.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":[]},{"id":"pc_2","description":"Typical case: number does not satisfy the condition.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":["not (2 * rev(n) == n + 1)"]},{"id":"pc_3","description":"Boundary case: smallest positive integer (1).","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":[]},{"id":"pc_4","description":"Edge case: zero.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":[]},{"id":"pc_5","description":"Numbers with trailing zeros in original (leading zeros in reverse).","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":1000000}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":["str(n).endswith('0')"]},{"id":"pc_6","description":"Numbers that are palindromes.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":["str(n) == str(n)[::-1]"]},{"id":"pc_7","description":"Large number satisfying the condition.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000,"max_val":7812500}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":["2 * rev(n) == n + 1"]},{"id":"pc_8","description":"Large number not satisfying the condition.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000,"max_val":1000000000}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":["not (2 * rev(n) == n + 1)"]},{"id":"pc_9","description":"Numbers where reverse is significantly larger than original.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":1000000}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":["rev(n) > n * 2"]},{"id":"pc_10","description":"Numbers where reverse is significantly smaller than original.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":1000000}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":["rev(n) < n / 2"]},{"id":"pc_11","description":"Test with a number that has many digits and satisfies the condition.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000000,"max_val":7812500}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":["2 * rev(n) == n + 1"]},{"id":"pc_12","description":"Test with a number that has many digits and does not satisfy the condition.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000000,"max_val":1000000000}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":["not (2 * rev(n) == n + 1)"]},{"id":"pc_13","description":"Test with a number that results in a large reversed number.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":7812500}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":["rev(n) > 1000000000"]},{"id":"pc_14","description":"Test with a number that results in a small reversed number.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000000}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":["rev(n) < 10"]},{"id":"pc_15","description":"Invariant test: For numbers satisfying the condition, check the relation.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000}},"postconditions":[{"assertion":"result is True"},{"assertion":"n == 199"}],"assumptions":["2 * rev(n) == n + 1"]},{"id":"pc_16","description":"Test with a number that is close to a number satisfying the condition.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":18,"max_val":20}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":[]},{"id":"pc_17","description":"Test with a number that is close to a number satisfying the condition (larger range).","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":198,"max_val":200}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":[]},{"id":"pc_18","description":"Test with a number that has a single digit and satisfies the condition.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":9}},"postconditions":[{"assertion":"result == True"}],"assumptions":["2 * rev(n) == n + 1"]},{"id":"pc_19","description":"Test with a number that has a single digit and does not satisfy the condition.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":9}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not (2 * rev(n) == n + 1)"]},{"id":"pc_20","description":"Test with a number that has a large number of digits and satisfies the condition.","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100000000,"max_val":78125000}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":["2 * rev(n) == n + 1"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6073"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive integer where check returns True","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["2 * rev(n) == n + 1"]},{"id":"pc_2","description":"Happy Path: Positive integer where check returns False","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["2 * rev(n) != n + 1"]},{"id":"pc_3","description":"Edge Case: Input is 0","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Case: Large integer where check returns True","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000001,"max_val":78125}},"postconditions":[{"assertion":"result == True"}],"assumptions":["2 * rev(n) == n + 1"]},{"id":"pc_5","description":"Boundary Case: Large integer where check returns False","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000001,"max_val":10000000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["2 * rev(n) != n + 1"]},{"id":"pc_6","description":"Negative Test: Non-integer input (float)","execution_statement":"try: result = check(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Non-integer input (string)","execution_statement":"try: result = check(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Non-integer input (None)","execution_statement":"try: result = check(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Invariant: For any non-negative input, rev(n) should be non-negative","execution_statement":"rev_val = rev(n); result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000000}},"postconditions":[{"assertion":"rev_val >= 0"}],"assumptions":[]},{"id":"pc_10","description":"Invariant: For any positive input, rev(n) should be positive","execution_statement":"rev_val = rev(n); result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000}},"postconditions":[{"assertion":"rev_val > 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6074"},"test_cases":[{"id":"pc_1","description":"Typical case with multiple distinct digits.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":2,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_2","description":"Edge case: List with all same digits.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":5,"max_val":5,"min_len":3,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_3","description":"Boundary case: List with minimum allowed digits (2).","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":2,"max_len":2}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_4","description":"Boundary case: List with maximum allowed digits (10).","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":10,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_5","description":"Edge case: List containing only zeros.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":0,"min_len":4,"max_len":6}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_6","description":"Edge case: List containing only nines.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":9,"max_val":9,"min_len":3,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_7","description":"Typical case with a mix of small and large digits.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":5,"max_len":8}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_8","description":"Test with digits that would form a large number.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":7,"max_val":9,"min_len":6,"max_len":9}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_9","description":"Test with digits that would form a small number (if not sorted).","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":2,"min_len":5,"max_len":7}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_10","description":"Test with a single digit (boundary).","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_11","description":"Test with duplicate digits, ensuring correct sorting.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":1,"max_val":8,"min_len":6,"max_len":6}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":["arr[0] == arr[1] or arr[1] == arr[2] or arr[2] == arr[3] or arr[3] == arr[4] or arr[4] == arr[5]"]},{"id":"pc_12","description":"Test with a mix of zeros and other digits.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":5,"max_len":7}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":["0 in arr"]},{"id":"pc_13","description":"Test with a list where the largest number is formed by placing smaller digits first after sorting.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":5,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":["arr[0] > arr[1] and arr[1] < arr[2] and arr[2] < arr[3] and arr[3] < arr[4]"]},{"id":"pc_14","description":"Test with a list that results in a number with leading zeros if not handled correctly (though sort should prevent this).","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":4,"max_len":4}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":["0 in arr"]},{"id":"pc_15","description":"Test with a list of digits that are already in descending order.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":5,"max_len":7}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":["all(arr[i] >= arr[i+1] for i in range(len(arr)-1))"]},{"id":"pc_16","description":"Test with a list of digits that are in ascending order.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":5,"max_len":7}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":["all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"]},{"id":"pc_17","description":"Test with a list containing a mix of digits, including 0, to ensure correct placement.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":6,"max_len":8}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":["0 in arr and any(d > 0 for d in arr)"]},{"id":"pc_18","description":"Test with a list of digits that are all distinct and not in order.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":5,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":["len(set(arr)) == len(arr)"]},{"id":"pc_19","description":"Test with a list of digits that are all distinct and in descending order.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":5,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":["len(set(arr)) == len(arr) and all(arr[i] > arr[i+1] for i in range(len(arr)-1))"]},{"id":"pc_20","description":"Test with a list of digits that are all distinct and in ascending order.","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":5,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":["len(set(arr)) == len(arr) and all(arr[i] < arr[i+1] for i in range(len(arr)-1))"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6075"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic positive digits","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":2,"max_len":10}},"postconditions":[{"assertion":"result == int(''.join(map(str, sorted(arr, reverse=True))))"}]},{"id":"pc_2","description":"Edge Case: Single digit list","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == arr[0]"}]},{"id":"pc_3","description":"Edge Case: List containing zero","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":2,"max_len":10}},"assumptions":["0 in arr"],"postconditions":[{"assertion":"result == int(''.join(map(str, sorted(arr, reverse=True))))"}]},{"id":"pc_4","description":"Invariant: Result is always non-negative","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":1,"max_len":10}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"pc_5","description":"Boundary: Large list of digits","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":1,"max_len":100}},"postconditions":[{"assertion":"result == int(''.join(map(str, sorted(arr, reverse=True))))"}]},{"id":"pc_6","description":"Typical Case: Mixed digits","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":2,"max_len":10,"is_mixed":true}},"postconditions":[{"assertion":"result == int(''.join(map(str, sorted(arr, reverse=True))))"}]},{"id":"pc_7","description":"Edge Case: All same digits","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":5,"max_val":5,"min_len":3,"max_len":5}},"postconditions":[{"assertion":"result == int(''.join(map(str, sorted(arr, reverse=True))))"}]},{"id":"pc_8","description":"Negative Test: Non-list input (TypeError)","execution_statement":"try: result = find_Max_Num(arr) except Exception as e: result = e","input_types":{"arr":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: List with non-digit elements (TypeError)","execution_statement":"try: result = find_Max_Num(arr) except Exception as e: result = e","input_types":{"arr":"list[str]"},"input_constraints":{"arr":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Edge Case: List with large digits (should still work)","execution_statement":"result = find_Max_Num(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":1,"max_len":15}},"postconditions":[{"assertion":"result == int(''.join(map(str, sorted(arr, reverse=True))))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6076"},"test_cases":[{"id":"pc_1","description":"Test with two positive integers.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":2147483647},"y":{"min_val":1,"max_val":2147483647}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_2","description":"Test with two negative integers.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-2147483648,"max_val":-1},"y":{"min_val":-2147483648,"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_3","description":"Test with one positive and one negative integer.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":2147483647},"y":{"min_val":-2147483648,"max_val":-1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Test with one negative and one positive integer.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-2147483648,"max_val":-1},"y":{"min_val":1,"max_val":2147483647}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_5","description":"Test with zero and a positive integer.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":0,"max_val":0},"y":{"min_val":1,"max_val":2147483647}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_6","description":"Test with a positive integer and zero.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":2147483647},"y":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Test with zero and a negative integer.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":0,"max_val":0},"y":{"min_val":-2147483648,"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_8","description":"Test with a negative integer and zero.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-2147483648,"max_val":-1},"y":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_9","description":"Test with two zeros.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":0,"max_val":0},"y":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"Test with minimum and maximum integer values (opposite signs).","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-2147483648,"max_val":-2147483648},"y":{"min_val":2147483647,"max_val":2147483647}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_11","description":"Test with maximum and minimum integer values (opposite signs).","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":2147483647,"max_val":2147483647},"y":{"min_val":-2147483648,"max_val":-2147483648}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_12","description":"Test with maximum integer value and a small positive integer.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":2147483647,"max_val":2147483647},"y":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_13","description":"Test with minimum integer value and a small negative integer.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-2147483648,"max_val":-2147483648},"y":{"min_val":-1,"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"Test with a large positive and a large negative integer.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1000000000,"max_val":1000000000},"y":{"min_val":-1000000000,"max_val":-1000000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_15","description":"Test with a large negative and a large positive integer.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-1000000000,"max_val":-1000000000},"y":{"min_val":1000000000,"max_val":1000000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_16","description":"Test with a small positive and a small negative integer.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1},"y":{"min_val":-1,"max_val":-1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_17","description":"Test with a small negative and a small positive integer.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-1,"max_val":-1},"y":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_18","description":"Test with a large positive and a small positive integer.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1000000000,"max_val":1000000000},"y":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_19","description":"Test with a large negative and a small negative integer.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-1000000000,"max_val":-1000000000},"y":{"min_val":-1,"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_20","description":"Test with a positive integer and the minimum integer value.","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1},"y":{"min_val":-2147483648,"max_val":-2147483648}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6077"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive and Negative Integers","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1000},"y":{"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Negative and Positive Integers","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-1000,"max_val":-1},"y":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Same Sign (Both Positive)","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1000},"y":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Same Sign (Both Negative)","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-1000,"max_val":-1},"y":{"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Zero and Positive","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":0,"max_val":0},"y":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Positive and Zero","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1000},"y":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: Zero and Negative","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":0,"max_val":0},"y":{"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_8","description":"Edge Case: Negative and Zero","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-1000,"max_val":-1},"y":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_9","description":"Edge Case: Both Zeros","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":0,"max_val":0},"y":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"Boundary Value: Max Int and Min Int","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":2147483647,"max_val":2147483647},"y":{"min_val":-2147483648,"max_val":-2147483648}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_11","description":"Boundary Value: Min Int and Max Int","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-2147483648,"max_val":-2147483648},"y":{"min_val":2147483647,"max_val":2147483647}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_12","description":"Boundary Value: Max Int and Positive Int","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":2147483647,"max_val":2147483647},"y":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_13","description":"Boundary Value: Min Int and Negative Int","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-2147483648,"max_val":-2147483648},"y":{"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"Large Magnitude: Positive and Negative","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1000000000,"max_val":2000000000},"y":{"min_val":-2000000000,"max_val":-1000000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_15","description":"Large Magnitude: Negative and Positive","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-2000000000,"max_val":-1000000000},"y":{"min_val":1000000000,"max_val":2000000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_16","description":"Large Magnitude: Same Sign Positive","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1000000000,"max_val":2000000000},"y":{"min_val":1000000000,"max_val":2000000000}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_17","description":"Large Magnitude: Same Sign Negative","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-2000000000,"max_val":-1000000000},"y":{"min_val":-2000000000,"max_val":-1000000000}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_18","description":"Near Zero: Positive and Negative","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":10},"y":{"min_val":-10,"max_val":-1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_19","description":"Near Zero: Negative and Positive","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-10,"max_val":-1},"y":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_20","description":"Near Zero: Same Sign Positive","execution_statement":"result = opposite_Signs(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":10},"y":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6078"},"test_cases":[{"id":"test_is_octagonal_positive_integers","description":"Test with positive integers.","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}]},{"id":"test_is_octagonal_zero","description":"Test with zero.","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"assumptions":[],"postconditions":[{"assertion":"result == 0"}]},{"id":"test_is_octagonal_large_integers","description":"Test with large positive integers.","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":100000}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > 0"}]},{"id":"test_is_octagonal_formula_check","description":"Verify the octagonal number formula.","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":500}},"assumptions":[],"postconditions":[{"assertion":"result == 3 * n * n - 2 * n"}]},{"id":"test_is_octagonal_boundary_one","description":"Test the boundary case n=1.","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"assumptions":[],"postconditions":[{"assertion":"result == 1"}]},{"id":"test_is_octagonal_non_integer_float","description":"Test with a float input, expecting TypeError.","execution_statement":"result = is_octagonal(n)","input_types":{"n":"float"},"input_constraints":{},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"test_is_octagonal_non_integer_string","description":"Test with a string input, expecting TypeError.","execution_statement":"result = is_octagonal(n)","input_types":{"n":"str"},"input_constraints":{"n":{"max_codepoint":255}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"test_is_octagonal_non_integer_none","description":"Test with None input, expecting TypeError.","execution_statement":"result = is_octagonal(n)","input_types":{"n":"None"},"input_constraints":{},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"test_is_octagonal_negative_input","description":"Test with a negative integer input, expecting TypeError.","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1000,"max_val":-1}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6079"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive integer input","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == (3 * n * n - 2 * n)"},{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Zero input","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Case: Large positive integer input","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":100000}},"postconditions":[{"assertion":"result == (3 * n * n - 2 * n)"}],"assumptions":[]},{"id":"pc_4","description":"Invariant: Octagonal numbers are non-negative for non-negative inputs","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":5000}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: Growth rate of octagonal numbers","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2000}},"postconditions":[{"assertion":"result > is_octagonal(n - 1)"}],"assumptions":["n > 1"]},{"id":"pc_6","description":"Negative Test: Invalid input type (string)","execution_statement":"try: result = is_octagonal(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Invalid input type (None)","execution_statement":"try: result = is_octagonal(n) except Exception as e: result = e","input_types":{"n":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Invalid input type (float)","execution_statement":"try: result = is_octagonal(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{"n":{"min_val":-1000.0,"max_val":1000.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc607a"},"test_cases":[{"id":"pc_1","description":"Test with an empty string.","execution_statement":"result = count_Substrings('')","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_2","description":"Test with a single digit '1'.","execution_statement":"result = count_Substrings('1')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^1$","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_3","description":"Test with a single digit other than '1'.","execution_statement":"result = count_Substrings('5')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[-7]$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Test with a string of all zeros.","execution_statement":"result = count_Substrings('0000')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^0+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_5","description":"Test with a string of all ones.","execution_statement":"result = count_Substrings('1111')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^1+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 4"}],"assumptions":[]},{"id":"pc_6","description":"Test with a simple mixed digit string.","execution_statement":"result = count_Substrings('123')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^123$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_7","description":"Test with a longer string containing valid substrings.","execution_statement":"result = count_Substrings('10110')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^10110$","max_codepoint":255}},"postconditions":[{"assertion":"result == 3"}],"assumptions":[]},{"id":"pc_8","description":"Test with a string of maximum length consisting of ones.","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"max_len":1000,"pattern":"^1+$","max_codepoint":255}},"postconditions":[{"assertion":"result == len(s)"}],"assumptions":[]},{"id":"pc_9","description":"Test with a string of maximum length consisting of zeros.","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"max_len":1000,"pattern":"^0+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_10","description":"Test with a string containing various digits.","execution_statement":"result = count_Substrings('9876543210')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^9876543210$","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_11","description":"Test with a string containing repeated patterns.","execution_statement":"result = count_Substrings('121212')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^(12)+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 3"}],"assumptions":[]},{"id":"pc_12","description":"Test with a string containing leading zeros.","execution_statement":"result = count_Substrings('001')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^001$","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_13","description":"Test with a string containing trailing zeros.","execution_statement":"result = count_Substrings('100')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^100$","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_14","description":"Test with a string containing internal zeros.","execution_statement":"result = count_Substrings('101')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^101$","max_codepoint":255}},"postconditions":[{"assertion":"result == 2"}],"assumptions":[]},{"id":"pc_15","description":"Test a string designed to have many valid substrings.","execution_statement":"result = count_Substrings('11111')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^1{5}$","max_codepoint":255}},"postconditions":[{"assertion":"result == 5"}],"assumptions":[]},{"id":"pc_16","description":"Test a string where no substring meets the criteria.","execution_statement":"result = count_Substrings('234')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^234$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_17","description":"Test a string with a mix of valid and invalid substrings.","execution_statement":"result = count_Substrings('1210')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^1210$","max_codepoint":255}},"postconditions":[{"assertion":"result == 2"}],"assumptions":[]},{"id":"pc_18","description":"Test with a long string of random digits.","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"max_len":1000,"pattern":"^[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_19","description":"Test with a string of only nines.","execution_statement":"result = count_Substrings('999')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^9+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_20","description":"Test with a string of alternating digits.","execution_statement":"result = count_Substrings('101010')","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^(10)+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 3"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc607b"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical string with digits","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[-9]+$","min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= (len(s) * (len(s) + 1)) // 2"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String with only zeros","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^0+$","min_len":1,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: String with only ones","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^1+$","min_len":1,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_5","description":"Typical Case: Mixed digits","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[-9]+$","min_len":5,"max_len":30,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Case: Long string of digits","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[-9]+$","min_len":50,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Non-digit characters","execution_statement":"try: result = count_Substrings(s) except Exception as e: result = e","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[^-9]+$","min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Mixed digits and non-digits","execution_statement":"try: result = count_Substrings(s) except Exception as e: result = e","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[-9a-zA-Z]+$","min_len":1,"max_len":10,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: null input","execution_statement":"try: result = count_Substrings(s) except Exception as e: result = e","input_types":{"s":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Integer input","execution_statement":"try: result = count_Substrings(s) except Exception as e: result = e","input_types":{"s":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Invariant: Count is always non-negative","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[-9]+$","min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_12","description":"Invariant: Count does not exceed total possible substrings","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[-9]+$","min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result <= (len(s) * (len(s) + 1)) // 2"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc607c"},"test_cases":[{"id":"pc_1","description":"Typical case: list of positive integers.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":1,"max_val":100,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":[]},{"id":"pc_2","description":"Edge case: list with all same integers.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":50,"max_val":50,"min_len":10,"max_len":30}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":[]},{"id":"pc_3","description":"Boundary case: list with minimum length.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-100,"max_val":100,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":[]},{"id":"pc_4","description":"Typical case: list of negative integers.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-100,"max_val":-1,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":[]},{"id":"pc_5","description":"Mixed case: list with positive, negative, and zero.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-50,"max_val":50,"min_len":10,"max_len":40,"is_mixed":true}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":["any(x < 0 for x in list_of_integers)","any(x > 0 for x in list_of_integers)","0 in list_of_integers"]},{"id":"pc_6","description":"Boundary case: list with very large negative numbers.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-1000000,"max_val":-500000,"min_len":5,"max_len":25}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":[]},{"id":"pc_7","description":"Boundary case: list with very large positive numbers.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":500000,"max_val":1000000,"min_len":5,"max_len":25}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":[]},{"id":"pc_8","description":"Edge case: list with one smallest negative number and rest are larger positive.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":1,"max_val":100,"min_len":10,"max_len":50}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":["list_of_integers[0] < 0"]},{"id":"pc_9","description":"Edge case: list with one largest positive number and rest are smaller negative.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-100,"max_val":-1,"min_len":10,"max_len":50}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":["list_of_integers[-1] > 0"]},{"id":"pc_10","description":"Typical case: list with a mix of numbers, including duplicates.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-200,"max_val":200,"min_len":15,"max_len":60}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":[]},{"id":"pc_11","description":"Boundary case: list with maximum length.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-1000,"max_val":1000,"min_len":1000,"max_len":1000}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":[]},{"id":"pc_12","description":"Edge case: list with only zero.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":0,"max_val":0,"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":[]},{"id":"pc_13","description":"Typical case: list with numbers close to zero.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-5,"max_val":5,"min_len":10,"max_len":30}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":[]},{"id":"pc_14","description":"Edge case: list with only one element (positive).","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":1,"max_val":100,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":[]},{"id":"pc_15","description":"Edge case: list with only one element (negative).","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":[]},{"id":"pc_16","description":"Typical case: list with a wide range of values.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-5000,"max_val":5000,"min_len":20,"max_len":100}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":[]},{"id":"pc_17","description":"Edge case: list with minimum and maximum allowed values.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-1000000,"max_val":1000000,"min_len":2,"max_len":10}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":["-1000000 in list_of_integers","1000000 in list_of_integers"]},{"id":"pc_18","description":"Typical case: list with many duplicates of the smallest number.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-100,"max_val":100,"min_len":10,"max_len":50}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":["list_of_integers.count(min(list_of_integers)) > len(list_of_integers) / 2"]},{"id":"pc_19","description":"Edge case: list with only two elements, one smaller than the other.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-100,"max_val":100,"min_len":2,"max_len":2}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":["list_of_integers[0] != list_of_integers[1]"]},{"id":"pc_20","description":"Typical case: list with numbers spanning across zero.","execution_statement":"result = smallest_num(list_of_integers)","input_types":{"list_of_integers":"List[int]"},"input_constraints":{"list_of_integers":{"min_val":-100,"max_val":100,"min_len":10,"max_len":50}},"postconditions":[{"assertion":"result in list_of_integers"},{"assertion":"all(result <= x for x in list_of_integers)"}],"assumptions":["any(x < 0 for x in list_of_integers)","any(x > 0 for x in list_of_integers)"]}]}
{"_id":{"$oid":"692adffe1b18223597bc607d"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with positive integers.","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"elements":{"min_val":1,"max_val":1000}}},"postconditions":[{"assertion":"result == min(xs)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: List with a single positive integer.","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":1,"max_len":1,"elements":{"min_val":1,"max_val":1000}}},"postconditions":[{"assertion":"result == xs[0]"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Value: List with negative integers.","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"elements":{"min_val":-1000,"max_val":-1}}},"postconditions":[{"assertion":"result == min(xs)"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Value: List with mixed positive and negative integers.","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":2,"max_len":100,"elements":{"min_val":-1000,"max_val":1000},"is_mixed":true}},"postconditions":[{"assertion":"result == min(xs)"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: List remains unmodified.","execution_statement":"original_xs = list(xs); result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"elements":{"min_val":-1000,"max_val":1000}}},"postconditions":[{"assertion":"xs == original_xs"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Value: List with zero.","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"elements":{"min_val":-1000,"max_val":1000}}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["0 in xs"]},{"id":"pc_7","description":"Boundary Value: List with large numbers.","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"elements":{"min_val":1000000,"max_val":1000000000}}},"postconditions":[{"assertion":"result == min(xs)"}],"assumptions":[]},{"id":"pc_8","description":"Edge Case: List with duplicate smallest numbers.","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":2,"max_len":100,"elements":{"min_val":-1000,"max_val":1000}}},"postconditions":[{"assertion":"result == min(xs)"}],"assumptions":["xs.count(min(xs)) > 1"]},{"id":"pc_9","description":"Negative Test: Empty list should raise ValueError.","execution_statement":"try: result = smallest_num(xs) except Exception as e: result = e","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Non-list input (integer).","execution_statement":"try: result = smallest_num(xs) except Exception as e: result = e","input_types":{"xs":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-list input (None).","execution_statement":"try: result = smallest_num(xs) except Exception as e: result = e","input_types":{"xs":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Boundary Value: List with floating point numbers.","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[float]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"elements":{"min_val":-1000.5,"max_val":1000.5}}},"postconditions":[{"assertion":"result == min(xs)"}],"assumptions":[]},{"id":"pc_13","description":"Boundary Value: List with mixed integers and floats.","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[Union[int, float]]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"elements":{"min_val":-1000,"max_val":1000},"is_mixed":true}},"postconditions":[{"assertion":"result == min(xs)"}],"assumptions":[]},{"id":"pc_14","description":"Invariant: All elements in the list are less than or equal to the maximum element.","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"elements":{"min_val":-1000,"max_val":1000}}},"postconditions":[{"assertion":"all(x >= result for x in xs)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc607e"},"test_cases":[{"id":"TC001","description":"Typical case with positive integers.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":50,"elements":{"min_val":1,"max_val":1000}}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC002","description":"Typical case with negative integers.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":50,"elements":{"min_val":-1000,"max_val":-1}}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC003","description":"Typical case with mixed positive and negative integers.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":50,"elements":{"min_val":-1000,"max_val":1000},"is_mixed":true}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC004","description":"Edge case: list with only one pair.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"elements":{"min_val":-1000,"max_val":1000}}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC005","description":"Edge case: empty list.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}]},{"id":"TC006","description":"Boundary case: large numbers.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":20,"elements":{"min_val":999999,"max_val":1000000}}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC007","description":"Boundary case: small numbers (close to zero).","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":20,"elements":{"min_val":-1,"max_val":1}}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC008","description":"Edge case: all pairs have identical numbers.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":50,"elements":{"min_val":-500,"max_val":500}}},"assumptions":["all(a == b for a, b in test_list)"],"postconditions":[{"assertion":"result == 0"}]},{"id":"TC009","description":"Invariant testing: difference should always be non-negative.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":50,"elements":{"min_val":-1000,"max_val":1000}}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC010","description":"Test with zero values.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":50,"elements":{"min_val":-100,"max_val":100}}},"assumptions":["any(0 in pair for pair in test_list)"],"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC011","description":"Test with maximum possible difference.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":2,"elements":{"min_val":-1000000,"max_val":1000000}}},"assumptions":["test_list[0] == (-1000000, 1000000) or test_list[0] == (1000000, -1000000)"],"postconditions":[{"assertion":"result == 2000000"}]},{"id":"TC012","description":"Test with minimum possible difference (non-zero).","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":2,"elements":{"min_val":-1,"max_val":1}}},"assumptions":["test_list[0] == (-1, 0) or test_list[0] == (0, -1) or test_list[0] == (0, 1) or test_list[0] == (1, 0)"],"postconditions":[{"assertion":"result == 1"}]},{"id":"TC013","description":"Test with a list of size 100.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":100,"max_len":100,"elements":{"min_val":-1000,"max_val":1000}}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC014","description":"Test with boundary values at list size 2.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":2,"elements":{"min_val":-1000000,"max_val":1000000}}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC015","description":"Test with values that result in zero difference.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":50,"elements":{"min_val":500,"max_val":500}}},"postconditions":[{"assertion":"result == 0"}]},{"id":"TC016","description":"Test with a mix of zero and non-zero differences.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":3,"max_len":50,"elements":{"min_val":-100,"max_val":100}}},"assumptions":["test_list[0] == (10, 10)","test_list[1] == (-50, 50)"],"postconditions":[{"assertion":"result == 100"}]},{"id":"TC017","description":"Test with large list and small differences.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":50,"max_len":100,"elements":{"min_val":-10,"max_val":10}}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC018","description":"Test with large list and large differences.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":50,"max_len":100,"elements":{"min_val":-10000,"max_val":10000}}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC019","description":"Test with boundary values at list size 100.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":100,"max_len":100,"elements":{"min_val":-1000000,"max_val":1000000}}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC020","description":"Test with negative numbers resulting in positive differences.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"List[Tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":50,"elements":{"min_val":-1000,"max_val":-10}}},"postconditions":[{"assertion":"result >= 0"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc607f"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with typical list of pairs.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":10}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result == max([abs(b - a) for a, b in test_list])"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list.","execution_statement":"try: result = max_difference(test_list) except Exception as e: result = e","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with a single pair.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == abs(test_list[0][1] - test_list[0][0])"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Value: Large numbers in pairs.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5},"test_list__element__0":{"min_val":-1000000,"max_val":1000000},"test_list__element__1":{"min_val":-1000000,"max_val":1000000}},"postconditions":[{"assertion":"result == max([abs(b - a) for a, b in test_list])"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: All individual differences are non-negative.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":10}},"postconditions":[{"assertion":"all(abs(b - a) >= 0 for a, b in test_list)"}],"assumptions":[]},{"id":"pc_6","description":"Typical Case: Pairs with zero difference.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":10}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":["any(a == b for a, b in test_list)"]},{"id":"pc_7","description":"Boundary Value: Pairs with negative numbers.","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":10}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result == max([abs(b - a) for a, b in test_list])"}],"assumptions":["any(a < 0 or b < 0 for a, b in test_list)"]},{"id":"pc_8","description":"Negative Test: Input is not a list.","execution_statement":"try: result = max_difference(test_list) except Exception as e: result = e","input_types":{"test_list":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: List contains non-tuple elements.","execution_statement":"try: result = max_difference(test_list) except Exception as e: result = e","input_types":{"test_list":"list[Any]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["not all(isinstance(item, tuple) for item in test_list)"]},{"id":"pc_10","description":"Negative Test: Tuple elements are not numbers.","execution_statement":"try: result = max_difference(test_list) except Exception as e: result = e","input_types":{"test_list":"list[tuple[str, str]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6080"},"test_cases":[{"id":"TC1","description":"Typical case with mixed subjects and marks.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":10,"sorted":"ascending","unique":false,"is_mixed":true},"subjectmarks[*]":{"0":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":0,"max_val":100},"is_mixed":true}},"assumptions":[],"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"}]},{"id":"TC2","description":"Edge case: Empty list.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":0,"max_len":0}},"assumptions":[],"postconditions":[{"assertion":"result == []"}]},{"id":"TC3","description":"Edge case: List with a single element.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":1},"subjectmarks[*]":{"0":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":0,"max_val":100}}},"assumptions":[],"postconditions":[{"assertion":"len(result) == 1 and result[0] == subjectmarks[0]"}]},{"id":"TC4","description":"Boundary case: Maximum list size.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":100,"max_len":100},"subjectmarks[*]":{"0":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":0,"max_val":100}}},"assumptions":[],"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"}]},{"id":"TC5","description":"Boundary case: Minimum marks (0).","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":10},"subjectmarks[*]":{"0":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":0,"max_val":0}}},"assumptions":[],"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"}]},{"id":"TC6","description":"Boundary case: Maximum marks (100).","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":10},"subjectmarks[*]":{"0":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":100,"max_val":100}}},"assumptions":[],"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"}]},{"id":"TC7","description":"Case with duplicate marks.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":5,"max_len":15},"subjectmarks[*]":{"0":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":50,"max_val":70}}},"assumptions":["len(set(s[1] for s in subjectmarks)) < len(subjectmarks)"],"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"}]},{"id":"TC8","description":"Invariant: All original elements are present.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":10},"subjectmarks[*]":{"0":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":0,"max_val":100}}},"assumptions":[],"postconditions":[{"assertion":"sorted(result, key=lambda x: x[1]) == result"},{"assertion":"len(result) == len(subjectmarks)"},{"assertion":"all(item in result for item in subjectmarks)"}]},{"id":"TC9","description":"Negative Test: Invalid type for subjectmarks (int).","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"int"},"input_constraints":{},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC10","description":"Negative Test: Invalid type for subjectmarks (None).","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"None"},"input_constraints":{},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, AttributeError)"}]},{"id":"TC11","description":"Negative Test: Invalid type for tuple element (str instead of int for marks).","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, str]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":5},"subjectmarks[*]":{"0":{"min_len":1,"max_len":10,"pattern":"^[a-zA-Z ]+$"},"1":{"min_len":1,"max_len":5,"pattern":"^[a-zA-Z]+$"}}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC12","description":"Test with subjects containing spaces.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":10},"subjectmarks[*]":{"0":{"min_len":5,"max_len":25,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":0,"max_val":100}}},"assumptions":[],"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"}]},{"id":"TC13","description":"Test with very short subject names.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":10},"subjectmarks[*]":{"0":{"min_len":1,"max_len":1,"pattern":"^[a-zA-Z]$"},"1":{"min_val":0,"max_val":100}}},"assumptions":[],"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"}]},{"id":"TC14","description":"Test with very long subject names.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":10},"subjectmarks[*]":{"0":{"min_len":50,"max_len":100,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":0,"max_val":100}}},"assumptions":[],"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"}]},{"id":"TC15","description":"Test with marks close to boundaries.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":5,"max_len":15},"subjectmarks[*]":{"0":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":1,"max_val":99}}},"assumptions":[],"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"}]},{"id":"TC16","description":"Test with negative marks (if allowed by problem domain, otherwise this is a negative test). Assuming marks can be negative for generality.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":10},"subjectmarks[*]":{"0":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":-100,"max_val":100}}},"assumptions":[],"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"}]},{"id":"TC17","description":"Invariant: Length of output equals length of input.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":10},"subjectmarks[*]":{"0":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":0,"max_val":100}}},"assumptions":[],"postconditions":[{"assertion":"len(result) == len(subjectmarks)"}]},{"id":"TC18","description":"Test with a large number of elements.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":500,"max_len":1000},"subjectmarks[*]":{"0":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":0,"max_val":100}}},"assumptions":[],"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"}]},{"id":"TC19","description":"Test with marks that are all the same.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":5,"max_len":15},"subjectmarks[*]":{"0":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":50,"max_val":50}}},"assumptions":[],"postconditions":[{"assertion":"all(subjectmarks[i][1] == subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"}]},{"id":"TC20","description":"Test with marks that are strictly increasing.","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"List[Tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":5,"max_len":15},"subjectmarks[*]":{"0":{"min_len":1,"max_len":20,"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":0,"max_val":100}}},"assumptions":["len(set(s[1] for s in subjectmarks)) == len(subjectmarks)"],"postconditions":[{"assertion":"all(subjectmarks[i][1] < subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6081"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic sorting of tuples","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"result == sorted(subjectmarks, key=lambda x: x[1])"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list input","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":0,"max_len":0,"max_codepoint":127}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with a single tuple","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":1,"max_codepoint":127}},"postconditions":[{"assertion":"result == subjectmarks"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Case: List with identical second elements (stable sort)","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":2,"max_len":5,"elements":{"tuple":{"min_len":2,"max_len":2,"0":{"pattern":"^[a-zA-Z ]+$"},"1":{"min_val":80,"max_val":90}},"max_codepoint":127},"max_codepoint":127}},"postconditions":[{"assertion":"result == sorted(subjectmarks, key=lambda x: x[1])"}],"assumptions":["subjectmarks[0][1] == subjectmarks[1][1]"]},{"id":"pc_5","description":"Invariant: All elements in the returned list are tuples of length 2","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"all(isinstance(item, tuple) and len(item) == 2 for item in result)"}],"assumptions":[]},{"id":"pc_6","description":"Invariant: The second element of each tuple is an integer","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"all(isinstance(item[1], int) for item in result)"}],"assumptions":[]},{"id":"pc_7","description":"Boundary Case: Large number of tuples","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":0,"max_len":100,"max_codepoint":127}},"postconditions":[{"assertion":"result == sorted(subjectmarks, key=lambda x: x[1])"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Input is not a list (expect TypeError)","execution_statement":"try: result = subject_marks(subjectmarks) except Exception as e: result = e","input_types":{"subjectmarks":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: List contains non-tuple elements (expect TypeError)","execution_statement":"try: result = subject_marks(subjectmarks) except Exception as e: result = e","input_types":{"subjectmarks":"list[int]"},"input_constraints":{"subjectmarks":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: List contains tuples with incorrect number of elements (expect TypeError)","execution_statement":"try: result = subject_marks(subjectmarks) except Exception as e: result = e","input_types":{"subjectmarks":"list[tuple[str]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, IndexError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: List contains tuples with non-integer second element (expect TypeError)","execution_statement":"try: result = subject_marks(subjectmarks) except Exception as e: result = e","input_types":{"subjectmarks":"list[tuple[str, str]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6082"},"test_cases":[{"id":"TC1","description":"Test with a simple flat list of integers.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[int]"},"input_constraints":{"data_list":{"min_len":1,"max_len":10,"unique":true}},"assumptions":[],"postconditions":[{"assertion":"result == sum(data_list)"}]},{"id":"TC2","description":"Test with a nested list of integers.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[Union[int, List]]"},"input_constraints":{"data_list":{"min_len":1,"max_len":5,"allow_none":false}},"assumptions":[],"postconditions":[{"assertion":"result == sum(element for element in flatten(data_list) if isinstance(element, int))"}]},{"id":"TC3","description":"Test with an empty list.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[int]"},"input_constraints":{"data_list":{"min_len":0,"max_len":0}},"assumptions":[],"postconditions":[{"assertion":"result == 0"}]},{"id":"TC4","description":"Test with a list containing only empty lists.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[List]"},"input_constraints":{"data_list":{"min_len":1,"max_len":5}},"assumptions":[],"postconditions":[{"assertion":"result == 0"}]},{"id":"TC5","description":"Test with deeply nested lists.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[Any]"},"input_constraints":{"data_list":{"max_depth":5,"max_leaves":10}},"assumptions":[],"postconditions":[{"assertion":"result == sum(element for element in flatten(data_list) if isinstance(element, int))"}]},{"id":"TC6","description":"Test with a mix of integers and empty lists at various levels.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[Union[int, List]]"},"input_constraints":{"data_list":{"min_len":1,"max_len":10,"allow_none":false}},"assumptions":[],"postconditions":[{"assertion":"result == sum(element for element in flatten(data_list) if isinstance(element, int))"}]},{"id":"TC7","description":"Test with large integers to check for overflow (if applicable, though Python handles large ints).","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[int]"},"input_constraints":{"data_list":{"min_val":-1000000,"max_val":1000000,"min_len":1,"max_len":10}},"assumptions":[],"postconditions":[{"assertion":"result == sum(data_list)"}]},{"id":"TC8","description":"Test with negative integers.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[int]"},"input_constraints":{"data_list":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":10}},"assumptions":[],"postconditions":[{"assertion":"result == sum(data_list)"}]},{"id":"TC9","description":"Test with a mix of positive and negative integers.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[int]"},"input_constraints":{"data_list":{"min_val":-100,"max_val":100,"min_len":1,"max_len":10}},"assumptions":[],"postconditions":[{"assertion":"result == sum(data_list)"}]},{"id":"TC10","description":"Test with a single element list (integer).","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[int]"},"input_constraints":{"data_list":{"min_len":1,"max_len":1}},"assumptions":[],"postconditions":[{"assertion":"result == data_list[0]"}]},{"id":"TC11","description":"Test with a single element list (nested empty list).","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[List]"},"input_constraints":{"data_list":{"min_len":1,"max_len":1}},"assumptions":[],"postconditions":[{"assertion":"result == 0"}]},{"id":"TC12","description":"Test with a single element list (nested list with one integer).","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[List[int]]"},"input_constraints":{"data_list":{"min_len":1,"max_len":1}},"assumptions":[],"postconditions":[{"assertion":"result == data_list[0][0]"}]},{"id":"TC13","description":"Test with a list containing zero.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[int]"},"input_constraints":{"data_list":{"min_val":0,"max_val":0,"min_len":1,"max_len":10}},"assumptions":[],"postconditions":[{"assertion":"result == 0"}]},{"id":"TC14","description":"Test with a list containing zero and other numbers.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[int]"},"input_constraints":{"data_list":{"min_val":-10,"max_val":10,"min_len":1,"max_len":10}},"assumptions":["0 in data_list"],"postconditions":[{"assertion":"result == sum(data_list)"}]},{"id":"TC15","description":"Test with a list containing only one type of nested structure.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[List[List[int]]]"},"input_constraints":{"data_list":{"min_len":1,"max_len":5}},"assumptions":[],"postconditions":[{"assertion":"result == sum(element for element in flatten(data_list) if isinstance(element, int))"}]},{"id":"TC16","description":"Test with a list containing a mix of integers and deeply nested empty lists.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[Union[int, List]]"},"input_constraints":{"data_list":{"min_len":1,"max_len":10,"allow_none":false}},"assumptions":[],"postconditions":[{"assertion":"result == sum(element for element in flatten(data_list) if isinstance(element, int))"}]},{"id":"TC17","description":"Test with a list where all elements are the same.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[int]"},"input_constraints":{"data_list":{"min_val":5,"max_val":5,"min_len":1,"max_len":10,"unique":false}},"assumptions":[],"postconditions":[{"assertion":"result == len(data_list) * 5"}]},{"id":"TC18","description":"Test with a list containing a single nested list with multiple elements.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[List[int]]"},"input_constraints":{"data_list":{"min_len":1,"max_len":1}},"assumptions":[],"postconditions":[{"assertion":"result == sum(data_list[0])"}]},{"id":"TC19","description":"Test with a list containing a single nested list with nested lists.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[List[List[int]]]"},"input_constraints":{"data_list":{"min_len":1,"max_len":1}},"assumptions":[],"postconditions":[{"assertion":"result == sum(element for element in flatten(data_list[0]) if isinstance(element, int))"}]},{"id":"TC20","description":"Test with a complex nested structure.","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"List[Any]"},"input_constraints":{"data_list":{"max_depth":4,"max_leaves":8}},"assumptions":[],"postconditions":[{"assertion":"result == sum(element for element in flatten(data_list) if isinstance(element, int))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6083"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic list of integers","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"list[int]"},"input_constraints":{"data_list":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"result == sum(flatten(data_list))"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"list[int]"},"input_constraints":{"data_list":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with only empty lists","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"list[list[int]]"},"input_constraints":{"data_list":{"min_len":1,"max_len":5,"elements":{"min_len":0,"max_len":0}}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Happy Path: Nested lists with integers","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"list"},"input_constraints":{"data_list":{"min_len":1,"max_len":5,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(flatten(data_list))"}],"assumptions":[]},{"id":"pc_5","description":"Happy Path: Deeply nested lists","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"list"},"input_constraints":{"data_list":{"min_len":1,"max_len":3,"elements":{"max_depth":5,"is_mixed":true}}},"postconditions":[{"assertion":"result == sum(flatten(data_list))"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: List with zeros","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"list[int]"},"input_constraints":{"data_list":{"min_len":1,"max_len":10,"elements":{"max_val":0}}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_7","description":"Invariant: Sum should be non-negative for non-negative inputs","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"list"},"input_constraints":{"data_list":{"min_len":1,"max_len":10,"is_mixed":true,"elements":{"min_val":0}}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_8","description":"Happy Path: Mixed integers and empty lists","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"list"},"input_constraints":{"data_list":{"min_len":1,"max_len":10,"is_mixed":true,"elements":{"allow_none":false}}},"postconditions":[{"assertion":"result == sum(flatten(data_list))"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = recursive_list_sum(data_list) except Exception as e: result = e","input_types":{"data_list":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = recursive_list_sum(data_list) except Exception as e: result = e","input_types":{"data_list":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Happy Path: Large list of integers","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"list[int]"},"input_constraints":{"data_list":{"min_len":100,"max_len":200}},"postconditions":[{"assertion":"result == sum(flatten(data_list))"}],"assumptions":[]},{"id":"pc_12","description":"Happy Path: List with negative numbers","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"list[int]"},"input_constraints":{"data_list":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"result == sum(flatten(data_list))"}],"assumptions":[]},{"id":"pc_13","description":"Happy Path: Mixed positive and negative numbers in nested lists","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"list"},"input_constraints":{"data_list":{"min_len":1,"max_len":5,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(flatten(data_list))"}],"assumptions":[]},{"id":"pc_14","description":"Edge Case: List containing a single large integer","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"list[int]"},"input_constraints":{"data_list":{"min_len":1,"max_len":1,"elements":{"min_val":1000000,"max_val":10000000}}},"postconditions":[{"assertion":"result == 10000000"}],"assumptions":[]},{"id":"pc_15","description":"Edge Case: List containing a single nested list with a large integer","execution_statement":"result = recursive_list_sum(data_list)","input_types":{"data_list":"list[list[int]]"},"input_constraints":{"data_list":{"min_len":1,"max_len":1,"elements":{"min_len":1,"max_len":1,"elements":{"min_val":1000000,"max_val":10000000}}}},"postconditions":[{"assertion":"result == 10000000"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6084"},"test_cases":[{"id":"pc_1","description":"Test with a typical list of positive, negative, and zero integers.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"result >= 0 and result <= len(list_arg)"}],"assumptions":[]},{"id":"pc_2","description":"Test with an empty list.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Test with a list containing only positive integers.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_val":1}},"postconditions":[{"assertion":"result == len(list_arg)"}],"assumptions":[]},{"id":"pc_4","description":"Test with a list containing only negative integers.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"max_val":-1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_5","description":"Test with a list containing only zeros.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_6","description":"Test with a large list of integers.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_size":1000,"max_size":5000,"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"result >= 0 and result <= len(list_arg)"}],"assumptions":[]},{"id":"pc_7","description":"Test with a list containing the boundary value 0.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"allow_none":false,"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result >= 0 and result <= len(list_arg)"}],"assumptions":["0 in list_arg"]},{"id":"pc_8","description":"Test with a list containing the boundary value 1.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"allow_none":false,"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result >= 0 and result <= len(list_arg)"}],"assumptions":["1 in list_arg"]},{"id":"pc_9","description":"Test with a list containing the boundary value -1.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"allow_none":false,"min_val":-1,"max_val":-1}},"postconditions":[{"assertion":"result >= 0 and result <= len(list_arg)"}],"assumptions":["-1 in list_arg"]},{"id":"pc_10","description":"Test with a list containing a mix of positive and negative numbers, ensuring at least one positive.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_val":-10,"max_val":10}},"postconditions":[{"assertion":"result > 0 and result <= len(list_arg)"}],"assumptions":["any(x > 0 for x in list_arg)"]},{"id":"pc_11","description":"Test with a list containing a mix of positive and negative numbers, ensuring at least one negative.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_val":-10,"max_val":10}},"postconditions":[{"assertion":"result >= 0 and result <= len(list_arg)"}],"assumptions":["any(x < 0 for x in list_arg)"]},{"id":"pc_12","description":"Test with a list containing a mix of positive, negative, and zero.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_val":-50,"max_val":50}},"postconditions":[{"assertion":"result >= 0 and result <= len(list_arg)"}],"assumptions":["any(x > 0 for x in list_arg)","any(x < 0 for x in list_arg)","any(x == 0 for x in list_arg)"]},{"id":"pc_13","description":"Test with a list where all numbers are positive and large.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_val":10000,"max_val":100000}},"postconditions":[{"assertion":"result == len(list_arg)"}],"assumptions":[]},{"id":"pc_14","description":"Test with a list where all numbers are negative and small.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_val":-100000,"max_val":-10000}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_15","description":"Test with a list containing a single positive number.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_size":1,"max_size":1,"min_val":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_16","description":"Test with a list containing a single negative number.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_size":1,"max_size":1,"max_val":-1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_17","description":"Test with a list containing a single zero.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_size":1,"max_size":1,"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_18","description":"Test with a list containing duplicate positive numbers.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result >= 0 and result <= len(list_arg)"}],"assumptions":["len(list_arg) > 1"]},{"id":"pc_19","description":"Test with a list containing duplicate negative numbers.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_val":-10,"max_val":-1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["len(list_arg) > 1"]},{"id":"pc_20","description":"Test with a list containing duplicate zeros.","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"List[int]"},"input_constraints":{"list_arg":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["len(list_arg) > 1"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6085"},"test_cases":[{"id":"pc_1","description":"Happy Path: List with positive, negative, and zero integers","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"list[int]"},"input_constraints":{"list_arg":{"min_len":5,"max_len":20}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result <= len(list_arg)"},{"assertion":"result == sum(1 for num in list_arg if num >= 0)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"list[int]"},"input_constraints":{"list_arg":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with only negative integers","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"list[int]"},"input_constraints":{"list_arg":{"min_len":5,"max_len":20},"list_arg[*]":{"max_val":-1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: List with only non-negative integers (including zero)","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"list[int]"},"input_constraints":{"list_arg":{"min_len":5,"max_len":20},"list_arg[*]":{"min_val":0}},"postconditions":[{"assertion":"result == len(list_arg)"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Value: List with large positive and negative integers","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"list[int]"},"input_constraints":{"list_arg":{"min_len":10,"max_len":30},"list_arg[*]":{"min_val":-1000000,"max_val":1000000}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(list_arg)"},{"assertion":"result == sum(1 for num in list_arg if num >= 0)"}],"assumptions":[]},{"id":"pc_6","description":"Happy Path: List with floating point numbers","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"list[float]"},"input_constraints":{"list_arg":{"min_len":5,"max_len":20}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result <= len(list_arg)"},{"assertion":"result == sum(1 for num in list_arg if num >= 0)"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: List with only zeros","execution_statement":"result = pos_count(list_arg)","input_types":{"list_arg":"list[int]"},"input_constraints":{"list_arg":{"min_len":5,"max_len":20},"list_arg[*]":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == len(list_arg)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = pos_count(list_arg) except Exception as e: result = e","input_types":{"list_arg":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = pos_count(list_arg) except Exception as e: result = e","input_types":{"list_arg":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: List contains non-numeric types (string)","execution_statement":"try: result = pos_count(list_arg) except Exception as e: result = e","input_types":{"list_arg":"list"},"input_constraints":{"list_arg":{"min_len":1,"max_len":5,"elements":{"allow_none":false,"is_mixed":true}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["not all(isinstance(x, (int, float)) for x in list_arg)"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6086"},"test_cases":[{"id":"pc_1","description":"Test with the smallest valid input for n (n=0).","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_2","description":"Test with a small positive input for n (n=1).","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_3","description":"Test with a small positive input for n (n=2).","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == 2"}],"assumptions":[]},{"id":"pc_4","description":"Test with a small positive input for n (n=3).","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"result == 5"}],"assumptions":[]},{"id":"pc_5","description":"Test with a moderately larger input for n (n=5).","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"result == 52"}],"assumptions":[]},{"id":"pc_6","description":"Test with a larger input for n (n=10).","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":10}},"postconditions":[{"assertion":"result == 115975"}],"assumptions":[]},{"id":"pc_7","description":"Test with a range of small positive integers.","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":15}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":[]},{"id":"pc_8","description":"Test with a range of moderate positive integers.","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":15,"max_val":30}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":[]},{"id":"pc_9","description":"Test with a larger range of positive integers.","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":30,"max_val":50}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":[]},{"id":"pc_10","description":"Test the non-decreasing property of Bell numbers.","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":20}},"postconditions":[{"assertion":"result >= bell_number(n-1)"}],"assumptions":["n > 0"]},{"id":"pc_11","description":"Test the recurrence relation for Bell numbers (B_{n+1} = sum_{k=0 to n} (n choose k) * B_k). This requires a helper for combinations and memoization.","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":10}},"postconditions":[{"assertion":"result == sum(math.comb(n - 1, k) * bell_number(k) for k in range(n))"}],"assumptions":["n > 0"]},{"id":"pc_12","description":"Test with a negative input (expecting TypeError).","execution_statement":"try: result = bell_number(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{"n":{"min_val":-10.0,"max_val":-0.1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Test with a string input (expecting TypeError).","execution_statement":"try: result = bell_number(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"pattern":"[a-z]+","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Test with None input (expecting TypeError).","execution_statement":"try: result = bell_number(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Test with a large integer input to check for potential overflow or performance issues.","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":50,"max_val":70}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6087"},"test_cases":[{"id":"pc_1","description":"Basic Functionality (Happy Path)","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":30}},"postconditions":[{"assertion":"return_value >= 0"},{"assertion":"isinstance(return_value, int)"}]},{"id":"pc_2","description":"Edge Case: n = 0","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"return_value == 1"}]},{"id":"pc_3","description":"Boundary Value: Large n","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":31,"max_val":50}},"postconditions":[{"assertion":"return_value >= 0"},{"assertion":"isinstance(return_value, int)"}]},{"id":"pc_4","description":"Invariant: Bell number grows with n (for n > 0)","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":30}},"assumptions":["n > 0"],"postconditions":[{"assertion":"return_value > bell_number(n-1)"}]},{"id":"pc_5","description":"Negative Test: Invalid Input Type (float)","execution_statement":"try: result = bell_number(n) except Exception as e: result = e","input_types":{"n":"float"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_6","description":"Negative Test: Invalid Input Type (string)","execution_statement":"try: result = bell_number(n) except Exception as e: result = e","input_types":{"n":"str"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_7","description":"Negative Test: Invalid Input Type (None)","execution_statement":"try: result = bell_number(n) except Exception as e: result = e","input_types":{"n":"None"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_8","description":"Negative Test: Negative integer input","execution_statement":"try: result = bell_number(n) except Exception as e: result = e","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-10,"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6088"},"test_cases":[{"id":"pc_1","description":"Test with an empty list.","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Test with a single element list.","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_3","description":"Test with a strictly increasing list.","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"sorted":"ascending"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Test with a strictly decreasing list.","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"sorted":"descending"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_5","description":"Test with a non-decreasing list (with duplicates).","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["all(A[i] <= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_6","description":"Test with a non-increasing list (with duplicates).","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["all(A[i] >= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_7","description":"Test with a list that is not monotonic (increasing then decreasing).","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":3,"max_len":100,"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or all(A[i] >= A[i + 1] for i in range(len(A) - 1)))"]},{"id":"pc_8","description":"Test with a list that is not monotonic (decreasing then increasing).","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":3,"max_len":100,"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or all(A[i] >= A[i + 1] for i in range(len(A) - 1)))"]},{"id":"pc_9","description":"Test with large values (positive).","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"min_val":1000000,"max_val":2000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["all(A[i] <= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_10","description":"Test with large values (negative).","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"min_val":-2000000,"max_val":-1000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["all(A[i] >= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_11","description":"Test with mixed positive and negative values (increasing).","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"min_val":-1000,"max_val":1000,"is_mixed":true}},"postconditions":[{"assertion":"result == True"}],"assumptions":["all(A[i] <= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_12","description":"Test with mixed positive and negative values (decreasing).","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"min_val":-1000,"max_val":1000,"is_mixed":true}},"postconditions":[{"assertion":"result == True"}],"assumptions":["all(A[i] >= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_13","description":"Test with all elements being the same.","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(A)) == 1"]},{"id":"pc_14","description":"Test with a list of two elements, increasing.","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":2}},"postconditions":[{"assertion":"result == True"}],"assumptions":["A[0] <= A[1]"]},{"id":"pc_15","description":"Test with a list of two elements, decreasing.","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":2}},"postconditions":[{"assertion":"result == True"}],"assumptions":["A[0] >= A[1]"]},{"id":"pc_16","description":"Test with a list of two elements, not monotonic.","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":2}},"postconditions":[{"assertion":"result == False"}],"assumptions":["A[0] != A[1]"]},{"id":"pc_17","description":"Test with a long strictly increasing list.","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":100,"max_len":1000,"sorted":"ascending"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_18","description":"Test with a long strictly decreasing list.","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":100,"max_len":1000,"sorted":"descending"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_19","description":"Test with a long non-monotonic list.","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":100,"max_len":1000,"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or all(A[i] >= A[i + 1] for i in range(len(A) - 1)))"]},{"id":"pc_20","description":"Test with boundary values at the limits.","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"min_val":-1000000,"max_val":1000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["all(A[i] <= A[i + 1] for i in range(len(A) - 1))"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6089"},"test_cases":[{"id":"pc_1","description":"Happy Path: Non-decreasing list","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"unique":false}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(A[i] <= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_2","description":"Happy Path: Non-increasing list","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"unique":false}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(A[i] >= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_3","description":"Edge Case: Empty list","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Single element list","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: All elements are the same","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":0,"max_len":50,"unique":false}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(set(A)) == 1"]},{"id":"pc_6","description":"Typical Case: Mixed list (not monotonic)","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":3,"max_len":100,"is_mixed":true}},"postconditions":[{"assertion":"result is False"}],"assumptions":["not (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or all(A[i] >= A[i + 1] for i in range(len(A) - 1)))"]},{"id":"pc_7","description":"Boundary Case: Large list (non-decreasing)","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":1000,"max_len":1000}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(A[i] <= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_8","description":"Boundary Case: Large list (non-increasing)","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":1000,"max_len":1000}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(A[i] >= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_9","description":"Boundary Case: Large list (not monotonic)","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":1000,"max_len":1000}},"postconditions":[{"assertion":"result is False"}],"assumptions":["not (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or all(A[i] >= A[i + 1] for i in range(len(A) - 1)))"]},{"id":"pc_10","description":"Negative Test: Non-list input (int)","execution_statement":"try: result = is_Monotonic(A) except Exception as e: result = e","input_types":{"A":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-list input (None)","execution_statement":"try: result = is_Monotonic(A) except Exception as e: result = e","input_types":{"A":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Happy Path: List with negative numbers (non-decreasing)","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(A[i] <= A[i + 1] for i in range(len(A) - 1))","all(x < 0 for x in A)"]},{"id":"pc_13","description":"Happy Path: List with negative numbers (non-increasing)","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(A[i] >= A[i + 1] for i in range(len(A) - 1))","all(x < 0 for x in A)"]},{"id":"pc_14","description":"Happy Path: List with mixed positive and negative numbers (non-decreasing)","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"is_mixed":true}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(A[i] <= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_15","description":"Happy Path: List with mixed positive and negative numbers (non-increasing)","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"is_mixed":true}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(A[i] >= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_16","description":"Edge Case: List with zeros (non-decreasing)","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(A[i] <= A[i + 1] for i in range(len(A) - 1))","0 in A"]},{"id":"pc_17","description":"Edge Case: List with zeros (non-increasing)","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(A[i] >= A[i + 1] for i in range(len(A) - 1))","0 in A"]},{"id":"pc_18","description":"Typical Case: List with duplicates (non-decreasing)","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"unique":false}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(A[i] <= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_19","description":"Typical Case: List with duplicates (non-increasing)","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":100,"unique":false}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(A[i] >= A[i + 1] for i in range(len(A) - 1))"]},{"id":"pc_20","description":"Typical Case: Alternating values (not monotonic)","execution_statement":"result = is_Monotonic(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":3,"max_len":100}},"postconditions":[{"assertion":"result is False"}],"assumptions":["not (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or all(A[i] >= A[i + 1] for i in range(len(A) - 1)))"]}]}
{"_id":{"$oid":"692adffe1b18223597bc608a"},"test_cases":[{"id":"TC1","description":"Typical case: Sublist is present in the middle of the main list.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":2,"max_len":5}},"assumptions":["sub_list in [main_list[i:i+len(sub_list)] for i in range(len(main_list)-len(sub_list)+1)]"],"postconditions":[{"assertion":"result == True"}]},{"id":"TC2","description":"Typical case: Sublist is not present in the main list.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":2,"max_len":5}},"assumptions":["sub_list not in [main_list[i:i+len(sub_list)] for i in range(len(main_list)-len(sub_list)+1)]"],"postconditions":[{"assertion":"result == False"}]},{"id":"TC3","description":"Edge case: Empty sublist.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"max_len":0}},"assumptions":[],"postconditions":[{"assertion":"result == True"}]},{"id":"TC4","description":"Edge case: Empty main list, non-empty sublist.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"max_len":0},"s":{"min_len":1,"max_len":5}},"assumptions":[],"postconditions":[{"assertion":"result == False"}]},{"id":"TC5","description":"Edge case: Both lists are empty.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"max_len":0},"s":{"max_len":0}},"assumptions":[],"postconditions":[{"assertion":"result == True"}]},{"id":"TC6","description":"Boundary case: Sublist is identical to the main list.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":5,"max_len":10},"s":{}},"assumptions":["main_list == sub_list"],"postconditions":[{"assertion":"result == True"}]},{"id":"TC7","description":"Boundary case: Sublist is longer than the main list.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":1,"max_len":5},"s":{"min_len":6,"max_len":10}},"assumptions":[],"postconditions":[{"assertion":"result == False"}]},{"id":"TC8","description":"Invariant: Main list contains repeated elements, sublist present.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":10,"max_len":20,"unique":false},"s":{"min_len":2,"max_len":5}},"assumptions":["sub_list in [main_list[i:i+len(sub_list)] for i in range(len(main_list)-len(sub_list)+1)]"],"postconditions":[{"assertion":"result == True"}]},{"id":"TC9","description":"Invariant: Sublist contains repeated elements, present.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":2,"max_len":5,"unique":false}},"assumptions":["sub_list in [main_list[i:i+len(sub_list)] for i in range(len(main_list)-len(sub_list)+1)]"],"postconditions":[{"assertion":"result == True"}]},{"id":"TC10","description":"Invariant: Sublist at the beginning of the main list.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":2,"max_len":5}},"assumptions":["main_list[:len(sub_list)] == sub_list"],"postconditions":[{"assertion":"result == True"}]},{"id":"TC11","description":"Invariant: Sublist at the end of the main list.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":2,"max_len":5}},"assumptions":["main_list[-len(sub_list):] == sub_list"],"postconditions":[{"assertion":"result == True"}]},{"id":"TC12","description":"Invariant: Overlapping potential sublists, sublist present.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":10,"max_len":20,"unique":false},"s":{"min_len":3,"max_len":6}},"assumptions":["sub_list in [main_list[i:i+len(sub_list)] for i in range(len(main_list)-len(sub_list)+1)]"],"postconditions":[{"assertion":"result == True"}]},{"id":"TC13","description":"Testing with different data types (strings), sublist present.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[str]","s":"List[str]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":2,"max_len":5}},"assumptions":["sub_list in [main_list[i:i+len(sub_list)] for i in range(len(main_list)-len(sub_list)+1)]"],"postconditions":[{"assertion":"result == True"}]},{"id":"TC14","description":"Testing with different data types (strings), sublist absent.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[str]","s":"List[str]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":2,"max_len":5}},"assumptions":["sub_list not in [main_list[i:i+len(sub_list)] for i in range(len(main_list)-len(sub_list)+1)]"],"postconditions":[{"assertion":"result == False"}]},{"id":"TC15","description":"Main list with single element, sublist is that element.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":1,"max_len":1},"s":{"min_len":1,"max_len":1}},"assumptions":["main_list == sub_list"],"postconditions":[{"assertion":"result == True"}]},{"id":"TC16","description":"Main list with single element, sublist is different.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":1,"max_len":1},"s":{"min_len":1,"max_len":1}},"assumptions":["main_list != sub_list"],"postconditions":[{"assertion":"result == False"}]},{"id":"TC17","description":"Main list with multiple identical elements, sublist is one of them.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":5,"max_len":10,"unique":false},"s":{"min_len":1,"max_len":1}},"assumptions":["sub_list[0] in main_list"],"postconditions":[{"assertion":"result == True"}]},{"id":"TC18","description":"Main list with multiple identical elements, sublist is not present.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":5,"max_len":10,"unique":false},"s":{"min_len":1,"max_len":1}},"assumptions":["sub_list[0] not in main_list"],"postconditions":[{"assertion":"result == False"}]},{"id":"TC19","description":"Sublist is a single element, present multiple times in main list.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_len":5,"max_len":10,"unique":false},"s":{"min_len":1,"max_len":1}},"assumptions":["sub_list[0] in main_list"],"postconditions":[{"assertion":"result == True"}]},{"id":"TC20","description":"Main list and sublist with negative numbers.","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"l":"List[int]","s":"List[int]"},"input_constraints":{"l":{"min_val":-20,"max_val":-1,"min_len":5,"max_len":10},"s":{"min_val":-20,"max_val":-1,"min_len":2,"max_len":5}},"assumptions":["sub_list in [main_list[i:i+len(sub_list)] for i in range(len(main_list)-len(sub_list)+1)]"],"postconditions":[{"assertion":"result == True"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc608b"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic sublist found","input_types":{"l":"list[int]","s":"list[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":1,"max_len":5}},"assumptions":["s in [l[i:i+len(s)] for i in range(len(l)-len(s)+1)]"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is True"}]},{"id":"pc_2","description":"Happy Path: Sublist at the beginning","input_types":{"l":"list[int]","s":"list[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":1,"max_len":5}},"assumptions":["l[:len(s)] == s"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is True"}]},{"id":"pc_3","description":"Happy Path: Sublist at the end","input_types":{"l":"list[int]","s":"list[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":1,"max_len":5}},"assumptions":["l[-len(s):] == s"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is True"}]},{"id":"pc_4","description":"Edge Case: Empty sublist","input_types":{"l":"list[int]","s":"list[int]"},"input_constraints":{"l":{"min_len":0,"max_len":20}},"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is True"}]},{"id":"pc_5","description":"Edge Case: Identical lists","input_types":{"l":"list[int]","s":"list[int]"},"input_constraints":{"l":{"min_len":1,"max_len":20}},"assumptions":["l == s"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is True"}]},{"id":"pc_6","description":"Edge Case: Sublist longer than list","input_types":{"l":"list[int]","s":"list[int]"},"input_constraints":{"l":{"min_len":1,"max_len":10},"s":{"min_len":11,"max_len":20}},"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is False"}]},{"id":"pc_7","description":"Edge Case: Empty list, non-empty sublist","input_types":{"l":"list[int]","s":"list[int]"},"input_constraints":{"l":{"min_len":0,"max_len":0},"s":{"min_len":1,"max_len":5}},"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is False"}]},{"id":"pc_8","description":"Negative Case: Sublist not found","input_types":{"l":"list[int]","s":"list[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":1,"max_len":5}},"assumptions":["s not in [l[i:i+len(s)] for i in range(len(l)-len(s)+1)]"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is False"}]},{"id":"pc_9","description":"Mixed Types: Sublist found with different hashable types","input_types":{"l":"list[Any]","s":"list[Any]"},"input_constraints":{"l":{"min_len":5,"max_len":20,"is_mixed":true},"s":{"min_len":1,"max_len":5,"is_mixed":true}},"assumptions":["s in [l[i:i+len(s)] for i in range(len(l)-len(s)+1)]"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is True"}]},{"id":"pc_10","description":"Large list, small sublist","input_types":{"l":"list[int]","s":"list[int]"},"input_constraints":{"l":{"min_len":100,"max_len":200},"s":{"min_len":1,"max_len":3}},"assumptions":["s in [l[i:i+len(s)] for i in range(len(l)-len(s)+1)]"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is True"}]},{"id":"pc_11","description":"List with duplicate elements, sublist found","input_types":{"l":"list[int]","s":"list[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":2,"max_len":5}},"assumptions":["l == [1, 2, 1, 2, 3, 4, 1, 2, 3]","s == [1, 2, 3]"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is True"}]},{"id":"pc_12","description":"List with duplicate elements, sublist not found","input_types":{"l":"list[int]","s":"list[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":2,"max_len":5}},"assumptions":["l == [1, 2, 1, 2, 3, 4, 1, 2, 3]","s == [1, 2, 4]"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is False"}]},{"id":"pc_13","description":"Sublist is a single element found in list","input_types":{"l":"list[int]","s":"list[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":1,"max_len":1}},"assumptions":["s[0] in l"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is True"}]},{"id":"pc_14","description":"Sublist is a single element not found in list","input_types":{"l":"list[int]","s":"list[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":1,"max_len":1}},"assumptions":["s[0] not in l"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is False"}]},{"id":"pc_15","description":"List contains None, sublist contains None","input_types":{"l":"list[Optional[int]]","s":"list[Optional[int]]"},"input_constraints":{"l":{"min_len":5,"max_len":20,"allow_none":true},"s":{"min_len":1,"max_len":5,"allow_none":true}},"assumptions":["s in [l[i:i+len(s)] for i in range(len(l)-len(s)+1)]"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is True"}]},{"id":"pc_16","description":"List contains None, sublist does not contain None but matches","input_types":{"l":"list[Optional[int]]","s":"list[int]"},"input_constraints":{"l":{"min_len":5,"max_len":20,"allow_none":true},"s":{"min_len":1,"max_len":5}},"assumptions":["s in [l[i:i+len(s)] for i in range(len(l)-len(s)+1)]"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is True"}]},{"id":"pc_17","description":"List does not contain None, sublist contains None (should not match)","input_types":{"l":"list[int]","s":"list[Optional[int]]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":1,"max_len":5,"allow_none":true}},"assumptions":["None not in l","s != []"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is False"}]},{"id":"pc_18","description":"Test with strings","input_types":{"l":"list[str]","s":"list[str]"},"input_constraints":{"l":{"min_len":5,"max_len":20,"pattern":"^[a-z ]+$"},"s":{"min_len":1,"max_len":5,"pattern":"^[a-z ]+$"}},"assumptions":["s in [l[i:i+len(s)] for i in range(len(l)-len(s)+1)]"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is True"}]},{"id":"pc_19","description":"Test with strings, sublist not found","input_types":{"l":"list[str]","s":"list[str]"},"input_constraints":{"l":{"min_len":5,"max_len":20,"pattern":"^[a-z ]+$"},"s":{"min_len":1,"max_len":5,"pattern":"^[a-z ]+$"}},"assumptions":["s not in [l[i:i+len(s)] for i in range(len(l)-len(s)+1)]"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is False"}]},{"id":"pc_20","description":"Test with tuples","input_types":{"l":"list[tuple[int]]","s":"list[tuple[int]]"},"input_constraints":{"l":{"min_len":5,"max_len":20},"s":{"min_len":1,"max_len":5}},"assumptions":["s in [l[i:i+len(s)] for i in range(len(l)-len(s)+1)]"],"execution_statement":"result = is_sublist(l, s)","postconditions":[{"assertion":"result is True"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc608c"},"test_cases":[{"id":"pc_1","description":"Test with a list of tuples of equal length.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":{"type":"tuple","min_len":2,"max_len":5,"elements":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(len(t) for t in Input)) == 1"]},{"id":"pc_2","description":"Test with a list of tuples of unequal length.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":{"type":"tuple","min_len":1,"max_len":5,"elements":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(set(len(t) for t in Input)) > 1"]},{"id":"pc_3","description":"Test with an empty list.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Test with a list containing a single tuple.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":1,"max_len":1,"elements":{"type":"tuple","min_len":1,"max_len":5,"elements":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_5","description":"Test with tuples of length 0.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":{"type":"tuple","min_len":0,"max_len":0}}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Test with a mix of empty and non-empty tuples.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":3,"max_len":5,"elements":{"type":"tuple","min_len":0,"max_len":5,"elements":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"result == False"}],"assumptions":["any(len(t) == 0 for t in Input) and any(len(t) > 0 for t in Input)"]},{"id":"pc_7","description":"Test with large tuples of equal length.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":3,"elements":{"type":"tuple","min_len":50,"max_len":100,"elements":{"type":"int","min_val":0,"max_val":1000}}}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(len(t) for t in Input)) == 1"]},{"id":"pc_8","description":"Test with large tuples of unequal length.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":3,"elements":{"type":"tuple","min_len":50,"max_len":100,"elements":{"type":"int","min_val":0,"max_val":1000}}}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(set(len(t) for t in Input)) > 1"]},{"id":"pc_9","description":"Test with tuples containing negative numbers.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":{"type":"tuple","min_len":2,"max_len":5,"elements":{"type":"int","min_val":-100,"max_val":100}}}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(len(t) for t in Input)) == 1"]},{"id":"pc_10","description":"Test with tuples containing mixed positive and negative numbers.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":0,"max_len":2,"elements":{"type":"tuple","min_len":0,"max_len":2,"elements":{"type":"int","min_val":-100,"max_val":2}},"is_mixed":true}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(set(len(t) for t in Input)) > 1"]},{"id":"pc_11","description":"Test with a list of tuples where the first tuple has a different length.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":3,"max_len":5,"elements":{"type":"tuple","min_len":1,"max_len":5,"elements":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(Input) >= 2 and len(Input[0]) != len(Input[1])"]},{"id":"pc_12","description":"Test with a list of tuples where a middle tuple has a different length.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":3,"max_len":5,"elements":{"type":"tuple","min_len":1,"max_len":5,"elements":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(Input) >= 3 and len(Input[1]) != len(Input[0])"]},{"id":"pc_13","description":"Test with a list of tuples where the last tuple has a different length.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":3,"max_len":5,"elements":{"type":"tuple","min_len":1,"max_len":5,"elements":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(Input) >= 2 and len(Input[-1]) != len(Input[0])"]},{"id":"pc_14","description":"Test with tuples containing large integers.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":{"type":"tuple","min_len":2,"max_len":5,"elements":{"type":"int","min_val":1000000,"max_val":10000000}}}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(len(t) for t in Input)) == 1"]},{"id":"pc_15","description":"Test with tuples containing zero.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":{"type":"tuple","min_len":2,"max_len":5,"elements":{"type":"int","min_val":0,"max_val":0}}}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(len(t) for t in Input)) == 1"]},{"id":"pc_16","description":"Test with a list of tuples where all elements are the same tuple.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":{"type":"tuple","min_len":2,"max_len":5,"elements":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(Input)) == 1"]},{"id":"pc_17","description":"Test with a list of tuples where elements are different but have same length.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":{"type":"tuple","min_len":2,"max_len":5,"elements":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(len(t) for t in Input)) == 1 and len(set(Input)) > 1"]},{"id":"pc_18","description":"Test with a list of tuples containing only one element.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":{"type":"tuple","min_len":1,"max_len":1,"elements":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(len(t) for t in Input)) == 1"]},{"id":"pc_19","description":"Test with a list of tuples containing only one element, but with different lengths.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":{"type":"tuple","min_len":1,"max_len":5,"elements":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(set(len(t) for t in Input)) > 1"]},{"id":"pc_20","description":"Test with a list of tuples where lengths are 1 and 2.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":{"type":"tuple","min_len":1,"max_len":2,"elements":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(set(len(t) for t in Input)) > 1"]}]}
{"_id":{"$oid":"692adffe1b18223597bc608d"},"test_cases":[{"id":"pc_1","description":"Happy Path: All tuples have equal length.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":10,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(len(t) for t in Input)) == 1"]},{"id":"pc_2","description":"Happy Path: Tuples have unequal lengths.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":10}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(set(len(t) for t in Input)) > 1"]},{"id":"pc_3","description":"Edge Case: Empty input list.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Input list with a single tuple.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Input list contains empty tuples, all equal length.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":0,"max_len":5}},"postconditions":[{"assertion":"result == True"}],"assumptions":["all(len(t) == 0 for t in Input)"]},{"id":"pc_6","description":"Edge Case: Input list contains empty tuples, mixed with non-empty.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":0,"max_len":2,"is_mixed":true}},"postconditions":[{"assertion":"result == False"}],"assumptions":["any(len(t) == 0 for t in Input) and any(len(t) > 0 for t in Input)"]},{"id":"pc_7","description":"Boundary Case: Large number of tuples, all equal length.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":50,"max_len":100}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(len(t) for t in Input)) == 1"]},{"id":"pc_8","description":"Boundary Case: Large number of tuples, unequal lengths.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":0,"max_len":50}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(set(len(t) for t in Input)) > 1"]},{"id":"pc_9","description":"Invariant: Return value is always boolean.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":0,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, bool)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Input is not a list (e.g., int).","execution_statement":"try: result = get_equal(Input) except Exception as e: result = e","input_types":{"Input":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Input is not a list (e.g., None).","execution_statement":"try: result = get_equal(Input) except Exception as e: result = e","input_types":{"Input":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Input list contains non-tuple elements (e.g., int).","execution_statement":"try: result = get_equal(Input) except Exception as e: result = e","input_types":{"Input":"list[int]"},"input_constraints":{"Input":{"min_len":2,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Input list contains non-tuple elements (e.g., None).","execution_statement":"try: result = get_equal(Input) except Exception as e: result = e","input_types":{"Input":"list[None]"},"input_constraints":{"Input":{"min_len":2,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Edge Case: Tuples with varying lengths, first tuple determines k.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":3,"max_len":10}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(Input[0]) != len(Input[1])"]},{"id":"pc_15","description":"Edge Case: All tuples are empty, but input list is large.","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int]]"},"input_constraints":{"Input":{"min_len":0,"max_len":50}},"postconditions":[{"assertion":"result == True"}],"assumptions":["all(len(t) == 0 for t in Input)"]}]}
{"_id":{"$oid":"692adffe1b18223597bc608e"},"test_cases":[{"id":"TC1","description":"Test with a typical unsorted list of integers.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":-1000,"max_val":1000}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC2","description":"Test with an empty list.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"assumptions":[],"postconditions":[{"assertion":"result == []"}]},{"id":"TC3","description":"Test with a list containing a single element.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1,"min_val":-100,"max_val":100}},"assumptions":[],"postconditions":[{"assertion":"result == nums_original"}]},{"id":"TC4","description":"Test with an already sorted list.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":-1000,"max_val":1000}},"assumptions":["nums == sorted(nums)"],"postconditions":[{"assertion":"result == nums_original"}]},{"id":"TC5","description":"Test with a reverse sorted list.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":-1000,"max_val":1000}},"assumptions":["nums == sorted(nums, reverse=True)"],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC6","description":"Test with a list containing duplicate elements.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":10,"max_len":100,"min_val":-50,"max_val":50}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC7","description":"Test with a list containing all identical elements.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":10,"max_val":10}},"assumptions":[],"postconditions":[{"assertion":"result == nums_original"}]},{"id":"TC8","description":"Test with a large list.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":500,"max_len":1000,"min_val":-10000,"max_val":10000}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC9","description":"Test with a list containing negative and positive numbers.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":10,"max_len":100,"min_val":-1000,"max_val":1000}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC10","description":"Test with a list containing zero.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":-100,"max_val":100}},"assumptions":["0 in nums"],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC11","description":"Test with a list of strings (lexicographical sort).","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[str]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_codepoint":97,"max_codepoint":122}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC12","description":"Test with a list of floats.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[float]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":-1000.0,"max_val":1000.0,"allow_nan":false,"allow_infinity":false}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC13","description":"Test with a list containing mixed comparable types (int and float).","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[Union[int, float]]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"is_mixed":true,"allow_nan":false,"allow_infinity":false}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC14","description":"Test with a list where elements are close to each other.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":10,"max_len":50,"min_val":100,"max_val":110}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC15","description":"Test with a list containing large numbers.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":1000000,"max_val":2000000}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC16","description":"Test with a list containing small negative numbers.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":-2000000,"max_val":-1000000}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC17","description":"Test with a list that requires multiple passes of the outer loop.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":20,"max_len":100,"min_val":-1000,"max_val":1000}},"assumptions":["nums != sorted(nums)"],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC18","description":"Test with a list containing only two elements, unsorted.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":2,"min_val":-100,"max_val":100}},"assumptions":["nums[0] != nums[1]"],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"TC19","description":"Test with a list containing only two elements, sorted.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":2,"min_val":-100,"max_val":100}},"assumptions":["nums[0] <= nums[1]"],"postconditions":[{"assertion":"result == nums_original"}]},{"id":"TC20","description":"Test with a list of strings with varying lengths and cases.","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[str]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z-9]{1,10}$"}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc608f"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic sorting of integers","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":100}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"len(nums) == len(result)"},{"assertion":"sorted(nums) == sorted(result)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Single element list","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == nums"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: List with duplicate elements","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":100,"unique":false}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"sorted(nums) == sorted(result)"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Value: Large list","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1000,"max_len":5000}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"len(nums) == len(result)"},{"assertion":"sorted(nums) == sorted(result)"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Value: List with negative numbers","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":100,"max_val":-1}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"sorted(nums) == sorted(result)"}],"assumptions":[]},{"id":"pc_7","description":"Boundary Value: List with mixed positive and negative numbers","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":100,"min_val":-100,"max_val":100,"is_mixed":true}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"sorted(nums) == sorted(result)"}],"assumptions":[]},{"id":"pc_8","description":"Invariant: Length of list is preserved","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":10,"max_len":200}},"postconditions":[{"assertion":"len(nums) == len(result)"}],"assumptions":[]},{"id":"pc_9","description":"Invariant: All original elements are present","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":10,"max_len":200}},"postconditions":[{"assertion":"sorted(nums) == sorted(result)"}],"assumptions":[]},{"id":"pc_10","description":"Happy Path: List with zeros","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":100,"allow_none":false}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"sorted(nums) == sorted(result)"}],"assumptions":["0 in nums"]},{"id":"pc_11","description":"Edge Case: List with identical elements","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":25,"unique":false}},"postconditions":[{"assertion":"result == nums"}],"assumptions":["len(set(nums)) == 1"]},{"id":"pc_12","description":"Boundary Value: List with large integers","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":1000000,"max_val":1000000000}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"sorted(nums) == sorted(result)"}],"assumptions":[]},{"id":"pc_13","description":"Happy Path: Sorting already sorted list","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":100}},"postconditions":[{"assertion":"result == nums"}],"assumptions":["all(nums[i] <= nums[i+1] for i in range(len(nums)-1))"]},{"id":"pc_14","description":"Happy Path: Sorting reverse sorted list","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":100}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"sorted(nums) == sorted(result)"}],"assumptions":["all(nums[i] >= nums[i+1] for i in range(len(nums)-1))"]},{"id":"pc_15","description":"Edge Case: List with one positive and one negative number","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":2}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"sorted(nums) == sorted(result)"}],"assumptions":["(nums[0] > 0 and nums[1] < 0) or (nums[0] < 0 and nums[1] > 0)"]},{"id":"pc_16","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = comb_sort(nums) except Exception as e: result = e","input_types":{"nums":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = comb_sort(nums) except Exception as e: result = e","input_types":{"nums":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_18","description":"Negative Test: List contains non-comparable types (int and str)","execution_statement":"try: result = comb_sort(nums) except Exception as e: result = e","input_types":{"nums":"list[Any]"},"input_constraints":{"nums":{"min_len":2,"max_len":10,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["not all(isinstance(x, int) for x in nums) or not all(isinstance(x, str) for x in nums)"]},{"id":"pc_19","description":"Happy Path: List with floats","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[float]"},"input_constraints":{"nums":{"min_len":5,"max_len":100}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"sorted(nums) == sorted(result)"}],"assumptions":[]},{"id":"pc_20","description":"Happy Path: List with mixed ints and floats","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[Union[int, float]]"},"input_constraints":{"nums":{"min_len":5,"max_len":100,"is_mixed":true}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"sorted(nums) == sorted(result)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6090"},"test_cases":[{"id":"pc_1","description":"Test with a number divisible by 4.","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000,"pattern":"^(?!.*2$)(.*)$"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Test with a number that leaves a remainder of 1 when divided by 4.","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000,"pattern":"^.*[13579]$"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_3","description":"Test with a number that leaves a remainder of 3 when divided by 4.","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":3,"max_val":1000,"pattern":"^.*[13579]$"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Test with a number that leaves a remainder of 2 when divided by 4 (edge case).","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1000,"pattern":"^.*2$"}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"Test with zero.","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Test with a large number divisible by 4.","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":20000,"pattern":"^(?!.*2$)(.*)$"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_7","description":"Test with a large number leaving remainder 1 when divided by 4.","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10001,"max_val":20001,"pattern":"^.*[13579]$"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_8","description":"Test with a large number leaving remainder 3 when divided by 4.","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10003,"max_val":20003,"pattern":"^.*[13579]$"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_9","description":"Test with a large number leaving remainder 2 when divided by 4.","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10002,"max_val":20002,"pattern":"^.*2$"}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"Test with a number that is a perfect square (divisible by 4).","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10000,"strategy":"integers(min_value=0, max_value=100).map(lambda x: x*x)"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_11","description":"Test with a number that is one more than a perfect square (remainder 1).","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10001,"strategy":"integers(min_value=0, max_value=100).map(lambda x: x*x + 1)"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_12","description":"Test with a number that is two more than a perfect square (remainder 2).","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":10002,"strategy":"integers(min_value=0, max_value=100).map(lambda x: x*x + 2)"}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_13","description":"Test with a number that is three more than a perfect square (remainder 3).","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":3,"max_val":10003,"strategy":"integers(min_value=0, max_value=100).map(lambda x: x*x + 3)"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_14","description":"Test with a number that is a difference of two squares (e.g., 16 = 5^-1^2).","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000,"strategy":"integers(min_value=1, max_value=50).flat_map(lambda a: integers(min_value=0, max_value=a-1).map(lambda b: a*a - b*b))"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_15","description":"Test with a number that is NOT a difference of two squares (e.g., 2).","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000,"strategy":"integers(min_value=0, max_value=1000).filter(lambda x: x % 4 == 2)"}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_16","description":"Test with a number that is NOT a difference of two squares (e.g., 6).","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000,"strategy":"integers(min_value=0, max_value=1000).filter(lambda x: x % 4 == 2)"}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_17","description":"Test with a number that is NOT a difference of two squares (e.g., 10).","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000,"strategy":"integers(min_value=0, max_value=1000).filter(lambda x: x % 4 == 2)"}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_18","description":"Test with a number that is NOT a difference of two squares (e.g., 14).","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000,"strategy":"integers(min_value=0, max_value=1000).filter(lambda x: x % 4 == 2)"}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_19","description":"Test with a number that is NOT a difference of two squares (e.g., 18).","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000,"strategy":"integers(min_value=0, max_value=1000).filter(lambda x: x % 4 == 2)"}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_20","description":"Test with a number that is NOT a difference of two squares (e.g., 22).","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000,"strategy":"integers(min_value=0, max_value=1000).filter(lambda x: x % 4 == 2)"}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6091"},"test_cases":[{"id":"pc_1","description":"Happy Path: Numbers not congruent to 2 mod 4","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"result == True"}],"assumptions":["n % 4 != 2"]},{"id":"pc_2","description":"Happy Path: Numbers congruent to 2 mod 4","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"result == False"}],"assumptions":["n % 4 == 2"]},{"id":"pc_3","description":"Edge Case: Input is 0","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Smallest positive number congruent to 2 mod 4 (2)","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Smallest positive number not congruent to 2 mod 4 (1)","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Smallest negative number congruent to 2 mod 4 (-2)","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-2,"max_val":-2}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: Smallest negative number not congruent to 2 mod 4 (-1)","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1,"max_val":-1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_8","description":"Boundary Value: Large positive number not congruent to 2 mod 4","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000,"max_val":1000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["n % 4 != 2"]},{"id":"pc_9","description":"Boundary Value: Large negative number not congruent to 2 mod 4","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1000000,"max_val":-1000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["n % 4 != 2"]},{"id":"pc_10","description":"Invariant: The result should always be a boolean.","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"isinstance(result, bool)"}],"assumptions":[]},{"id":"pc_11","description":"Invariant: The result is True if n is not 2 mod 4, False otherwise.","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"result == (n % 4 != 2)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Non-integer input (float)","execution_statement":"try: result = dif_Square(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Non-integer input (string)","execution_statement":"try: result = dif_Square(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Non-integer input (None)","execution_statement":"try: result = dif_Square(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6092"},"test_cases":[{"id":"pc_1","description":"Happy path: colors and patterns have same length, same unique elements, and each pattern maps to a single color.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":2,"unique":false,"max_codepoint":127},"patterns":{"min_len":0,"max_len":2,"unique":false,"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(colors) == len(patterns)","set(colors) == set(patterns)"]},{"id":"pc_2","description":"Happy path: colors and patterns have same length, same unique elements, and each pattern maps to a single color, with repeated colors.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":3,"max_len":5,"max_codepoint":127},"patterns":{"min_len":3,"max_len":5,"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(colors) == len(patterns)","set(colors) == set(patterns)","colors.count(colors[0]) > 1 if len(colors) > 1 else True"]},{"id":"pc_3","description":"Negative path: colors and patterns have different lengths.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":3,"max_len":5,"max_codepoint":127},"patterns":{"min_len":1,"max_len":2,"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(colors) != len(patterns)"]},{"id":"pc_4","description":"Negative path: colors and patterns have same length, but different unique elements.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":3,"max_len":5,"unique":true,"max_codepoint":127},"patterns":{"min_len":3,"max_len":5,"unique":true,"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(colors) == len(patterns)","set(colors) != set(patterns)"]},{"id":"pc_5","description":"Negative path: colors and patterns have same length and same unique elements, but a pattern maps to multiple colors.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":4,"max_len":6,"max_codepoint":127},"patterns":{"min_len":4,"max_len":6,"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(colors) == len(patterns)","len(set(colors)) == len(set(patterns))","colors[0] != colors[1] or patterns[0] != patterns[1]"]},{"id":"pc_6","description":"Edge case: Empty lists.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":0,"max_codepoint":127},"patterns":{"min_len":0,"max_len":0,"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_7","description":"Edge case: Single element lists, matching.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":1,"max_len":1,"max_codepoint":127},"patterns":{"min_len":1,"max_len":1,"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["colors == patterns"]},{"id":"pc_8","description":"Edge case: Single element lists, not matching.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":1,"max_len":1,"max_codepoint":127},"patterns":{"min_len":1,"max_len":1,"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":["colors != patterns"]},{"id":"pc_9","description":"Boundary case: colors list has one more element than patterns.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":4,"max_len":4,"max_codepoint":127},"patterns":{"min_len":3,"max_len":3,"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(colors) == len(patterns) + 1"]},{"id":"pc_10","description":"Boundary case: patterns list has one more element than colors.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":3,"max_len":3,"max_codepoint":127},"patterns":{"min_len":4,"max_len":4,"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(patterns) == len(colors) + 1"]},{"id":"pc_11","description":"Invariant test: Long lists with matching patterns and colors.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":100,"unique":false,"max_codepoint":127},"patterns":{"min_len":0,"max_len":100,"unique":false,"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(colors) == len(patterns)","set(colors) == set(patterns)"]},{"id":"pc_12","description":"Invariant test: Long lists with different unique elements.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":100,"unique":false,"max_codepoint":127},"patterns":{"min_len":0,"max_len":100,"unique":false,"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(colors) == len(patterns)","set(colors) != set(patterns)"]},{"id":"pc_13","description":"Test with special characters in strings.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":3,"max_len":5,"pattern":"^[\\w\\s!@#$%^&*()_+=-`~]*$"},"patterns":{"min_len":3,"max_len":5,"pattern":"^[\\w\\s!@#$%^&*()_+=-`~]*$"}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(colors) == len(patterns)","set(colors) == set(patterns)"]},{"id":"pc_14","description":"Test with special characters and a pattern mapping to multiple colors.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":4,"max_len":6,"pattern":"^[\\w\\s!@#$%^&*()_+=-`~]*$"},"patterns":{"min_len":4,"max_len":6,"pattern":"^[\\w\\s!@#$%^&*()_+=-`~]*$"}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(colors) == len(patterns)","len(set(colors)) == len(set(patterns))","colors[0] != colors[1] or patterns[0] != patterns[1]"]},{"id":"pc_15","description":"Test with empty strings in lists, matching.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":2,"max_codepoint":127},"patterns":{"min_len":0,"max_len":2,"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(colors) == len(patterns)","set(colors) == set(patterns)","'' in colors"]},{"id":"pc_16","description":"Test with empty strings in lists, not matching.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":2,"max_codepoint":127},"patterns":{"min_len":0,"max_len":2,"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(colors) == len(patterns)","set(colors) != set(patterns)","'' in colors"]},{"id":"pc_17","description":"Test with None values (expecting TypeError due to strict type hints).","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"allow_none":true,"min_len":3,"max_len":5,"max_codepoint":127},"patterns":{"allow_none":true,"min_len":3,"max_len":5,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["len(colors) == len(patterns)","None in colors or None in patterns"]},{"id":"pc_18","description":"Test with mixed types (expecting TypeError).","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"is_mixed":true,"min_len":3,"max_len":5,"max_codepoint":127},"patterns":{"is_mixed":true,"min_len":3,"max_len":5,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["len(colors) == len(patterns)","not all(isinstance(c, str) for c in colors) or not all(isinstance(p, str) for p in patterns)"]},{"id":"pc_19","description":"Test with identical lists where one element is repeated.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":4,"max_len":6,"max_codepoint":127},"patterns":{"min_len":4,"max_len":6,"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(colors) == len(patterns)","colors == patterns","colors.count(colors[0]) > 1 if len(colors) > 1 else True"]},{"id":"pc_20","description":"Test with identical lists where all elements are unique.","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"List[str]","patterns":"List[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":3,"unique":false,"max_codepoint":127},"patterns":{"min_len":0,"max_len":3,"unique":false,"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(colors) == len(patterns)","colors == patterns"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6093"},"test_cases":[{"id":"pc_1","description":"Happy Path: Identical patterns and colors","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":5,"unique":false,"max_codepoint":127},"patterns":{"min_len":0,"max_len":5,"unique":false,"max_codepoint":127}},"postconditions":[{"assertion":"result is True"}],"assumptions":["colors == patterns"]},{"id":"pc_2","description":"Happy Path: Different patterns and colors, but same mapping","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"unique":true,"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"unique":true,"max_codepoint":127}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(set(colors)) == len(set(patterns))","len(colors) == len(patterns)","all(colors.count(c) == patterns.count(p) for c, p in zip(sorted(list(set(colors))), sorted(list(set(patterns)))))"]},{"id":"pc_3","description":"Happy Path: Repeated patterns with consistent colors","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(colors) == len(patterns)","len(set(colors)) == 1","len(set(patterns)) == 1"]},{"id":"pc_4","description":"Edge Case: Empty lists","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":0,"max_codepoint":127},"patterns":{"min_len":0,"max_len":0,"max_codepoint":127}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Mismatched lengths","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":1,"max_len":10,"max_codepoint":127},"patterns":{"min_len":1,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"result is False"}],"assumptions":["len(colors) != len(patterns)"]},{"id":"pc_6","description":"Negative Case: Different number of unique patterns and colors","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"result is False"}],"assumptions":["len(colors) == len(patterns)","len(set(colors)) != len(set(patterns))"]},{"id":"pc_7","description":"Negative Case: Pattern maps to inconsistent colors","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":2,"max_codepoint":127},"patterns":{"min_len":0,"max_len":2,"max_codepoint":127}},"postconditions":[{"assertion":"result is False"}],"assumptions":["len(colors) == len(patterns)","len(set(colors)) == len(set(patterns))","any(colors.count(c) != patterns.count(p) for c, p in zip(sorted(list(set(colors))), sorted(list(set(patterns)))))"]},{"id":"pc_8","description":"Boundary Case: Large lists with same patterns and colors","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":100,"unique":false,"max_codepoint":127},"patterns":{"min_len":0,"max_len":100,"unique":false,"max_codepoint":127}},"postconditions":[{"assertion":"result is True"}],"assumptions":["colors == patterns"]},{"id":"pc_9","description":"Boundary Case: Large lists with different patterns and colors, but same mapping","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":100,"unique":false,"max_codepoint":127},"patterns":{"min_len":0,"max_len":100,"unique":false,"max_codepoint":127}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(colors) == len(patterns)","len(set(colors)) == len(set(patterns))","all(colors.count(c) == patterns.count(p) for c, p in zip(sorted(list(set(colors))), sorted(list(set(patterns)))))"]},{"id":"pc_10","description":"Negative Case: Large lists with mismatched lengths","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":100,"max_codepoint":127},"patterns":{"min_len":0,"max_len":100,"max_codepoint":127}},"postconditions":[{"assertion":"result is False"}],"assumptions":["len(colors) != len(patterns)"]},{"id":"pc_11","description":"Negative Case: Large lists with different number of unique patterns and colors","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":100,"max_codepoint":127},"patterns":{"min_len":0,"max_len":100,"max_codepoint":127}},"postconditions":[{"assertion":"result is False"}],"assumptions":["len(colors) == len(patterns)","len(set(colors)) != len(set(patterns))"]},{"id":"pc_12","description":"Negative Case: Large lists where pattern maps to inconsistent colors","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":2,"max_codepoint":127},"patterns":{"min_len":0,"max_len":2,"max_codepoint":127}},"postconditions":[{"assertion":"result is False"}],"assumptions":["len(colors) == len(patterns)","len(set(colors)) == len(set(patterns))","any(colors.count(c) != patterns.count(p) for c, p in zip(sorted(list(set(colors))), sorted(list(set(patterns)))))"]},{"id":"pc_13","description":"Invariant: Number of unique patterns equals number of unique colors when True","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(colors) == len(patterns)","len(set(colors)) == len(set(patterns))"]},{"id":"pc_14","description":"Invariant: For each pattern, all associated colors are identical","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(colors) == len(patterns)","len(set(colors)) == len(set(patterns))"]},{"id":"pc_15","description":"Test with None values in lists (should ideally not happen based on typical usage, but testing robustness)","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str | None]","patterns":"list[str | None]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"allow_none":true,"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"allow_none":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, bool)"}],"assumptions":["len(colors) == len(patterns)"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6094"},"test_cases":[{"id":"TC1","description":"Typical case: list with tuples, some elements divisible by K.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5}},"K":{"min_val":2,"max_val":10}},"assumptions":[],"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in sub) for sub in result)"},{"assertion":"set(map(tuple, result)).issubset(set(map(tuple, test_list)))"}]},{"id":"TC2","description":"Edge case: K = 1. All elements should be divisible by 1.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5}},"K":{"min_val":1,"max_val":1}},"assumptions":[],"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in sub) for sub in result)"},{"assertion":"set(map(tuple, result)).issubset(set(map(tuple, test_list)))"}]},{"id":"TC3","description":"Edge case: Empty test_list.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":0,"max_len":0},"K":{"min_val":2,"max_val":10}},"assumptions":[],"postconditions":[{"assertion":"result == []"}]},{"id":"TC4","description":"Edge case: All tuples have elements divisible by K.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5}},"K":{"min_val":2,"max_val":10}},"assumptions":["all(all(ele % K == 0 for ele in sub) for sub in test_list)"],"postconditions":[{"assertion":"result == test_list"}]},{"id":"TC5","description":"Edge case: No tuples have all elements divisible by K.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5}},"K":{"min_val":2,"max_val":10}},"assumptions":["not any(all(ele % K == 0 for ele in sub) for sub in test_list)"],"postconditions":[{"assertion":"result == []"}]},{"id":"TC6","description":"Boundary case: Large values for tuple elements and K.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":10000,"max_val":100000,"min_len":1,"max_len":5}},"K":{"min_val":100,"max_val":500}},"assumptions":[],"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in sub) for sub in result)"},{"assertion":"set(map(tuple, result)).issubset(set(map(tuple, test_list)))"}]},{"id":"TC7","description":"Boundary case: Negative values for tuple elements and K.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-10000,"max_val":-100,"min_len":1,"max_len":5}},"K":{"min_val":-500,"max_val":-2}},"assumptions":[],"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in sub) for sub in result)"},{"assertion":"set(map(tuple, result)).issubset(set(map(tuple, test_list)))"}]},{"id":"TC8","description":"Mixed positive and negative values in tuples and K.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5},"is_mixed":true},"K":{"min_val":-10,"max_val":10,"is_mixed":true}},"assumptions":["K != 0"],"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in sub) for sub in result)"},{"assertion":"set(map(tuple, result)).issubset(set(map(tuple, test_list)))"}]},{"id":"TC9","description":"Tuples with zero elements.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5}},"K":{"min_val":2,"max_val":10}},"assumptions":["0 in [ele for sub in test_list for ele in sub]"],"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in sub) for sub in result)"},{"assertion":"set(map(tuple, result)).issubset(set(map(tuple, test_list)))"}]},{"id":"TC10","description":"Tuples with varying lengths.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5}},"K":{"min_val":2,"max_val":10}},"assumptions":[],"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in sub) for sub in result)"},{"assertion":"set(map(tuple, result)).issubset(set(map(tuple, test_list)))"}]},{"id":"TC11","description":"Test with K=0 (expecting TypeError due to division by zero).","execution_statement":"try: result = find_tuples(test_list, K) except Exception as e: result = e","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5}},"K":{"min_val":0,"max_val":0}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, ZeroDivisionError)"}]},{"id":"TC12","description":"Test with non-integer K (expecting TypeError).","execution_statement":"try: result = find_tuples(test_list, K) except Exception as e: result = e","input_types":{"test_list":"List[Tuple[int, ...]]","K":"float"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5}},"K":{"min_val":1.1,"max_val":10.9}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC13","description":"Test with non-integer elements in tuples (expecting TypeError).","execution_statement":"try: result = find_tuples(test_list, K) except Exception as e: result = e","input_types":{"test_list":"List[Tuple[Union[int, float], ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5}},"K":{"min_val":2,"max_val":10}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC14","description":"Test with None as K (expecting TypeError).","execution_statement":"try: result = find_tuples(test_list, K) except Exception as e: result = e","input_types":{"test_list":"List[Tuple[int, ...]]","K":"Optional[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5}},"K":{"allow_none":true}},"assumptions":["K is None"],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC15","description":"Test with None in tuples (expecting TypeError).","execution_statement":"try: result = find_tuples(test_list, K) except Exception as e: result = e","input_types":{"test_list":"List[Tuple[Optional[int], ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5,"allow_none":true}},"K":{"min_val":2,"max_val":10}},"assumptions":["any(None in sub for sub in test_list)"],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC16","description":"Test with very small K values (e.g., K=2).","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5}},"K":{"min_val":2,"max_val":2}},"assumptions":[],"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in sub) for sub in result)"},{"assertion":"set(map(tuple, result)).issubset(set(map(tuple, test_list)))"}]},{"id":"TC17","description":"Test with tuples containing only one element.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":1}},"K":{"min_val":2,"max_val":10}},"assumptions":[],"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in sub) for sub in result)"},{"assertion":"set(map(tuple, result)).issubset(set(map(tuple, test_list)))"}]},{"id":"TC18","description":"Test with large number of tuples.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":100,"max_len":200,"elements":{"min_val":-100,"max_val":100,"min_len":1,"max_len":5}},"K":{"min_val":2,"max_val":10}},"assumptions":[],"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in sub) for sub in result)"},{"assertion":"set(map(tuple, result)).issubset(set(map(tuple, test_list)))"}]},{"id":"TC19","description":"Test with large tuple sizes.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100,"min_len":10,"max_len":20}},"K":{"min_val":2,"max_val":10}},"assumptions":[],"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in sub) for sub in result)"},{"assertion":"set(map(tuple, result)).issubset(set(map(tuple, test_list)))"}]},{"id":"TC20","description":"Test with K being a large prime number.","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"List[Tuple[int, ...]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-1000,"max_val":1000,"min_len":1,"max_len":5}},"K":{"min_val":997,"max_val":997}},"assumptions":[],"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in sub) for sub in result)"},{"assertion":"set(map(tuple, result)).issubset(set(map(tuple, test_list)))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6095"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with positive integers","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"unique_tuples":false},"K":{"min_val":2,"max_val":10}},"postconditions":[{"assertion":"all(all(element % K == 0 for element in sub_tuple) for sub_tuple in result)"},{"assertion":"all(sub_tuple in test_list for sub_tuple in result)"},{"assertion":"result == [sub for sub in test_list if all(ele % K == 0 for ele in sub)]"}]},{"id":"pc_2","description":"Edge Case: Empty input list","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":0,"max_len":0},"K":{"min_val":2,"max_val":10}},"postconditions":[{"assertion":"result == []"}]},{"id":"pc_3","description":"Edge Case: K is 1","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10},"K":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"all(sub_tuple in result for sub_tuple in test_list if sub_tuple and all(isinstance(el, int) for el in sub_tuple))"},{"assertion":"result == [sub for sub in test_list if all(ele % K == 0 for ele in sub)]"}]},{"id":"pc_4","description":"Edge Case: Input list contains empty tuples","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"tuple":{"min_len":0,"max_len":0}}},"K":{"min_val":2,"max_val":10}},"postconditions":[{"assertion":"all(sub_tuple in result for sub_tuple in test_list if not sub_tuple)"}]},{"id":"pc_5","description":"Boundary Case: Large numbers in tuples","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"tuple":{"min_val":1000000,"max_val":1000000000}}},"K":{"min_val":2,"max_val":10}},"postconditions":[{"assertion":"all(all(element % K == 0 for element in sub_tuple) for sub_tuple in result)"},{"assertion":"result == [sub for sub in test_list if all(ele % K == 0 for ele in sub)]"}]},{"id":"pc_6","description":"Boundary Case: Large number of tuples","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":50,"max_len":100,"elements":{"tuple":{"min_val":1,"max_val":100}}},"K":{"min_val":2,"max_val":10}},"postconditions":[{"assertion":"all(all(element % K == 0 for element in sub_tuple) for sub_tuple in result)"},{"assertion":"result == [sub for sub in test_list if all(ele % K == 0 for ele in sub)]"}]},{"id":"pc_7","description":"Invariant: Order of tuples preserved","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":10},"K":{"min_val":2,"max_val":10}},"postconditions":[{"assertion":"result == [sub for sub in test_list if all(ele % K == 0 for ele in sub)]"}]},{"id":"pc_8","description":"Negative Case: K is zero (expecting ZeroDivisionError)","execution_statement":"try: result = find_tuples(test_list, K) except Exception as e: result = e","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"K":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"isinstance(result, ZeroDivisionError)"}]},{"id":"pc_9","description":"Mixed Types: Tuples with mixed hashable types (int, float)","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[Union[int, float]]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"tuple":{"is_mixed":true,"allow_none":false}},"is_mixed":true},"K":{"min_val":2,"max_val":10,"is_mixed":true}},"postconditions":[{"assertion":"all(all(element % K == 0 for element in sub_tuple) for sub_tuple in result)"}]},{"id":"pc_10","description":"Negative Case: Non-iterable for test_list","execution_statement":"try: result = find_tuples(test_list, K) except Exception as e: result = e","input_types":{"test_list":"int","K":"int"},"input_constraints":{"K":{"min_val":2,"max_val":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6096"},"test_cases":[{"id":"pc_1","description":"Test with a typical positive integer divisible by 11.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":11,"max_val":10000,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["n % 11 == 0"]},{"id":"pc_2","description":"Test with a typical positive integer not divisible by 11.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10000,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":["n % 11 != 0"]},{"id":"pc_3","description":"Test with a typical negative integer divisible by 11.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-10000,"max_val":-11,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["n % 11 == 0"]},{"id":"pc_4","description":"Test with a typical negative integer not divisible by 11.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-10000,"max_val":-1,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":["n % 11 != 0"]},{"id":"pc_5","description":"Test with zero.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Test with a large positive integer divisible by 11.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000,"max_val":2000000,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["n % 11 == 0"]},{"id":"pc_7","description":"Test with a large negative integer divisible by 11.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-2000000,"max_val":-1000000,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["n % 11 == 0"]},{"id":"pc_8","description":"Test with a number just above a multiple of 11.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":12,"max_val":21,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":["n % 11 != 0"]},{"id":"pc_9","description":"Test with a number just below a multiple of 11.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":["n % 11 != 0"]},{"id":"pc_10","description":"Test with a number that is a multiple of 11, but not a power of 10.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":110,"max_val":110,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_11","description":"Test with a number that is a multiple of 11, and a power of 10.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1100,"max_val":1100,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_12","description":"Test with a large number that is a multiple of 11.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1111111111,"max_val":1111111111,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_13","description":"Test with a large number that is not a multiple of 11.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1111111112,"max_val":1111111112,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"Test with a number that is a multiple of 11, and has repeating digits.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":121,"max_val":121,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_15","description":"Test with a number that is not a multiple of 11, and has repeating digits.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":123,"max_val":123,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_16","description":"Test with a number that is a multiple of 11, and has alternating digits.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":101010,"max_val":101010,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_17","description":"Test with a number that is not a multiple of 11, and has alternating digits.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":101011,"max_val":101011,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_18","description":"Test with a number that is a multiple of 11, and has a leading zero (as an integer, this is not possible, but testing the concept of '0' in front).","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_19","description":"Test with a number that is a multiple of 11, and has a trailing zero.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":110,"max_val":110,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_20","description":"Test with a number that is not a multiple of 11, and has a trailing zero.","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":120,"max_val":120,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6097"},"test_cases":[{"id":"pc_1","description":"Happy Path: Number divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["n % 11 == 0"]},{"id":"pc_2","description":"Happy Path: Number not divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":["n % 11 != 0"]},{"id":"pc_3","description":"Edge Case: Zero input","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Negative number divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1000000,"max_val":-1,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["n % 11 == 0"]},{"id":"pc_5","description":"Edge Case: Negative number not divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1000000,"max_val":-1,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":["n % 11 != 0"]},{"id":"pc_6","description":"Boundary Value: Large positive number divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000001,"max_val":2000000,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["n % 11 == 0"]},{"id":"pc_7","description":"Boundary Value: Large positive number not divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000001,"max_val":2000000,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":["n % 11 != 0"]},{"id":"pc_8","description":"Boundary Value: Large negative number divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-2000000,"max_val":-1000001,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["n % 11 == 0"]},{"id":"pc_9","description":"Boundary Value: Large negative number not divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-2000000,"max_val":-1000001,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":["n % 11 != 0"]},{"id":"pc_10","description":"Invariant: Modulo result should match boolean output","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1000000,"max_val":1000000,"allow_none":false}},"postconditions":[{"assertion":"(n % 11 == 0) == result"}],"assumptions":[]},{"id":"pc_11","description":"Edge Case: Smallest positive integer divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":11,"max_val":11,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_12","description":"Edge Case: Smallest positive integer not divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_13","description":"Edge Case: Largest negative integer divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-11,"max_val":-11,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_14","description":"Edge Case: Largest negative integer not divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-10,"max_val":-1,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_15","description":"Test with a number that has repeating digits and is divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":1000000,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["str(n) == str(n)[::-1]","n % 11 == 0"]},{"id":"pc_16","description":"Test with a number that has repeating digits and is not divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":1000000,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":["str(n) == str(n)[::-1]","n % 11 != 0"]},{"id":"pc_17","description":"Test with a number that alternates digits and is divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":1000000,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(str(n))) > 1","n % 11 == 0"]},{"id":"pc_18","description":"Test with a number that alternates digits and is not divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":1000000,"allow_none":false}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(set(str(n))) > 1","n % 11 != 0"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6098"},"test_cases":[{"id":"pc_1","description":"Test with a typical odd-length word.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":50,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(s) % 2 != 0"]},{"id":"pc_2","description":"Test with a typical even-length word.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":50,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":["len(s) % 2 == 0"]},{"id":"pc_3","description":"Test with a single odd-length character.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":1,"max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(s) % 2 != 0"]},{"id":"pc_4","description":"Test with a single even-length character.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":1,"max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":["len(s) % 2 == 0"]},{"id":"pc_5","description":"Test with a string containing multiple words, first word odd length.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":5,"max_size":100,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":["s.split(' ')[0].__len__() % 2 != 0"]},{"id":"pc_6","description":"Test with a string containing multiple words, first word even length.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":5,"max_size":100,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":["s.split(' ')[0].__len__() % 2 == 0"]},{"id":"pc_7","description":"Test with a string containing only spaces.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":50,"pattern":"^[ ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_8","description":"Test with a string containing special characters and odd length.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":50,"pattern":"^[^ ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(s) % 2 != 0"]},{"id":"pc_9","description":"Test with a string containing special characters and even length.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":50,"pattern":"^[^ ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":["len(s) % 2 == 0"]},{"id":"pc_10","description":"Test with a very long odd-length string.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1000,"max_size":2000,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(s) % 2 != 0"]},{"id":"pc_11","description":"Test with a very long even-length string.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1000,"max_size":2000,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":["len(s) % 2 == 0"]},{"id":"pc_12","description":"Test with a string containing unicode characters and odd length.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":50,"pattern":"^[\\w\\s]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(s) % 2 != 0"]},{"id":"pc_13","description":"Test with a string containing unicode characters and even length.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":50,"pattern":"^[\\w\\s]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":["len(s) % 2 == 0"]},{"id":"pc_14","description":"Test with a string that splits into multiple words, where the first word has odd length.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":3,"max_size":100,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":["s.split(' ')[0].__len__() % 2 != 0"]},{"id":"pc_15","description":"Test with a string that splits into multiple words, where the first word has even length.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":3,"max_size":100,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":["s.split(' ')[0].__len__() % 2 == 0"]},{"id":"pc_16","description":"Test with an empty string.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":0,"max_size":0,"max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_17","description":"Test with a string containing numbers and odd length.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":50,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(s) % 2 != 0"]},{"id":"pc_18","description":"Test with a string containing numbers and even length.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":50,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":["len(s) % 2 == 0"]},{"id":"pc_19","description":"Test with a string containing mixed alphanumeric and special characters, odd length.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":50,"pattern":"^[a-zA-Z-9 !@#$%^&*()_+=-]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":["len(s) % 2 != 0"]},{"id":"pc_20","description":"Test with a string containing mixed alphanumeric and special characters, even length.","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":50,"pattern":"^[a-zA-Z-9 !@#$%^&*()_+=-]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":["len(s) % 2 == 0"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6099"},"test_cases":[{"id":"pc_1","description":"Happy Path: String with at least one odd length word","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[a-z ]*[a-z]{3}[a-z ]*$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: String with all even length words","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^([a-z]{2}|[a-z]{4}|[a-z]{6}|[a-z]{8}|[a-z]{10}|[a-z]{12}|[a-z]{14}|[a-z]{16}|[a-z]{18}|[a-z]{20}| )*$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Empty string","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: String with only spaces","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^\\s+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: String with leading/trailing spaces and odd word","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^\\s+[a-z]{3}[a-z ]*\\s+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: String with multiple spaces between even length words","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[a-z]{2}(\\s+)[a-z]{4}(\\s+)[a-z]{6}$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: String with multiple spaces between words, one odd","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[a-z]{2}(\\s+)[a-z]{3}(\\s+)[a-z]{6}$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_8","description":"Boundary: Very long string with only even length words","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":100,"max_len":200,"pattern":"^([a-z]{2}\\s)*[a-z]{2}$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_9","description":"Boundary: Very long string with one odd length word","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":100,"max_len":200,"pattern":"^([a-z]{2}\\s)*[a-z]{3}([a-z]{2}\\s)*[a-z]{2}$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Non-string input (integer)","execution_statement":"try: result = word_len(s) except Exception as e: result = e","input_types":{"s":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-string input (None)","execution_statement":"try: result = word_len(s) except Exception as e: result = e","input_types":{"s":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_12","description":"Invariant: Always returns a boolean","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, bool)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc609a"},"test_cases":[{"id":"pc_1","description":"Test with a typical positive integer.","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == (n * (n + 1) * (n + 2)) / 6"}],"assumptions":[]},{"id":"pc_2","description":"Test with the smallest valid input (0).","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Test with a small positive integer (1).","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_4","description":"Test with a larger positive integer.","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":500}},"postconditions":[{"assertion":"result == (n * (n + 1) * (n + 2)) / 6"}],"assumptions":[]},{"id":"pc_5","description":"Test with a boundary value near zero.","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":5}},"postconditions":[{"assertion":"result == (n * (n + 1) * (n + 2)) / 6"}],"assumptions":[]},{"id":"pc_6","description":"Test with a boundary value at the upper end of a typical range.","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":995,"max_val":1005}},"postconditions":[{"assertion":"result == (n * (n + 1) * (n + 2)) / 6"}],"assumptions":[]},{"id":"pc_7","description":"Test with a very large integer to check for potential overflow.","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":100000}},"postconditions":[{"assertion":"result == (n * (n + 1) * (n + 2)) / 6"}],"assumptions":[]},{"id":"pc_8","description":"Test with a negative integer (expecting TypeError or specific handling if designed).","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"int"},"input_constraints":{"n":{"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, Exception)"}],"assumptions":[]},{"id":"pc_9","description":"Test with a float input (expecting TypeError).","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Test with a string input (expecting TypeError).","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Test with None input (expecting TypeError).","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Test with a boolean input (expecting TypeError, as bool is not directly compatible with the formula's arithmetic operations without explicit conversion).","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"bool"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Test with a list input (expecting TypeError).","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"list"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Test with a tuple input (expecting TypeError).","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"tuple"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Test with a dictionary input (expecting TypeError).","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"dict"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"Test with a large number that is a perfect cube (edge case for division).","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":10,"allow_none":false}},"postconditions":[{"assertion":"result == 220"}],"assumptions":["n == 10"]},{"id":"pc_17","description":"Test with a number that results in an integer tetrahedral number.","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"result == 35"}],"assumptions":["n == 5"]},{"id":"pc_18","description":"Test with a number that results in a non-integer intermediate value before division.","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == 4"}],"assumptions":["n == 2"]},{"id":"pc_19","description":"Test with a number that results in a non-integer intermediate value before division (different case).","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"result == 10"}],"assumptions":["n == 3"]},{"id":"pc_20","description":"Test with a large number that is a perfect cube (edge case for division).","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":100}},"postconditions":[{"assertion":"result == 166650"}],"assumptions":["n == 100"]}]}
{"_id":{"$oid":"692adffe1b18223597bc609b"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic positive integer input","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result >= 0 and isinstance(result, int)"},{"assertion":"result == (n * (n + 1) * (n + 2)) / 6"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Input is zero","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Value: Large positive integer input","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":100000}},"postconditions":[{"assertion":"result >= 0 and isinstance(result, int)"}],"assumptions":[]},{"id":"pc_4","description":"Invariant: Result is always an integer","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":5000}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: Divisibility check for n*(n+1)*(n+2)","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":5000}},"postconditions":[{"assertion":"(n * (n + 1) * (n + 2)) % 6 == 0"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: Non-integer input (float)","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Non-integer input (string)","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: null input","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Invariant: Non-decreasing sequence (n > m)","execution_statement":"result_n = tetrahedral_number(n); result_m = tetrahedral_number(m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000},"m":{"min_val":0,"max_val":999}},"postconditions":[{"assertion":"result_n >= result_m"}],"assumptions":["n > m"]},{"id":"pc_10","description":"Happy Path: Small positive integer","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == (n * (n + 1) * (n + 2)) / 6"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc609c"},"test_cases":[{"id":"TC1","description":"Test with a typical positive radius.","execution_statement":"result = volume_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":0.1,"max_val":100.0}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"abs(result - (4/3) * math.pi * r**3) < 1e-9"}]},{"id":"TC2","description":"Test with zero radius (boundary case).","execution_statement":"result = volume_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":0.0,"max_val":0.0}},"postconditions":[{"assertion":"result == 0.0"}]},{"id":"TC3","description":"Test with a very small positive radius.","execution_statement":"result = volume_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":1E-09,"max_val":0.001}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"abs(result - (4/3) * math.pi * r**3) < 1e-9"}]},{"id":"TC4","description":"Test with a large radius.","execution_statement":"result = volume_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":1E+06,"max_val":1E+09}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"abs(result - (4/3) * math.pi * r**3) < 1e-9"}]},{"id":"TC5","description":"Test with a negative radius (expecting TypeError).","execution_statement":"result = volume_sphere(r)","input_types":{"r":"int"},"input_constraints":{"r":{"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC6","description":"Test with a string input (expecting TypeError).","execution_statement":"result = volume_sphere(r)","input_types":{"r":"str"},"input_constraints":{"r":{"pattern":"[a-z]+","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC7","description":"Test with None input (expecting TypeError).","execution_statement":"result = volume_sphere(r)","input_types":{"r":"None"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC8","description":"Test with NaN input (expecting ValueError).","execution_statement":"result = volume_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"allow_nan":true}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}]},{"id":"TC9","description":"Test with infinity input (expecting OverflowError).","execution_statement":"result = volume_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"allow_infinity":true}},"postconditions":[{"assertion":"isinstance(result, OverflowError)"}]},{"id":"TC10","description":"Test with a very large number that might cause overflow.","execution_statement":"result = volume_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":1E+100,"max_val":1E+150}},"postconditions":[{"assertion":"result >= 0 or isinstance(result, OverflowError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc609d"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive radius","execution_statement":"result = volume_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":0.1,"max_val":1000.0}},"postconditions":[{"assertion":"result > 0"},{"assertion":"result == (4/3) * math.pi * r * r * r"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Zero radius","execution_statement":"result = volume_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":0.0,"max_val":0.0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Case: Small positive radius","execution_statement":"result = volume_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":1E-09,"max_val":0.001}},"postconditions":[{"assertion":"result > 0"},{"assertion":"result < 1e-6"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Case: Large radius","execution_statement":"result = volume_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":1E+06,"max_val":1E+09}},"postconditions":[{"assertion":"result > 1e18"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: Volume scales with radius cubed","execution_statement":"result = volume_sphere(r)","input_types":{"r":"float","r_prime":"float"},"input_constraints":{"r":{"min_val":0.1,"max_val":100.0},"r_prime":{"min_val":0.1,"max_val":100.0}},"postconditions":[{"assertion":"volume_sphere(r_prime) / volume_sphere(r) == (r_prime / r)**3"}],"assumptions":["r != 0","r_prime != 0","r != r_prime"]},{"id":"pc_6","description":"Negative Test: Invalid input type (string)","execution_statement":"try: result = volume_sphere(r) except Exception as e: result = e","input_types":{"r":"str"},"input_constraints":{"r":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Invalid input type (None)","execution_statement":"try: result = volume_sphere(r) except Exception as e: result = e","input_types":{"r":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Invalid input type (list)","execution_statement":"try: result = volume_sphere(r) except Exception as e: result = e","input_types":{"r":"list"},"input_constraints":{"r":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Test with integer input","execution_statement":"result = volume_sphere(r)","input_types":{"r":"int"},"input_constraints":{"r":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result > 0"},{"assertion":"result == (4/3) * math.pi * r * r * r"}],"assumptions":[]},{"id":"pc_10","description":"Test with very small positive integer radius","execution_statement":"result = volume_sphere(r)","input_types":{"r":"int"},"input_constraints":{"r":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result > 0"},{"assertion":"result == (4/3) * math.pi"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc609e"},"test_cases":[{"id":"TC1","description":"Typical case: lowercase string","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":10,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, str) and len(result) == 1 and 'a' <= result <= 'z'"}]},{"id":"TC2","description":"Edge case: single character string","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":1,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, str) and len(result) == 1 and 'a' <= result <= 'z'"}]},{"id":"TC3","description":"Edge case: string with sum % 26 == 0","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":5,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) % 26 == 0"],"postconditions":[{"assertion":"result == 'z'"}]},{"id":"TC4","description":"Edge case: string with sum % 26 == 1","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":5,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) % 26 == 1"],"postconditions":[{"assertion":"result == 'a'"}]},{"id":"TC5","description":"Edge case: string with sum % 26 == 25","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":5,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) % 26 == 25"],"postconditions":[{"assertion":"result == 'y'"}]},{"id":"TC6","description":"Typical case: longer string","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":10,"max_size":50,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, str) and len(result) == 1 and 'a' <= result <= 'z'"}]},{"id":"TC7","description":"Edge case: string with all same characters","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":10,"alphabet":"a","max_codepoint":255}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, str) and len(result) == 1 and 'a' <= result <= 'z'"}]},{"id":"TC8","description":"Edge case: string with mixed case characters (should fail if function expects only lowercase)","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":10,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ","is_mixed":true,"max_codepoint":255}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, str) and len(result) == 1 and 'a' <= result <= 'z'"}]},{"id":"TC9","description":"Edge case: string with numbers (should fail if function expects only lowercase)","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":10,"alphabet":"abcdefghijklmnopqrstuvwxyz0123456789","max_codepoint":255}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, str) and len(result) == 1 and 'a' <= result <= 'z'"}]},{"id":"TC10","description":"Edge case: string with special characters (should fail if function expects only lowercase)","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":10,"alphabet":"abcdefghijklmnopqrstuvwxyz!@#$%^&*()","max_codepoint":255}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, str) and len(result) == 1 and 'a' <= result <= 'z'"}]},{"id":"TC11","description":"Negative test: empty string","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":0,"max_size":0,"max_codepoint":255}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, Exception)"}]},{"id":"TC12","description":"Negative test: non-string input (integer)","execution_statement":"result = get_Char(strr)","input_types":{"strr":"int"},"input_constraints":{},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC13","description":"Negative test: non-string input (float)","execution_statement":"result = get_Char(strr)","input_types":{"strr":"float"},"input_constraints":{},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC14","description":"Negative test: non-string input (None)","execution_statement":"result = get_Char(strr)","input_types":{"strr":"None"},"input_constraints":{},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC15","description":"Edge case: string with characters that sum to a large number before modulo","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":10,"max_size":20,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, str) and len(result) == 1 and 'a' <= result <= 'z'"}]},{"id":"TC16","description":"Edge case: string with characters that sum to a number just below a multiple of 26","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":5,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"assumptions":["(sum(ord(c) - ord('a') + 1 for c in strr) + 1) % 26 == 0"],"postconditions":[{"assertion":"isinstance(result, str) and len(result) == 1 and 'a' <= result <= 'z'"}]},{"id":"TC17","description":"Edge case: string with characters that sum to a number just above a multiple of 26","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":5,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"assumptions":["(sum(ord(c) - ord('a') + 1 for c in strr) - 1) % 26 == 0 and sum(ord(c) - ord('a') + 1 for c in strr) > 1"],"postconditions":[{"assertion":"isinstance(result, str) and len(result) == 1 and 'a' <= result <= 'z'"}]},{"id":"TC18","description":"Typical case: string with unicode characters (should fail if function expects ASCII)","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":10,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, str) and len(result) == 1 and 'a' <= result <= 'z'"}]},{"id":"TC19","description":"Edge case: string with characters that sum to exactly 26","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":5,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) == 26"],"postconditions":[{"assertion":"result == 'z'"}]},{"id":"TC20","description":"Edge case: string with characters that sum to exactly 27","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_size":1,"max_size":5,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) == 27"],"postconditions":[{"assertion":"result == 'a'"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc609f"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic lowercase string","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"pattern":"^[a-z]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) == 1"},{"assertion":"result.islower()"},{"assertion":"result.isalpha()"}]},{"id":"pc_2","description":"Edge Case: Empty string","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == 'z'"}]},{"id":"pc_3","description":"Boundary Value: Single character 'a'","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"pattern":"^a$","max_codepoint":255}},"postconditions":[{"assertion":"result == 'a'"}]},{"id":"pc_4","description":"Boundary Value: Single character 'z'","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"pattern":"^z$","max_codepoint":255}},"postconditions":[{"assertion":"result == 'z'"}]},{"id":"pc_5","description":"Invariant: Sum of character values is a multiple of 26","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"pattern":"^[a-z]+$","min_len":2,"max_codepoint":255}},"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) % 26 == 0"],"postconditions":[{"assertion":"result == 'z'"}]},{"id":"pc_6","description":"Typical Case: Sum modulo 26 is not zero","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"pattern":"^[a-z]+$","min_len":1,"max_codepoint":255}},"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) % 26 != 0"],"postconditions":[{"assertion":"result == chr(ord('a') + (sum(ord(c) - ord('a') + 1 for c in strr) % 26) - 1)"}]},{"id":"pc_7","description":"Boundary Value: String with sum exactly 26 ('ay')","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"pattern":"^ay$","max_codepoint":255}},"postconditions":[{"assertion":"result == 'z'"}]},{"id":"pc_8","description":"Typical Case: String with sum resulting in 'f' ('abc')","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"pattern":"^abc$","max_codepoint":255}},"postconditions":[{"assertion":"result == 'f'"}]},{"id":"pc_9","description":"Boundary Value: Long string","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"pattern":"^[a-z]+$","min_len":10,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) == 1"},{"assertion":"result.islower()"},{"assertion":"result.isalpha()"}]},{"id":"pc_10","description":"Negative Test: String with uppercase letters","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"pattern":"^[A-Z]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) == 1"}]},{"id":"pc_11","description":"Negative Test: String with mixed case letters","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"pattern":"^[a-zA-Z]+$","min_len":1,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) == 1"}]},{"id":"pc_12","description":"Negative Test: String with numbers","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"pattern":"^[a-z-9]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) == 1"}]},{"id":"pc_13","description":"Negative Test: String with special characters","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"pattern":"^[a-z!@#$%^&*()_+]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) == 1"}]},{"id":"pc_14","description":"Negative Test: Non-string input (integer)","execution_statement":"try: result = get_Char(strr) except Exception as e: result = e","input_types":{"strr":"int"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_15","description":"Negative Test: Non-string input (None)","execution_statement":"try: result = get_Char(strr) except Exception as e: result = e","input_types":{"strr":"None"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_16","description":"Invariant: Result is always a single character","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) == 1"}]},{"id":"pc_17","description":"Invariant: Result is always a lowercase alphabetic character for valid inputs","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"pattern":"^[a-z]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result.islower()"},{"assertion":"result.isalpha()"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60a0"},"test_cases":[{"id":"TC1","description":"Test with the smallest valid n (n=1).","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}]},{"id":"TC2","description":"Test with n=2.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == 1"}]},{"id":"TC3","description":"Test with a small n (n=3).","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"result == 2"}]},{"id":"TC4","description":"Test with a slightly larger n (n=4).","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":4,"max_val":4}},"postconditions":[{"assertion":"result == 3"}]},{"id":"TC5","description":"Test with a typical n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":5,"max_val":10}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC6","description":"Test with a larger n to check for potential performance issues or deep recursion.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":11,"max_val":20}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC7","description":"Test with a moderate n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":21,"max_val":30}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC8","description":"Test with a larger n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":31,"max_val":50}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC9","description":"Test with a larger n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":51,"max_val":100}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC10","description":"Test with a larger n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":101,"max_val":200}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC11","description":"Test with a larger n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":201,"max_val":300}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC12","description":"Test with a larger n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":301,"max_val":400}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC13","description":"Test with a larger n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":401,"max_val":500}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC14","description":"Test with a larger n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":501,"max_val":600}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC15","description":"Test with a larger n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":601,"max_val":700}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC16","description":"Test with a larger n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":701,"max_val":800}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC17","description":"Test with a larger n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":801,"max_val":900}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC18","description":"Test with a larger n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":901,"max_val":1000}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC19","description":"Test with a larger n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1001,"max_val":1500}},"postconditions":[{"assertion":"result > 0"}]},{"id":"TC20","description":"Test with a larger n value.","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1501,"max_val":2000}},"postconditions":[{"assertion":"result > 0"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60a1"},"test_cases":[{"id":"pc_1","description":"Happy Path: Base case n=1","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_2","description":"Happy Path: Base case n=2","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_3","description":"Happy Path: Small n=3","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"result == 2"}]},{"id":"pc_4","description":"Happy Path: Small n=4","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":4,"max_val":4}},"postconditions":[{"assertion":"result == 2"}]},{"id":"pc_5","description":"Happy Path: Small n=5","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"result == 3"}]},{"id":"pc_6","description":"Invariant: Result is always an integer for n >= 1","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, int)"}]},{"id":"pc_7","description":"Invariant: Result is always positive for n >= 1","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result > 0"}]},{"id":"pc_8","description":"Typical Case: Larger n","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":20}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > 0"}]},{"id":"pc_9","description":"Edge Case: Minimum valid input n=1","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_10","description":"Edge Case: Second minimum valid input n=2","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == 1"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60a2"},"test_cases":[{"id":"pc_1","description":"Test with a typical positive radius.","execution_statement":"result = surfacearea_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":0.1,"max_val":1000.0}},"postconditions":[{"assertion":"result >= 0.0"},{"assertion":"abs(result - (4 * math.pi * radius**2)) < 1e-9"}],"assumptions":[]},{"id":"pc_2","description":"Test with radius zero (boundary case).","execution_statement":"result = surfacearea_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":0.0,"max_val":0.0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_3","description":"Test with a very small positive radius.","execution_statement":"result = surfacearea_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":1E-09,"max_val":0.001}},"postconditions":[{"assertion":"result >= 0.0"},{"assertion":"abs(result - (4 * math.pi * radius**2)) < 1e-9"}],"assumptions":[]},{"id":"pc_4","description":"Test with a very large positive radius.","execution_statement":"result = surfacearea_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":1E+06,"max_val":1E+12}},"postconditions":[{"assertion":"result >= 0.0"},{"assertion":"abs(result - (4 * math.pi * radius**2)) < 1e-9"}],"assumptions":[]},{"id":"pc_5","description":"Test with a radius that is a float with many decimal places.","execution_statement":"result = surfacearea_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":1.23456789,"max_val":1.2345679}},"postconditions":[{"assertion":"result >= 0.0"},{"assertion":"abs(result - (4 * math.pi * radius**2)) < 1e-9"}],"assumptions":[]},{"id":"pc_6","description":"Test with a radius that is an integer.","execution_statement":"result = surfacearea_sphere(radius)","input_types":{"radius":"int"},"input_constraints":{"radius":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result >= 0.0"},{"assertion":"abs(result - (4 * math.pi * radius**2)) < 1e-9"}],"assumptions":[]},{"id":"pc_7","description":"Test with a large integer radius.","execution_statement":"result = surfacearea_sphere(radius)","input_types":{"radius":"int"},"input_constraints":{"radius":{"min_val":10000,"max_val":100000}},"postconditions":[{"assertion":"result >= 0.0"},{"assertion":"abs(result - (4 * math.pi * radius**2)) < 1e-9"}],"assumptions":[]},{"id":"pc_8","description":"Test with a radius that is a float close to zero.","execution_statement":"result = surfacearea_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":1E-15,"max_val":1E-12}},"postconditions":[{"assertion":"result >= 0.0"},{"assertion":"abs(result - (4 * math.pi * radius**2)) < 1e-9"}],"assumptions":[]},{"id":"pc_9","description":"Test with a radius that is a float close to a large number.","execution_statement":"result = surfacearea_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":9.99999999999E+11,"max_val":1E+12}},"postconditions":[{"assertion":"result >= 0.0"},{"assertion":"abs(result - (4 * math.pi * radius**2)) < 1e-9"}],"assumptions":[]},{"id":"pc_10","description":"Test with a radius that is a float with scientific notation.","execution_statement":"result = surfacearea_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":150000.0,"max_val":160000.0}},"postconditions":[{"assertion":"result >= 0.0"},{"assertion":"abs(result - (4 * math.pi * radius**2)) < 1e-9"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60a3"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive radius","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":0.1,"max_val":1000.0}},"postconditions":[{"assertion":"result > 0"},{"assertion":"result == 4 * math.pi * r * r"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Zero radius","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":0.0,"max_val":0.0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Case: Large radius","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":1E+06,"max_val":1E+06}},"postconditions":[{"assertion":"result > 0"},{"assertion":"result == 4 * math.pi * r * r"}],"assumptions":[]},{"id":"pc_4","description":"Invariant: Surface area is non-negative for non-negative radius","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":0.0,"max_val":1000.0}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_5","description":"Negative Test: Invalid Type (string)","execution_statement":"try: result = surfacearea_sphere(r) except Exception as e: result = e","input_types":{"r":"str"},"input_constraints":{"r":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: Invalid Type (None)","execution_statement":"try: result = surfacearea_sphere(r) except Exception as e: result = e","input_types":{"r":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Invalid Type (list)","execution_statement":"try: result = surfacearea_sphere(r) except Exception as e: result = e","input_types":{"r":"list"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Boundary Case: Small positive radius","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":1E-06,"max_val":1E-06}},"postconditions":[{"assertion":"result > 0"},{"assertion":"result == 4 * math.pi * r * r"}],"assumptions":[]},{"id":"pc_9","description":"Invariant: Surface area increases with radius squared","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":0.0,"max_val":1000.0}},"postconditions":[{"assertion":"result == 4 * math.pi * r * r"}],"assumptions":["r >= 0"]}]}
{"_id":{"$oid":"692adffe1b18223597bc60a4"},"test_cases":[{"id":"pc_1","description":"Test with a typical positive integer input.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":100}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]},{"id":"pc_2","description":"Test with the smallest valid positive integer (n=1).","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_3","description":"Test with n=0, the base case.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_4","description":"Test with a larger positive integer.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000,"max_val":1010}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]},{"id":"pc_5","description":"Test with a boundary value close to zero.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":5}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]},{"id":"pc_6","description":"Test with a boundary value close to a larger number.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":95,"max_val":105}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]},{"id":"pc_7","description":"Test invariant: result must be non-negative.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":500}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_8","description":"Test invariant: result must be an integer.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":500}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_9","description":"Test with a very large number to check for potential overflow (if applicable, though Python handles large ints).","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100000,"max_val":100010}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]},{"id":"pc_10","description":"Test with a moderately large number.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":500,"max_val":510}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60a5"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality for non-negative integers.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: n = 0.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: n = 1.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Value: Large positive integer for n.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100000,"max_val":101000}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: Result is always non-negative for non-negative n.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":10000}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_6","description":"Invariant: Result is always greater than or equal to 1 for non-negative n.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":10000}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Invalid input type (string).","execution_statement":"try: result = centered_hexagonal_number(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Invalid input type (float).","execution_statement":"try: result = centered_hexagonal_number(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Invalid input type (None).","execution_statement":"try: result = centered_hexagonal_number(n) except Exception as e: result = e","input_types":{"n":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Test with a moderately large number.","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":500,"max_val":600}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60a6"},"test_cases":[{"id":"pc_1","description":"Typical case: Three non-empty dictionaries with some overlapping keys.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":{}},"dict2":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":{}},"dict3":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":{}}},"postconditions":[{"assertion":"set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"},{"assertion":"all(result[k] == dict3.get(k, dict2.get(k, dict1.get(k))) for k in result)"}],"assumptions":[]},{"id":"pc_2","description":"Edge case: All three dictionaries are empty.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":0,"max_len":0},"dict2":{"min_len":0,"max_len":0},"dict3":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == {}"}],"assumptions":[]},{"id":"pc_3","description":"Edge case: Two empty dictionaries and one non-empty.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":0,"max_len":0},"dict2":{"min_len":0,"max_len":0},"dict3":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10}}},"postconditions":[{"assertion":"result == dict3"}],"assumptions":[]},{"id":"pc_4","description":"Edge case: First and third dictionaries empty, second non-empty.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":0,"max_len":0},"dict2":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10}},"dict3":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == dict2"}],"assumptions":[]},{"id":"pc_5","description":"Edge case: First and second dictionaries empty, third non-empty.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":0,"max_len":0},"dict2":{"min_len":0,"max_len":0},"dict3":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10}}},"postconditions":[{"assertion":"result == dict3"}],"assumptions":[]},{"id":"pc_6","description":"Edge case: All keys unique across dictionaries.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":{"unique":true,"min_len":1,"max_len":5}},"dict2":{"keys":{"unique":true,"min_len":1,"max_len":5}},"dict3":{"keys":{"unique":true,"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"},{"assertion":"all(result[k] == dict1[k] for k in dict1)"},{"assertion":"all(result[k] == dict2[k] for k in dict2)"},{"assertion":"all(result[k] == dict3[k] for k in dict3)"}],"assumptions":["set(dict1.keys()).isdisjoint(dict2.keys())","set(dict1.keys()).isdisjoint(dict3.keys())","set(dict2.keys()).isdisjoint(dict3.keys())"]},{"id":"pc_7","description":"Edge case: All keys are the same across dictionaries.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":5}},"dict2":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":5}},"dict3":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"set(result.keys()) == set(dict1.keys())"},{"assertion":"all(result[k] == dict3[k] for k in dict3)"}],"assumptions":["dict1.keys() == dict2.keys()","dict1.keys() == dict3.keys()"]},{"id":"pc_8","description":"Diverse value types: Integers, strings, booleans, None.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.one_of(st.integers(), st.text(), st.booleans(), st.none())"},"dict2":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.one_of(st.integers(), st.text(), st.booleans(), st.none())"},"dict3":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.one_of(st.integers(), st.text(), st.booleans(), st.none())"}},"postconditions":[{"assertion":"set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"},{"assertion":"all(result[k] == dict3.get(k, dict2.get(k, dict1.get(k))) for k in result)"}],"assumptions":[]},{"id":"pc_9","description":"Diverse key types: Integers, strings, booleans, tuples, None.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"keys":"st.one_of(st.integers(), st.text(max_size=5), st.booleans(), st.tuples(st.integers(), st.text(max_size=5)), st.none())","values":{}},"dict2":{"min_len":1,"max_len":5,"keys":"st.one_of(st.integers(), st.text(max_size=5), st.booleans(), st.tuples(st.integers(), st.text(max_size=5)), st.none())","values":{}},"dict3":{"min_len":1,"max_len":5,"keys":"st.one_of(st.integers(), st.text(max_size=5), st.booleans(), st.tuples(st.integers(), st.text(max_size=5)), st.none())","values":{}}},"postconditions":[{"assertion":"set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"},{"assertion":"all(result[k] == dict3.get(k, dict2.get(k, dict1.get(k))) for k in result)"}],"assumptions":[]},{"id":"pc_10","description":"Large dictionaries with significant overlap.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":50,"max_len":100,"keys":{"min_len":1,"max_len":20}},"dict2":{"min_len":50,"max_len":100,"keys":{"min_len":1,"max_len":20}},"dict3":{"min_len":50,"max_len":100,"keys":{"min_len":1,"max_len":20}}},"postconditions":[{"assertion":"set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"},{"assertion":"all(result[k] == dict3.get(k, dict2.get(k, dict1.get(k))) for k in result)"}],"assumptions":[]},{"id":"pc_11","description":"Test precedence: dict3 overrides dict2, dict2 overrides dict1.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10}},"dict2":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10}},"dict3":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10}}},"postconditions":[{"assertion":"all(result[k] == dict3[k] for k in dict3)"}],"assumptions":["dict1.keys() == dict2.keys()","dict1.keys() == dict3.keys()"]},{"id":"pc_12","description":"Test precedence: dict3 overrides dict2, dict2 has unique keys.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":0,"max_len":2,"keys":{"min_len":0,"max_len":5}},"dict2":{"min_len":0,"max_len":2,"keys":{"min_len":0,"max_len":5}},"dict3":{"min_len":0,"max_len":2,"keys":{"min_len":0,"max_len":5}}},"postconditions":[{"assertion":"all(result[k] == dict3[k] for k in dict3)"},{"assertion":"all(result[k] == dict2[k] for k in dict2 if k not in dict3)"}],"assumptions":["set(dict1.keys()).isdisjoint(dict2.keys())","dict1.keys() == dict3.keys()","dict2.keys() == dict3.keys()"]},{"id":"pc_13","description":"Test precedence: dict2 overrides dict1, dict3 has unique keys.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10}},"dict2":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10}},"dict3":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10}}},"postconditions":[{"assertion":"all(result[k] == dict2[k] for k in dict2)"},{"assertion":"all(result[k] == dict3[k] for k in dict3)"}],"assumptions":["dict1.keys() == dict2.keys()","set(dict1.keys()).isdisjoint(dict3.keys())","set(dict2.keys()).isdisjoint(dict3.keys())"]},{"id":"pc_14","description":"Test with nested dictionaries (should be treated as values).","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":3,"keys":{"min_len":1,"max_len":5},"values":"st.dictionaries(keys={'min_len': 1, 'max_len': 3}, values={})"},"dict2":{"min_len":1,"max_len":3,"keys":{"min_len":1,"max_len":5},"values":"st.dictionaries(keys={'min_len': 1, 'max_len': 3}, values={})"},"dict3":{"min_len":1,"max_len":3,"keys":{"min_len":1,"max_len":5},"values":"st.dictionaries(keys={'min_len': 1, 'max_len': 3}, values={})"}},"postconditions":[{"assertion":"set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"},{"assertion":"all(result[k] == dict3.get(k, dict2.get(k, dict1.get(k))) for k in result)"}],"assumptions":[]},{"id":"pc_15","description":"Test with tuples as values.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.tuples(st.integers(), st.text())"},"dict2":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.tuples(st.integers(), st.text())"},"dict3":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.tuples(st.integers(), st.text())"}},"postconditions":[{"assertion":"set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"},{"assertion":"all(result[k] == dict3.get(k, dict2.get(k, dict1.get(k))) for k in result)"}],"assumptions":[]},{"id":"pc_16","description":"Test with float values.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.floats(allow_nan=False, allow_infinity=False)"},"dict2":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.floats(allow_nan=False, allow_infinity=False)"},"dict3":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.floats(allow_nan=False, allow_infinity=False)"}},"postconditions":[{"assertion":"set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"},{"assertion":"all(result[k] == dict3.get(k, dict2.get(k, dict1.get(k))) for k in result)"}],"assumptions":[]},{"id":"pc_17","description":"Test with mixed key types and overlapping keys.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"keys":"st.one_of(st.integers(), st.text(max_size=5))","values":{},"is_mixed":true},"dict2":{"min_len":1,"max_len":5,"keys":"st.one_of(st.integers(), st.text(max_size=5))","values":{},"is_mixed":true},"dict3":{"min_len":1,"max_len":5,"keys":"st.one_of(st.integers(), st.text(max_size=5))","values":{},"is_mixed":true}},"postconditions":[{"assertion":"set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"},{"assertion":"all(result[k] == dict3.get(k, dict2.get(k, dict1.get(k))) for k in result)"}],"assumptions":[]},{"id":"pc_18","description":"Test with mixed value types and overlapping keys.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.one_of(st.integers(), st.text(), st.booleans())","is_mixed":true},"dict2":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.one_of(st.integers(), st.text(), st.booleans())","is_mixed":true},"dict3":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.one_of(st.integers(), st.text(), st.booleans())","is_mixed":true}},"postconditions":[{"assertion":"set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"},{"assertion":"all(result[k] == dict3.get(k, dict2.get(k, dict1.get(k))) for k in result)"}],"assumptions":[]},{"id":"pc_19","description":"Test with None values and overlapping keys.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.one_of(st.integers(), st.none())","allow_none":true},"dict2":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.one_of(st.integers(), st.none())","allow_none":true},"dict3":{"min_len":1,"max_len":5,"keys":{"min_len":1,"max_len":10},"values":"st.one_of(st.integers(), st.none())","allow_none":true}},"postconditions":[{"assertion":"set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"},{"assertion":"all(result[k] == dict3.get(k, dict2.get(k, dict1.get(k))) for k in result)"}],"assumptions":[]},{"id":"pc_20","description":"Test with None keys and overlapping keys.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"keys":"st.one_of(st.integers(), st.none())","allow_none":true},"dict2":{"min_len":1,"max_len":5,"keys":"st.one_of(st.integers(), st.none())","allow_none":true},"dict3":{"min_len":1,"max_len":5,"keys":"st.one_of(st.integers(), st.none())","allow_none":true}},"postconditions":[{"assertion":"set(result.keys()) == set(dict1.keys()) | set(dict2.keys()) | set(dict3.keys())"},{"assertion":"all(result[k] == dict3.get(k, dict2.get(k, dict1.get(k))) for k in result)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60a7"},"test_cases":[{"id":"pc_1","description":"Happy Path: Merging three non-empty dictionaries with unique keys.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":10,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict2":{"min_len":1,"max_len":10,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict3":{"min_len":1,"max_len":10,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}}},"postconditions":[{"assertion":"len(result) == len(dict1) + len(dict2) + len(dict3)"},{"assertion":"all(k in result for k in dict1)"},{"assertion":"all(k in result for k in dict2)"},{"assertion":"all(k in result for k in dict3)"},{"assertion":"result == {**dict1, **dict2, **dict3}"}],"assumptions":["not any(k in dict2 for k in dict1)","not any(k in dict3 for k in dict1)","not any(k in dict3 for k in dict2)"]},{"id":"pc_2","description":"Edge Case: Merging with empty dictionaries.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"max_len":0},"dict2":{"max_len":0},"dict3":{"max_len":0}},"postconditions":[{"assertion":"result == {}"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Merging with one empty dictionary.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict2":{"max_len":0},"dict3":{"max_len":0}},"postconditions":[{"assertion":"result == dict1"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Merging with two empty dictionaries.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict2":{"max_len":0},"dict3":{"max_len":0}},"postconditions":[{"assertion":"result == dict1"}],"assumptions":[]},{"id":"pc_5","description":"Key Overlap: dict1 and dict2 overlap, dict3 is unique.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict2":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict3":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"},{"assertion":"all(k in result for k in dict1)"},{"assertion":"all(k in result for k in dict2)"},{"assertion":"all(k in result for k in dict3)"}],"assumptions":["any(k in dict2 for k in dict1)","not any(k in dict3 for k in dict1)","not any(k in dict3 for k in dict2)"]},{"id":"pc_6","description":"Key Overlap: dict1 and dict3 overlap, dict2 is unique.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict2":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict3":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"},{"assertion":"all(k in result for k in dict1)"},{"assertion":"all(k in result for k in dict2)"},{"assertion":"all(k in result for k in dict3)"}],"assumptions":["any(k in dict3 for k in dict1)","not any(k in dict2 for k in dict1)","not any(k in dict2 for k in dict3)"]},{"id":"pc_7","description":"Key Overlap: dict2 and dict3 overlap, dict1 is unique.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict2":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict3":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"},{"assertion":"all(k in result for k in dict1)"},{"assertion":"all(k in result for k in dict2)"},{"assertion":"all(k in result for k in dict3)"}],"assumptions":["any(k in dict3 for k in dict2)","not any(k in dict1 for k in dict2)","not any(k in dict1 for k in dict3)"]},{"id":"pc_8","description":"Key Overlap: All three dictionaries overlap on some keys.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict2":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict3":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"},{"assertion":"all(k in result for k in dict1)"},{"assertion":"all(k in result for k in dict2)"},{"assertion":"all(k in result for k in dict3)"}],"assumptions":["any(k in dict2 for k in dict1)","any(k in dict3 for k in dict1)","any(k in dict3 for k in dict2)"]},{"id":"pc_9","description":"Value precedence: Overlapping keys should take value from dict3.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict2":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict3":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}}},"postconditions":[{"assertion":"all(result[k] == dict3[k] for k in dict3 if k in dict1 or k in dict2)"}],"assumptions":["any(k in dict2 for k in dict1)","any(k in dict3 for k in dict1)","any(k in dict3 for k in dict2)"]},{"id":"pc_10","description":"Value precedence: Overlapping keys between dict1 and dict2, dict3 has unique keys.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict2":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict3":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}}},"postconditions":[{"assertion":"all(result[k] == dict2[k] for k in dict2 if k in dict1)"}],"assumptions":["any(k in dict2 for k in dict1)","not any(k in dict3 for k in dict1)","not any(k in dict3 for k in dict2)"]},{"id":"pc_11","description":"Large dictionaries with overlaps.","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":50,"max_len":100,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict2":{"min_len":50,"max_len":100,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict3":{"min_len":50,"max_len":100,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"},{"assertion":"len(result) <= len(dict1) + len(dict2) + len(dict3)"}],"assumptions":["any(k in dict2 for k in dict1)","any(k in dict3 for k in dict1)","any(k in dict3 for k in dict2)"]},{"id":"pc_12","description":"Dictionaries with mixed value types (integers and strings).","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"is_mixed":true},"is_mixed":true},"dict2":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"is_mixed":true},"is_mixed":true},"dict3":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"is_mixed":true},"is_mixed":true}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"},{"assertion":"all(k in result for k in dict1)"},{"assertion":"all(k in result for k in dict2)"},{"assertion":"all(k in result for k in dict3)"}],"assumptions":["not any(k in dict2 for k in dict1)","not any(k in dict3 for k in dict1)","not any(k in dict3 for k in dict2)"]},{"id":"pc_13","description":"Negative Test: Passing None as a dictionary.","execution_statement":"try: result = merge_dictionaries_three(dict1, dict2, dict3) except Exception as e: result = e","input_types":{"dict1":"None","dict2":"dict","dict3":"dict"},"input_constraints":{"dict2":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict3":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Passing an integer as a dictionary.","execution_statement":"try: result = merge_dictionaries_three(dict1, dict2, dict3) except Exception as e: result = e","input_types":{"dict1":"int","dict2":"dict","dict3":"dict"},"input_constraints":{"dict2":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict3":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: Passing a list as a dictionary.","execution_statement":"try: result = merge_dictionaries_three(dict1, dict2, dict3) except Exception as e: result = e","input_types":{"dict1":"list","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_len":1,"max_len":5},"dict2":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}},"dict3":{"min_len":1,"max_len":5,"key_constraints":{"pattern":"^[a-z]{1,5}$"},"value_constraints":{"integers":true}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60a8"},"test_cases":[{"id":"pc_1","description":"Test with a typical list of integers.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[int]"},"input_constraints":{"list1":{"min_val":-100,"max_val":100,"min_len":1,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(isinstance(k, int) for k in result.keys())"},{"assertion":"all(isinstance(v, int) and v >= 0 for v in result.values())"}],"assumptions":[]},{"id":"pc_2","description":"Test with an empty list.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[int]"},"input_constraints":{"list1":{"max_len":0}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"len(result) == 0"}],"assumptions":[]},{"id":"pc_3","description":"Test with a list containing all the same elements.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":2,"unique":false}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"len(result) == 1"},{"assertion":"list(result.values())[0] == len(list1)"}],"assumptions":["len(set(list1)) == 1"]},{"id":"pc_4","description":"Test with a list containing all unique elements.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":5,"unique":true}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"len(result) == len(list1)"},{"assertion":"all(v == 1 for v in result.values())"}],"assumptions":[]},{"id":"pc_5","description":"Test with a list of strings.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[str]"},"input_constraints":{"list1":{"min_len":1,"max_len":50,"min_size":1,"max_size":10,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(isinstance(k, str) for k in result.keys())"},{"assertion":"all(isinstance(v, int) and v >= 0 for v in result.values())"}],"assumptions":[]},{"id":"pc_6","description":"Test with a list of mixed hashable types.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[Union[int, str, bool, None, tuple]]"},"input_constraints":{"list1":{"min_len":1,"max_len":50,"allow_none":true,"is_hashable_mix":true,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(isinstance(v, int) and v >= 0 for v in result.values())"}],"assumptions":[]},{"id":"pc_7","description":"Test with a large list of integers.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[int]"},"input_constraints":{"list1":{"min_val":-1000,"max_val":1000,"min_len":1000,"max_len":1000}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"}],"assumptions":[]},{"id":"pc_8","description":"Test with a list containing None values.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[Optional[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":50,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"None in result"}],"assumptions":[]},{"id":"pc_9","description":"Test with a list of tuples.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[tuple]"},"input_constraints":{"list1":{"min_len":1,"max_len":20,"elements":{"min_len":1,"max_len":3,"elements":{"type":"int","min_val":0,"max_val":10}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(isinstance(k, tuple) for k in result.keys())"}],"assumptions":[]},{"id":"pc_10","description":"Test with a list containing boolean values.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[bool]"},"input_constraints":{"list1":{"min_len":1,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(isinstance(k, bool) for k in result.keys())"}],"assumptions":[]},{"id":"pc_11","description":"Test with a list of short strings.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[str]"},"input_constraints":{"list1":{"min_len":1,"max_len":50,"min_size":1,"max_size":3,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"}],"assumptions":[]},{"id":"pc_12","description":"Test with a list of long strings.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[str]"},"input_constraints":{"list1":{"min_len":1,"max_len":20,"min_size":50,"max_size":100,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"}],"assumptions":[]},{"id":"pc_13","description":"Test with a list containing negative integers.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[int]"},"input_constraints":{"list1":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(k < 0 for k in result.keys())"}],"assumptions":[]},{"id":"pc_14","description":"Test with a list containing positive integers.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[int]"},"input_constraints":{"list1":{"min_val":1,"max_val":100,"min_len":1,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(k > 0 for k in result.keys())"}],"assumptions":[]},{"id":"pc_15","description":"Test with a list containing zero.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[int]"},"input_constraints":{"list1":{"min_val":0,"max_val":0,"min_len":1,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"len(result) == 1"},{"assertion":"0 in result"},{"assertion":"result[0] == len(list1)"}],"assumptions":[]},{"id":"pc_16","description":"Test with a list of strings and integers.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[Union[int, str]]"},"input_constraints":{"list1":{"min_len":1,"max_len":50,"is_hashable_mix":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"}],"assumptions":[]},{"id":"pc_17","description":"Test with a list of strings with specific patterns.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[str]"},"input_constraints":{"list1":{"min_len":1,"max_len":50,"pattern":"^[a-z]{3}$"}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(len(k) == 3 and k.islower() for k in result.keys())"}],"assumptions":[]},{"id":"pc_18","description":"Test with a list of integers and None.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[Optional[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":50,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(isinstance(v, int) and v >= 0 for v in result.values())"}],"assumptions":[]},{"id":"pc_19","description":"Test with a list of tuples containing mixed types.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[tuple]"},"input_constraints":{"list1":{"min_len":1,"max_len":20,"elements":{"min_len":1,"max_len":3,"is_mixed":true,"allow_none":true},"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(isinstance(v, int) and v >= 0 for v in result.values())"}],"assumptions":[]},{"id":"pc_20","description":"Test with a list of very large integers.","execution_statement":"result = freq_count(list1)","input_types":{"list1":"List[int]"},"input_constraints":{"list1":{"min_val":1000000,"max_val":10000000,"min_len":1,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60a9"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic frequency counting","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[int]"},"input_constraints":{"list1":{"min_len":1,"max_len":100}},"postconditions":[{"assertion":"isinstance(result, collections.Counter)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(item in list1 for item in result)"},{"assertion":"all(result[item] == list1.count(item) for item in result)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, collections.Counter)"},{"assertion":"len(result) == 0"},{"assertion":"sum(result.values()) == 0"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: List with duplicate elements","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":5,"max_len":50,"unique":false,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, collections.Counter)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(result[item] == list1.count(item) for item in result)"}],"assumptions":[]},{"id":"pc_4","description":"Happy Path: List with mixed data types (hashable)","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[Any]"},"input_constraints":{"list1":{"min_len":5,"max_len":50,"hashable_mix":true,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, collections.Counter)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(result[item] == list1.count(item) for item in result)"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: List with None values","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[Optional[int]]"},"input_constraints":{"list1":{"min_len":5,"max_len":50,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, collections.Counter)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(result[item] == list1.count(item) for item in result)"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Case: Large list","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[int]"},"input_constraints":{"list1":{"min_len":1000,"max_len":5000}},"postconditions":[{"assertion":"isinstance(result, collections.Counter)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(result[item] == list1.count(item) for item in result)"}],"assumptions":[]},{"id":"pc_7","description":"Happy Path: List with boolean values","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[bool]"},"input_constraints":{"list1":{"min_len":5,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, collections.Counter)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(result[item] == list1.count(item) for item in result)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Non-iterable input (int)","execution_statement":"try: result = freq_count(list1) except Exception as e: result = e","input_types":{"list1":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Non-iterable input (float)","execution_statement":"try: result = freq_count(list1) except Exception as e: result = e","input_types":{"list1":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Non-iterable input (None)","execution_statement":"try: result = freq_count(list1) except Exception as e: result = e","input_types":{"list1":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Happy Path: List with only one distinct element","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":25,"unique":false}},"postconditions":[{"assertion":"isinstance(result, collections.Counter)"},{"assertion":"len(result) == 1"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(result[item] == list1.count(item) for item in result)"}],"assumptions":["len(set(list1)) == 1"]},{"id":"pc_12","description":"Happy Path: List with all unique elements","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":5,"max_len":50,"unique":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, collections.Counter)"},{"assertion":"len(result) == len(list1)"},{"assertion":"sum(result.values()) == len(list1)"},{"assertion":"all(result[item] == 1 for item in result)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60aa"},"test_cases":[{"id":"pc_1","description":"Test with a typical positive integer.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":10,"max_val":1000000}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_2","description":"Test with the smallest positive integer.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_3","description":"Test with a larger positive integer.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":1000000,"max_val":1000000000}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_4","description":"Test with a number close to the maximum integer limit (if applicable).","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":2147483647,"max_val":2147483647}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_5","description":"Test with a number that results in zero.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_6","description":"Test with a number that results in a negative number.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":-1000000,"max_val":-1}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_7","description":"Test with zero.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_8","description":"Test with a negative number close to zero.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":-1,"max_val":-1}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_9","description":"Test with a large negative number.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":-1000000000,"max_val":-1000000}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_10","description":"Test with a number that is a power of 2.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":1024,"max_val":1024}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_11","description":"Test with a number that is a power of 10.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":100000,"max_val":100000}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_12","description":"Test with a number that has repeating digits.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":555,"max_val":555}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_13","description":"Test with a number that is a palindrome.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":121,"max_val":121}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_14","description":"Test with a number that contains zero.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":101,"max_val":101}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_15","description":"Test with a number that is a single digit.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_16","description":"Test with a number that is two digits and decreasing.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":21,"max_val":21}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_17","description":"Test with a number that is two digits and increasing.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":12,"max_val":12}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_18","description":"Test with a number that is a large prime.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":7919,"max_val":7919}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_19","description":"Test with a number that is a large composite.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":10000,"max_val":10000}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_20","description":"Test with a number that is close to a power of 10 minus 1.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":99999,"max_val":99999}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60ab"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with positive integers.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Basic functionality with negative integers.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Input is zero.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"value":0}},"postconditions":[{"assertion":"result == -1"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Value: Maximum integer value.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"value":2147483647}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Value: Minimum integer value.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"value":-2147483648}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_6","description":"Invariant: The result is always strictly less than the input.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":-10000,"max_val":10000}},"postconditions":[{"assertion":"result < N"}],"assumptions":[]},{"id":"pc_7","description":"Large positive integer input.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":1000000,"max_val":2000000}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_8","description":"Large negative integer input.","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":-2000000,"max_val":-1000000}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_9","description":"Input near zero (positive).","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_10","description":"Input near zero (negative).","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":-5,"max_val":-1}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60ac"},"test_cases":[{"id":"test_case_1","description":"Typical case: list of strings with varying lengths.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":20,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":[],"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"test_case_2","description":"Edge case: list with a single string.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":1,"max_len":1,"elements":{"min_len":1,"max_len":10,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":[],"postconditions":[{"assertion":"result == len(list1[0])"}]},{"id":"test_case_3","description":"Edge case: list with empty strings.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":0,"max_len":0}}},"assumptions":[],"postconditions":[{"assertion":"result == 0"}]},{"id":"test_case_4","description":"Boundary case: list with very long strings.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":5,"elements":{"min_len":500,"max_len":500,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":[],"postconditions":[{"assertion":"result == 500"}]},{"id":"test_case_5","description":"Typical case: strings with numbers and mixed casing.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":5,"max_len":15,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"},"is_mixed":true}},"assumptions":[],"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"test_case_6","description":"Edge case: list where all strings have the same length.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":3,"max_len":8,"elements":{"min_len":5,"max_len":5,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":[],"postconditions":[{"assertion":"result == 5"}]},{"id":"test_case_7","description":"Invariant: The result should never be negative.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":0,"max_len":20,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":[],"postconditions":[{"assertion":"result >= 0"}]},{"id":"test_case_8","description":"Invariant: The result should be less than or equal to the length of the longest string in the list.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":30,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":[],"postconditions":[{"assertion":"result <= max(len(s) for s in list1)"}]},{"id":"test_case_9","description":"Typical case: list with a mix of short and long strings.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":5,"max_len":15,"elements":{"min_len":1,"max_len":50,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":[],"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"test_case_10","description":"Edge case: list containing a string with special characters (if allowed by alphabet).","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":5,"max_len":15,"alphabet":"abcdefghijklmnopqrstuvwxyz!@#$%^&*()"}}},"assumptions":[],"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"test_case_11","description":"Boundary case: list with minimum allowed lengths for list and elements.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":1,"max_len":1,"elements":{"min_len":1,"max_len":1,"alphabet":"a"}}},"assumptions":[],"postconditions":[{"assertion":"result == 1"}]},{"id":"test_case_12","description":"Typical case: list with strings of moderate length.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":5,"max_len":15,"elements":{"min_len":10,"max_len":20,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":[],"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"test_case_13","description":"Edge case: list with one very short string and one very long string.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":2,"elements":[{"min_len":1,"max_len":1,"alphabet":"a"},{"min_len":50,"max_len":50,"alphabet":"b"}]}},"assumptions":[],"postconditions":[{"assertion":"result == 50"}]},{"id":"test_case_14","description":"Invariant: The result should be equal to the length of the first string if it's the longest.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":5,"max_len":15,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":["len(list1[0]) >= max(len(s) for s in list1[1:])"],"postconditions":[{"assertion":"result == len(list1[0])"}]},{"id":"test_case_15","description":"Invariant: The result should be equal to the length of the last string if it's the longest.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":5,"max_len":15,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":["len(list1[-1]) >= max(len(s) for s in list1[:-1])"],"postconditions":[{"assertion":"result == len(list1[-1])"}]},{"id":"test_case_16","description":"Typical case: list with strings containing spaces (should be treated as part of the string length).","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":5,"max_len":15,"alphabet":"abcdefghijklmnopqrstuvwxyz "}}},"assumptions":[],"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"test_case_17","description":"Boundary case: list with maximum allowed lengths for list and elements.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":10,"max_len":10,"elements":{"min_len":20,"max_len":20,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":[],"postconditions":[{"assertion":"result == 20"}]},{"id":"test_case_18","description":"Typical case: list with many strings, some short, some long.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":20,"max_len":30,"elements":{"min_len":1,"max_len":40,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":[],"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"test_case_19","description":"Edge case: list with only one character strings.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":5,"max_len":15,"elements":{"min_len":1,"max_len":1,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":[],"postconditions":[{"assertion":"result == 1"}]},{"id":"test_case_20","description":"Invariant: The result should be equal to the length of the first string if all strings have the same length.","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":5,"max_len":5,"alphabet":"abcdefghijklmnopqrstuvwxyz"}}},"assumptions":[],"postconditions":[{"assertion":"result == len(list1[0])"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60ad"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list of strings","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result == max(len(s) for s in list1)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: List with empty strings","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"pattern":"^$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with one empty string and one non-empty string","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":2,"elements":{"pattern":"^$|^[a-z]{1,5}$"},"max_codepoint":127}},"postconditions":[{"assertion":"result > 0"},{"assertion":"result == max(len(s) for s in list1)"}],"assumptions":["'' in list1","any(len(s) > 0 for s in list1)"]},{"id":"pc_4","description":"Edge Case: List with a single string","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":1,"max_len":1,"max_codepoint":127}},"postconditions":[{"assertion":"result == len(list1[0])"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: List with all strings of the same length","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":3,"max_len":10,"elements":{"min_len":5,"max_len":5,"max_codepoint":127},"max_codepoint":127}},"postconditions":[{"assertion":"result == 5"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Value: List with very long strings","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":5,"elements":{"min_len":100,"max_len":200,"max_codepoint":127},"max_codepoint":127}},"postconditions":[{"assertion":"result >= 100"},{"assertion":"result == max(len(s) for s in list1)"}],"assumptions":[]},{"id":"pc_7","description":"Boundary Value: List with strings of length 0 and 1","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":5,"elements":{"min_len":0,"max_len":1,"max_codepoint":127},"max_codepoint":127}},"postconditions":[{"assertion":"result == 1"}],"assumptions":["any(len(s) == 1 for s in list1)"]},{"id":"pc_8","description":"Invariant: Returned length is always non-negative","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_9","description":"Invariant: Returned length is less than or equal to the longest string's length","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"result <= max(len(s) for s in list1)"}],"assumptions":[]},{"id":"pc_10","description":"Invariant: Returned length is greater than or equal to the first string's length","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"result >= len(list1[0])"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Empty list (IndexError)","execution_statement":"try: result = len_log(list1) except Exception as e: result = e","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":0,"max_len":0,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, IndexError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Input is not a list (TypeError)","execution_statement":"try: result = len_log(list1) except Exception as e: result = e","input_types":{"list1":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: List contains non-string elements (TypeError)","execution_statement":"try: result = len_log(list1) except Exception as e: result = e","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"is_mixed":true}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["not all(isinstance(x, str) for x in list1)"]}]}
{"_id":{"$oid":"692adffe1b18223597bc60ae"},"test_cases":[{"id":"pc_1","description":"Typical case: substring present in one of the strings.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Typical case: substring not present in any string.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not any(sub_str in s for s in str1)"]},{"id":"pc_3","description":"Edge case: Empty substring.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Edge case: Empty list of strings.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":0,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"Edge case: Empty list and empty substring.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":0,"max_codepoint":127},"sub_str":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_6","description":"Boundary case: Substring is identical to one of the strings.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["sub_str in str1"]},{"id":"pc_7","description":"Boundary case: Long strings and long substring.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":5,"max_codepoint":127},"sub_str":{"min_len":100,"max_len":200,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_8","description":"Typical case: Substring at the beginning of a string.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["any(s.startswith(sub_str) for s in str1)"]},{"id":"pc_9","description":"Typical case: Substring at the end of a string.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["any(s.endswith(sub_str) for s in str1)"]},{"id":"pc_10","description":"Edge case: List contains empty strings.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":5,"max_codepoint":127},"sub_str":{"min_len":0,"max_len":2,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["'' in str1"]},{"id":"pc_11","description":"Edge case: List contains only empty strings.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":5,"max_codepoint":127},"sub_str":{"min_len":0,"max_len":2,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["all(s == '' for s in str1)"]},{"id":"pc_12","description":"Typical case: Substring is a part of a larger string.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["any(sub_str in s for s in str1) and any(len(s) > len(sub_str) for s in str1)"]},{"id":"pc_13","description":"Boundary case: Very short strings, substring is longer.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":3,"max_codepoint":127},"sub_str":{"min_len":5,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"Typical case: Multiple occurrences of substring in different strings.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":2,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["sum(1 for s in str1 if sub_str in s) > 1"]},{"id":"pc_15","description":"Edge case: Strings with special characters.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"pattern":"[!@#$%^&*()_+=-`~{}\\[\\]|;:'\",.<>/?]","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_16","description":"Edge case: Substring with special characters, not found.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"pattern":"[!@#$%^&*()_+=-`~{}\\[\\]|;:'\",.<>/?]","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not any(sub_str in s for s in str1)"]},{"id":"pc_17","description":"Boundary case: Single string in list, substring present.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":1,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["sub_str in str1[0]"]},{"id":"pc_18","description":"Boundary case: Single string in list, substring not present.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":1,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["sub_str not in str1[0]"]},{"id":"pc_19","description":"Typical case: Substring is a prefix of multiple strings.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":2,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["sum(1 for s in str1 if s.startswith(sub_str)) > 1"]},{"id":"pc_20","description":"Typical case: Substring is a suffix of multiple strings.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":2,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["sum(1 for s in str1 if s.endswith(sub_str)) > 1"]}]}
{"_id":{"$oid":"692adffe1b18223597bc60af"},"test_cases":[{"id":"pc_1","description":"Happy Path: Substring present in one of the strings.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["any(sub_str in s for s in str1)"]},{"id":"pc_2","description":"Happy Path: Substring not present in any string.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not any(sub_str in s for s in str1)"]},{"id":"pc_3","description":"Edge Case: Empty list of strings.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":0,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Empty substring.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Empty list and empty substring.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":0,"max_codepoint":127},"sub_str":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: List contains an empty string.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":5,"contains_none_element":true,"max_codepoint":127},"sub_str":{"min_len":0,"max_len":2,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["'' in str1"]},{"id":"pc_7","description":"Boundary Value: Substring is an exact match for one of the strings.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["sub_str in str1"]},{"id":"pc_8","description":"Boundary Value: Substring is a prefix of a string in the list.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["any(s.startswith(sub_str) for s in str1)"]},{"id":"pc_9","description":"Boundary Value: Substring is a suffix of a string in the list.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["any(s.endswith(sub_str) for s in str1)"]},{"id":"pc_10","description":"Invariant: Input list should not be modified.","execution_statement":"original_list = list(str1); result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"str1 == original_list"}],"assumptions":[]},{"id":"pc_11","description":"Case Sensitivity: Substring with different casing.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["any(sub_str.lower() in s.lower() for s in str1)","not any(sub_str in s for s in str1)"]},{"id":"pc_12","description":"Long strings in list and substring.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":2,"str_len":{"min_val":50,"max_val":50},"max_codepoint":127},"sub_str":{"min_len":0,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["any(sub_str in s for s in str1)"]},{"id":"pc_13","description":"Long strings in list and substring (no match).","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":5,"str_len":{"min_val":50,"max_val":100},"max_codepoint":127},"sub_str":{"min_len":10,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not any(sub_str in s for s in str1)"]},{"id":"pc_14","description":"List with special characters, substring present.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"pattern":"^[\\w\\s!@#$%^&*()_+={}\\[\\]:;\"'<>?,./|\\-]+$"},"sub_str":{"min_len":1,"max_len":5,"pattern":"^[\\w\\s!@#$%^&*()_+={}\\[\\]:;\"'<>?,./|\\-]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["any(sub_str in s for s in str1)"]},{"id":"pc_15","description":"List with special characters, substring not present.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"pattern":"^[\\w\\s!@#$%^&*()_+={}\\[\\]:;\"'<>?,./|\\-]+$"},"sub_str":{"min_len":1,"max_len":5,"pattern":"^[\\w\\s!@#$%^&*()_+={}\\[\\]:;\"'<>?,./|\\-]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not any(sub_str in s for s in str1)"]},{"id":"pc_16","description":"Substring is longer than any string in the list.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"str_len":{"max_val":5},"max_codepoint":127},"sub_str":{"min_val":6,"max_val":10,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_17","description":"Substring is present multiple times across different strings.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":2,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["sum(s.count(sub_str) for s in str1) > 1"]},{"id":"pc_18","description":"Substring is a single character.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"max_codepoint":127},"sub_str":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["any(sub_str in s for s in str1)"]},{"id":"pc_19","description":"List contains only empty strings, substring is not empty.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"str_len":{"min_len":0,"max_len":0},"max_codepoint":127},"sub_str":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_20","description":"List contains strings with unicode characters, substring present.","execution_statement":"result = find_substring(str1, sub_str)","input_types":{"str1":"list[str]","sub_str":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":10,"pattern":"^[\\w\\s\\u00C0-\\u00FF]+$"},"sub_str":{"min_len":1,"max_len":5,"pattern":"^[\\w\\s\\u00C0-\\u00FF]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["any(sub_str in s for s in str1)"]}]}
{"_id":{"$oid":"692adffe1b18223597bc60b0"},"test_cases":[{"id":"pc_1","description":"Test with a typical undulating number (e.g., 12121).","execution_statement":"result = is_undulating(n=12121)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":99999}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Test with a number that is not undulating (e.g., 12345).","execution_statement":"result = is_undulating(n=12345)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":99999}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_3","description":"Test with a number having repeating digits (e.g., 11111).","execution_statement":"result = is_undulating(n=11111)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":99999}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"Test with a number that has alternating digits but not undulating (e.g., 12131).","execution_statement":"result = is_undulating(n=12131)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":99999}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"Test with a short number (2 digits) - should be False.","execution_statement":"result = is_undulating(n=12)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":99}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_6","description":"Test with a short number (1 digit) - should be False.","execution_statement":"result = is_undulating(n=5)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":9}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Test with zero - should be False.","execution_statement":"result = is_undulating(n=0)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_8","description":"Test with a larger undulating number (e.g., 808080).","execution_statement":"result = is_undulating(n=808080)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100000,"max_val":999999}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_9","description":"Test with a number that starts undulating but breaks pattern (e.g., 12123).","execution_statement":"result = is_undulating(n=12123)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":99999}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"Test with a number where the first two digits are the same, but subsequent digits alternate (e.g., 11212).","execution_statement":"result = is_undulating(n=11212)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":99999}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_11","description":"Test with a number that has only two distinct digits, but not in an undulating pattern (e.g., 12211).","execution_statement":"result = is_undulating(n=12211)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":99999}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_12","description":"Test with a very large undulating number.","execution_statement":"result = is_undulating(n=101010101010101010)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100000000000000000,"max_val":999999999999999999}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_13","description":"Test with a very large non-undulating number.","execution_statement":"result = is_undulating(n=123456789012345678)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100000000000000000,"max_val":999999999999999999}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"Test with a number that has alternating digits but uses 0 in a way that breaks the pattern (e.g., 10100).","execution_statement":"result = is_undulating(n=10100)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":99999}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_15","description":"Test with a number that has alternating digits and uses 0 correctly (e.g., 10101).","execution_statement":"result = is_undulating(n=10101)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":99999}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_16","description":"Test with a number that has three distinct digits but might appear undulating initially (e.g., 12134).","execution_statement":"result = is_undulating(n=12134)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":99999}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_17","description":"Test with a number that has only two digits and they are the same (e.g., 55).","execution_statement":"result = is_undulating(n=55)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":99}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_18","description":"Test with a number that has only two digits and they are different (e.g., 57).","execution_statement":"result = is_undulating(n=57)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":99}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_19","description":"Test with a number that has alternating digits and is exactly 3 digits long (e.g., 737).","execution_statement":"result = is_undulating(n=737)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":999}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_20","description":"Test with a number that has alternating digits and is exactly 4 digits long (e.g., 7373).","execution_statement":"result = is_undulating(n=7373)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000,"max_val":9999}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60b1"},"test_cases":[{"id":"pc_1","description":"Edge Case: Short numbers (length <= 2) should return False.","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"max_val":99}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Single digit numbers should return False.","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":9}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Two digit numbers should return False.","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":99}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_4","description":"Happy Path: Undulating number (e.g., 121) should return True.","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":999}},"postconditions":[{"assertion":"result is True"}],"assumptions":["str(n)[0] == str(n)[2]"]},{"id":"pc_5","description":"Happy Path: Longer undulating number (e.g., 12121) should return True.","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":99999}},"postconditions":[{"assertion":"result is True"}],"assumptions":["str(n)[0] == str(n)[2]","str(n)[1] == str(n)[3]"]},{"id":"pc_6","description":"Typical Case: Non-undulating number (e.g., 123) should return False.","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":999}},"postconditions":[{"assertion":"result is False"}],"assumptions":["str(n)[0] != str(n)[2]"]},{"id":"pc_7","description":"Typical Case: Longer non-undulating number (e.g., 12131) should return False.","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":99999}},"postconditions":[{"assertion":"result is False"}],"assumptions":["str(n)[0] == str(n)[2]","str(n)[1] != str(n)[3]"]},{"id":"pc_8","description":"Edge Case: Zero input should return False.","execution_statement":"result = is_undulating(0)","input_types":{},"input_constraints":{},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_9","description":"Edge Case: null input should return False.","execution_statement":"result = is_undulating(None)","input_types":{},"input_constraints":{},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_10","description":"Edge Case: Negative numbers should return False (due to '-').","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-99999,"max_val":-100}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_11","description":"Invariant: For undulating numbers, str(n)[i] must equal str(n)[i-2].","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_len":2}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(str(n)[i] == str(n)[i-2] for i in range(2, len(str(n))))"]},{"id":"pc_12","description":"Invariant: For non-undulating numbers, there must be at least one i where str(n)[i] != str(n)[i-2].","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_len":10}},"postconditions":[{"assertion":"result is False"}],"assumptions":["any(str(n)[i] != str(n)[i-2] for i in range(2, len(str(n))))"]},{"id":"pc_13","description":"Edge Case: Float input that becomes short string.","execution_statement":"result = is_undulating(n)","input_types":{"n":"float"},"input_constraints":{"n":{"max_val":9.99}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_14","description":"Edge Case: Float input that becomes longer string but not undulating.","execution_statement":"result = is_undulating(n)","input_types":{"n":"float"},"input_constraints":{"n":{"min_val":100.0,"max_val":999.99}},"postconditions":[{"assertion":"result is False"}],"assumptions":["str(n).replace('.', '')[0] != str(n).replace('.', '')[2]"]},{"id":"pc_15","description":"Edge Case: String input that is short.","execution_statement":"result = is_undulating(n)","input_types":{"n":"str"},"input_constraints":{"n":{"max_len":2,"pattern":"^[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_16","description":"Happy Path: String input that is undulating.","execution_statement":"result = is_undulating(n)","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":3,"max_len":5,"pattern":"^[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(n[i] == n[i-2] for i in range(2, len(n)))"]},{"id":"pc_17","description":"Typical Case: String input that is not undulating.","execution_statement":"result = is_undulating(n)","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":3,"max_len":5,"pattern":"^[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":["any(n[i] != n[i-2] for i in range(2, len(n)))"]},{"id":"pc_18","description":"Edge Case: Boolean True input (string 'True').","execution_statement":"result = is_undulating(True)","input_types":{},"input_constraints":{},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_19","description":"Edge Case: Boolean False input (string 'False').","execution_statement":"result = is_undulating(False)","input_types":{},"input_constraints":{},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_20","description":"Large number that is undulating.","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000000,"max_val":9999999999}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(str(n)[i] == str(n)[i-2] for i in range(2, len(str(n))))"]}]}
{"_id":{"$oid":"692adffe1b18223597bc60b2"},"test_cases":[{"id":"TC001","description":"Test with typical positive integers for base and exponent.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":2,"max_val":100},"b":{"min_val":2,"max_val":10}},"postconditions":[{"assertion":"result == a ** b"}]},{"id":"TC002","description":"Test with base as 0 and a positive exponent.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0},"b":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == 0"}]},{"id":"TC003","description":"Test with a positive base and exponent as 0.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"TC004","description":"Test with base as 1 and any exponent.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1,"max_val":1},"b":{"min_val":-10,"max_val":10}},"postconditions":[{"assertion":"result == 1"}]},{"id":"TC005","description":"Test with any base and exponent as 1.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":100},"b":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == a"}]},{"id":"TC006","description":"Test with negative base and even positive exponent.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":-2},"b":{"min_val":2,"max_val":10,"step":2}},"postconditions":[{"assertion":"result == a ** b"},{"assertion":"result > 0"}]},{"id":"TC007","description":"Test with negative base and odd positive exponent.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":-1},"b":{"min_val":1,"max_val":9,"step":2}},"postconditions":[{"assertion":"result == a ** b"},{"assertion":"result < 0"}]},{"id":"TC008","description":"Test with base 0 and exponent 0 (edge case).","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0},"b":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"TC009","description":"Test with large positive integers.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1000,"max_val":10000},"b":{"min_val":2,"max_val":5}},"postconditions":[{"assertion":"result == a ** b"}]},{"id":"TC010","description":"Test with negative base and exponent 1.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":-1},"b":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == a"}]},{"id":"TC011","description":"Test with base -1 and even exponent.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-1,"max_val":-1},"b":{"min_val":2,"max_val":10,"step":2}},"postconditions":[{"assertion":"result == 1"}]},{"id":"TC012","description":"Test with base -1 and odd exponent.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-1,"max_val":-1},"b":{"min_val":1,"max_val":9,"step":2}},"postconditions":[{"assertion":"result == -1"}]},{"id":"TC013","description":"Test with a small negative base and a small positive exponent.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-5,"max_val":-2},"b":{"min_val":2,"max_val":4}},"postconditions":[{"assertion":"result == a ** b"}]},{"id":"TC014","description":"Test with a small positive base and a small negative exponent (expecting TypeError due to recursion).","execution_statement":"try: result = power(a, b) except Exception as e: result = e","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":2,"max_val":10},"b":{"min_val":-10,"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, RecursionError)"}]},{"id":"TC015","description":"Test with a negative base and a small negative exponent (expecting TypeError due to recursion).","execution_statement":"try: result = power(a, b) except Exception as e: result = e","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-10,"max_val":-2},"b":{"min_val":-10,"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, RecursionError)"}]},{"id":"TC016","description":"Test with a very large base and a small exponent.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":100000,"max_val":1000000},"b":{"min_val":2,"max_val":3}},"postconditions":[{"assertion":"result == a ** b"}]},{"id":"TC017","description":"Test with a moderate base and a moderate exponent.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":10,"max_val":50},"b":{"min_val":5,"max_val":10}},"postconditions":[{"assertion":"result == a ** b"}]},{"id":"TC018","description":"Test with base 0 and exponent 1.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0},"b":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 0"}]},{"id":"TC019","description":"Test with base 1 and exponent 0.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1,"max_val":1},"b":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"TC020","description":"Test with a negative base and exponent 0.","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":-1},"b":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60b3"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive base and exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":2,"max_val":100},"b":{"min_val":2,"max_val":10}},"postconditions":[{"assertion":"result == a ** b"}]},{"id":"pc_2","description":"Edge Case: Exponent is zero","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":2,"max_val":100},"b":{"only":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_3","description":"Edge Case: Base is zero, positive exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"only":0},"b":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_4","description":"Edge Case: Exponent is one","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":2,"max_val":100},"b":{"only":1}},"postconditions":[{"assertion":"result == a"}]},{"id":"pc_5","description":"Edge Case: Base is zero, exponent is zero","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"only":0},"b":{"only":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_6","description":"Negative Base: Even exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":-2},"b":{"min_val":2,"max_val":10,"exclude":0}},"assumptions":["b % 2 == 0"],"postconditions":[{"assertion":"result == a ** b"}]},{"id":"pc_7","description":"Negative Base: Odd exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":-2},"b":{"min_val":1,"max_val":9,"exclude":0}},"assumptions":["b % 2 != 0"],"postconditions":[{"assertion":"result == a ** b"}]},{"id":"pc_8","description":"Large exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":2,"max_val":5},"b":{"min_val":10,"max_val":50}},"postconditions":[{"assertion":"result == a ** b"}]},{"id":"pc_9","description":"Invariant: Non-negative base, non-negative result","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0,"max_val":100},"b":{"min_val":0,"max_val":100}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"pc_10","description":"Invariant: Zero base, positive exponent yields zero","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"only":0},"b":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_11","description":"Invariant: Non-zero base, zero exponent yields one","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"only":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_12","description":"Negative Test: Non-integer base (expect TypeError)","execution_statement":"try: result = power(a, b) except Exception as e: result = e","input_types":{"a":"str","b":"int"},"input_constraints":{"a":{"min_len":1,"max_codepoint":255},"b":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Negative Test: Non-integer exponent (expect TypeError)","execution_statement":"try: result = power(a, b) except Exception as e: result = e","input_types":{"a":"int","b":"str"},"input_constraints":{"a":{"min_val":1,"max_val":10},"b":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Negative Test: Float base (expect TypeError due to recursion)","execution_statement":"try: result = power(a, b) except Exception as e: result = e","input_types":{"a":"float","b":"int"},"input_constraints":{"a":{},"b":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_15","description":"Negative Test: Float exponent (expect TypeError due to recursion)","execution_statement":"try: result = power(a, b) except Exception as e: result = e","input_types":{"a":"int","b":"float"},"input_constraints":{"a":{"min_val":1,"max_val":10},"b":{}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_16","description":"Edge Case: Base is 1, any exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"only":1},"b":{"min_val":0,"max_val":100}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_17","description":"Edge Case: Base is -1, even exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"only":-1},"b":{"min_val":2,"max_val":100}},"assumptions":["b % 2 == 0"],"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_18","description":"Edge Case: Base is -1, odd exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"only":-1},"b":{"min_val":1,"max_val":99}},"assumptions":["b % 2 != 0"],"postconditions":[{"assertion":"result == -1"}]},{"id":"pc_19","description":"Large base, small exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":100,"max_val":1000},"b":{"min_val":2,"max_val":5}},"postconditions":[{"assertion":"result == a ** b"}]},{"id":"pc_20","description":"Invariant: Result sign for negative base and odd exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":-2},"b":{"min_val":1,"max_val":9,"exclude":0}},"assumptions":["b % 2 != 0"],"postconditions":[{"assertion":"result < 0"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60b4"},"test_cases":[{"id":"test_general_case","description":"General case with a mix of positive and negative integers, unique second values.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"elements":{"min_val":-100,"max_val":100}}},"postconditions":[{"assertion":"assert result in [t[0] for t in test_list]"},{"assertion":"assert test_list[test_list.index(next(t for t in test_list if t[0] == result))][1] == min(t[1] for t in test_list)"}]},{"id":"test_duplicate_min_second_values","description":"List with multiple tuples having the same minimum second value.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"elements":{"min_val":0,"max_val":100}}},"assumptions":["len(set(t[1] for t in test_list)) < len(test_list)"],"postconditions":[{"assertion":"assert result in [t[0] for t in test_list]"},{"assertion":"assert test_list[test_list.index(next(t for t in test_list if t[0] == result))][1] == min(t[1] for t in test_list)"}]},{"id":"test_single_element_list","description":"List containing only one tuple.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_size":1,"max_size":1,"elements":{"min_val":-100,"max_val":100}}},"postconditions":[{"assertion":"assert result == test_list[0][0]"}]},{"id":"test_negative_second_values","description":"List where all second values are negative.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"elements":{"max_val":-1}}},"postconditions":[{"assertion":"assert result in [t[0] for t in test_list]"},{"assertion":"assert test_list[test_list.index(next(t for t in test_list if t[0] == result))][1] == min(t[1] for t in test_list)"}]},{"id":"test_large_and_small_second_values","description":"List with tuples containing very large and very small second values.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"elements":{"min_val":-1000000000,"max_val":1000000000}}},"postconditions":[{"assertion":"assert result in [t[0] for t in test_list]"},{"assertion":"assert test_list[test_list.index(next(t for t in test_list if t[0] == result))][1] == min(t[1] for t in test_list)"}]},{"id":"test_strings_as_second_values","description":"Using strings as the second value for comparison.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, str]]"},"input_constraints":{"test_list":{"min_len":1,"elements":{"max_codepoint":122}}},"postconditions":[{"assertion":"assert result in [t[0] for t in test_list]"},{"assertion":"assert test_list[test_list.index(next(t for t in test_list if t[0] == result))][1] == min(t[1] for t in test_list)"}]},{"id":"test_mixed_types_second_values","description":"List with tuples where second values are of different comparable types (e.g., int, float, string).","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, Union[int, float, str]]]"},"input_constraints":{"test_list":{"min_len":1,"elements":{"is_mixed":true}}},"postconditions":[{"assertion":"assert result in [t[0] for t in test_list]"},{"assertion":"assert test_list[test_list.index(next(t for t in test_list if t[0] == result))][1] == min(t[1] for t in test_list)"}]},{"id":"test_min_max_second_values","description":"List with tuples having the smallest and largest possible second values.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"elements":{"min_val":-1000,"max_val":1000}}},"postconditions":[{"assertion":"assert result in [t[0] for t in test_list]"},{"assertion":"assert test_list[test_list.index(next(t for t in test_list if t[0] == result))][1] == min(t[1] for t in test_list)"}]},{"id":"test_invariant_result_is_first_element","description":"The returned value must be the first element of one of the input tuples.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"elements":{"min_val":-100,"max_val":100}}},"postconditions":[{"assertion":"assert result in [t[0] for t in test_list]"}]},{"id":"test_invariant_min_second_value_consistency","description":"The second value of the tuple from which the result is taken must be the minimum second value in the list.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"elements":{"min_val":-100,"max_val":100}}},"postconditions":[{"assertion":"assert test_list[test_list.index(next(t for t in test_list if t[0] == result))][1] == min(t[1] for t in test_list)"}]},{"id":"test_typical_case_strings","description":"Using strings as the second value for comparison, typical case.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, str]]"},"input_constraints":{"test_list":{"min_len":1,"elements":{"max_codepoint":122}}},"postconditions":[{"assertion":"assert result in [t[0] for t in test_list]"},{"assertion":"assert test_list[test_list.index(next(t for t in test_list if t[0] == result))][1] == min(t[1] for t in test_list)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60b5"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with diverse tuples.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result in [t[0] for t in test_list]"},{"assertion":"all(t[1] >= min(t[1] for t in test_list) for t in test_list)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list.","execution_statement":"try: result = index_minimum(test_list) except Exception as e: result = e","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with a single tuple.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == test_list[0][0]"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Value: Minimum possible second element.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":10,"elements":{"min_val":-2147483648,"max_val":2147483647}}},"postconditions":[{"assertion":"result == next(t[0] for t in test_list if t[1] == -2147483648)"}],"assumptions":["min(t[1] for t in test_list) == -2147483648"]},{"id":"pc_5","description":"Boundary Value: Maximum possible second element.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":10,"elements":{"min_val":-2147483648,"max_val":2147483647}}},"postconditions":[{"assertion":"result == next(t[0] for t in test_list if t[1] == 2147483647)"}],"assumptions":["max(t[1] for t in test_list) == 2147483647"]},{"id":"pc_6","description":"Invariant: Returned value is the first element of a tuple in the list.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"any(t[0] == result for t in test_list)"}],"assumptions":[]},{"id":"pc_7","description":"Invariant: The second element of the tuple corresponding to the returned value is the minimum.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"all(t[1] >= min(t[1] for t in test_list) for t in test_list)"}],"assumptions":[]},{"id":"pc_8","description":"Typical Case: Multiple tuples with the same minimum second value.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":3,"max_len":10}},"postconditions":[{"assertion":"result in [t[0] for t in test_list if t[1] == min(t[1] for t in test_list)]"}],"assumptions":["test_list.count(min(test_list, key=itemgetter(1))) > 1"]},{"id":"pc_9","description":"Edge Case: Tuples with negative second elements.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":10,"elements":{"max_val":-1}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result in [t[0] for t in test_list]"}],"assumptions":[]},{"id":"pc_10","description":"Edge Case: Tuples with zero as the second element.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":10,"elements":{"min_val":0,"max_val":100}}},"postconditions":[{"assertion":"result == next(t[0] for t in test_list if t[1] == 0)"}],"assumptions":["0 in [t[1] for t in test_list]"]},{"id":"pc_11","description":"Large list input.","execution_statement":"result = index_minimum(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1000,"max_len":2000}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result in [t[0] for t in test_list]"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Input is not a list.","execution_statement":"try: result = index_minimum(test_list) except Exception as e: result = e","input_types":{"test_list":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: List contains non-tuple elements.","execution_statement":"try: result = index_minimum(test_list) except Exception as e: result = e","input_types":{"test_list":"list[int]"},"input_constraints":{"test_list":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Tuples have less than two elements.","execution_statement":"try: result = index_minimum(test_list) except Exception as e: result = e","input_types":{"test_list":"list[tuple[int]]"},"input_constraints":{"test_list":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, IndexError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: Second elements of tuples are not comparable.","execution_statement":"try: result = index_minimum(test_list) except Exception as e: result = e","input_types":{"test_list":"list[tuple[int, str]]"},"input_constraints":{"test_list":{"min_len":2,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60b6"},"test_cases":[{"id":"pc_1","description":"Typical case: list of lists with varying lengths.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":1,"max_len":10,"items":{"min_len":1,"max_len":10}}},"postconditions":[{"assertion":"result == min(len(x) for x in list_of_lists)"}],"assumptions":[]},{"id":"pc_2","description":"Edge case: empty outer list.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge case: outer list with one empty inner list.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":1,"max_len":1,"items":{"min_len":0,"max_len":0}}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Edge case: outer list with multiple empty inner lists.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":3,"max_len":5,"items":{"min_len":0,"max_len":0}}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_5","description":"Boundary case: single inner list.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":1,"max_len":1,"items":{"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"result == min(len(x) for x in list_of_lists)"}],"assumptions":[]},{"id":"pc_6","description":"Boundary case: all inner lists have the same length.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":2,"max_len":5,"items":{"min_len":3,"max_len":3}}},"postconditions":[{"assertion":"result == 3"}],"assumptions":[]},{"id":"pc_7","description":"Invariant testing: one list is significantly shorter than others.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":3,"max_len":5,"items":{"min_len":1,"max_len":10,"allow_none":false}}},"postconditions":[{"assertion":"result == 1"}],"assumptions":["len(list_of_lists[0]) == 1 or len(list_of_lists[1]) == 1 or len(list_of_lists[2]) == 1"]},{"id":"pc_8","description":"Typical case: lists with different data types (should not affect length).","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[Any]]"},"input_constraints":{"list_of_lists":{"min_len":2,"max_len":5,"items":{"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"result == min(len(x) for x in list_of_lists)"}],"assumptions":[]},{"id":"pc_9","description":"Boundary case: maximum number of inner lists.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":100,"max_len":100,"items":{"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"result == min(len(x) for x in list_of_lists)"}],"assumptions":[]},{"id":"pc_10","description":"Boundary case: maximum length of inner lists.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":2,"max_len":5,"items":{"min_len":50,"max_len":50}}},"postconditions":[{"assertion":"result == 50"}],"assumptions":[]},{"id":"pc_11","description":"Mixed empty and non-empty inner lists.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":3,"max_len":7,"items":{"min_len":0,"max_len":10},"is_mixed":true}},"postconditions":[{"assertion":"result == min(len(x) for x in list_of_lists)"}],"assumptions":[]},{"id":"pc_12","description":"All inner lists have length 1.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":5,"max_len":10,"items":{"min_len":1,"max_len":1}}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_13","description":"One inner list is empty, others are not.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":2,"max_len":5,"items":{"min_len":0,"max_len":10}}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["any(len(x) == 0 for x in list_of_lists)"]},{"id":"pc_14","description":"Large number of inner lists, small lengths.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":50,"max_len":100,"items":{"min_len":1,"max_len":3}}},"postconditions":[{"assertion":"result == min(len(x) for x in list_of_lists)"}],"assumptions":[]},{"id":"pc_15","description":"Small number of inner lists, large lengths.","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"List[List[int]]"},"input_constraints":{"list_of_lists":{"min_len":2,"max_len":5,"items":{"min_len":40,"max_len":50}}},"postconditions":[{"assertion":"result == min(len(x) for x in list_of_lists)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60b7"},"test_cases":[{"id":"pc_1","description":"Happy Path: Non-empty list of non-empty lists","execution_statement":"result = Find_Min_Length(lst)","input_types":{"lst":"list[list[int]]"},"input_constraints":{"lst":{"min_len":1},"lst__*":{"min_len":1}},"postconditions":[{"assertion":"result == min(len(x) for x in lst)"}]},{"id":"pc_2","description":"Edge Case: List containing an empty inner list","execution_statement":"result = Find_Min_Length(lst)","input_types":{"lst":"list[list[int]]"},"input_constraints":{"lst":{"min_len":1},"lst__*":{"allow_none":false}},"assumptions":["any(len(x) == 0 for x in lst)"],"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_3","description":"Edge Case: Single inner list","execution_statement":"result = Find_Min_Length(lst)","input_types":{"lst":"list[list[int]]"},"input_constraints":{"lst":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == len(lst[0])"}]},{"id":"pc_4","description":"Invariant: Return type is always integer","execution_statement":"result = Find_Min_Length(lst)","input_types":{"lst":"list[list[int]]"},"input_constraints":{"lst":{"min_len":1},"lst__*":{"min_len":0}},"postconditions":[{"assertion":"isinstance(result, int)"}]},{"id":"pc_5","description":"Invariant: Return value is non-negative","execution_statement":"result = Find_Min_Length(lst)","input_types":{"lst":"list[list[int]]"},"input_constraints":{"lst":{"min_len":1},"lst__*":{"min_len":0}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"pc_6","description":"Boundary Value: Large number of inner lists","execution_statement":"result = Find_Min_Length(lst)","input_types":{"lst":"list[list[int]]"},"input_constraints":{"lst":{"min_len":100,"max_len":200},"lst__*":{"min_len":1}},"postconditions":[{"assertion":"result == min(len(x) for x in lst)"}]},{"id":"pc_7","description":"Boundary Value: Large inner lists","execution_statement":"result = Find_Min_Length(lst)","input_types":{"lst":"list[list[int]]"},"input_constraints":{"lst":{"min_len":1},"lst__*":{"min_len":100,"max_len":200}},"postconditions":[{"assertion":"result == min(len(x) for x in lst)"}]},{"id":"pc_8","description":"Negative Test: Input is not a list (e.g., int)","execution_statement":"try: result = Find_Min_Length(lst) except Exception as e: result = e","input_types":{"lst":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: Input is None","execution_statement":"try: result = Find_Min_Length(lst) except Exception as e: result = e","input_types":{"lst":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Edge Case: List of empty lists","execution_statement":"result = Find_Min_Length(lst)","input_types":{"lst":"list[list[int]]"},"input_constraints":{"lst":{"min_len":1},"lst__*":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60b8"},"test_cases":[{"id":"TC1","description":"Test with typical positive integers.","execution_statement":"result = divisor(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1000}},"postconditions":[{"assertion":"result >= 2"},{"assertion":"result <= n"}]},{"id":"TC2","description":"Test with boundary values: 0, 1, 2.","execution_statement":"result = divisor(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":2}},"postconditions":[{"assertion":"result == 1 if n in [0, 1] else result == 2"}]},{"id":"TC3","description":"Test with prime numbers (should have 2 divisors).","execution_statement":"result = divisor(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1000}},"assumptions":["all(n % i != 0 for i in range(2, int(n**0.5) + 1))"],"postconditions":[{"assertion":"result == 2"}]},{"id":"TC4","description":"Test with perfect squares (should have an odd number of divisors).","execution_statement":"result = divisor(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"assumptions":["int(n**0.5)**2 == n"],"postconditions":[{"assertion":"result % 2 == 1"}]},{"id":"TC5","description":"Test with large numbers.","execution_statement":"result = divisor(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":100000}},"postconditions":[{"assertion":"result >= 2"},{"assertion":"result <= n"}]},{"id":"TC6","description":"Test with negative numbers (expecting TypeError).","execution_statement":"result = divisor(n)","input_types":{"n":"int"},"input_constraints":{"n":{"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC7","description":"Test with float input (expecting TypeError).","execution_statement":"result = divisor(n)","input_types":{"n":"float"},"input_constraints":{"n":{"min_val":0.0,"max_val":100.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC8","description":"Test with string input (expecting TypeError).","execution_statement":"result = divisor(n)","input_types":{"n":"str"},"input_constraints":{"n":{"pattern":"[a-zA-Z]+","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC9","description":"Test with None input (expecting TypeError).","execution_statement":"result = divisor(n)","input_types":{"n":"None"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC10","description":"Test with a number that has many divisors (highly composite).","execution_statement":"result = divisor(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":720,"max_val":720}},"postconditions":[{"assertion":"result == 30"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60b9"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical positive integer","execution_statement":"result = divisor(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1000}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 2"},{"assertion":"result <= n"}]},{"id":"pc_2","description":"Edge Case: Input is 1","execution_statement":"result = divisor(n)","input_types":{"n":"int"},"input_constraints":{"n":{"val":1}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result == 1"}]},{"id":"pc_3","description":"Edge Case: Input is a prime number","execution_statement":"result = divisor(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1000}},"assumptions":["all(n % i != 0 for i in range(2, int(n**0.5) + 1))"],"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result == 2"}]},{"id":"pc_4","description":"Edge Case: Input is a perfect square of a prime","execution_statement":"result = divisor(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":4,"max_val":1000}},"assumptions":["int(n**0.5)**2 == n","all(n % i != 0 for i in range(2, int(n**0.5)))"],"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result == 3"}]},{"id":"pc_5","description":"Boundary Case: Large integer input","execution_statement":"result = divisor(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":50000}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 2"},{"assertion":"result <= n"}]},{"id":"pc_6","description":"Negative Test: Zero input","execution_statement":"try: result = divisor(n) except Exception as e: result = e","input_types":{"n":"int"},"input_constraints":{"n":{"val":0}},"postconditions":[{"assertion":"isinstance(result, int)"}]},{"id":"pc_7","description":"Negative Test: Negative integer input","execution_statement":"try: result = divisor(n) except Exception as e: result = e","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, int)"}]},{"id":"pc_8","description":"Negative Test: Non-integer input (float)","execution_statement":"try: result = divisor(n) except Exception as e: result = e","input_types":{"n":"float"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: Non-integer input (string)","execution_statement":"try: result = divisor(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Non-integer input (None)","execution_statement":"try: result = divisor(n) except Exception as e: result = e","input_types":{"n":"None"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60ba"},"test_cases":[{"id":"TC001","description":"Typical case with integers, positive and negative.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"all(isinstance(k, int) for k in result.keys())"},{"assertion":"all(isinstance(v, int) and v >= 0 for v in result.values())"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"TC002","description":"Empty outer list.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == {}"}]},{"id":"TC003","description":"List with empty sublists.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"min_len":0,"max_len":0}}},"postconditions":[{"assertion":"result == {}"}]},{"id":"TC004","description":"List with a single element in each sublist.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":1,"elements":{"min_val":1,"max_val":10}}}},"postconditions":[{"assertion":"all(v == 1 for v in result.values())"},{"assertion":"len(result) == len(list1)"}]},{"id":"TC005","description":"List with duplicate elements across sublists.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":2,"max_len":5,"elements":{"min_len":1,"max_len":3,"elements":{"min_val":1,"max_val":5}}}},"assumptions":["len(set(item for sublist in list1 for item in sublist)) < sum(len(sublist) for sublist in list1)"],"postconditions":[{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"},{"assertion":"all(v > 1 for v in result.values())"}]},{"id":"TC006","description":"List with strings.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[str]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":5,"elements":{"min_codepoint":97,"max_codepoint":122,"max_len":5}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"all(isinstance(k, str) for k in result.keys())"},{"assertion":"all(isinstance(v, int) and v >= 0 for v in result.values())"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"TC007","description":"List with mixed hashable types (int, str, bool, None).","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[object]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":5,"elements":{"allow_none":true,"is_hashable_mix":true}},"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"all(v >= 0 for v in result.values())"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"TC008","description":"Large list with many sublists and elements.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":50,"max_len":100,"elements":{"min_len":10,"max_len":20,"elements":{"min_val":-1000,"max_val":1000}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"all(isinstance(v, int) and v >= 0 for v in result.values())"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"TC009","description":"List with only one sublist, containing multiple elements.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":1,"elements":{"min_len":5,"max_len":10,"elements":{"min_val":0,"max_val":50}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == len(list1[0])"}]},{"id":"TC010","description":"List with many sublists, each containing only one element.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":50,"max_len":100,"elements":{"min_len":1,"max_len":1,"elements":{"min_val":1,"max_val":100}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"all(v == 1 for v in result.values())"},{"assertion":"len(result) == len(list1)"}]},{"id":"TC011","description":"List with boolean values.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[bool]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"all(isinstance(k, bool) for k in result.keys())"},{"assertion":"all(isinstance(v, int) and v >= 0 for v in result.values())"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"TC012","description":"List with None values.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[None]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"result == {None: sum(len(sublist) for sublist in list1)}"}]},{"id":"TC013","description":"List with a single empty sublist.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":1,"elements":{"min_len":0,"max_len":0}}},"postconditions":[{"assertion":"result == {}"}]},{"id":"TC014","description":"List with varying sublist lengths, including empty ones.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":3,"max_len":7,"elements":{"min_len":0,"max_len":5,"elements":{"min_val":1,"max_val":20}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"all(v >= 0 for v in result.values())"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"TC015","description":"List with identical elements in all sublists.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":2,"max_len":5,"elements":{"min_len":1,"max_len":3,"elements":{"min_val":5,"max_val":5}}}},"postconditions":[{"assertion":"result == {5: sum(len(sublist) for sublist in list1)}"}]},{"id":"TC016","description":"List with negative integers only.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":-100,"max_val":-1}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"all(isinstance(k, int) and k < 0 for k in result.keys())"},{"assertion":"all(isinstance(v, int) and v >= 0 for v in result.values())"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"TC017","description":"List with zero values.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":0,"max_val":0}}}},"postconditions":[{"assertion":"result == {0: sum(len(sublist) for sublist in list1)}"}]},{"id":"TC018","description":"List with a mix of positive, negative, and zero integers.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":5,"max_len":15,"elements":{"min_len":2,"max_len":8,"elements":{"min_val":-50,"max_val":50}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"all(isinstance(v, int) and v >= 0 for v in result.values())"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"TC019","description":"List with long strings.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[str]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":3,"elements":{"min_codepoint":32,"max_codepoint":126,"min_len":10,"max_len":20}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"all(isinstance(k, str) for k in result.keys())"},{"assertion":"all(isinstance(v, int) and v >= 0 for v in result.values())"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"TC020","description":"List with tuples as elements.","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[tuple]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":3,"elements":{"min_val":1,"max_val":10}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"all(isinstance(k, tuple) for k in result.keys())"},{"assertion":"all(isinstance(v, int) and v >= 0 for v in result.values())"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60bb"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list of lists with integers","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"},{"assertion":"all(isinstance(v, int) and v > 0 for v in result.values())"},{"assertion":"all(key in [item for sublist in list1 for item in sublist] for key in result.keys())"}]},{"id":"pc_2","description":"Edge Case: Empty input list","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == {}"}]},{"id":"pc_3","description":"Edge Case: List with empty sublists","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"min_len":0,"max_len":0}}},"postconditions":[{"assertion":"result == {}"}]},{"id":"pc_4","description":"Boundary Case: Large numbers","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":1000000,"max_val":2000000}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"pc_5","description":"Boundary Case: Large number of sublists","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":50,"max_len":100,"elements":{"min_len":1,"max_len":1,"elements":{"min_val":0,"max_val":10}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"pc_6","description":"Boundary Case: Large elements within sublists","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"min_len":50,"max_len":100,"elements":{"min_val":0,"max_val":10}}}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"pc_7","description":"Invariant: Sum of frequencies equals total elements","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"pc_8","description":"Invariant: All keys are elements from the flattened list","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"all(key in [item for sublist in list1 for item in sublist] for key in result.keys())"}]},{"id":"pc_9","description":"Typical Case: Mixed positive and negative integers","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100}},"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"sum(result.values()) == sum(len(sublist) for sublist in list1)"}]},{"id":"pc_10","description":"Edge Case: List containing only zeros","execution_statement":"result = frequency_lists(list1)","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":0,"max_val":0}}}},"postconditions":[{"assertion":"result == {0: sum(len(sublist) for sublist in list1)}"}]},{"id":"pc_11","description":"Negative Test: Input is not a list of lists (e.g., list of ints)","execution_statement":"try: result = frequency_lists(list1) except Exception as e: result = e","input_types":{"list1":"list[int]"},"input_constraints":{"list1":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: Input is not iterable (e.g., int)","execution_statement":"try: result = frequency_lists(list1) except Exception as e: result = e","input_types":{"list1":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Negative Test: Input contains non-integer elements","execution_statement":"try: result = frequency_lists(list1) except Exception as e: result = e","input_types":{"list1":"list[list[str]]"},"input_constraints":{"list1":{"min_len":1,"elements":{"min_len":1}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Test with None values (should raise TypeError during flattening)","execution_statement":"try: result = frequency_lists(list1) except Exception as e: result = e","input_types":{"list1":"list[list[int | None]]"},"input_constraints":{"list1":{"min_len":1,"elements":{"min_len":1,"allow_none":true}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60bc"},"test_cases":[{"id":"pc_1","description":"Typical case with positive integers.","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":2,"max_len":10,"min_val":1,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)"}],"assumptions":[]},{"id":"pc_2","description":"Typical case with negative integers.","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":2,"max_len":10,"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)"}],"assumptions":[]},{"id":"pc_3","description":"Typical case with mixed positive and negative integers.","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":2,"max_len":10,"min_val":-100,"max_val":100,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)"}],"assumptions":[]},{"id":"pc_4","description":"Edge case: list with zeros.","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"allow_none":false}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == 0.0"}],"assumptions":["0 in numbers"]},{"id":"pc_5","description":"Edge case: list with ones.","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":1,"max_val":1}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == 1.0"}],"assumptions":[]},{"id":"pc_6","description":"Boundary case: minimum list length (1).","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":1,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)"}],"assumptions":[]},{"id":"pc_7","description":"Boundary case: maximum list length (10).","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":10,"max_len":10,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)"}],"assumptions":[]},{"id":"pc_8","description":"Boundary case: minimum value in range (-100).","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":2,"max_len":10,"min_val":-100,"max_val":-100}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)"}],"assumptions":[]},{"id":"pc_9","description":"Boundary case: maximum value in range (100).","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":2,"max_len":10,"min_val":100,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)"}],"assumptions":[]},{"id":"pc_10","description":"Typical case with floating-point numbers.","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[float]"},"input_constraints":{"numbers":{"min_len":2,"max_len":10,"min_val":-100.0,"max_val":100.0,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"abs(result - (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)) < 1e-9"}],"assumptions":[]},{"id":"pc_11","description":"Edge case: list with a single zero.","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":1,"min_val":0,"max_val":0}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_12","description":"Edge case: list with a single one.","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":1,"min_val":1,"max_val":1}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == 1.0"}],"assumptions":[]},{"id":"pc_13","description":"Typical case with large numbers.","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":2,"max_len":5,"min_val":10000,"max_val":100000}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)"}],"assumptions":[]},{"id":"pc_14","description":"Typical case with small numbers (close to zero).","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[float]"},"input_constraints":{"numbers":{"min_len":2,"max_len":10,"min_val":-0.001,"max_val":0.001,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"abs(result - (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)) < 1e-9"}],"assumptions":[]},{"id":"pc_15","description":"Edge case: list with alternating signs.","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":3,"max_len":10,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)"}],"assumptions":["numbers[0] > 0 and numbers[1] < 0 or numbers[0] < 0 and numbers[1] > 0"]},{"id":"pc_16","description":"Negative test: input is not a list (TypeError expected).","execution_statement":"try: result = multiply_num(numbers) except Exception as e: result = e","input_types":{"numbers":"int"},"input_constraints":{"numbers":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Negative test: input is an empty list (ZeroDivisionError expected).","execution_statement":"try: result = multiply_num(numbers) except Exception as e: result = e","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, ZeroDivisionError)"}],"assumptions":[]},{"id":"pc_18","description":"Typical case with a mix of integers and floats.","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[Union[int, float]]"},"input_constraints":{"numbers":{"min_len":2,"max_len":10,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"abs(result - (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)) < 1e-9"}],"assumptions":[]},{"id":"pc_19","description":"Boundary case: list with minimum and maximum values.","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":2,"max_len":2,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)"}],"assumptions":["numbers[0] == -100 and numbers[1] == 100 or numbers[0] == 100 and numbers[1] == -100"]},{"id":"pc_20","description":"Typical case with many numbers.","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"List[int]"},"input_constraints":{"numbers":{"min_len":50,"max_len":100,"min_val":-50,"max_val":50}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == (lambda nums: functools.reduce(lambda x, y: x * y, nums) / len(nums))(numbers)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60bd"},"test_cases":[{"id":"pc_1","description":"Happy Path: List of positive integers","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":1,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, float) and result == (1 if not numbers else eval('*'.join(map(str, numbers)))) / len(numbers)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"try: result = multiply_num(numbers) except Exception as e: result = e","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, ZeroDivisionError)"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List contains zero","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":0,"max_val":100}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":["0 in numbers"]},{"id":"pc_4","description":"Boundary: Single element list","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":1,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"result == numbers[0]"}],"assumptions":[]},{"id":"pc_5","description":"Typical Case: Mixed positive and negative integers","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":2,"max_len":10,"min_val":-100,"max_val":100,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, float) and result == (1 if not numbers else eval('*'.join(map(str, numbers)))) / len(numbers)"}],"assumptions":["not (all(n > 0 for n in numbers) or all(n < 0 for n in numbers))"]},{"id":"pc_6","description":"Boundary: Large numbers (potential overflow if not handled by Python's arbitrary precision integers)","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":5,"min_val":1000000,"max_val":10000000}},"postconditions":[{"assertion":"isinstance(result, float) and abs(result - (1 if not numbers else eval('*'.join(map(str, numbers)))) / len(numbers)) < 1e-9"}],"assumptions":[]},{"id":"pc_7","description":"Invariant: Result type is always float","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, float)"}],"assumptions":[]},{"id":"pc_8","description":"Typical Case: List with negative numbers","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, float) and result == (1 if not numbers else eval('*'.join(map(str, numbers)))) / len(numbers)"}],"assumptions":[]},{"id":"pc_9","description":"Edge Case: List with one element, zero","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":1,"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_10","description":"Invariant: Non-negative result if all inputs are non-negative","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":0,"max_val":100}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60be"},"test_cases":[{"id":"pc_1","description":"Test with typical positive integer.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"all(c in '01' for c in result)"},{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_2","description":"Test with zero.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == '0'"}],"assumptions":[]},{"id":"pc_3","description":"Test with a power of 2.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1024,"is_power_of_two":true}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"},{"assertion":"result.startswith('1')"},{"assertion":"result.count('0') == int(math.log2(n))"}],"assumptions":[]},{"id":"pc_4","description":"Test with a number just below a power of 2.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1023,"is_one_less_than_power_of_two":true}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"},{"assertion":"result.startswith('1')"}],"assumptions":[]},{"id":"pc_5","description":"Test with a large integer.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000,"max_val":1000000000}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_6","description":"Test with maximum integer value.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2147483647,"max_val":2147483647}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_7","description":"Test with a number that results in a short binary string.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":3}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_8","description":"Test with a number that results in a long binary string.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":500,"max_val":1000}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_9","description":"Test with a number that has alternating 0s and 1s in binary.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000,"pattern":"^(10)*1?$|^1(01)*$"}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_10","description":"Test with a number that has only 1s in binary.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000,"pattern":"^1+$"}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_11","description":"Test with a number that has only 0s in binary (only possible for 0).","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == '0'"}],"assumptions":[]},{"id":"pc_12","description":"Test with a number that is a perfect square.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10000,"is_perfect_square":true}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_13","description":"Test with a number that is a perfect cube.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000,"is_perfect_cube":true}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_14","description":"Test with a prime number.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1000,"is_prime":true}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_15","description":"Test with a composite number.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":4,"max_val":1000,"is_composite":true}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_16","description":"Test with a number that has leading zeros in its standard binary representation (should be removed).","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"},{"assertion":"not result.startswith('0')"}],"assumptions":["bin(n).replace('0b', '').startswith('0') == False"]},{"id":"pc_17","description":"Test with a number that requires many bits.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000000,"max_val":2000000000}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_18","description":"Test with a number that is a Fibonacci number.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10000,"is_fibonacci":true}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_19","description":"Test with a number that is a Catalan number.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000,"is_catalan":true}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_20","description":"Test with a number that is a triangular number.","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10000,"is_triangular":true}},"postconditions":[{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60bf"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic positive integer conversion","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Input is zero","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == '0'"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Value: Large positive integer","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000001,"max_val":2147483647}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"result == bin(n).replace('0b', '')"}],"assumptions":[]},{"id":"pc_4","description":"Invariant: Output string should not have leading zeros (for n > 0)","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000}},"postconditions":[{"assertion":"not result.startswith('0')"}],"assumptions":[]},{"id":"pc_5","description":"Negative Test: Input is a negative integer (expecting TypeError)","execution_statement":"try: result = decimal_to_binary(n) except Exception as e: result = e","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-2147483648,"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: Input is a float (expecting TypeError)","execution_statement":"try: result = decimal_to_binary(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Input is a string (expecting TypeError)","execution_statement":"try: result = decimal_to_binary(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Input is None (expecting TypeError)","execution_statement":"try: result = decimal_to_binary(n) except Exception as e: result = e","input_types":{"n":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Invariant: Output is always a string","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000000}},"postconditions":[{"assertion":"isinstance(result, str)"}],"assumptions":[]},{"id":"pc_10","description":"Boundary Value: Smallest positive integer","execution_statement":"result = decimal_to_binary(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == '1'"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60c0"},"test_cases":[{"id":"pc_1","description":"Test with a typical integer.","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":10,"max_val":1000000}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_2","description":"Test with the smallest single-digit number (0).","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_3","description":"Test with the largest single-digit number (9).","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":9,"max_val":9}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_4","description":"Test with a two-digit palindrome (11).","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":11,"max_val":11}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_5","description":"Test with a two-digit non-palindrome (12).","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":12,"max_val":12}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_6","description":"Test with a number consisting of all nines (9).","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":9,"max_val":9}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_7","description":"Test with a number consisting of all nines (99).","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":99,"max_val":99}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_8","description":"Test with a number just above a power of 10 (101).","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":101,"max_val":101}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_9","description":"Test with a large integer.","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":100000000,"max_val":1000000000}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_10","description":"Another typical integer input.","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":100,"max_val":500000}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_11","description":"Test with a three-digit palindrome.","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":101,"max_val":999}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":["str(num) == str(num)[::-1]"]},{"id":"pc_12","description":"Test with a three-digit non-palindrome.","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":100,"max_val":999}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":["str(num) != str(num)[::-1]"]},{"id":"pc_13","description":"Test a number that requires a carry-over to find the next palindrome.","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":12921,"max_val":12921}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_14","description":"Another typical integer input.","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":500,"max_val":1500}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_15","description":"Test with a three-digit number consisting of all nines (999).","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":999,"max_val":999}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_16","description":"Integer input that is close to a palindrome.","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":1234,"max_val":1234}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_17","description":"Test with a number just below a power of 10 (99).","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":99,"max_val":99}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_18","description":"Another typical integer input.","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":2000,"max_val":3000}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_19","description":"Test with a four-digit palindrome.","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":1001,"max_val":9999}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":["str(num) == str(num)[::-1]"]},{"id":"pc_20","description":"Test with a four-digit non-palindrome.","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":1000,"max_val":9999}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":["str(num) != str(num)[::-1]"]}]}
{"_id":{"$oid":"692adffe1b18223597bc60c1"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic integer input","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"},{"assertion":"all(str(i) != str(i)[::-1] for i in range(num + 1, result))"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Input is already a palindrome","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":101,"max_val":999}},"postconditions":[{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"},{"assertion":"all(str(i) != str(i)[::-1] for i in range(num + 1, result))"}],"assumptions":["str(num) == str(num)[::-1]"]},{"id":"pc_3","description":"Edge Case: Single digit input","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":0,"max_val":8}},"postconditions":[{"assertion":"result == num + 1"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Input is 9 (single digit palindrome)","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":9,"max_val":9}},"postconditions":[{"assertion":"result == 11"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Input is 99","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":99,"max_val":99}},"postconditions":[{"assertion":"result == 101"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Input is 100","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":100,"max_val":100}},"postconditions":[{"assertion":"result == 101"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: Input is 0","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_8","description":"Typical Case: Larger number","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":1000,"max_val":10000}},"postconditions":[{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"},{"assertion":"all(str(i) != str(i)[::-1] for i in range(num + 1, result))"}],"assumptions":[]},{"id":"pc_9","description":"Boundary Case: Near max integer (if feasible to test)","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":2147483640,"max_val":2147483647}},"postconditions":[{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Non-integer input (string)","execution_statement":"try: result = next_smallest_palindrome(num) except Exception as e: result = e","input_types":{"num":"str"},"input_constraints":{"num":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-integer input (float)","execution_statement":"try: result = next_smallest_palindrome(num) except Exception as e: result = e","input_types":{"num":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: null input","execution_statement":"try: result = next_smallest_palindrome(num) except Exception as e: result = e","input_types":{"num":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Edge Case: Palindrome with trailing zeros","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":1001,"max_val":1001}},"postconditions":[{"assertion":"result == 1111"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_14","description":"Edge Case: Number just before a palindrome","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":120,"max_val":120}},"postconditions":[{"assertion":"result == 121"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_15","description":"Edge Case: Number just after a palindrome","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":122,"max_val":122}},"postconditions":[{"assertion":"result == 131"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60c2"},"test_cases":[{"id":"pc_1","description":"Typical case: find middle element in a sorted array.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":1,"max_val":100,"min_len":5,"max_len":10,"sorted":"ascending","unique":true},"k":{"min_val":2,"max_val":9}},"postconditions":[{"assertion":"result == arr[k-1]"}],"assumptions":["len(arr) > 0","k >= 1","k <= len(arr)"]},{"id":"pc_2","description":"Edge case: find the first element.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":1,"max_val":100,"min_len":5,"max_len":10,"sorted":"ascending","unique":true},"k":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == arr[k-1]"}],"assumptions":["len(arr) > 0","k >= 1","k <= len(arr)"]},{"id":"pc_3","description":"Edge case: find the last element.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":1,"max_val":100,"min_len":5,"max_len":10,"sorted":"ascending","unique":true},"k":{"min_val":10,"max_val":10}},"postconditions":[{"assertion":"result == arr[k-1]"}],"assumptions":["len(arr) > 0","k >= 1","k <= len(arr)"]},{"id":"pc_4","description":"Typical case: unsorted array.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":1,"max_val":100,"min_len":5,"max_len":10,"unique":true},"k":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == sorted(arr)[k-1]"}],"assumptions":["len(arr) > 0","k >= 1","k <= len(arr)"]},{"id":"pc_5","description":"Edge case: array with negative numbers.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":-100,"max_val":100,"min_len":5,"max_len":10,"unique":true},"k":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == sorted(arr)[k-1]"}],"assumptions":["len(arr) > 0","k >= 1","k <= len(arr)"]},{"id":"pc_6","description":"Edge case: array with duplicate numbers.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":1,"max_val":10,"min_len":5,"max_len":10},"k":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == sorted(arr)[k-1]"}],"assumptions":["len(arr) > 0","k >= 1","k <= len(arr)"]},{"id":"pc_7","description":"Negative test: k is out of bounds (too large).","execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":1,"max_val":100,"min_len":5,"max_len":10,"unique":true},"k":{"min_val":11,"max_val":15}},"postconditions":[{"assertion":"isinstance(result, IndexError)"}],"assumptions":["len(arr) > 0","k > len(arr)"]},{"id":"pc_8","description":"Negative test: k is out of bounds (too small).","execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":1,"max_val":100,"min_len":5,"max_len":10,"unique":true},"k":{"min_val":-5,"max_val":0}},"postconditions":[{"assertion":"isinstance(result, IndexError)"}],"assumptions":["k < 1"]},{"id":"pc_9","description":"Edge case: empty array.","execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_len":0,"max_len":0},"k":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"isinstance(result, IndexError)"}],"assumptions":["len(arr) == 0"]},{"id":"pc_10","description":"Typical case: larger array.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":1,"max_val":1000,"min_len":50,"max_len":100,"unique":true},"k":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == sorted(arr)[k-1]"}],"assumptions":["len(arr) > 0","k >= 1","k <= len(arr)"]},{"id":"pc_11","description":"Edge case: array with only one element.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":1,"max_val":100,"min_len":1,"max_len":1,"unique":true},"k":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == arr[k-1]"}],"assumptions":["len(arr) == 1","k == 1"]},{"id":"pc_12","description":"Typical case: array with mixed positive and negative numbers.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":-100,"max_val":100,"min_len":5,"max_len":10,"unique":true,"is_mixed":true},"k":{"min_val":1,"max_val":10,"is_mixed":true}},"postconditions":[{"assertion":"result == sorted(arr)[k-1]"}],"assumptions":["len(arr) > 0","k >= 1","k <= len(arr)"]},{"id":"pc_13","description":"Edge case: array with large numbers.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":1000000,"max_val":10000000,"min_len":5,"max_len":10,"unique":true},"k":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == sorted(arr)[k-1]"}],"assumptions":["len(arr) > 0","k >= 1","k <= len(arr)"]},{"id":"pc_14","description":"Edge case: array with small numbers.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":-10,"max_val":10,"min_len":5,"max_len":10,"unique":true},"k":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == sorted(arr)[k-1]"}],"assumptions":["len(arr) > 0","k >= 1","k <= len(arr)"]},{"id":"pc_15","description":"Typical case: array with many duplicates.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":1,"max_val":5,"min_len":10,"max_len":20},"k":{"min_val":1,"max_val":20}},"postconditions":[{"assertion":"result == sorted(arr)[k-1]"}],"assumptions":["len(arr) > 0","k >= 1","k <= len(arr)"]},{"id":"pc_16","description":"Edge case: k equals array length.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":1,"max_val":100,"min_len":5,"max_len":10,"unique":true},"k":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == sorted(arr)[k-1]"}],"assumptions":["len(arr) > 0","k == len(arr)"]},{"id":"pc_17","description":"Edge case: k equals 1.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":1,"max_val":100,"min_len":5,"max_len":10,"unique":true},"k":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == sorted(arr)[k-1]"}],"assumptions":["len(arr) > 0","k == 1"]},{"id":"pc_18","description":"Typical case: array with zeros.","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"List[int]","k":"int"},"input_constraints":{"arr":{"min_val":-10,"max_val":10,"min_len":5,"max_len":10},"k":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == sorted(arr)[k-1]"}],"assumptions":["len(arr) > 0","k >= 1","k <= len(arr)"]},{"id":"pc_19","description":"Negative test: k is float.","execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","input_types":{"arr":"List[int]","k":"float"},"input_constraints":{"arr":{"min_val":1,"max_val":100,"min_len":5,"max_len":10,"unique":true},"k":{"min_val":1.0,"max_val":5.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_20","description":"Negative test: arr is not a list (int).","execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","input_types":{"arr":"int","k":"int"},"input_constraints":{"arr":{"min_val":1,"max_val":100},"k":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60c3"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical case with positive integers","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"unique":false},"k":{"min_val":1}},"assumptions":["k <= len(arr)"],"postconditions":[{"assertion":"result in arr_copy_before_call"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"},{"assertion":"result == sorted(arr_copy_before_call)[k-1]"}]},{"id":"pc_2","description":"Edge Case: Empty array","execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":0,"max_len":0},"k":{"min_val":1}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_3","description":"Edge Case: k = 1 (smallest element)","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":1,"max_len":10},"k":{"min_val":1,"max_val":1}},"assumptions":["k <= len(arr)"],"postconditions":[{"assertion":"result == sorted(arr_copy_before_call)[0]"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"}]},{"id":"pc_4","description":"Edge Case: k = len(arr) (largest element)","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":1,"max_len":10},"k":{"min_val":1}},"assumptions":["k == len(arr)"],"postconditions":[{"assertion":"result == sorted(arr_copy_before_call)[-1]"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"}]},{"id":"pc_5","description":"Boundary Case: Array with single element","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":1,"max_len":1},"k":{"min_val":1,"max_val":1}},"assumptions":["k <= len(arr)"],"postconditions":[{"assertion":"result == arr_copy_before_call[0]"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"}]},{"id":"pc_6","description":"Case: Array with duplicate elements","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":15,"unique":false},"k":{"min_val":1}},"assumptions":["k <= len(arr)"],"postconditions":[{"assertion":"result in arr_copy_before_call"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"},{"assertion":"result == sorted(arr_copy_before_call)[k-1]"}]},{"id":"pc_7","description":"Case: Array with negative integers","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"unique":false},"k":{"min_val":1}},"assumptions":["k <= len(arr)","all(x < 0 for x in arr_copy_before_call)"],"postconditions":[{"assertion":"result in arr_copy_before_call"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"},{"assertion":"result == sorted(arr_copy_before_call)[k-1]"}]},{"id":"pc_8","description":"Case: Array with mixed positive and negative integers","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"unique":false,"is_mixed":true},"k":{"min_val":1,"is_mixed":true}},"assumptions":["k <= len(arr)"],"postconditions":[{"assertion":"result in arr_copy_before_call"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"},{"assertion":"result == sorted(arr_copy_before_call)[k-1]"}]},{"id":"pc_9","description":"Case: Array with zeros","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"unique":false},"k":{"min_val":1}},"assumptions":["k <= len(arr)","0 in arr_copy_before_call"],"postconditions":[{"assertion":"result in arr_copy_before_call"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"},{"assertion":"result == sorted(arr_copy_before_call)[k-1]"}]},{"id":"pc_10","description":"Case: Large array","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":100,"max_len":500,"unique":false},"k":{"min_val":1}},"assumptions":["k <= len(arr)"],"postconditions":[{"assertion":"result in arr_copy_before_call"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"},{"assertion":"result == sorted(arr_copy_before_call)[k-1]"}]},{"id":"pc_11","description":"Negative Test: k is out of bounds (too large)","execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":1,"max_len":10},"k":{"min_val":1}},"assumptions":["k > len(arr)"],"postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_12","description":"Negative Test: k is out of bounds (zero)","execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":1,"max_len":10},"k":{"min_val":0,"max_val":0}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_13","description":"Negative Test: k is out of bounds (negative)","execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":1,"max_len":10},"k":{"min_val":-10,"max_val":-1}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_14","description":"Negative Test: Non-integer k","execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","input_types":{"arr":"list[int]","k":"float"},"input_constraints":{"arr":{"min_len":1,"max_len":10},"k":{}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_15","description":"Negative Test: Non-list arr","execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","input_types":{"arr":"int","k":"int"},"input_constraints":{"arr":{},"k":{"min_val":1}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_16","description":"Case: Array with large numbers","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"min_val":1000000,"max_val":1000000000},"k":{"min_val":1}},"assumptions":["k <= len(arr)"],"postconditions":[{"assertion":"result in arr_copy_before_call"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"},{"assertion":"result == sorted(arr_copy_before_call)[k-1]"}]},{"id":"pc_17","description":"Case: Array with small numbers (close to zero)","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"min_val":-1000000,"max_val":-1000000000},"k":{"min_val":1}},"assumptions":["k <= len(arr)"],"postconditions":[{"assertion":"result in arr_copy_before_call"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"},{"assertion":"result == sorted(arr_copy_before_call)[k-1]"}]},{"id":"pc_18","description":"Case: Array with mixed number magnitudes","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"min_val":-1000000000,"max_val":1000000000,"is_mixed":true},"k":{"min_val":1,"is_mixed":true}},"assumptions":["k <= len(arr)"],"postconditions":[{"assertion":"result in arr_copy_before_call"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"},{"assertion":"result == sorted(arr_copy_before_call)[k-1]"}]},{"id":"pc_19","description":"Case: Array with identical elements","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":10,"unique":true},"k":{"min_val":1}},"assumptions":["k <= len(arr)","len(set(arr_copy_before_call)) == 1"],"postconditions":[{"assertion":"result == arr_copy_before_call[0]"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"}]},{"id":"pc_20","description":"Case: Array with elements that are already sorted","execution_statement":"result = kth_element(arr, k)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"unique":false},"k":{"min_val":1}},"assumptions":["k <= len(arr)","all(arr_copy_before_call[i] <= arr_copy_before_call[i+1] for i in range(len(arr_copy_before_call)-1))"],"postconditions":[{"assertion":"result == arr_copy_before_call[k-1]"},{"assertion":"all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60c4"},"test_cases":[{"id":"pc_1","description":"Typical snake_case string","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+(_[a-z-9]+)*$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_2","description":"Empty string","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''"}],"assumptions":[]},{"id":"pc_3","description":"String with no underscores (single word)","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == word"}],"assumptions":[]},{"id":"pc_4","description":"String with leading underscore","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^_[a-z-9]+(_[a-z-9]+)*$","min_len":2,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_5","description":"String with trailing underscore","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+(_[a-z-9]+)*_$","min_len":2,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_6","description":"String with consecutive underscores","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+(__[a-z-9]+)+$","min_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_7","description":"String with numbers","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+(_[a-z-9]+)*$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_8","description":"Long snake_case string","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+(_[a-z-9]+)*$","min_len":50,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_9","description":"Snake_case string with only numbers","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[-9]+(_[-9]+)*$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_10","description":"Snake_case string with mixed letters and numbers","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+(_[a-z-9]+)*$","min_len":1,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_11","description":"String with single underscore in the middle","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+_[a-z-9]+$","min_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_12","description":"String with multiple underscores and numbers","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+(_[a-z-9]+)*$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_13","description":"String that results in empty string after split (e.g., only underscores)","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^_+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''"}],"assumptions":[]},{"id":"pc_14","description":"String with underscore followed by number","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+(_[-9]+)+$","min_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_15","description":"String with number followed by underscore","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[-9]+(_[a-z-9]+)+$","min_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_16","description":"String with mixed case letters (should be treated as lowercase by snake_case convention)","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9A-Z]+(_[a-z-9A-Z]+)*$","min_len":1,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_17","description":"String with only one word and numbers","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == word"}],"assumptions":[]},{"id":"pc_18","description":"String with multiple words and numbers, starting with number","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[-9]+(_[a-z-9]+)+$","min_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_19","description":"String with multiple words and numbers, ending with number","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+(_[a-z-9]+)*[-9]$","min_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_20","description":"String with underscores and numbers, starting and ending with underscore","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^_([a-z-9]+_)*[a-z-9]+_$","min_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"lambda word, result: result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60c5"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic snake_case to camelCase conversion.","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z]+(_[a-z]+)*$","max_codepoint":255}},"postconditions":[{"assertion":"result == word.replace('_', ' ').title().replace(' ', '')"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string input.","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String with no underscores.","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == word.capitalize()"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: String with multiple consecutive underscores.","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z]*__+[a-z]*(_[a-z]+)*$","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() for x in word.split('_') if x)"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: String with leading underscore.","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^_[a-z]+(_[a-z]+)*$","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() for x in word.split('_') if x)"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: String with trailing underscore.","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z]+(_[a-z]+)*_$","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() for x in word.split('_') if x)"}],"assumptions":[]},{"id":"pc_7","description":"Mixed Case: Input with mixed casing.","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-zA-Z]+(_[a-zA-Z]+)*$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() or '_' for x in word.lower().split('_'))"}],"assumptions":[]},{"id":"pc_8","description":"Numeric Strings: Input contains numbers.","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+(_[a-z-9]+)*$","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() or '_' for x in word.split('_'))"}],"assumptions":[]},{"id":"pc_9","description":"Invariant: Output should not contain underscores.","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z]+(_[a-z]+)*$","max_codepoint":255}},"postconditions":[{"assertion":"'_' not in result"}],"assumptions":[]},{"id":"pc_10","description":"Invariant: First character of output should be uppercase (if input not empty).","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"min_len":1,"pattern":"^[a-z]+(_[a-z]+)*$","max_codepoint":255}},"postconditions":[{"assertion":"result[0].isupper()"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-string input (integer).","execution_statement":"try: result = snake_to_camel(word) except Exception as e: result = e","input_types":{"word":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Non-string input (None).","execution_statement":"try: result = snake_to_camel(word) except Exception as e: result = e","input_types":{"word":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_13","description":"Long snake_case string.","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"min_len":50,"max_len":100,"pattern":"^[a-z]+(_[a-z]+)*$","max_codepoint":255}},"postconditions":[{"assertion":"result == word.replace('_', ' ').title().replace(' ', '')"}],"assumptions":[]},{"id":"pc_14","description":"String with only underscores.","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^_+$","max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":[]},{"id":"pc_15","description":"Invariant: Output length should be less than or equal to input length.","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"min_len":1,"pattern":"^[a-z]+(_[a-z]+)*$","max_codepoint":255}},"postconditions":[{"assertion":"len(result) <= len(word)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60c6"},"test_cases":[{"id":"TC1","description":"Test with typical valid inputs for n and m.","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":1,"max_val":100},"m":{"min_val":0,"max_val":99}},"assumptions":["m < n"],"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC2","description":"Test edge case where m is 0.","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":1,"max_val":100},"m":{"min_val":0,"max_val":0}},"assumptions":["m < n"],"postconditions":[{"assertion":"result == 1"}]},{"id":"TC3","description":"Test edge case where m is n-1.","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":1,"max_val":100},"m":{"min_val":0,"max_val":99}},"assumptions":["m == n - 1"],"postconditions":[{"assertion":"result == 1"}]},{"id":"TC4","description":"Test invalid case where m >= n.","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":1,"max_val":100},"m":{"min_val":0,"max_val":100}},"assumptions":["m >= n"],"postconditions":[{"assertion":"result == 0"}]},{"id":"TC5","description":"Test invalid case where n is 0.","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0},"m":{"min_val":0,"max_val":0}},"assumptions":[],"postconditions":[{"assertion":"result == 0"}]},{"id":"TC6","description":"Test symmetry property: a(n, m) == a(n, n - 1 - m).","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":2,"max_val":50},"m":{"min_val":0,"max_val":49}},"assumptions":["m < n - 1"],"postconditions":[{"assertion":"result == eulerian_num(n, n - 1 - m)"}]},{"id":"TC7","description":"Test recurrence relation: a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m).","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":2,"max_val":50},"m":{"min_val":1,"max_val":49}},"assumptions":["m < n"],"postconditions":[{"assertion":"result == (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)"}]},{"id":"TC8","description":"Test with larger values of n and m.","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":50,"max_val":100},"m":{"min_val":10,"max_val":40}},"assumptions":["m < n"],"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC9","description":"Test case where n is small and m is close to n.","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":5,"max_val":10},"m":{"min_val":3,"max_val":8}},"assumptions":["m < n"],"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC10","description":"Test case where n is small and m is close to 0.","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":5,"max_val":10},"m":{"min_val":0,"max_val":2}},"assumptions":["m < n"],"postconditions":[{"assertion":"result >= 0"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60c7"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical values for n and m","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10},"m":{"min_val":1,"max_val":10}},"assumptions":["m < n"],"postconditions":[{"assertion":"result >= 0"},{"assertion":"isinstance(result, int)"}]},{"id":"pc_2","description":"Edge Case: n = 0","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0},"m":{"min_val":0,"max_val":10}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_3","description":"Edge Case: m = 0 and n > 0","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10},"m":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_4","description":"Edge Case: m >= n","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10},"m":{"min_val":1,"max_val":10}},"assumptions":["m >= n"],"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_5","description":"Boundary Case: Large n and m within valid range","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":50,"max_val":60},"m":{"min_val":10,"max_val":40}},"assumptions":["m < n"],"postconditions":[{"assertion":"result >= 0"},{"assertion":"isinstance(result, int)"}]},{"id":"pc_6","description":"Invariant: Result is always non-negative","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":0,"max_val":20},"m":{"min_val":0,"max_val":20}},"assumptions":["n >= 0","m >= 0"],"postconditions":[{"assertion":"result >= 0"}]},{"id":"pc_7","description":"Invariant: Result is always an integer","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":0,"max_val":20},"m":{"min_val":0,"max_val":20}},"assumptions":["n >= 0","m >= 0"],"postconditions":[{"assertion":"isinstance(result, int)"}]},{"id":"pc_8","description":"Specific case: A(3, 1)","execution_statement":"result = eulerian_num(3, 1)","input_types":{},"postconditions":[{"assertion":"result == 3"}]},{"id":"pc_9","description":"Specific case: A(4, 2)","execution_statement":"result = eulerian_num(4, 2)","input_types":{},"postconditions":[{"assertion":"result == 6"}]},{"id":"pc_10","description":"Specific case: A(5, 0)","execution_statement":"result = eulerian_num(5, 0)","input_types":{},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_11","description":"Specific case: A(5, 5)","execution_statement":"result = eulerian_num(5, 5)","input_types":{},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_12","description":"Specific case: A(5, 6)","execution_statement":"result = eulerian_num(5, 6)","input_types":{},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_13","description":"Test with larger values for n and m, ensuring m < n","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":10,"max_val":15},"m":{"min_val":1,"max_val":9}},"assumptions":["m < n"],"postconditions":[{"assertion":"result >= 0"},{"assertion":"isinstance(result, int)"}]},{"id":"pc_14","description":"Test case where n is large and m is close to n","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":15,"max_val":20},"m":{"min_val":13,"max_val":19}},"assumptions":["m < n"],"postconditions":[{"assertion":"result >= 0"},{"assertion":"isinstance(result, int)"}]},{"id":"pc_15","description":"Test case where n is large and m is 0","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":20,"max_val":30},"m":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_16","description":"Test case where n is large and m is equal to n","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":20,"max_val":30},"m":{"min_val":20,"max_val":30}},"assumptions":["m == n"],"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_17","description":"Test case where n is large and m is greater than n","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":20,"max_val":30},"m":{"min_val":31,"max_val":40}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_18","description":"Test with negative inputs (should ideally not happen based on typical Eulerian number definition, but testing robustness)","execution_statement":"try: result = eulerian_num(n, m) except Exception as e: result = e","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"max_val":-1},"m":{"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, RecursionError) or isinstance(result, ValueError) or isinstance(result, IndexError)"}]},{"id":"pc_19","description":"Test with mixed types for n and m (expecting TypeError)","execution_statement":"try: result = eulerian_num(n, m) except Exception as e: result = e","input_types":{"n":"str","m":"int"},"input_constraints":{"n":{"min_len":1,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_20","description":"Test with None for n and m (expecting TypeError)","execution_statement":"try: result = eulerian_num(n, m) except Exception as e: result = e","input_types":{"n":"NoneType","m":"int"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60c8"},"test_cases":[{"id":"TC001","description":"Typical case with multiple sublists and strings.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":2,"max_size":5,"elements":{"min_size":1,"max_size":5,"elements":{"min_length":1,"max_length":10}}}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC002","description":"Edge case: Empty outer list.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":0,"max_size":0}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"result == []"}]},{"id":"TC003","description":"Edge case: Outer list with empty sublists.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":1,"max_size":3,"elements":{"min_size":0,"max_size":0}}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC004","description":"Boundary case: Single sublist with single string.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":1,"max_size":1,"elements":{"min_size":1,"max_size":1,"elements":{"min_length":1,"max_length":5}}}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC005","description":"Strings with different cases and special characters.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":2,"max_size":4,"elements":{"min_size":2,"max_size":4,"elements":{"min_length":1,"max_length":15,"max_codepoint":255}}}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC006","description":"Sublists with identical strings.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":2,"max_size":3,"elements":{"min_size":3,"max_size":3,"elements":{"value":"duplicate_string","min_length":5,"max_length":5}}}},"assumptions":["all(len(set(sublist)) == 1 for sublist in input_list)"],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC007","description":"Sublists with strings that are prefixes of each other.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":2,"max_size":3,"elements":{"min_size":2,"max_size":3,"elements":{"min_length":1,"max_length":10}}}},"assumptions":["all(sublist[i].startswith(sublist[i+1]) or sublist[i+1].startswith(sublist[i]) for sublist in input_list for i in range(len(sublist)-1))"],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC008","description":"Large number of sublists with short strings.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":50,"max_size":100,"elements":{"min_size":1,"max_size":5,"elements":{"min_length":1,"max_length":3}}}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC009","description":"Small number of sublists with long strings.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":1,"max_size":3,"elements":{"min_size":1,"max_size":3,"elements":{"min_length":50,"max_length":100}}}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC010","description":"Strings with unicode characters.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":2,"max_size":4,"elements":{"min_size":2,"max_size":4,"elements":{"min_length":1,"max_length":10,"max_codepoint":1114111}}}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC011","description":"Mixed length strings within sublists.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":2,"max_size":5,"elements":{"min_size":2,"max_size":5,"elements":{"min_length":0,"max_length":20}},"is_mixed":true}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC012","description":"Sublists with only one element.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":2,"max_size":5,"elements":{"min_size":1,"max_size":1,"elements":{"min_length":1,"max_length":10}}}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC013","description":"Strings containing numbers and symbols.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":2,"max_size":4,"elements":{"min_size":2,"max_size":4,"elements":{"min_length":1,"max_length":15,"pattern":"^[a-zA-Z-9!@#$%^&*()_+=-`~{}\\[\\]:;\"'<>?,./|\\ ]+$"}}}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC014","description":"Sublists with very similar strings.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":2,"max_size":3,"elements":{"min_size":3,"max_size":3,"elements":{"min_length":5,"max_length":10,"pattern":"abc.*"}}}},"assumptions":["all(sublist[i].startswith('abc') and sublist[i+1].startswith('abc') for sublist in input_list for i in range(len(sublist)-1))"],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC015","description":"Empty strings within sublists.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":2,"max_size":5,"elements":{"min_size":2,"max_size":5,"elements":{"min_length":0,"max_length":5}}}},"assumptions":["all('' in sublist for sublist in input_list)"],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC016","description":"Single sublist with multiple strings.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":1,"max_size":1,"elements":{"min_size":5,"max_size":10,"elements":{"min_length":1,"max_length":10}}}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC017","description":"Strings with leading/trailing spaces.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":2,"max_size":4,"elements":{"min_size":2,"max_size":4,"elements":{"min_length":1,"max_length":10,"pattern":"^\\s*.*\\s*$"}}}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC018","description":"Sublists with mixed string lengths and content.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":3,"max_size":6,"elements":{"min_size":3,"max_size":6,"elements":{"min_length":0,"max_length":25}},"is_mixed":true}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]},{"id":"TC019","description":"Boundary case: Single empty sublist.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":1,"max_size":1,"elements":{"min_size":0,"max_size":0}}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"result == [[]]"}]},{"id":"TC020","description":"Boundary case: Multiple sublists, each with one empty string.","execution_statement":"result = sort_sublists(input_list)","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_size":3,"max_size":5,"elements":{"min_size":1,"max_size":1,"elements":{"min_length":0,"max_length":0}}}},"assumptions":[],"postconditions":[{"assertion":"len(input_list) == len(result)"},{"assertion":"all(len(sublist) == len(sorted_sublist) for sublist, sorted_sublist in zip(input_list, result))"},{"assertion":"all(sorted(sublist) == sorted_sublist for sublist, sorted_sublist in zip(input_list, result))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60c9"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic sorting of sublists","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_codepoint":97,"max_codepoint":122,"max_len":1}}}},"execution_statement":"result = sort_sublists(input_list)","postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(sublist, list) for sublist in result)"},{"assertion":"all(all(sublist[i][0] <= sublist[i+1][0] for i in range(len(sublist) - 1)) for sublist in result)"},{"assertion":"len(result) == len(input_list) and all(len(result[i]) == len(input_list[i]) for i in range(len(input_list)))"}]},{"id":"pc_2","description":"Edge Case: Empty input list","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_len":0,"max_len":0}},"execution_statement":"result = sort_sublists(input_list)","postconditions":[{"assertion":"result == []"}]},{"id":"pc_3","description":"Edge Case: List with empty sublists","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_len":1,"max_len":5,"elements":{"min_len":0,"max_len":0}}},"execution_statement":"result = sort_sublists(input_list)","postconditions":[{"assertion":"all(len(sublist) == 0 for sublist in result)"}]},{"id":"pc_4","description":"Edge Case: Sublists with single element","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":1,"elements":{"min_codepoint":97,"max_codepoint":122,"max_len":1}}}},"execution_statement":"result = sort_sublists(input_list)","postconditions":[{"assertion":"all(len(sublist) == 1 for sublist in result)"},{"assertion":"result == input_list"}]},{"id":"pc_5","description":"Boundary Case: Large number of sublists","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_len":100,"max_len":200,"elements":{"min_len":1,"max_len":5,"elements":{"min_codepoint":97,"max_codepoint":122,"max_len":1}}}},"execution_statement":"result = sort_sublists(input_list)","postconditions":[{"assertion":"len(result) == len(input_list)"},{"assertion":"all(len(result[i]) == len(input_list[i]) for i in range(len(input_list)))"},{"assertion":"all(all(sublist[i][0] <= sublist[i+1][0] for i in range(len(sublist) - 1)) for sublist in result)"}]},{"id":"pc_6","description":"Boundary Case: Large sublists","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_len":1,"max_len":5,"elements":{"min_len":100,"max_len":200,"elements":{"min_codepoint":97,"max_codepoint":122,"max_len":1}}}},"execution_statement":"result = sort_sublists(input_list)","postconditions":[{"assertion":"len(result) == len(input_list)"},{"assertion":"all(len(result[i]) == len(input_list[i]) for i in range(len(input_list)))"},{"assertion":"all(all(sublist[i][0] <= sublist[i+1][0] for i in range(len(sublist) - 1)) for sublist in result)"}]},{"id":"pc_7","description":"Invariant: Elements within sublists are sorted by first character","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_len":1,"max_len":10,"elements":{"min_len":2,"max_len":10,"elements":{"min_codepoint":65,"max_codepoint":122,"max_len":1}}}},"execution_statement":"result = sort_sublists(input_list)","postconditions":[{"assertion":"all(all(sublist[i][0] <= sublist[i+1][0] for i in range(len(sublist) - 1)) for sublist in result)"}]},{"id":"pc_8","description":"Typical Case: Mixed case strings","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_codepoint":65,"max_codepoint":122,"max_len":1}},"is_mixed":true}},"execution_statement":"result = sort_sublists(input_list)","postconditions":[{"assertion":"all(all(sublist[i][0] <= sublist[i+1][0] for i in range(len(sublist) - 1)) for sublist in result)"}]},{"id":"pc_9","description":"Negative Test: Input contains non-string elements in sublists","input_types":{"input_list":"list[list[any]]"},"input_constraints":{"input_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5}}},"execution_statement":"try: result = sort_sublists(input_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Input is not a list of lists","input_types":{"input_list":"int"},"execution_statement":"try: result = sort_sublists(input_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Negative Test: Input is a list of non-lists","input_types":{"input_list":"list[int]"},"input_constraints":{"input_list":{"min_len":1,"max_len":5}},"execution_statement":"try: result = sort_sublists(input_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Invariant: All elements in the output are strings","input_types":{"input_list":"list[list[str]]"},"input_constraints":{"input_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_codepoint":97,"max_codepoint":122,"max_len":1}}}},"execution_statement":"result = sort_sublists(input_list)","postconditions":[{"assertion":"all(isinstance(item, str) for sublist in result for item in sublist)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60ca"},"test_cases":[{"id":"TC1","description":"Typical case: list of integers.","execution_statement":"result = count(lst)","input_types":{"lst":"List[int]"},"input_constraints":{"lst":{"min_val":-100,"max_val":100,"min_len":1,"max_len":100}},"postconditions":[{"assertion":"result == sum(lst)"}]},{"id":"TC2","description":"Boundary case: empty list.","execution_statement":"result = count(lst)","input_types":{"lst":"List[int]"},"input_constraints":{"lst":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == sum(lst)"}]},{"id":"TC3","description":"Boundary case: list with all zeros.","execution_statement":"result = count(lst)","input_types":{"lst":"List[int]"},"input_constraints":{"lst":{"min_val":0,"max_val":0,"min_len":1,"max_len":50}},"postconditions":[{"assertion":"result == sum(lst)"}]},{"id":"TC4","description":"Boundary case: list with all positive numbers.","execution_statement":"result = count(lst)","input_types":{"lst":"List[int]"},"input_constraints":{"lst":{"min_val":1,"max_val":100,"min_len":1,"max_len":50}},"postconditions":[{"assertion":"result == sum(lst)"}]},{"id":"TC5","description":"Boundary case: list with all negative numbers.","execution_statement":"result = count(lst)","input_types":{"lst":"List[int]"},"input_constraints":{"lst":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":50}},"postconditions":[{"assertion":"result == sum(lst)"}]},{"id":"TC6","description":"Edge case: list with large numbers.","execution_statement":"result = count(lst)","input_types":{"lst":"List[int]"},"input_constraints":{"lst":{"min_val":1000000,"max_val":2000000,"min_len":1,"max_len":10}},"postconditions":[{"assertion":"result == sum(lst)"}]},{"id":"TC7","description":"Edge case: list with small negative numbers.","execution_statement":"result = count(lst)","input_types":{"lst":"List[int]"},"input_constraints":{"lst":{"min_val":-10,"max_val":-1,"min_len":1,"max_len":10}},"postconditions":[{"assertion":"result == sum(lst)"}]},{"id":"TC8","description":"Mixed case: list with positive, negative, and zero.","execution_statement":"result = count(lst)","input_types":{"lst":"List[int]"},"input_constraints":{"lst":{"min_val":-50,"max_val":50,"min_len":5,"max_len":50,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(lst)"}]},{"id":"TC9","description":"Large list with mixed values.","execution_statement":"result = count(lst)","input_types":{"lst":"List[int]"},"input_constraints":{"lst":{"min_val":-1000,"max_val":1000,"min_len":500,"max_len":1000,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(lst)"}]},{"id":"TC10","description":"List with single element (positive).","execution_statement":"result = count(lst)","input_types":{"lst":"List[int]"},"input_constraints":{"lst":{"min_val":1,"max_val":100,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == sum(lst)"}]},{"id":"TC11","description":"List with single element (negative).","execution_statement":"result = count(lst)","input_types":{"lst":"List[int]"},"input_constraints":{"lst":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == sum(lst)"}]},{"id":"TC12","description":"List with single element (zero).","execution_statement":"result = count(lst)","input_types":{"lst":"List[int]"},"input_constraints":{"lst":{"min_val":0,"max_val":0,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == sum(lst)"}]},{"id":"TC13","description":"Negative test: input is not a list (int).","execution_statement":"result = count(lst)","input_types":{"lst":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC14","description":"Negative test: input is not a list (None).","execution_statement":"result = count(lst)","input_types":{"lst":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC15","description":"Negative test: list contains non-integer types (float).","execution_statement":"result = count(lst)","input_types":{"lst":"List[Union[int, float]]"},"input_constraints":{"lst":{"min_val":-100,"max_val":100,"min_len":1,"max_len":50,"allow_none":false,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC16","description":"Negative test: list contains non-integer types (string).","execution_statement":"result = count(lst)","input_types":{"lst":"List[Union[int, str]]"},"input_constraints":{"lst":{"min_val":-100,"max_val":100,"min_len":1,"max_len":50,"allow_none":false,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC17","description":"Negative test: list contains non-integer types (None).","execution_statement":"result = count(lst)","input_types":{"lst":"List[Optional[int]]"},"input_constraints":{"lst":{"min_val":-100,"max_val":100,"min_len":1,"max_len":50,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60cb"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic list of booleans","execution_statement":"result = count(lst)","input_types":{"lst":"list[bool]"},"input_constraints":{"lst":{"min_len":1,"max_len":100}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result <= len(lst)"},{"assertion":"result == sum(1 for x in lst if x is True)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = count(lst)","input_types":{"lst":"list[bool]"},"input_constraints":{"lst":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with only True values","execution_statement":"result = count(lst)","input_types":{"lst":"list[bool]"},"input_constraints":{"lst":{"min_len":1,"max_len":50}},"postconditions":[{"assertion":"result == len(lst)"}],"assumptions":["all(x is True for x in lst)"]},{"id":"pc_4","description":"Edge Case: List with only False values","execution_statement":"result = count(lst)","input_types":{"lst":"list[bool]"},"input_constraints":{"lst":{"min_len":1,"max_len":50}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["all(x is False for x in lst)"]},{"id":"pc_5","description":"Boundary Case: Large list of booleans","execution_statement":"result = count(lst)","input_types":{"lst":"list[bool]"},"input_constraints":{"lst":{"min_len":1000,"max_len":1000}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result <= len(lst)"},{"assertion":"result == sum(1 for x in lst if x is True)"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = count(lst) except Exception as e: result = e","input_types":{"lst":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = count(lst) except Exception as e: result = e","input_types":{"lst":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: List contains non-boolean, non-numeric types (string)","execution_statement":"try: result = count(lst) except Exception as e: result = e","input_types":{"lst":"list[str]"},"input_constraints":{"lst":{"min_len":1,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: List contains mixed types (int and string)","execution_statement":"try: result = count(lst) except Exception as e: result = e","input_types":{"lst":"list[Union[int, str]]"},"input_constraints":{"lst":{"min_len":2,"max_len":10,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Test with a mix of booleans and integers (assuming sum handles it)","execution_statement":"result = count(lst)","input_types":{"lst":"list[Union[bool, int]]"},"input_constraints":{"lst":{"min_len":1,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result == sum(lst)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60cc"},"test_cases":[{"id":"pc_1","description":"Happy path: typical lists and tuples.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[int]","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"min_val":0,"max_val":100},"test_tup":{"min_len":1,"max_len":5,"min_val":0,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup) + len(test_list)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_2","description":"Edge case: empty list.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[int]","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0},"test_tup":{"min_len":1,"max_len":5,"min_val":0,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup)"},{"assertion":"result == test_tup"}],"assumptions":[]},{"id":"pc_3","description":"Edge case: empty tuple.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[int]","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"min_val":0,"max_val":100},"test_tup":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list)"},{"assertion":"result == tuple(test_list)"}],"assumptions":[]},{"id":"pc_4","description":"Edge case: both empty.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[int]","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0},"test_tup":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == 0"},{"assertion":"result == tuple()"}],"assumptions":[]},{"id":"pc_5","description":"Boundary case: single element list and tuple.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[int]","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"min_val":0,"max_val":100},"test_tup":{"min_len":1,"max_len":1,"min_val":0,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == 2"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_6","description":"Mixed data types in list and tuple.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[Union[int, str, bool]]","test_tup":"Tuple[Union[int, str, bool], ...]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"is_mixed":true,"max_codepoint":127},"test_tup":{"min_len":1,"max_len":5,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup) + len(test_list)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_7","description":"Large numbers in list and tuple.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[int]","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"min_val":1000000,"max_val":2000000},"test_tup":{"min_len":1,"max_len":5,"min_val":1000000,"max_val":2000000}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup) + len(test_list)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_8","description":"Negative test: invalid type for test_list (int).","execution_statement":"try: result = add_lists(test_list, test_tup) except Exception as e: result = e","input_types":{"test_list":"int","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_tup":{"min_len":1,"max_len":5,"min_val":0,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative test: invalid type for test_tup (str).","execution_statement":"try: result = add_lists(test_list, test_tup) except Exception as e: result = e","input_types":{"test_list":"List[int]","test_tup":"str"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"min_val":0,"max_val":100},"test_tup":{"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative test: invalid type for test_tup (None).","execution_statement":"try: result = add_lists(test_list, test_tup) except Exception as e: result = e","input_types":{"test_list":"List[int]","test_tup":"None"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"min_val":0,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Test with string elements.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[str]","test_tup":"Tuple[str, ...]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"pattern":"[a-z]{1,5}"},"test_tup":{"min_len":1,"max_len":5,"pattern":"[a-z]{1,5}"}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup) + len(test_list)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_12","description":"Test with boolean elements.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[bool]","test_tup":"Tuple[bool, ...]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"test_tup":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup) + len(test_list)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_13","description":"Test with mixed types including None in list.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[Optional[int]]","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"allow_none":true,"is_mixed":true},"test_tup":{"min_len":1,"max_len":5,"min_val":0,"max_val":100,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup) + len(test_list)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_14","description":"Test with mixed types including None in tuple.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[int]","test_tup":"Tuple[Optional[int], ...]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"min_val":0,"max_val":100,"is_mixed":true},"test_tup":{"min_len":1,"max_len":5,"allow_none":true,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup) + len(test_list)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_15","description":"Test with large list and tuple.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[int]","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_list":{"min_len":100,"max_len":200,"min_val":0,"max_val":1000},"test_tup":{"min_len":100,"max_len":200,"min_val":0,"max_val":1000}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup) + len(test_list)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_16","description":"Test with negative numbers.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[int]","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"min_val":-100,"max_val":-1},"test_tup":{"min_len":1,"max_len":5,"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup) + len(test_list)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_17","description":"Test with mixed positive and negative numbers.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[int]","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"min_val":-100,"max_val":100,"is_mixed":true},"test_tup":{"min_len":1,"max_len":5,"min_val":-100,"max_val":100,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup) + len(test_list)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_18","description":"Test with tuple containing only one element.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[int]","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"min_val":0,"max_val":100},"test_tup":{"min_len":1,"max_len":1,"min_val":0,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup) + len(test_list)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_19","description":"Test with list containing only one element.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[int]","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"min_val":0,"max_val":100},"test_tup":{"min_len":1,"max_len":5,"min_val":0,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup) + len(test_list)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_20","description":"Test with empty list and non-empty tuple.","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"List[int]","test_tup":"Tuple[int, ...]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0},"test_tup":{"min_len":1,"max_len":5,"min_val":0,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup)"},{"assertion":"result == test_tup"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60cd"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic list and tuple concatenation","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10},"test_tup":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list input","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0},"test_tup":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"result == test_tup"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Empty tuple input","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10},"test_tup":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == tuple(test_list)"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Both inputs empty","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0},"test_tup":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == tuple()"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Case: Large list and tuple","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":100,"max_len":100},"test_tup":{"min_len":100,"max_len":100}},"postconditions":[{"assertion":"len(result) == 200"},{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_6","description":"Mixed Data Types in list and tuple","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[object]","test_tup":"tuple[object]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"is_mixed":true},"test_tup":{"min_len":1,"max_len":5,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_7","description":"List with None values","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int | None]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"allow_none":true},"test_tup":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_8","description":"Tuple with None values","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[int | None]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"test_tup":{"min_len":1,"max_len":5,"allow_none":true}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_9","description":"Both inputs with None values","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int | None]","test_tup":"tuple[int | None]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"allow_none":true},"test_tup":{"min_len":1,"max_len":5,"allow_none":true}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_10","description":"List with different numeric types","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[float]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"test_tup":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_11","description":"Tuple with different numeric types","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[float]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"test_tup":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_12","description":"List with strings","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[str]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"max_codepoint":127},"test_tup":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_13","description":"Tuple with strings","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[str]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"test_tup":{"min_len":1,"max_len":5,"max_codepoint":127}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_14","description":"List with booleans","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[bool]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"test_tup":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_15","description":"Tuple with booleans","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[bool]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"test_tup":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_16","description":"List with nested tuples","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[tuple[int]]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"test_tup":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_17","description":"Tuple with nested lists","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"test_tup":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_18","description":"List with empty tuples","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[tuple]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"test_tup":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_19","description":"Tuple with empty lists","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[list]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"test_tup":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]},{"id":"pc_20","description":"List and tuple with negative numbers","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":10},"test_tup":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":10}},"postconditions":[{"assertion":"result == test_tup + tuple(test_list)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60ce"},"test_cases":[{"id":"TC001","description":"Merge three typical sorted lists of integers.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC002","description":"Merge three lists, one of which is empty.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_len":0,"max_len":10,"sorted":"ascending"},"num2":{"min_len":0,"max_len":10,"sorted":"ascending"},"num3":{"min_len":0,"max_len":10,"sorted":"ascending"}},"assumptions":["len(list1) == 0 or len(list2) == 0 or len(list3) == 0"],"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC003","description":"Merge three empty lists.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_len":0,"max_len":0,"sorted":"ascending"},"num2":{"min_len":0,"max_len":0,"sorted":"ascending"},"num3":{"min_len":0,"max_len":0,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC004","description":"Merge lists with duplicate elements.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_len":1,"max_len":10,"sorted":"ascending"}},"assumptions":["list1[0] == list2[0] or list1[0] == list3[0] or list2[0] == list3[0]"],"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC005","description":"Merge lists with single element.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_len":1,"max_len":1,"sorted":"ascending"},"num2":{"min_len":1,"max_len":1,"sorted":"ascending"},"num3":{"min_len":1,"max_len":1,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC006","description":"Merge lists with negative numbers.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC007","description":"Merge lists with large numbers.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_val":1000000,"max_val":2000000,"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_val":1000000,"max_val":2000000,"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_val":1000000,"max_val":2000000,"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC008","description":"Merge lists with mixed positive and negative numbers.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_val":-100,"max_val":100,"min_len":1,"max_len":10,"sorted":"ascending","is_mixed":true},"num2":{"min_val":-100,"max_val":100,"min_len":1,"max_len":10,"sorted":"ascending","is_mixed":true},"num3":{"min_val":-100,"max_val":100,"min_len":1,"max_len":10,"sorted":"ascending","is_mixed":true}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC009","description":"Merge lists where one list contains all elements.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_val":1,"max_val":5,"min_len":5,"max_len":5,"sorted":"ascending","unique":true},"num2":{"min_val":1,"max_val":5,"min_len":0,"max_len":0,"sorted":"ascending"},"num3":{"min_val":1,"max_val":5,"min_len":0,"max_len":0,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC010","description":"Merge lists with boundary integer values.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_val":-2147483648,"max_val":2147483647,"min_len":1,"max_len":5,"sorted":"ascending"},"num2":{"min_val":-2147483648,"max_val":2147483647,"min_len":1,"max_len":5,"sorted":"ascending"},"num3":{"min_val":-2147483648,"max_val":2147483647,"min_len":1,"max_len":5,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC011","description":"Merge lists with overlapping ranges.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_val":1,"max_val":10,"min_len":3,"max_len":5,"sorted":"ascending"},"num2":{"min_val":5,"max_val":15,"min_len":3,"max_len":5,"sorted":"ascending"},"num3":{"min_val":10,"max_val":20,"min_len":3,"max_len":5,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC012","description":"Merge lists with identical elements across all lists.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_val":5,"max_val":5,"min_len":3,"max_len":5,"sorted":"ascending"},"num2":{"min_val":5,"max_val":5,"min_len":3,"max_len":5,"sorted":"ascending"},"num3":{"min_val":5,"max_val":5,"min_len":3,"max_len":5,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC013","description":"Merge lists with large number of elements.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_len":100,"max_len":200,"sorted":"ascending"},"num2":{"min_len":100,"max_len":200,"sorted":"ascending"},"num3":{"min_len":100,"max_len":200,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC014","description":"Merge lists with zero.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_val":-10,"max_val":10,"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_val":-10,"max_val":10,"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_val":-10,"max_val":10,"min_len":1,"max_len":10,"sorted":"ascending"}},"assumptions":["0 in list1 or 0 in list2 or 0 in list3"],"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC015","description":"Merge lists with only one list having elements.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_len":5,"max_len":10,"sorted":"ascending"},"num2":{"min_len":0,"max_len":0,"sorted":"ascending"},"num3":{"min_len":0,"max_len":0,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC016","description":"Merge lists with two lists having elements.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_len":5,"max_len":10,"sorted":"ascending"},"num2":{"min_len":5,"max_len":10,"sorted":"ascending"},"num3":{"min_len":0,"max_len":0,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC017","description":"Merge lists with elements that are close to each other.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_val":1,"max_val":5,"min_len":3,"max_len":5,"sorted":"ascending"},"num2":{"min_val":2,"max_val":6,"min_len":3,"max_len":5,"sorted":"ascending"},"num3":{"min_val":3,"max_val":7,"min_len":3,"max_len":5,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC018","description":"Merge lists with elements far apart.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_val":1,"max_val":10,"min_len":3,"max_len":5,"sorted":"ascending"},"num2":{"min_val":100,"max_val":110,"min_len":3,"max_len":5,"sorted":"ascending"},"num3":{"min_val":1000,"max_val":1010,"min_len":3,"max_len":5,"sorted":"ascending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC019","description":"Merge lists with unique elements.","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_len":1,"max_len":10,"sorted":"ascending","unique":true},"num2":{"min_len":1,"max_len":10,"sorted":"ascending","unique":true},"num3":{"min_len":1,"max_len":10,"sorted":"ascending","unique":true}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]},{"id":"TC020","description":"Merge lists with descending order (should be sorted by function).","execution_statement":"result = merge_sorted_list(list1, list2, list3)","input_types":{"num1":"List[int]","num2":"List[int]","num3":"List[int]"},"input_constraints":{"num1":{"min_len":1,"max_len":10,"sorted":"descending"},"num2":{"min_len":1,"max_len":10,"sorted":"descending"},"num3":{"min_len":1,"max_len":10,"sorted":"descending"}},"postconditions":[{"assertion":"sorted(result) == sorted(list1 + list2 + list3)"},{"assertion":"len(result) == len(list1) + len(list2) + len(list3)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60cf"},"test_cases":[{"id":"pc_1","description":"Happy Path: Merging three non-empty sorted lists","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"len(result) == len(num1) + len(num2) + len(num3)"},{"assertion":"sorted(num1 + num2 + num3) == result"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: All three lists are empty","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_len":0,"max_len":0},"num2":{"min_len":0,"max_len":0},"num3":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: One list is empty, others are not","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_len":0,"max_len":0},"num2":{"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"len(result) == len(num1) + len(num2) + len(num3)"},{"assertion":"sorted(num1 + num2 + num3) == result"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Two lists are empty, one is not","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_len":0,"max_len":0},"num2":{"min_len":0,"max_len":0},"num3":{"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"len(result) == len(num1) + len(num2) + len(num3)"},{"assertion":"sorted(num1 + num2 + num3) == result"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Case: Lists with single elements","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_len":1,"max_len":1,"sorted":"ascending"},"num2":{"min_len":1,"max_len":1,"sorted":"ascending"},"num3":{"min_len":1,"max_len":1,"sorted":"ascending"}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"len(result) == 3"},{"assertion":"sorted(num1 + num2 + num3) == result"}],"assumptions":[]},{"id":"pc_6","description":"Typical Case: Lists with duplicate numbers","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_len":3,"max_len":10,"sorted":"ascending","unique":false},"num2":{"min_len":3,"max_len":10,"sorted":"ascending","unique":false},"num3":{"min_len":3,"max_len":10,"sorted":"ascending","unique":false}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"len(result) == len(num1) + len(num2) + len(num3)"},{"assertion":"sorted(num1 + num2 + num3) == result"}],"assumptions":[]},{"id":"pc_7","description":"Typical Case: Lists with negative numbers","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"len(result) == len(num1) + len(num2) + len(num3)"},{"assertion":"sorted(num1 + num2 + num3) == result"}],"assumptions":[]},{"id":"pc_8","description":"Typical Case: Lists with mixed positive and negative numbers","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_val":-50,"max_val":50,"min_len":1,"max_len":10,"sorted":"ascending","is_mixed":true},"num2":{"min_val":-50,"max_val":50,"min_len":1,"max_len":10,"sorted":"ascending","is_mixed":true},"num3":{"min_val":-50,"max_val":50,"min_len":1,"max_len":10,"sorted":"ascending","is_mixed":true}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"len(result) == len(num1) + len(num2) + len(num3)"},{"assertion":"sorted(num1 + num2 + num3) == result"}],"assumptions":[]},{"id":"pc_9","description":"Boundary Case: Large lists","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_len":100,"max_len":200,"sorted":"ascending"},"num2":{"min_len":100,"max_len":200,"sorted":"ascending"},"num3":{"min_len":100,"max_len":200,"sorted":"ascending"}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"len(result) == len(num1) + len(num2) + len(num3)"},{"assertion":"sorted(num1 + num2 + num3) == result"}],"assumptions":[]},{"id":"pc_10","description":"Edge Case: Input lists contain None (should raise TypeError during sorting)","execution_statement":"try: result = merge_sorted_list(num1, num2, num3) except Exception as e: result = e","input_types":{"num1":"list[int | None]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_len":1,"max_len":5,"allow_none":true},"num2":{"min_len":1,"max_len":5,"sorted":"ascending"},"num3":{"min_len":1,"max_len":5,"sorted":"ascending"}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Edge Case: Input lists contain non-numeric types (should raise TypeError during sorting)","execution_statement":"try: result = merge_sorted_list(num1, num2, num3) except Exception as e: result = e","input_types":{"num1":"list[int | str]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_len":1,"max_len":5,"is_mixed":true,"max_codepoint":127},"num2":{"min_len":1,"max_len":5,"sorted":"ascending"},"num3":{"min_len":1,"max_len":5,"sorted":"ascending"}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Happy Path: Lists with floats","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[float]","num2":"list[float]","num3":"list[float]"},"input_constraints":{"num1":{"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"len(result) == len(num1) + len(num2) + len(num3)"},{"assertion":"sorted(num1 + num2 + num3) == result"}],"assumptions":[]},{"id":"pc_13","description":"Happy Path: Lists with mixed integers and floats","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int | float]","num2":"list[int | float]","num3":"list[int | float]"},"input_constraints":{"num1":{"min_len":1,"max_len":10,"sorted":"ascending","is_mixed":true},"num2":{"min_len":1,"max_len":10,"sorted":"ascending","is_mixed":true},"num3":{"min_len":1,"max_len":10,"sorted":"ascending","is_mixed":true}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result)-1))"},{"assertion":"len(result) == len(num1) + len(num2) + len(num3)"},{"assertion":"sorted(num1 + num2 + num3) == result"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60d0"},"test_cases":[{"id":"pc_1","description":"Typical case with a mix of 0s and 1s and a moderate number of rotations.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^[01]+$","min_len":1,"max_len":50,"max_codepoint":255},"n":{"min_val":1,"max_val":50}},"postconditions":[{"assertion":"result >= 0 and result <= n"}],"assumptions":["n <= len(s)"]},{"id":"pc_2","description":"Edge case: String with all 1s.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"min_val":"1","max_val":"1","min_len":1,"max_len":50,"max_codepoint":255},"n":{"min_val":1,"max_val":50}},"postconditions":[{"assertion":"result == n"}],"assumptions":["n <= len(s)"]},{"id":"pc_3","description":"Edge case: String with all 0s.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"min_val":"0","max_val":"0","min_len":1,"max_len":50,"max_codepoint":255},"n":{"min_val":1,"max_val":50}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["n <= len(s)"]},{"id":"pc_4","description":"Boundary case: Minimum string length (1) and minimum rotations (1).","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^[01]+$","min_len":1,"max_len":1,"max_codepoint":255},"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result >= 0 and result <= n"}],"assumptions":["n <= len(s)"]},{"id":"pc_5","description":"Boundary case: String length equals rotations.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^[01]+$","min_len":10,"max_len":10,"max_codepoint":255},"n":{"min_val":10,"max_val":10}},"postconditions":[{"assertion":"result >= 0 and result <= n"}],"assumptions":["n == len(s)"]},{"id":"pc_6","description":"Case where n is 0 (should not happen due to min_val=1, but good to consider if min_val changes).","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^[01]+$","min_len":1,"max_len":50,"max_codepoint":255},"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["n <= len(s)"]},{"id":"pc_7","description":"Long string with alternating 0s and 1s.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^(01)+$","min_len":100,"max_len":100,"max_codepoint":255},"n":{"min_val":50,"max_val":100}},"postconditions":[{"assertion":"result >= 0 and result <= n"}],"assumptions":["n <= len(s)"]},{"id":"pc_8","description":"Long string with alternating 1s and 0s.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^(10)+$","min_len":100,"max_len":100,"max_codepoint":255},"n":{"min_val":50,"max_val":100}},"postconditions":[{"assertion":"result >= 0 and result <= n"}],"assumptions":["n <= len(s)"]},{"id":"pc_9","description":"String with a single '1' at the beginning.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^10*$","min_len":1,"max_len":50,"max_codepoint":255},"n":{"min_val":1,"max_val":50}},"postconditions":[{"assertion":"result >= 0 and result <= n"}],"assumptions":["n <= len(s)"]},{"id":"pc_10","description":"String with a single '1' at the end.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^0*1$","min_len":1,"max_len":50,"max_codepoint":255},"n":{"min_val":1,"max_val":50}},"postconditions":[{"assertion":"result >= 0 and result <= n"}],"assumptions":["n <= len(s)"]},{"id":"pc_11","description":"String with '1' in the middle.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^0*10*$","min_len":3,"max_len":50,"max_codepoint":255},"n":{"min_val":1,"max_val":50}},"postconditions":[{"assertion":"result >= 0 and result <= n"}],"assumptions":["n <= len(s)"]},{"id":"pc_12","description":"Maximum string length and maximum rotations.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^[01]+$","min_len":0,"max_len":2,"max_codepoint":255},"n":{"min_val":100,"max_val":2}},"postconditions":[{"assertion":"result >= 0 and result <= n"}],"assumptions":["n <= len(s)"]},{"id":"pc_13","description":"String with many 1s and few rotations.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^1+$","min_len":50,"max_len":50,"max_codepoint":255},"n":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == n"}],"assumptions":["n <= len(s)"]},{"id":"pc_14","description":"String with many 0s and few rotations.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^0+$","min_len":50,"max_len":50,"max_codepoint":255},"n":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["n <= len(s)"]},{"id":"pc_15","description":"String with a single '1' and rotations equal to string length.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^1$","min_len":1,"max_len":1,"max_codepoint":255},"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":["n == len(s)"]},{"id":"pc_16","description":"String with a single '0' and rotations equal to string length.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^0$","min_len":1,"max_len":1,"max_codepoint":255},"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["n == len(s)"]},{"id":"pc_17","description":"String with many 1s and rotations equal to string length.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^1+$","min_len":20,"max_len":20,"max_codepoint":255},"n":{"min_val":20,"max_val":20}},"postconditions":[{"assertion":"result == n"}],"assumptions":["n == len(s)"]},{"id":"pc_18","description":"String with many 0s and rotations equal to string length.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^0+$","min_len":20,"max_len":20,"max_codepoint":255},"n":{"min_val":20,"max_val":20}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["n == len(s)"]},{"id":"pc_19","description":"String with alternating 0s and 1s, rotations less than string length.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^(01)+$","min_len":30,"max_len":30,"max_codepoint":255},"n":{"min_val":15,"max_val":29}},"postconditions":[{"assertion":"result >= 0 and result <= n"}],"assumptions":["n <= len(s)"]},{"id":"pc_20","description":"String with alternating 1s and 0s, rotations less than string length.","execution_statement":"result = odd_Equivalent(s, n)","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"pattern":"^(10)+$","min_len":30,"max_len":30,"max_codepoint":255},"n":{"min_val":15,"max_val":29}},"postconditions":[{"assertion":"result >= 0 and result <= n"}],"assumptions":["n <= len(s)"]}]}
{"_id":{"$oid":"692adffe1b18223597bc60d1"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with typical inputs.","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"min_len":1,"max_len":100,"pattern":"^[01]+$","max_codepoint":255},"n":{"min_val":1,"max_val":100}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= n"},{"assertion":"result <= len(s)"}]},{"id":"pc_2","description":"Edge Case: Empty string input.","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"min_len":0,"max_len":0,"pattern":"^[01]*$","max_codepoint":255},"n":{"min_val":1,"max_val":100}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_3","description":"Edge Case: Zero rotation count.","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"min_len":1,"max_len":100,"pattern":"^[01]+$","max_codepoint":255},"n":{"min_val":0,"max_val":0}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_4","description":"Edge Case: String contains only zeros.","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"min_len":1,"max_len":100,"pattern":"^0+$","max_codepoint":255},"n":{"min_val":1,"max_val":100}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_5","description":"Edge Case: String contains only ones.","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"min_len":1,"max_len":100,"pattern":"^1+$","max_codepoint":255},"n":{"min_val":1,"max_val":100}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == min(len(s), n)"}]},{"id":"pc_6","description":"Boundary Value: Rotation count exceeds string length.","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"min_len":1,"max_len":50,"pattern":"^[01]+$","max_codepoint":255},"n":{"min_val":51,"max_val":100}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result <= len(s)"}]},{"id":"pc_7","description":"Invariant: Count is always non-negative.","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"min_len":0,"max_len":100,"pattern":"^[01]*$","max_codepoint":255},"n":{"min_val":0,"max_val":100}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result >= 0"}]},{"id":"pc_8","description":"Invariant: Count is less than or equal to rotation count.","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"min_len":0,"max_len":100,"pattern":"^[01]*$","max_codepoint":255},"n":{"min_val":0,"max_val":100}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result <= n"}]},{"id":"pc_9","description":"Invariant: Count is less than or equal to string length.","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"min_len":0,"max_len":100,"pattern":"^[01]*$","max_codepoint":255},"n":{"min_val":0,"max_val":100}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result <= len(s)"}]},{"id":"pc_10","description":"Large string and rotation count.","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"min_len":100,"max_len":1000,"pattern":"^[01]+$","max_codepoint":255},"n":{"min_val":100,"max_val":1000}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= n"},{"assertion":"result <= len(s)"}]},{"id":"pc_11","description":"Negative Test: Invalid type for string 's' (integer).","input_types":{"s":"int","n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":100}},"execution_statement":"try: result = odd_Equivalent(s, n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: Invalid type for rotation count 'n' (string).","input_types":{"s":"str","n":"str"},"input_constraints":{"s":{"min_len":1,"max_len":100,"pattern":"^[01]+$","max_codepoint":255},"n":{"min_len":1,"max_len":5,"max_codepoint":255}},"execution_statement":"try: result = odd_Equivalent(s, n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60d2"},"test_cases":[{"id":"TC001","description":"Typical case with common elements.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":2,"max_len":5,"element_constraints":{"min_val":1,"max_val":10}}}},"assumptions":["len(nestedlist) > 1"],"postconditions":[{"assertion":"set(result) == set.intersection(*map(set, nestedlist))"}]},{"id":"TC002","description":"Edge case: Empty input list.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[int]]"},"input_constraints":{"nestedlist":{"max_len":0}},"postconditions":[{"assertion":"set(result) == set()"}]},{"id":"TC003","description":"Edge case: List with one empty sublist.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[int]]"},"input_constraints":{"nestedlist":{"min_len":1,"max_len":5,"element_constraints":{"min_len":0,"max_len":5,"element_constraints":{"min_val":1,"max_val":10}}}},"assumptions":["any(len(sublist) == 0 for sublist in nestedlist)"],"postconditions":[{"assertion":"set(result) == set()"}]},{"id":"TC004","description":"Edge case: All sublists are empty.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"max_len":0}}},"assumptions":["len(nestedlist) > 1"],"postconditions":[{"assertion":"set(result) == set()"}]},{"id":"TC005","description":"No common elements between sublists.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"element_constraints":{"min_val":1,"max_val":10}}}},"assumptions":["len(set.intersection(*map(set, nestedlist))) == 0"],"postconditions":[{"assertion":"set(result) == set()"}]},{"id":"TC006","description":"All elements are common.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"element_constraints":{"min_val":1,"max_val":10}}}},"assumptions":["len(set.intersection(*map(set, nestedlist))) == len(nestedlist[0])"],"postconditions":[{"assertion":"set(result) == set(nestedlist[0])"}]},{"id":"TC007","description":"Sublists with different lengths but common elements.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":1,"max_len":10,"element_constraints":{"min_val":1,"max_val":20}}}},"assumptions":["len(set.intersection(*map(set, nestedlist))) > 0"],"postconditions":[{"assertion":"set(result) == set.intersection(*map(set, nestedlist))"}]},{"id":"TC008","description":"Input with duplicate elements within sublists.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":2,"max_len":5,"element_constraints":{"min_val":1,"max_val":10}}}},"assumptions":["len(nestedlist[0]) != len(set(nestedlist[0]))"],"postconditions":[{"assertion":"set(result) == set.intersection(*map(set, nestedlist))"}]},{"id":"TC009","description":"Input with mixed data types (strings and integers).","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[Union[int, str]]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"element_constraints":{"is_hashable_mix":true}},"is_mixed":true}},"assumptions":["len(nestedlist) > 1"],"postconditions":[{"assertion":"set(result) == set.intersection(*map(set, nestedlist))"}]},{"id":"TC010","description":"Large number of sublists with few common elements.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[int]]"},"input_constraints":{"nestedlist":{"min_len":50,"max_len":100,"element_constraints":{"min_len":1,"max_len":5,"element_constraints":{"min_val":1,"max_val":1000}}}},"assumptions":["len(nestedlist) > 1"],"postconditions":[{"assertion":"set(result) == set.intersection(*map(set, nestedlist))"}]},{"id":"TC011","description":"Large sublists with many common elements.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":50,"max_len":100,"element_constraints":{"min_val":1,"max_val":100}}}},"assumptions":["len(nestedlist) > 1"],"postconditions":[{"assertion":"set(result) == set.intersection(*map(set, nestedlist))"}]},{"id":"TC012","description":"Input with negative integers.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"element_constraints":{"min_val":-10,"max_val":-1}}}},"assumptions":["len(nestedlist) > 1"],"postconditions":[{"assertion":"set(result) == set.intersection(*map(set, nestedlist))"}]},{"id":"TC013","description":"Input with boolean values.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[bool]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":1,"max_len":5}}},"assumptions":["len(nestedlist) > 1"],"postconditions":[{"assertion":"set(result) == set.intersection(*map(set, nestedlist))"}]},{"id":"TC014","description":"Input with None values (requires hashable_mix).","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[Optional[int]]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"allow_none":true,"is_hashable_mix":true}}},"assumptions":["len(nestedlist) > 1"],"postconditions":[{"assertion":"set(result) == set.intersection(*map(set, nestedlist))"}]},{"id":"TC015","description":"Input with tuples as elements.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[tuple[int, str]]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"element_constraints":{"is_hashable_mix":true}}}},"assumptions":["len(nestedlist) > 1"],"postconditions":[{"assertion":"set(result) == set.intersection(*map(set, nestedlist))"}]},{"id":"TC016","description":"Input with identical sublists.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"element_constraints":{"min_val":1,"max_val":10}}}},"assumptions":["len(set(map(tuple, nestedlist))) == 1"],"postconditions":[{"assertion":"set(result) == set(nestedlist[0])"}]},{"id":"TC017","description":"Input with only one sublist (edge case).","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[int]]"},"input_constraints":{"nestedlist":{"min_len":1,"max_len":1,"element_constraints":{"min_len":1,"max_len":5,"element_constraints":{"min_val":1,"max_val":10}}}},"postconditions":[{"assertion":"set(result) == set(nestedlist[0])"}]},{"id":"TC018","description":"Input with floating point numbers.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[float]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"element_constraints":{"min_val":1.0,"max_val":10.0}}}},"assumptions":["len(nestedlist) > 1"],"postconditions":[{"assertion":"set(result) == set.intersection(*map(set, nestedlist))"}]},{"id":"TC019","description":"Input with strings of varying lengths.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[str]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"element_constraints":{"min_len":1,"max_len":10}}}},"assumptions":["len(nestedlist) > 1"],"postconditions":[{"assertion":"set(result) == set.intersection(*map(set, nestedlist))"}]},{"id":"TC020","description":"Input with a mix of integers and strings, ensuring commonality.","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"List[List[Union[int, str]]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5,"element_constraints":{"min_len":2,"max_len":5,"element_constraints":{"is_hashable_mix":true}}}},"assumptions":["len(nestedlist) > 1","len(set.intersection(*map(set, nestedlist))) > 0"],"postconditions":[{"assertion":"set(result) == set.intersection(*map(set, nestedlist))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60d3"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic intersection","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"list[list[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5},"nestedlist[*]":{"min_len":1,"max_len":10}},"assumptions":["len(nestedlist) > 0"],"postconditions":[{"assertion":"all(all(elem in sublist for sublist in nestedlist) for elem in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"len(result) <= min(len(sublist) for sublist in nestedlist)"}]},{"id":"pc_2","description":"Edge Case: Empty input list","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"list[list[int]]"},"input_constraints":{"nestedlist":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == []"}]},{"id":"pc_3","description":"Edge Case: One inner list is empty","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"list[list[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5},"nestedlist[*]":{"min_len":0,"max_len":10}},"assumptions":["any(not sublist for sublist in nestedlist)"],"postconditions":[{"assertion":"result == []"}]},{"id":"pc_4","description":"Edge Case: All inner lists are empty","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"list[list[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5},"nestedlist[*]":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == []"}]},{"id":"pc_5","description":"Edge Case: Single inner list","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"list[list[int]]"},"input_constraints":{"nestedlist":{"min_len":1,"max_len":1},"nestedlist[*]":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"set(result) == set(nestedlist[0])"}]},{"id":"pc_6","description":"Happy Path: Constructive intersection (forcing overlap)","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"list[list[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":3},"nestedlist[*]":{"min_val":1,"max_val":5,"min_len":2,"max_len":5}},"assumptions":["len(nestedlist) > 0"],"postconditions":[{"assertion":"all(all(elem in sublist for sublist in nestedlist) for elem in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"len(result) <= min(len(sublist) for sublist in nestedlist)"}]},{"id":"pc_7","description":"Happy Path: Different data types (hashable)","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"list[list[Union[int, str, bool, None, tuple]]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":4},"nestedlist[*]":{"min_len":1,"max_len":5,"allow_none":true,"is_mixed":true}},"assumptions":["len(nestedlist) > 0"],"postconditions":[{"assertion":"all(all(elem in sublist for sublist in nestedlist) for elem in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"len(result) <= min(len(sublist) for sublist in nestedlist)"}]},{"id":"pc_8","description":"Edge Case: Large number of inner lists","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"list[list[int]]"},"input_constraints":{"nestedlist":{"min_len":10,"max_len":20},"nestedlist[*]":{"min_len":1,"max_len":5}},"assumptions":["len(nestedlist) > 0"],"postconditions":[{"assertion":"all(all(elem in sublist for sublist in nestedlist) for elem in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"len(result) <= min(len(sublist) for sublist in nestedlist)"}]},{"id":"pc_9","description":"Edge Case: Large inner lists","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"list[list[int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":3},"nestedlist[*]":{"min_len":50,"max_len":100}},"assumptions":["len(nestedlist) > 0"],"postconditions":[{"assertion":"all(all(elem in sublist for sublist in nestedlist) for elem in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"len(result) <= min(len(sublist) for sublist in nestedlist)"}]},{"id":"pc_10","description":"Negative Test: Input is not a list","execution_statement":"try: result = common_in_nested_lists(nestedlist) except Exception as e: result = e","input_types":{"nestedlist":"int"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Negative Test: Inner element is not iterable (int)","execution_statement":"try: result = common_in_nested_lists(nestedlist) except Exception as e: result = e","input_types":{"nestedlist":"list[Union[list[int], int]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":3},"nestedlist[*]":{"min_len":1,"max_len":5}},"assumptions":["any(isinstance(sublist, int) for sublist in nestedlist)"],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: Inner list contains unhashable type (list)","execution_statement":"try: result = common_in_nested_lists(nestedlist) except Exception as e: result = e","input_types":{"nestedlist":"list[list[Union[int, list]]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":3},"nestedlist[*]":{"min_len":1,"max_len":5}},"assumptions":["any(isinstance(item, list) for sublist in nestedlist for item in sublist)"],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Happy Path: Lists with strings","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"list[list[str]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":5},"nestedlist[*]":{"min_len":1,"max_len":10,"pattern":"^[a-z]+$"}},"assumptions":["len(nestedlist) > 0"],"postconditions":[{"assertion":"all(all(elem in sublist for sublist in nestedlist) for elem in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"len(result) <= min(len(sublist) for sublist in nestedlist)"}]},{"id":"pc_14","description":"Happy Path: Mixed hashable types, forcing overlap","execution_statement":"result = common_in_nested_lists(nestedlist)","input_types":{"nestedlist":"list[list[Union[int, str, bool]]]"},"input_constraints":{"nestedlist":{"min_len":2,"max_len":3,"is_mixed":true},"nestedlist[*]":{"min_val":1,"max_val":5,"min_len":2,"max_len":5,"is_mixed":true}},"assumptions":["len(nestedlist) > 0"],"postconditions":[{"assertion":"all(all(elem in sublist for sublist in nestedlist) for elem in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"len(result) <= min(len(sublist) for sublist in nestedlist)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60d4"},"test_cases":[{"id":"pc_1","description":"Typical valid integer string","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":1,"max_len":50,"pattern":"^[+-]?[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Valid integer string with leading plus sign","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":2,"max_len":50,"pattern":"^\\+[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_3","description":"Valid integer string with leading minus sign","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":2,"max_len":50,"pattern":"^-[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"String containing only zero","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^0$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_5","description":"String containing only zero with plus sign","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^\\+0$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"String containing only zero with minus sign","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^-0$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_7","description":"Empty string","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^$","max_codepoint":255}},"postconditions":[{"assertion":"result is None"}],"assumptions":[]},{"id":"pc_8","description":"String with non-digit characters","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":1,"max_len":50,"pattern":"^[^-9+-]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_9","description":"String with mixed digits and non-digits","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":2,"max_len":50,"pattern":"^[-9]*[^-9+-][-9]*$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"String with multiple signs","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":2,"max_len":50,"pattern":"^[+-]{2}.*$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_11","description":"String with sign in the middle","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":2,"max_len":50,"pattern":"^[-9]+[+-][-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_12","description":"String with only a plus sign","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^\\+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_13","description":"String with only a minus sign","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^-$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"String with leading whitespace","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":2,"max_len":50,"pattern":"^\\s+[+-]?[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_15","description":"String with trailing whitespace","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":2,"max_len":50,"pattern":"^[+-]?[-9]+\\s+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_16","description":"Very long valid integer string","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":100,"max_len":200,"pattern":"^[+-]?[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_17","description":"String with only digits and a sign at the end","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":2,"max_len":50,"pattern":"^[-9]+[+-]$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_18","description":"String with a sign followed by non-digits","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":2,"max_len":50,"pattern":"^[+-][^-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_19","description":"String with leading zeros","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":2,"max_len":50,"pattern":"^0+[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_20","description":"String with leading zeros and plus sign","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":3,"max_len":50,"pattern":"^\\+0+[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60d5"},"test_cases":[{"id":"pc_1","description":"Happy Path: Valid positive integer string","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Valid negative integer string","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^-[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: Valid positive signed integer string","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^\\+[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Empty string","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result is None"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Whitespace only string","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^\\s+$","max_codepoint":255}},"postconditions":[{"assertion":"result is None"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: String with non-digit characters","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[^-9\\-\\+]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: String with mixed digits and non-digits (not at start)","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[-9]+[^-9]+[-9]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_8","description":"Edge Case: String with only a sign","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[\\-\\+]$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_9","description":"Edge Case: String with sign followed by non-digits","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[\\-\\+][^-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_10","description":"Boundary Case: Single digit","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[-9]$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_11","description":"Invariant: Non-empty valid integer string should not return None","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[\\-\\+]?[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is not None"}],"assumptions":["len(text.strip()) > 0"]},{"id":"pc_12","description":"Invariant: Return type is always bool or None","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, (bool, type(None)))"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Non-string input (int)","execution_statement":"try: result = check_integer(text) except Exception as e: result = e","input_types":{"text":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Non-string input (None)","execution_statement":"try: result = check_integer(text) except Exception as e: result = e","input_types":{"text":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_15","description":"Happy Path: Long integer string","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":100,"pattern":"^[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_16","description":"Happy Path: Long signed integer string","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":101,"pattern":"^[\\-\\+][-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_17","description":"Edge Case: String with leading/trailing whitespace","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^\\s+[-9]+\\s+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_18","description":"Edge Case: String with internal whitespace (invalid)","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[-9]+\\s+[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_19","description":"Edge Case: String with sign and internal whitespace (invalid)","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[\\-\\+][-9]+\\s+[-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_20","description":"Happy Path: Zero string","execution_statement":"result = check_integer(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^0+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60d6"},"test_cases":[{"id":"pc_1","description":"Test with an empty list.","execution_statement":"result = empty_dit([])","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Test with a list containing only empty dictionaries.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"type":"dict","dict_keys":{},"dict_values":{}}}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_3","description":"Test with a list containing one non-empty dictionary.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"type":"dict","dict_keys":{"min_len":1,"max_len":5},"dict_values":{}}}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(list1) > 0"]},{"id":"pc_4","description":"Test with a list containing a mix of empty and non-empty dictionaries.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"type":"dict","dict_keys":{},"dict_values":{}}}},"postconditions":[{"assertion":"result == False"}],"assumptions":["any(not d for d in list1) and any(d for d in list1)"]},{"id":"pc_5","description":"Test with a large list where all dictionaries are empty.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":50,"max_len":100,"elements":{"type":"dict","dict_keys":{},"dict_values":{}}}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Test with a large list where only one dictionary is non-empty.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":50,"max_len":100,"elements":{"type":"dict","dict_keys":{},"dict_values":{}}}},"postconditions":[{"assertion":"result == False"}],"assumptions":["sum(1 for d in list1 if d) == 1"]},{"id":"pc_7","description":"Test with a list containing non-dictionary elements, expecting TypeError.","execution_statement":"try: result = empty_dit(list1) except Exception as e: result = e","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"type":"int"}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Test with a non-list input, expecting TypeError.","execution_statement":"try: result = empty_dit(list1) except Exception as e: result = e","input_types":{"list1":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Test with a list containing None, expecting TypeError.","execution_statement":"try: result = empty_dit(list1) except Exception as e: result = e","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"allow_none":true}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["None in list1"]},{"id":"pc_10","description":"Test with a list containing an empty dict with None value (should be treated as empty).","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"type":"dict","dict_keys":{},"dict_values":{"allow_none":true}}}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60d7"},"test_cases":[{"id":"pc_1","description":"Happy Path: All dictionaries are empty.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"dict_keys":{"max_len":0}}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Some dictionaries are not empty.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"result is False"}],"assumptions":["any(len(d) > 0 for d in list1)"]},{"id":"pc_3","description":"Edge Case: Empty list input.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: List contains None values, no dictionaries.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[Optional[dict]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"allow_none":true}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(d is None for d in list1)"]},{"id":"pc_5","description":"Edge Case: Mixed None and empty dictionaries.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[Optional[dict]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"allow_none":true,"is_mixed":true}},"postconditions":[{"assertion":"result is True"}],"assumptions":["all(d is None or len(d) == 0 for d in list1)"]},{"id":"pc_6","description":"Edge Case: Mixed None and non-empty dictionaries.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[Optional[dict]]"},"input_constraints":{"list1":{"min_len":0,"max_len":2,"allow_none":true,"is_mixed":true}},"postconditions":[{"assertion":"result is False"}],"assumptions":["any(len(d) > 0 for d in list1)"]},{"id":"pc_7","description":"Boundary: Large list with all empty dictionaries.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":100,"max_len":1000,"dict_keys":{"max_len":0}}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_8","description":"Boundary: Large list with one non-empty dictionary.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":100,"max_len":1000}},"postconditions":[{"assertion":"result is False"}],"assumptions":["sum(1 for d in list1 if len(d) > 0) == 1"]},{"id":"pc_9","description":"Invariant: Return type is always boolean.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[Any]"},"input_constraints":{"list1":{"min_len":0,"max_len":10,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, bool)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Input is not a list (int).","execution_statement":"try: result = empty_dit(list1) except Exception as e: result = e","input_types":{"list1":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Input is not a list (None).","execution_statement":"try: result = empty_dit(list1) except Exception as e: result = e","input_types":{"list1":"Optional[list]"},"input_constraints":{"list1":{"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["list1 is None"]},{"id":"pc_12","description":"Mixed types in list: contains non-dict, non-None elements.","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[Any]"},"input_constraints":{"list1":{"min_len":0,"max_len":5,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, bool)"}],"assumptions":["all(isinstance(d, (dict, type(None))) for d in list1)"]}]}
{"_id":{"$oid":"692adffe1b18223597bc60d8"},"test_cases":[{"id":"pc_1","description":"Typical case with multiple positive integers.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":999,"min_len":2,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_2","description":"Boundary case: tuple with single smallest positive integer.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":1,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_3","description":"Boundary case: tuple with single largest positive integer (within reasonable limits for string conversion).","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1000000000,"max_val":9999999999,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_4","description":"Edge case: tuple with many small positive integers.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":9,"min_len":15,"max_len":20}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_5","description":"Edge case: tuple with a mix of small and large positive integers.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":1000000,"min_len":5,"max_len":15}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_6","description":"Invariant test: Result should be consistent if input tuple is repeated.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":100,"min_len":2,"max_len":5}},"postconditions":[{"assertion":"tuple_to_int(nums) == result"}],"assumptions":["len(nums) > 1"]},{"id":"pc_7","description":"Invariant test: Result should be consistent with the first element if tuple has only one element.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":999,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == nums[0]"}],"assumptions":[]},{"id":"pc_8","description":"Typical case with integers that have leading zeros when converted to string (e.g., 01, 007). Note: Python ints don't store leading zeros, so this tests the string conversion part.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":9,"min_len":2,"max_len":3}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_9","description":"Boundary case: tuple with maximum length and small integers.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":9,"min_len":50,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_10","description":"Typical case with integers that result in a large concatenated number.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":100,"max_val":999,"min_len":5,"max_len":8}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_11","description":"Edge case: tuple with a single large integer.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1000000000000,"max_val":9999999999999,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_12","description":"Typical case with integers that are powers of 10.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":10,"max_val":10000,"min_len":2,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_13","description":"Boundary case: tuple with maximum possible integer value (if supported by Python's int).","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":9223372036854775807,"max_val":9223372036854775807,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_14","description":"Typical case with integers that are close to each other.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":500,"max_val":550,"min_len":3,"max_len":7}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_15","description":"Edge case: tuple with a mix of single-digit and multi-digit numbers.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":100,"min_len":4,"max_len":12}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_16","description":"Invariant test: The generated integer should be divisible by the first element if it's not zero.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":100,"min_len":2,"max_len":5}},"postconditions":[{"assertion":"result % nums[0] == 0"}],"assumptions":[]},{"id":"pc_17","description":"Typical case with integers that are palindromic when converted to string.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":99,"min_len":2,"max_len":4}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_18","description":"Boundary case: tuple with minimum length and maximum allowed integers.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":100000,"max_val":999999,"min_len":2,"max_len":2}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_19","description":"Typical case with integers that are multiples of each other.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":100,"min_len":3,"max_len":6}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":["nums[0] != 0 and nums[1] % nums[0] == 0"]},{"id":"pc_20","description":"Invariant test: The generated integer should be divisible by the last element if it's not zero.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":100,"min_len":2,"max_len":5}},"postconditions":[{"assertion":"result % nums[-1] == 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60d9"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic conversion of positive integers.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":10,"elements":{"min_val":1,"max_val":999}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"str(result) == ''.join(map(str, nums))"}]},{"id":"pc_2","description":"Edge Case: Single element tuple.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1,"elements":{"min_val":1,"max_val":9}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"str(result) == ''.join(map(str, nums))"}]},{"id":"pc_3","description":"Boundary Value: Tuple with large integers.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":5,"elements":{"min_val":1000000,"max_val":9999999}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"str(result) == ''.join(map(str, nums))"}]},{"id":"pc_4","description":"Invariant: Digit count preservation for non-empty tuples.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":15,"elements":{"min_val":1,"max_val":99999}}},"assumptions":["nums"],"postconditions":[{"assertion":"len(str(result)) == sum(len(str(n)) for n in nums)"}]},{"id":"pc_5","description":"Invariant: Reconstructibility of original tuple for non-empty tuples.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":10,"elements":{"min_val":1,"max_val":999}}},"assumptions":["nums"],"postconditions":[{"assertion":"tuple(map(int, list(str(result)))) == nums"}]},{"id":"pc_6","description":"Negative Test: Empty tuple input.","execution_statement":"try: result = tuple_to_int(nums) except Exception as e: result = e","input_types":{"nums":"tuple"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}]},{"id":"pc_7","description":"Negative Test: Tuple containing zero (violates 'positive integers' docstring).","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":5,"elements":{"min_val":0,"max_val":99}}},"assumptions":["0 in nums"],"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"str(result) == ''.join(map(str, nums))"}]},{"id":"pc_8","description":"Negative Test: Tuple containing negative integers (violates 'positive integers' docstring).","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":5,"elements":{"min_val":-99,"max_val":99}}},"assumptions":["any(n < 0 for n in nums)"],"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"str(result) == ''.join(map(str, nums))"}]},{"id":"pc_9","description":"Negative Test: Tuple containing non-integer types (e.g., string).","execution_statement":"try: result = tuple_to_int(nums) except Exception as e: result = e","input_types":{"nums":"tuple[Union[int, str]]"},"input_constraints":{"nums":{"min_len":1,"max_len":5,"elements":{"allow_none":false}}},"assumptions":["any(isinstance(n, str) for n in nums)"],"postconditions":[{"assertion":"isinstance(result, ValueError)"}]},{"id":"pc_10","description":"Negative Test: Tuple containing None.","execution_statement":"try: result = tuple_to_int(nums) except Exception as e: result = e","input_types":{"nums":"tuple[Optional[int]]"},"input_constraints":{"nums":{"min_len":1,"max_len":5,"elements":{"allow_none":true}}},"assumptions":["any(n is None for n in nums)"],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Boundary Value: Tuple with many elements.","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":50,"max_len":100,"elements":{"min_val":1,"max_val":9}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"str(result) == ''.join(map(str, nums))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60da"},"test_cases":[{"id":"test_typical_integers","description":"Converts a list of lists of integers to floats.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_list":{"min_len":2,"max_len":2,"min_val":-100,"max_val":100}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"all(len(inner_list) == 2 for inner_list in result)"},{"assertion":"all(isinstance(item, float) for inner_list in result for item in inner_list)"}]},{"id":"test_typical_floats","description":"Converts a list of lists of floats to floats.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[float]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_list":{"min_len":2,"max_len":2,"min_val":-1000.0,"max_val":1000.0}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"all(len(inner_list) == 2 for inner_list in result)"},{"assertion":"all(isinstance(item, float) for inner_list in result for item in inner_list)"}]},{"id":"test_mixed_types_convertible","description":"Converts a list of lists with mixed convertible types (int, float) to floats.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[any]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_list":{"min_len":2,"max_len":2,"allow_none":false,"is_mixed":true},"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"all(len(inner_list) == 2 for inner_list in result)"},{"assertion":"all(isinstance(item, float) for inner_list in result for item in inner_list)"}]},{"id":"test_boundary_zeros","description":"Tests conversion of zeros (int and float) to floats.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[any]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":2,"inner_list":{"min_len":2,"max_len":2,"min_val":0,"max_val":0}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"all(len(inner_list) == 2 for inner_list in result)"},{"assertion":"all(isinstance(item, float) and item == 0.0 for inner_list in result for item in inner_list)"}]},{"id":"test_boundary_one","description":"Tests conversion of ones (int and float) to floats.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[any]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":2,"inner_list":{"min_len":2,"max_len":2,"min_val":1,"max_val":1}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"all(len(inner_list) == 2 for inner_list in result)"},{"assertion":"all(isinstance(item, float) and item == 1.0 for inner_list in result for item in inner_list)"}]},{"id":"test_boundary_negative_one","description":"Tests conversion of negative ones (int and float) to floats.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[any]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":2,"inner_list":{"min_len":2,"max_len":2,"min_val":-1,"max_val":-1}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"all(len(inner_list) == 2 for inner_list in result)"},{"assertion":"all(isinstance(item, float) and item == -1.0 for inner_list in result for item in inner_list)"}]},{"id":"test_edge_empty_outer_list","description":"Tests with an empty outer list.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == []"}]},{"id":"test_edge_empty_inner_list","description":"Tests with an empty inner list (should raise error due to indexing).","execution_statement":"try: result = list_to_float(test_list) except Exception as e: result = e","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_list":{"min_len":0,"max_len":0}}},"postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"test_non_convertible_string","description":"Tests with a non-convertible string element (should be appended as is).","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[any]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_list":{"min_len":2,"max_len":2,"elements":["abc","123"]}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"len(result) == 1"},{"assertion":"result[0] == ('abc', 123.0)"}]},{"id":"test_non_convertible_boolean","description":"Tests with boolean elements (should be converted to float).","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[bool]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_list":{"min_len":2,"max_len":2,"elements":[true,false]}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"len(result) == 1"},{"assertion":"result[0] == (1.0, 0.0)"}]},{"id":"test_non_convertible_none","description":"Tests with None element (should raise TypeError).","execution_statement":"try: result = list_to_float(test_list) except Exception as e: result = e","input_types":{"test_list":"list[list[any]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_list":{"min_len":2,"max_len":2,"allow_none":true,"is_mixed":true}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"test_large_numbers","description":"Tests with large integer and float values.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[any]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_list":{"min_len":2,"max_len":2,"min_val":1000000,"max_val":1000000000}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"len(result) == 1"},{"assertion":"all(isinstance(item, float) for inner_list in result for item in inner_list)"}]},{"id":"test_string_zero_and_one","description":"Tests conversion of string '0' and '1' to floats.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_list":{"min_len":2,"max_len":2,"elements":["0","1"]}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"len(result) == 1"},{"assertion":"result[0] == (0.0, 1.0)"}]},{"id":"test_string_float_representation","description":"Tests conversion of strings representing floats to floats.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_list":{"min_len":2,"max_len":2,"elements":["123.45","-67.89"]}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"len(result) == 1"},{"assertion":"result[0] == (123.45, -67.89)"}]},{"id":"test_string_inf_nan","description":"Tests conversion of strings 'inf' and 'nan' to floats.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_list":{"min_len":2,"max_len":2,"elements":["inf","nan"]}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"len(result) == 1"},{"assertion":"all(isinstance(item, float) for inner_list in result for item in inner_list)"},{"assertion":"result[0][0] == float('inf')"},{"assertion":"result[0][1] != result[0][1]"}]},{"id":"test_mixed_string_and_number","description":"Tests a mix of strings that are convertible and non-convertible.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[any]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_list":{"min_len":2,"max_len":2,"elements":["10.5","hello"]}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"len(result) == 1"},{"assertion":"result[0] == (10.5, 'hello')"}]},{"id":"test_multiple_inner_lists","description":"Tests with multiple inner lists.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[any]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":3,"inner_list":{"min_len":2,"max_len":2,"min_val":-50,"max_val":50}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"len(result) == len(test_list)"},{"assertion":"all(len(inner_list) == 2 for inner_list in result)"},{"assertion":"all(isinstance(item, float) for inner_list in result for item in inner_list)"}]},{"id":"test_string_with_spaces","description":"Tests conversion of strings with spaces that are convertible.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_list":{"min_len":2,"max_len":2,"elements":[" 123 "," -45.6 "]}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"len(result) == 1"},{"assertion":"result[0] == (123.0, -45.6)"}]},{"id":"test_string_non_numeric","description":"Tests with a string that is not a valid number.","execution_statement":"result = list_to_float(test_list)","input_types":{"test_list":"list[list[any]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_list":{"min_len":2,"max_len":2,"elements":["not_a_number","5"]}}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(inner_list, tuple) for inner_list in result)"},{"assertion":"len(result) == 1"},{"assertion":"result[0] == ('not_a_number', 5.0)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60db"},"test_cases":[{"id":"pc_1","description":"Happy Path: Mixed convertible and alphabetic strings","input_types":{"test_list":"list[tuple[str, str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"is_mixed":true}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == len(test_list)"},{"assertion":"all(len(t) == 2 for t in result)"},{"assertion":"all((isinstance(t[0], str) or isinstance(t[0], float)) and (isinstance(t[1], str) or isinstance(t[1], float)) for t in result)"}]},{"id":"pc_2","description":"Edge Case: Empty input list","input_types":{"test_list":"list[tuple[str, str]]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"result == []"}]},{"id":"pc_3","description":"Edge Case: List with empty tuples (will raise IndexError)","input_types":{"test_list":"list[tuple[str, ...]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"max_len":1}}},"execution_statement":"try: result = list_to_float(test_list) except IndexError: result = 'IndexError'","postconditions":[{"assertion":"result == 'IndexError'"}]},{"id":"pc_4","description":"Edge Case: Tuples with only alphabetic strings","input_types":{"test_list":"list[tuple[str, str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"pattern":"^[a-zA-Z]+$"}}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"all(isinstance(t[0], str) and isinstance(t[1], str) for t in result)"},{"assertion":"len(result) == len(test_list)"}]},{"id":"pc_5","description":"Edge Case: Tuples with only float convertible strings","input_types":{"test_list":"list[tuple[str, str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"pattern":"^-?[-9]+(\\.[-9]+)?$"}}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"all(isinstance(t[0], float) and isinstance(t[1], float) for t in result)"},{"assertion":"len(result) == len(test_list)"}]},{"id":"pc_6","description":"Boundary Case: Large list of tuples","input_types":{"test_list":"list[tuple[str, str]]"},"input_constraints":{"test_list":{"min_len":100,"max_len":200}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"len(result) == len(test_list)"},{"assertion":"all(len(t) == 2 for t in result)"}]},{"id":"pc_7","description":"Edge Case: Tuple with non-convertible and non-alphabetic string (will raise ValueError)","input_types":{"test_list":"list[tuple[str, str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"pattern":"^[a-zA-Z-9_.-]+$"}}},"execution_statement":"try: result = list_to_float(test_list) except ValueError: result = 'ValueError'","postconditions":[{"assertion":"result == 'ValueError'"}]},{"id":"pc_8","description":"Happy Path: Tuples with mixed types (alphabetic and float convertible)","input_types":{"test_list":"list[tuple[str, str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"pattern":"^(-?[-9]+(\\.[-9]+)?|[a-zA-Z]+)$"},"is_mixed":true}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"len(result) == len(test_list)"},{"assertion":"all(isinstance(t[0], (str, float)) and isinstance(t[1], (str, float)) for t in result)"}]},{"id":"pc_9","description":"Edge Case: Tuple with one alphabetic and one float convertible","input_types":{"test_list":"list[tuple[str, str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"pattern":"^(-?[-9]+(\\.[-9]+)?|[a-zA-Z]+)$"}}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"len(result) == len(test_list)"},{"assertion":"all(isinstance(t[0], (str, float)) and isinstance(t[1], (str, float)) for t in result)"}]},{"id":"pc_10","description":"Invariant: Output tuple elements are either string or float","input_types":{"test_list":"list[tuple[str, str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"pattern":"^(-?[-9]+(\\.[-9]+)?|[a-zA-Z]+)$"}}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"all(isinstance(item, (str, float)) for tup in result for item in tup)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60dc"},"test_cases":[{"id":"pc_1","description":"Typical case: string with single spaces.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"pattern":"^[^ ]* [^ ]*$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(item, str) for item in result)"}],"assumptions":[]},{"id":"pc_2","description":"Edge case: empty string.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == ['']"}],"assumptions":[]},{"id":"pc_3","description":"Edge case: string with only spaces.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"pattern":"^ +$","max_codepoint":255}},"postconditions":[{"assertion":"result == [''] * len(string.split(' '))"}],"assumptions":[]},{"id":"pc_4","description":"Edge case: string with leading and trailing spaces.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":2,"pattern":"^ .+$|.+ $|^ .+$","max_codepoint":255}},"postconditions":[{"assertion":"result[0] == '' or result[-1] == ''"}],"assumptions":[]},{"id":"pc_5","description":"Edge case: string with multiple consecutive spaces.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":2,"pattern":"^.*  .*$","max_codepoint":255}},"postconditions":[{"assertion":"'' in result"}],"assumptions":[]},{"id":"pc_6","description":"Edge case: string with no spaces.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"pattern":"^[^ ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == [string]"}],"assumptions":[]},{"id":"pc_7","description":"Boundary case: long string with spaces.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":100,"pattern":"^.* .+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, list)"}],"assumptions":[]},{"id":"pc_8","description":"Mixed characters and spaces.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":5,"pattern":"^[a-zA-Z-9 ]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, list)"}],"assumptions":[]},{"id":"pc_9","description":"String with unicode characters and spaces.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":5,"pattern":"^[\\w\\s]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, list)"}],"assumptions":[]},{"id":"pc_10","description":"String with only one word and spaces around it.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":3,"pattern":"^ +[^ ]+ +$","max_codepoint":255}},"postconditions":[{"assertion":"result[0] == '' and result[-1] == '' and len(result) == 3"}],"assumptions":[]},{"id":"pc_11","description":"String with alternating words and multiple spaces.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":5,"pattern":"^[^ ]+  [^ ]+  [^ ]+$","max_codepoint":255}},"postconditions":[{"assertion":"'' in result"}],"assumptions":[]},{"id":"pc_12","description":"String with special characters and spaces.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":5,"pattern":"^[\\W\\s]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, list)"}],"assumptions":[]},{"id":"pc_13","description":"String with only one word (no spaces).","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"pattern":"^[^ ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == [string]"}],"assumptions":[]},{"id":"pc_14","description":"String with spaces at the beginning and end, and multiple spaces in between.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":5,"pattern":"^ +[^ ]+  [^ ]+ +$","max_codepoint":255}},"postconditions":[{"assertion":"result[0] == '' and result[-1] == '' and '' in result"}],"assumptions":[]},{"id":"pc_15","description":"String with only non-alphanumeric characters and spaces.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":5,"pattern":"^[^a-zA-Z-9]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, list)"}],"assumptions":[]},{"id":"pc_16","description":"String with a mix of single and multiple spaces.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":5,"pattern":"^[^ ]+ +[^ ]+  [^ ]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, list)"}],"assumptions":[]},{"id":"pc_17","description":"String with only one space.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":1,"pattern":"^ $","max_codepoint":255}},"postconditions":[{"assertion":"result == ['', '']"}],"assumptions":[]},{"id":"pc_18","description":"String with two spaces.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":2,"max_len":2,"pattern":"^  +$","max_codepoint":255}},"postconditions":[{"assertion":"result == ['', '', '']"}],"assumptions":[]},{"id":"pc_19","description":"String with spaces and tabs.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":5,"pattern":"^[\\w\\s\\t]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, list)"}],"assumptions":[]},{"id":"pc_20","description":"String with spaces and newlines.","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":5,"pattern":"^[\\w\\s\\n]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, list)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60dd"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic string conversion","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(item, str) for item in result)"},{"assertion":"result == string.split(' ')"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == ['']"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String with only spaces","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^ +$","max_codepoint":255}},"postconditions":[{"assertion":"result == string.split(' ')"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: String with leading/trailing spaces","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^ [a-zA-Z ]* $","min_len":3,"max_codepoint":255}},"postconditions":[{"assertion":"result == string.split(' ')"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: String with multiple spaces between words","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^[a-zA-Z ]*([ ]{2}[a-zA-Z ]*)+$","min_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == string.split(' ')"}],"assumptions":[]},{"id":"pc_6","description":"Happy Path: String with no spaces","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^[^ ]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == [string]"}],"assumptions":[]},{"id":"pc_7","description":"Invariant: Output is always a list","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, list)"}],"assumptions":[]},{"id":"pc_8","description":"Invariant: All elements in the list are strings","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"max_codepoint":255}},"postconditions":[{"assertion":"all(isinstance(item, str) for item in result)"}],"assumptions":[]},{"id":"pc_9","description":"Boundary: Long string","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1000,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == string.split(' ')"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Non-string input (int)","execution_statement":"try: result = string_to_list(string) except Exception as e: result = e","input_types":{"string":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-string input (None)","execution_statement":"try: result = string_to_list(string) except Exception as e: result = e","input_types":{"string":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_12","description":"Edge Case: String with punctuation","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^[a-zA-Z .,!?]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == string.split(' ')"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60de"},"test_cases":[{"id":"TC1","description":"Typical case: Array with a single unique element.","execution_statement":"result = search(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_len":3,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1"],"postconditions":[{"assertion":"result == (lambda a: a[0] if len(a) == 1 else (a[1] if len(a) == 2 and a[0] != a[1] else next(i for i in a if a.count(i) == 1)))(arr)"}]},{"id":"TC2","description":"Edge case: Smallest possible array with a single unique element.","execution_statement":"result = search(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_len":1,"max_len":1,"sorted":"ascending","unique":false}},"assumptions":["len(arr) == 1"],"postconditions":[{"assertion":"result == arr[0]"}]},{"id":"TC3","description":"Boundary case: Single unique element at the beginning.","execution_statement":"result = search(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_len":3,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1","arr.count(arr[0]) == 1"],"postconditions":[{"assertion":"result == arr[0]"}]},{"id":"TC4","description":"Boundary case: Single unique element at the end.","execution_statement":"result = search(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_len":3,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1","arr.count(arr[-1]) == 1"],"postconditions":[{"assertion":"result == arr[-1]"}]},{"id":"TC5","description":"Array with all elements appearing twice except one.","execution_statement":"result = search(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_len":3,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1"],"postconditions":[{"assertion":"result == (lambda a: next(i for i in a if a.count(i) == 1))(arr)"}]},{"id":"TC6","description":"Array with negative numbers.","execution_statement":"result = search(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":-1000,"max_val":-1,"min_len":3,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1"],"postconditions":[{"assertion":"result == (lambda a: next(i for i in a if a.count(i) == 1))(arr)"}]},{"id":"TC7","description":"Array with mixed positive and negative numbers.","execution_statement":"result = search(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":-1000,"max_val":1000,"min_len":3,"max_len":100,"sorted":"ascending","unique":false,"is_mixed":true}},"assumptions":["len(set(arr)) % 2 == 1"],"postconditions":[{"assertion":"result == (lambda a: next(i for i in a if a.count(i) == 1))(arr)"}]},{"id":"TC8","description":"Array with large numbers.","execution_statement":"result = search(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":1000000,"max_val":1000000000,"min_len":3,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1"],"postconditions":[{"assertion":"result == (lambda a: next(i for i in a if a.count(i) == 1))(arr)"}]},{"id":"TC9","description":"Array with zero as the unique element.","execution_statement":"result = search(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":-100,"max_val":100,"min_len":3,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1","0 in arr","arr.count(0) == 1"],"postconditions":[{"assertion":"result == 0"}]},{"id":"TC10","description":"Array with duplicate elements forming pairs, and one unique element.","execution_statement":"result = search(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_len":5,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1"],"postconditions":[{"assertion":"result == (lambda a: next(i for i in a if a.count(i) == 1))(arr)"}]},{"id":"TC11","description":"Array with only one distinct element, which is the unique one.","execution_statement":"result = search(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_len":1,"max_len":1,"sorted":"ascending","unique":false}},"assumptions":["len(arr) == 1"],"postconditions":[{"assertion":"result == arr[0]"}]},{"id":"TC12","description":"Array with string elements.","execution_statement":"result = search(arr)","input_types":{"arr":"List[str]"},"input_constraints":{"arr":{"min_len":3,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1"],"postconditions":[{"assertion":"result == (lambda a: next(i for i in a if a.count(i) == 1))(arr)"}]},{"id":"TC13","description":"Array with string elements, unique at the beginning.","execution_statement":"result = search(arr)","input_types":{"arr":"List[str]"},"input_constraints":{"arr":{"min_len":3,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1","arr.count(arr[0]) == 1"],"postconditions":[{"assertion":"result == arr[0]"}]},{"id":"TC14","description":"Array with string elements, unique at the end.","execution_statement":"result = search(arr)","input_types":{"arr":"List[str]"},"input_constraints":{"arr":{"min_len":3,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1","arr.count(arr[-1]) == 1"],"postconditions":[{"assertion":"result == arr[-1]"}]},{"id":"TC15","description":"Array with string elements, mixed case.","execution_statement":"result = search(arr)","input_types":{"arr":"List[str]"},"input_constraints":{"arr":{"min_len":3,"max_len":100,"sorted":"ascending","unique":false,"is_mixed":true}},"assumptions":["len(set(arr)) % 2 == 1"],"postconditions":[{"assertion":"result == (lambda a: next(i for i in a if a.count(i) == 1))(arr)"}]},{"id":"TC16","description":"Array with float elements.","execution_statement":"result = search(arr)","input_types":{"arr":"List[float]"},"input_constraints":{"arr":{"min_val":-1000.0,"max_val":1000.0,"min_len":3,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1"],"postconditions":[{"assertion":"result == (lambda a: next(i for i in a if a.count(i) == 1))(arr)"}]},{"id":"TC17","description":"Array with float elements, unique at the beginning.","execution_statement":"result = search(arr)","input_types":{"arr":"List[float]"},"input_constraints":{"arr":{"min_val":-1000.0,"max_val":1000.0,"min_len":3,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1","arr.count(arr[0]) == 1"],"postconditions":[{"assertion":"result == arr[0]"}]},{"id":"TC18","description":"Array with float elements, unique at the end.","execution_statement":"result = search(arr)","input_types":{"arr":"List[float]"},"input_constraints":{"arr":{"min_val":-1000.0,"max_val":1000.0,"min_len":3,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1","arr.count(arr[-1]) == 1"],"postconditions":[{"assertion":"result == arr[-1]"}]},{"id":"TC19","description":"Array with a single element repeated multiple times, and one unique element.","execution_statement":"result = search(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_len":5,"max_len":100,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) == 2","len(arr) % 2 == 1"],"postconditions":[{"assertion":"result == (lambda a: next(i for i in a if a.count(i) == 1))(arr)"}]},{"id":"TC20","description":"Array with a large number of elements.","execution_statement":"result = search(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_len":1000,"max_len":5000,"sorted":"ascending","unique":false}},"assumptions":["len(set(arr)) % 2 == 1"],"postconditions":[{"assertion":"result == (lambda a: next(i for i in a if a.count(i) == 1))(arr)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60df"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with unique element","execution_statement":"result = search(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":3,"max_len":10,"unique":true}},"assumptions":["len(arr) % 2 != 0"],"postconditions":[{"assertion":"result in arr"},{"assertion":"arr.count(result) == 1"}]},{"id":"pc_2","description":"Edge Case: Empty array","execution_statement":"result = search(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_3","description":"Edge Case: Single element array","execution_statement":"result = search(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == arr[0]"}]},{"id":"pc_4","description":"Boundary Value: Array with zero as unique element","execution_statement":"result = search(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":3,"max_len":10,"unique":true}},"assumptions":["len(arr) % 2 != 0","0 in arr"],"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_5","description":"Boundary Value: Array with large integers","execution_statement":"result = search(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":1000000000,"max_val":2000000000,"min_len":3,"max_len":10,"unique":true}},"assumptions":["len(arr) % 2 != 0"],"postconditions":[{"assertion":"result in arr"},{"assertion":"arr.count(result) == 1"}]},{"id":"pc_6","description":"Boundary Value: Array with negative integers","execution_statement":"result = search(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":-2000000000,"max_val":-1000000000,"min_len":3,"max_len":10,"unique":true}},"assumptions":["len(arr) % 2 != 0"],"postconditions":[{"assertion":"result in arr"},{"assertion":"arr.count(result) == 1"}]},{"id":"pc_7","description":"Invariant: XOR sum property","execution_statement":"result = search(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":1,"max_len":10}},"assumptions":["len(arr) % 2 != 0"],"postconditions":[{"assertion":"reduce(lambda x, y: x ^ y, arr, 0) == result"}]},{"id":"pc_8","description":"Invariant: Result must be from the array if not empty","execution_statement":"result = search(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":1,"max_len":10}},"assumptions":["len(arr) % 2 != 0"],"postconditions":[{"assertion":"result in arr"}]},{"id":"pc_9","description":"Scenario: All elements appear even times (should return 0)","execution_statement":"result = search(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"max_len":10}},"assumptions":["len(arr) % 2 == 0","all(arr.count(x) % 2 == 0 for x in set(arr))"],"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_10","description":"Happy Path: Array with duplicates, unique element at start","execution_statement":"result = search(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":3,"max_len":10}},"assumptions":["len(arr) % 2 != 0","arr[0] not in arr[1:]"],"postconditions":[{"assertion":"result == arr[0]"}]},{"id":"pc_11","description":"Happy Path: Array with duplicates, unique element at end","execution_statement":"result = search(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":3,"max_len":10}},"assumptions":["len(arr) % 2 != 0","arr[-1] not in arr[:-1]"],"postconditions":[{"assertion":"result == arr[-1]"}]},{"id":"pc_12","description":"Happy Path: Array with duplicates, unique element in middle","execution_statement":"result = search(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":5,"max_len":10}},"assumptions":["len(arr) % 2 != 0","arr[len(arr)//2] not in arr[:len(arr)//2] and arr[len(arr)//2] not in arr[len(arr)//3:]"],"postconditions":[{"assertion":"result == arr[len(arr)//2]"}]},{"id":"pc_13","description":"Negative Test: Non-integer type in array (expect TypeError)","execution_statement":"try: result = search(arr) except Exception as e: result = e","input_types":{"arr":"list[object]"},"input_constraints":{"arr":{"min_len":2,"max_len":5}},"assumptions":["not all(isinstance(x, int) for x in arr)"],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Negative Test: Non-list input (expect TypeError)","execution_statement":"try: result = search(arr) except Exception as e: result = e","input_types":{"arr":"int"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_15","description":"Negative Test: null input (expect TypeError)","execution_statement":"try: result = search(arr) except Exception as e: result = e","input_types":{"arr":"None"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60e0"},"test_cases":[{"id":"TC1","description":"Typical case with positive integers.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"items":{"min_val":1,"max_val":100}}},"assumptions":[],"postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"TC2","description":"Typical case with negative integers.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"items":{"min_val":-100,"max_val":-1}}},"assumptions":[],"postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"TC3","description":"Typical case with mixed positive and negative integers.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"items":{"min_val":-100,"max_val":100},"is_mixed":true}},"assumptions":[],"postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"TC4","description":"Edge case with zeros.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"items":{"min_val":-10,"max_val":10,"allow_none":false}}},"assumptions":["0 in [item[0] for item in list1] or 0 in [item[1] for item in list1]"],"postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"TC5","description":"Edge case with large integers.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"items":{"min_val":1000000,"max_val":1000000000}}},"assumptions":[],"postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"TC6","description":"Edge case with very small negative integers.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"items":{"min_val":-1000000000,"max_val":-1000000}}},"assumptions":[],"postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"TC7","description":"Boundary case: list with a single tuple.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":1,"items":{"min_val":-50,"max_val":50}}},"assumptions":[],"postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"TC8","description":"Boundary case: list with maximum allowed tuples.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":10,"max_len":10,"items":{"min_val":-10,"max_val":10}}},"assumptions":[],"postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"TC9","description":"Invariant test: result should always be non-negative.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"items":{"min_val":-100,"max_val":100}}},"assumptions":[],"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC10","description":"Invariant test: result should be the absolute product of at least one pair.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"items":{"min_val":-100,"max_val":100}}},"assumptions":[],"postconditions":[{"assertion":"result in [abs(x * y) for x, y in list1]"}]},{"id":"TC11","description":"Edge case: list containing tuples with zero and non-zero values.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"items":{"min_val":-10,"max_val":10}}},"assumptions":["any(0 in t for t in list1)"],"postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"TC12","description":"Edge case: list containing tuples with only zeros.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"items":{"min_val":0,"max_val":0}}},"assumptions":[],"postconditions":[{"assertion":"result == 0"}]},{"id":"TC13","description":"Typical case with floating point numbers.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[float, float]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"items":{"min_val":-100.0,"max_val":100.0,"allow_nan":false,"allow_infinity":false}}},"assumptions":[],"postconditions":[{"assertion":"abs(result - max([abs(x * y) for x, y in list1])) < 1e-9"}]},{"id":"TC14","description":"Edge case with large floating point numbers.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[float, float]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"items":{"min_val":1E+06,"max_val":1E+09,"allow_nan":false,"allow_infinity":false}}},"assumptions":[],"postconditions":[{"assertion":"abs(result - max([abs(x * y) for x, y in list1])) < 1e-9"}]},{"id":"TC15","description":"Edge case with very small negative floating point numbers.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[float, float]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"items":{"min_val":-1E+09,"max_val":-1E+06,"allow_nan":false,"allow_infinity":false}}},"assumptions":[],"postconditions":[{"assertion":"abs(result - max([abs(x * y) for x, y in list1])) < 1e-9"}]},{"id":"TC16","description":"Mixed types: integers and floats.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[Union[int, float], Union[int, float]]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"items":{"min_val":-100,"max_val":100,"allow_nan":false,"allow_infinity":false},"is_mixed":true}},"assumptions":[],"postconditions":[{"assertion":"abs(result - max([abs(x * y) for x, y in list1])) < 1e-9"}]},{"id":"TC17","description":"Empty list input.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":0,"max_len":0}},"assumptions":[],"postconditions":[{"assertion":"result == 0"}]},{"id":"TC18","description":"List with tuples containing one zero and one large number.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"items":{"min_val":-1000000,"max_val":1000000}}},"assumptions":["any(0 in t for t in list1)"],"postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"TC19","description":"List with tuples containing one large negative and one large positive number.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"items":{"min_val":-1000000,"max_val":1000000}}},"assumptions":["any((t[0] < 0 and t[1] > 0) or (t[0] > 0 and t[1] < 0) for t in list1)"],"postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"TC20","description":"List with tuples containing two large negative numbers.","execution_statement":"result = max_product_tuple(list1)","input_types":{"list1":"List[Tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"items":{"min_val":-1000000,"max_val":-1}}},"assumptions":[],"postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60e1"},"test_cases":[{"id":"pc_1","description":"Happy Path: List with positive integers","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_val":1,"max_val":100}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"isinstance(result, int) and result >= 0"}]},{"id":"pc_2","description":"Happy Path: List with mixed positive and negative integers","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100},"is_mixed":true}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"isinstance(result, int) and result >= 0"}]},{"id":"pc_3","description":"Edge Case: Empty list","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":0,"max_len":0}},"execution_statement":"try: result = max_product_tuple(list1) except ValueError: result = 0","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_4","description":"Edge Case: List with tuples containing zero","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_val":-50,"max_val":50}}},"assumptions":["0 in list1[0]"],"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"isinstance(result, int) and result >= 0"}]},{"id":"pc_5","description":"Boundary Case: Large positive numbers","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"min_val":10000,"max_val":100000}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"isinstance(result, int) and result >= 0"}]},{"id":"pc_6","description":"Boundary Case: Large negative numbers","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"min_val":-100000,"max_val":-10000}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"isinstance(result, int) and result >= 0"}]},{"id":"pc_7","description":"Invariant: Result is always non-negative","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_val":-1000,"max_val":1000}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result >= 0"}]},{"id":"pc_8","description":"Invariant: Result is always an integer","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"isinstance(result, int)"}]},{"id":"pc_9","description":"Negative Test: Input is not a list","input_types":{"list1":"int"},"input_constraints":{},"execution_statement":"try: result = max_product_tuple(list1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: List contains non-tuple elements","input_types":{"list1":"list[int]"},"input_constraints":{"list1":{"min_len":1,"max_len":5}},"execution_statement":"try: result = max_product_tuple(list1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Negative Test: Tuple elements are not numbers","input_types":{"list1":"list[tuple[str, str]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":10}}},"execution_statement":"try: result = max_product_tuple(list1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60e2"},"test_cases":[{"id":"TC001","description":"Test with the smallest valid limit (1).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 0"}]},{"id":"TC002","description":"Test with a limit that includes the first amicable pair (220, 284).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":284,"max_val":284}},"postconditions":[{"assertion":"result == 504"}]},{"id":"TC003","description":"Test with a limit just below the first amicable pair.","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":219,"max_val":219}},"postconditions":[{"assertion":"result == 0"}]},{"id":"TC004","description":"Test with a limit that includes multiple amicable pairs.","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1210,"max_val":1210}},"postconditions":[{"assertion":"result == 1690"}]},{"id":"TC005","description":"Test with a moderate limit to check for multiple amicable pairs.","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1000,"max_val":5000}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC006","description":"Test with a larger limit.","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":5000,"max_val":10000}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"TC007","description":"Test the invariant: sum should be monotonically increasing with the limit.","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1,"max_val":10000}},"assumptions":["limit1 <= limit"],"postconditions":[{"assertion":"result >= amicable_numbers_sum(limit1)"}]},{"id":"TC008","description":"Test with a limit that has no amicable numbers.","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1,"max_val":219}},"postconditions":[{"assertion":"result == 0"}]},{"id":"TC009","description":"Test with a limit that includes the third amicable pair (2620, 2924).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":2924,"max_val":2924}},"postconditions":[{"assertion":"result == 7232"}]},{"id":"TC010","description":"Test with a limit that includes the fourth amicable pair (5020, 5564).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":5564,"max_val":5564}},"postconditions":[{"assertion":"result == 17816"}]},{"id":"TC011","description":"Test with a limit that includes the fifth amicable pair (6232, 6368).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":6368,"max_val":6368}},"postconditions":[{"assertion":"result == 30416"}]},{"id":"TC012","description":"Test with a limit that includes the sixth amicable pair (10744, 10856).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":10856,"max_val":10856}},"postconditions":[{"assertion":"result == 30416 + 21600"}]},{"id":"TC013","description":"Test with a limit that includes the seventh amicable pair (12285, 14595).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":14595,"max_val":14595}},"postconditions":[{"assertion":"result == 30416 + 48480"}]},{"id":"TC014","description":"Test with a limit that includes the eighth amicable pair (17296, 18416).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":18416,"max_val":18416}},"postconditions":[{"assertion":"result == 30416 + 84192"}]},{"id":"TC015","description":"Test with a limit that includes the ninth amicable pair (63020, 76084).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":76084,"max_val":76084}},"postconditions":[{"assertion":"result == 30416 + 223296"}]},{"id":"TC016","description":"Test with a limit that includes the tenth amicable pair (66928, 66992).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":66992,"max_val":66992}},"postconditions":[{"assertion":"result == 30416 + 223296 + 133920"}]},{"id":"TC017","description":"Test with a limit that includes the eleventh amicable pair (67095, 71145).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":71145,"max_val":71145}},"postconditions":[{"assertion":"result == 30416 + 223296 + 272160"}]},{"id":"TC018","description":"Test with a limit that includes the twelfth amicable pair (79750, 88730).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":88730,"max_val":88730}},"postconditions":[{"assertion":"result == 30416 + 223296 + 440640"}]},{"id":"TC019","description":"Test with a limit that includes the thirteenth amicable pair (100485, 124155).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":124155,"max_val":124155}},"postconditions":[{"assertion":"result == 30416 + 223296 + 665280"}]},{"id":"TC020","description":"Test with a limit that includes the fourteenth amicable pair (126115, 135375).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":135375,"max_val":135375}},"postconditions":[{"assertion":"result == 30416 + 223296 + 665280 + 261490"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60e3"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with a positive integer limit.","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"isinstance(result, int) and result >= 0"}]},{"id":"pc_2","description":"Edge Case: Input is not an integer (float).","execution_statement":"try: result = amicable_numbers_sum(limit) except Exception as e: result = e","input_types":{"limit":"float"},"input_constraints":{},"postconditions":[{"assertion":"result == 'Input is not an integer!'"}]},{"id":"pc_3","description":"Edge Case: Input is not an integer (string).","execution_statement":"try: result = amicable_numbers_sum(limit) except Exception as e: result = e","input_types":{"limit":"str"},"input_constraints":{"limit":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == 'Input is not an integer!'"}]},{"id":"pc_4","description":"Edge Case: Input is not an integer (None).","execution_statement":"try: result = amicable_numbers_sum(limit) except Exception as e: result = e","input_types":{"limit":"None"},"input_constraints":{},"postconditions":[{"assertion":"result == 'Input is not an integer!'"}]},{"id":"pc_5","description":"Edge Case: Input is zero.","execution_statement":"try: result = amicable_numbers_sum(limit) except Exception as e: result = e","input_types":{"limit":"int"},"input_constraints":{"limit":{"max_val":0}},"postconditions":[{"assertion":"result == 'Input must be bigger than 0!'"}]},{"id":"pc_6","description":"Edge Case: Input is negative.","execution_statement":"try: result = amicable_numbers_sum(limit) except Exception as e: result = e","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"result == 'Input must be bigger than 0!'"}]},{"id":"pc_7","description":"Invariant: The sum of amicable numbers should always be non-negative.","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1,"max_val":5000}},"postconditions":[{"assertion":"isinstance(result, int) and result >= 0"}]},{"id":"pc_8","description":"Boundary Value: A limit that is known to produce amicable numbers (e.g., 300).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"val":300}},"postconditions":[{"assertion":"result == 504"}]},{"id":"pc_9","description":"Boundary Value: A limit that is known to produce no amicable numbers (e.g., 200).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"val":200}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_10","description":"Boundary Value: A larger limit to test performance and correctness.","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1000,"max_val":2000}},"postconditions":[{"assertion":"isinstance(result, int) and result >= 0"}]},{"id":"pc_11","description":"Test with a limit that includes the first amicable pair (220, 284).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":284,"max_val":284}},"postconditions":[{"assertion":"result == 504"}]},{"id":"pc_12","description":"Test with a limit just below the first amicable pair.","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":219,"max_val":219}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_13","description":"Test with a limit just above the first amicable pair.","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":285,"max_val":285}},"postconditions":[{"assertion":"result == 504"}]},{"id":"pc_14","description":"Test with a limit that includes the second amicable pair (1184, 1210).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1210,"max_val":1210}},"postconditions":[{"assertion":"result == 2394"}]},{"id":"pc_15","description":"Test with a limit that includes the third amicable pair (2620, 2924).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":2924,"max_val":2924}},"postconditions":[{"assertion":"result == 5318"}]},{"id":"pc_16","description":"Test with a limit that includes the fourth amicable pair (5020, 5564).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":5564,"max_val":5564}},"postconditions":[{"assertion":"result == 10582"}]},{"id":"pc_17","description":"Test with a limit that includes the fifth amicable pair (6232, 6368).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":6368,"max_val":6368}},"postconditions":[{"assertion":"result == 16982"}]},{"id":"pc_18","description":"Test with a limit that includes the sixth amicable pair (10744, 10856).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":10856,"max_val":10856}},"postconditions":[{"assertion":"result == 21600"}]},{"id":"pc_19","description":"Test with a limit that includes the seventh amicable pair (12285, 14595).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":14595,"max_val":14595}},"postconditions":[{"assertion":"result == 26880"}]},{"id":"pc_20","description":"Test with a limit that includes the eighth amicable pair (17296, 18416).","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":18416,"max_val":18416}},"postconditions":[{"assertion":"result == 35712"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60e4"},"test_cases":[{"id":"TC1","description":"Typical case: positive real and imaginary parts.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":0.1,"max_val":100.0},"b":{"min_val":0.1,"max_val":100.0}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC2","description":"Typical case: negative real and imaginary parts.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-100.0,"max_val":-0.1},"b":{"min_val":-100.0,"max_val":-0.1}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC3","description":"Typical case: positive real, negative imaginary.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":0.1,"max_val":100.0},"b":{"min_val":-100.0,"max_val":-0.1}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC4","description":"Typical case: negative real, positive imaginary.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-100.0,"max_val":-0.1},"b":{"min_val":0.1,"max_val":100.0}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC5","description":"Edge case: zero real part, positive imaginary part.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":0.0,"max_val":0.0},"b":{"min_val":0.1,"max_val":100.0}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC6","description":"Edge case: zero real part, negative imaginary part.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":0.0,"max_val":0.0},"b":{"min_val":-100.0,"max_val":-0.1}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC7","description":"Edge case: positive real part, zero imaginary part.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":0.1,"max_val":100.0},"b":{"min_val":0.0,"max_val":0.0}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC8","description":"Edge case: negative real part, zero imaginary part.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-100.0,"max_val":-0.1},"b":{"min_val":0.0,"max_val":0.0}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC9","description":"Edge case: zero real and imaginary parts (origin).","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":0.0,"max_val":0.0},"b":{"min_val":0.0,"max_val":0.0}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC10","description":"Boundary case: very small positive real and imaginary parts.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":1E-09,"max_val":1E-05},"b":{"min_val":1E-09,"max_val":1E-05}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC11","description":"Boundary case: very large positive real and imaginary parts.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":100000.0,"max_val":1E+10},"b":{"min_val":100000.0,"max_val":1E+10}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC12","description":"Boundary case: very small negative real and imaginary parts.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-1E-05,"max_val":-1E-09},"b":{"min_val":-1E-05,"max_val":-1E-09}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC13","description":"Boundary case: very large negative real and imaginary parts.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-1E+10,"max_val":-100000.0},"b":{"min_val":-1E+10,"max_val":-100000.0}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC14","description":"Invariant check: angle should be in [-pi, pi].","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-1E+10,"max_val":1E+10},"b":{"min_val":-1E+10,"max_val":1E+10}},"assumptions":[],"postconditions":[{"assertion":"-math.pi <= result <= math.pi"}]},{"id":"TC15","description":"Negative Test: invalid type for 'a' (string).","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"str","b":"float"},"input_constraints":{"a":{"max_codepoint":255},"b":{"min_val":-100.0,"max_val":100.0}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC16","description":"Negative Test: invalid type for 'b' (None).","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"None"},"input_constraints":{"a":{"min_val":-100.0,"max_val":100.0},"b":{}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC17","description":"Large magnitude, positive quadrant.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":1E+09,"max_val":1E+10},"b":{"min_val":1E+09,"max_val":1E+10}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC18","description":"Small magnitude, negative quadrant.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-1E-09,"max_val":-1E-10},"b":{"min_val":-1E-09,"max_val":-1E-10}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC19","description":"Real axis, positive value.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":1.0,"max_val":1000.0},"b":{"min_val":0.0,"max_val":0.0}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]},{"id":"TC20","description":"Imaginary axis, negative value.","execution_statement":"result = angle_complex(a,b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":0.0,"max_val":0.0},"b":{"min_val":-1000.0,"max_val":-1.0}},"assumptions":[],"postconditions":[{"assertion":"abs(result - cmath.phase(complex(a,b))) < 1e-9"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60e5"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive real and imaginary parts","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":0.1,"max_val":100.0},"b":{"min_val":0.1,"max_val":100.0}},"postconditions":[{"assertion":"result >= 0 and result <= cmath.pi / 2"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Negative real and imaginary parts","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-100.0,"max_val":-0.1},"b":{"min_val":-100.0,"max_val":-0.1}},"postconditions":[{"assertion":"result >= -cmath.pi and result <= -cmath.pi / 2"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: Mixed sign real and imaginary parts","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-100.0,"max_val":100.0,"is_mixed":true},"b":{"min_val":-100.0,"max_val":100.0,"is_mixed":true}},"postconditions":[{"assertion":"-cmath.pi <= result <= cmath.pi"}],"assumptions":["a != 0","b != 0"]},{"id":"pc_4","description":"Edge Case: Zero real part, positive imaginary part","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"max_val":0.0},"b":{"min_val":0.1,"max_val":100.0}},"postconditions":[{"assertion":"abs(result - cmath.pi / 2) < 1e-9"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Zero real part, negative imaginary part","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"max_val":0.0},"b":{"min_val":-100.0,"max_val":-0.1}},"postconditions":[{"assertion":"abs(result - (-cmath.pi / 2)) < 1e-9"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Positive real part, zero imaginary part","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":0.1,"max_val":100.0},"b":{"max_val":0.0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: Negative real part, zero imaginary part","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-100.0,"max_val":-0.1},"b":{"max_val":0.0}},"postconditions":[{"assertion":"result == cmath.pi"}],"assumptions":[]},{"id":"pc_8","description":"Edge Case: Both inputs are zero","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"max_val":0.0},"b":{"max_val":0.0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_9","description":"Boundary Value: Large positive numbers","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":1E+10,"max_val":1E+12},"b":{"min_val":1E+10,"max_val":1E+12}},"postconditions":[{"assertion":"-cmath.pi <= result <= cmath.pi"}],"assumptions":[]},{"id":"pc_10","description":"Boundary Value: Large negative numbers","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-1E+12,"max_val":-1E+10},"b":{"min_val":-1E+12,"max_val":-1E+10}},"postconditions":[{"assertion":"-cmath.pi <= result <= cmath.pi"}],"assumptions":[]},{"id":"pc_11","description":"Invariant: Angle is always within [-pi, pi]","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"allow_nan":false,"allow_infinity":false},"b":{"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"-cmath.pi <= result <= cmath.pi"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Non-numeric input for 'a'","execution_statement":"try: result = angle_complex(a, b) except Exception as e: result = e","input_types":{"a":"str","b":"float"},"input_constraints":{"a":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Non-numeric input for 'b'","execution_statement":"try: result = angle_complex(a, b) except Exception as e: result = e","input_types":{"a":"float","b":"str"},"input_constraints":{"b":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Edge Case: Very small positive numbers","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":1E-10,"max_val":1E-05},"b":{"min_val":1E-10,"max_val":1E-05}},"postconditions":[{"assertion":"result >= 0 and result <= cmath.pi / 2"}],"assumptions":[]},{"id":"pc_15","description":"Edge Case: Very small negative numbers","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-1E-05,"max_val":-1E-10},"b":{"min_val":-1E-05,"max_val":-1E-10}},"postconditions":[{"assertion":"result >= -cmath.pi and result <= -cmath.pi / 2"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60e6"},"test_cases":[{"id":"pc_1","description":"Typical case: Mixed 0s and 1s.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"pattern":"^[01]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(string)"}],"assumptions":[]},{"id":"pc_2","description":"Edge case: String with all 0s.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"pattern":"^0+$","max_codepoint":255}},"postconditions":[{"assertion":"result == len(string)"}],"assumptions":[]},{"id":"pc_3","description":"Edge case: String with all 1s.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"pattern":"^1+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Boundary case: Empty string.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":0,"max_len":0,"pattern":"^[01]*$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_5","description":"Boundary case: Single '0'.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":1,"pattern":"^0+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_6","description":"Boundary case: Single '1'.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":1,"pattern":"^1+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_7","description":"Alternating 0s and 1s.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"pattern":"^(01)+$|^10+$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(string)"}],"assumptions":[]},{"id":"pc_8","description":"String with a single '0' surrounded by '1's.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":3,"max_len":50,"pattern":"^2+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_9","description":"String with a single '1' surrounded by '0's.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":3,"max_len":50,"pattern":"^10+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_10","description":"Long string with a dominant '0' substring.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":50,"max_len":100,"pattern":"^1*0{20}1*$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 20"},{"assertion":"result <= len(string)"}],"assumptions":[]},{"id":"pc_11","description":"Long string with a dominant '1' substring.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":50,"max_len":100,"pattern":"^0*1{20}0*$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_12","description":"String where max difference occurs in the middle.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":50,"pattern":"^1{5}1+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 5"}],"assumptions":[]},{"id":"pc_13","description":"String with no 0s, only 1s.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"pattern":"^1+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_14","description":"String with no 1s, only 0s.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"pattern":"^0+$","max_codepoint":255}},"postconditions":[{"assertion":"result == len(string)"}],"assumptions":[]},{"id":"pc_15","description":"String with a large number of 0s followed by 1s.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":50,"pattern":"^0{5}1+$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 5"},{"assertion":"result <= len(string)"}],"assumptions":[]},{"id":"pc_16","description":"String with a large number of 1s followed by 0s.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":50,"pattern":"^1{5}0+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_17","description":"String with a pattern that resets current_sum to 0 multiple times.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":50,"pattern":"^(0101010101|1010101010)$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= 1"}],"assumptions":[]},{"id":"pc_18","description":"String with maximum length.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1000,"max_len":1000,"pattern":"^[01]+$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= 1000"}],"assumptions":[]},{"id":"pc_19","description":"String with a single 0 at the beginning.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":2,"max_len":50,"pattern":"^01+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_20","description":"String with a single 0 at the end.","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":2,"max_len":50,"pattern":"^1$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60e7"},"test_cases":[{"id":"pc_1","description":"Happy Path: Non-empty binary string","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^[01]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int) and result >= 0"},{"assertion":"result <= len(string)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String with all '0's","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^0+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == len(string)"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: String with all '1's","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^1+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Case: Single '0'","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^0$","min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Case: Single '1'","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^1$","min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_7","description":"Invariant: Result is always non-negative","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^[01]*$","min_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_8","description":"Typical Case: Mixed '0's and '1's","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^[01]+$","min_len":2,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int) and result >= 0"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Non-binary string characters","execution_statement":"try: result = find_length(string) except Exception as e: result = e","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^[^01]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Non-string input (integer)","execution_statement":"try: result = find_length(string) except Exception as e: result = e","input_types":{"string":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-string input (None)","execution_statement":"try: result = find_length(string) except Exception as e: result = e","input_types":{"string":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Long string with alternating 0s and 1s","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^(01)+$","min_len":100,"max_len":200,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int) and result >= 0"}],"assumptions":[]},{"id":"pc_13","description":"Long string with alternating 1s and 0s","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^(10)+$","min_len":100,"max_len":200,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int) and result >= 0"}],"assumptions":[]},{"id":"pc_14","description":"String with a long sequence of 0s","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^1*0{50,100}1*$","min_len":50,"max_len":200,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int) and result >= 0"}],"assumptions":[]},{"id":"pc_15","description":"String with a long sequence of 1s","execution_statement":"result = find_length(string)","input_types":{"string":"str"},"input_constraints":{"string":{"pattern":"^0*1{50,100}0*$","min_len":50,"max_len":200,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int) and result >= 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60e8"},"test_cases":[{"id":"TC001","description":"Test with typical positive integers.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":2,"max_val":100},"y":{"min_val":2,"max_val":100}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC002","description":"Test with boundary values for integers (positive).","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":2147483647,"max_val":2147483647},"y":{"min_val":2147483647,"max_val":2147483647}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC003","description":"Test with zero as one of the multiplicands.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":100},"y":{"value":0}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC004","description":"Test with one as one of the multiplicands.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":100},"y":{"value":1}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC005","description":"Test with negative numbers.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":-2},"y":{"min_val":-100,"max_val":-2}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC006","description":"Test with a positive and a negative number.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":2,"max_val":100},"y":{"min_val":-100,"max_val":-2}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC007","description":"Test with a negative and a positive number.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":-2},"y":{"min_val":2,"max_val":100}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC008","description":"Test commutativity: a * b == b * a","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":100},"y":{"min_val":-100,"max_val":100}},"assumptions":["x != 0 and y != 0"],"postconditions":[{"assertion":"result == y * x"}]},{"id":"TC009","description":"Test multiplication by one: a * 1 == a","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":100},"y":{"value":1}},"postconditions":[{"assertion":"result == x"}]},{"id":"TC010","description":"Test multiplication by zero: a * 0 == 0","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":100},"y":{"value":0}},"postconditions":[{"assertion":"result == 0"}]},{"id":"TC011","description":"Test with large positive numbers.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1000000,"max_val":10000000},"y":{"min_val":1000000,"max_val":10000000}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC012","description":"Test with large negative numbers.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-10000000,"max_val":-1000000},"y":{"min_val":-10000000,"max_val":-1000000}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC013","description":"Test with large positive and negative numbers.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1000000,"max_val":10000000},"y":{"min_val":-10000000,"max_val":-1000000}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC014","description":"Test with boundary value -1.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":100},"y":{"value":-1}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC015","description":"Test with boundary value -1 for both.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"value":-1},"y":{"value":-1}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC016","description":"Test with large number and -1.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1000000,"max_val":10000000},"y":{"value":-1}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC017","description":"Test with -1 and large number.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"value":-1},"y":{"min_val":1000000,"max_val":10000000}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC018","description":"Test with large negative number and -1.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-10000000,"max_val":-1000000},"y":{"value":-1}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC019","description":"Test with -1 and large negative number.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"value":-1},"y":{"min_val":-10000000,"max_val":-1000000}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"TC020","description":"Test with maximum and minimum integer values.","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-2147483648,"max_val":2147483647},"y":{"min_val":-2147483648,"max_val":2147483647}},"postconditions":[{"assertion":"result == x * y"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60e9"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive integers","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1000},"y":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_2","description":"Edge Case: y is zero","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-1000,"max_val":1000},"y":{"value":0}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_3","description":"Edge Case: y is one","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-1000,"max_val":1000},"y":{"value":1}},"postconditions":[{"assertion":"result == x"}]},{"id":"pc_4","description":"Edge Case: x is zero","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"value":0},"y":{"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_5","description":"Negative y value","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1000},"y":{"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_6","description":"Negative x value","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-1000,"max_val":-1},"y":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_7","description":"Both negative values","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-1000,"max_val":-1},"y":{"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_8","description":"Large positive integers","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":10000,"max_val":100000},"y":{"min_val":10000,"max_val":100000}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_9","description":"Large negative integers","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100000,"max_val":-10000},"y":{"min_val":-100000,"max_val":-10000}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_10","description":"Mixed large positive and negative integers","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100000,"max_val":100000,"is_mixed":true},"y":{"min_val":-100000,"max_val":100000,"is_mixed":true}},"assumptions":["x != 0","y != 0"],"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_11","description":"Result sign check: positive * positive","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1000},"y":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result > 0"}]},{"id":"pc_12","description":"Result sign check: positive * negative","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":1000},"y":{"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result < 0"}]},{"id":"pc_13","description":"Result sign check: negative * positive","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-1000,"max_val":-1},"y":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result < 0"}]},{"id":"pc_14","description":"Result sign check: negative * negative","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-1000,"max_val":-1},"y":{"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result > 0"}]},{"id":"pc_15","description":"Test with None input for x (expect TypeError)","execution_statement":"try: result = multiply_int(x, y) except Exception as e: result = e","input_types":{"x":"Optional[int]","y":"int"},"input_constraints":{"x":{"allow_none":true},"y":{"min_val":1,"max_val":100}},"assumptions":["x is None"],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_16","description":"Test with None input for y (expect TypeError)","execution_statement":"try: result = multiply_int(x, y) except Exception as e: result = e","input_types":{"x":"int","y":"Optional[int]"},"input_constraints":{"x":{"min_val":1,"max_val":100},"y":{"allow_none":true}},"assumptions":["y is None"],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_17","description":"Test with float input for x (expect TypeError)","execution_statement":"try: result = multiply_int(x, y) except Exception as e: result = e","input_types":{"x":"float","y":"int"},"input_constraints":{"y":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_18","description":"Test with float input for y (expect TypeError)","execution_statement":"try: result = multiply_int(x, y) except Exception as e: result = e","input_types":{"x":"int","y":"float"},"input_constraints":{"x":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_19","description":"Test with string input for x (expect TypeError)","execution_statement":"try: result = multiply_int(x, y) except Exception as e: result = e","input_types":{"x":"str","y":"int"},"input_constraints":{"x":{"min_len":1,"max_codepoint":255},"y":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_20","description":"Test with string input for y (expect TypeError)","execution_statement":"try: result = multiply_int(x, y) except Exception as e: result = e","input_types":{"x":"int","y":"str"},"input_constraints":{"x":{"min_val":1,"max_val":100},"y":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60ea"},"test_cases":[{"id":"pc_1","description":"Typical case: Find words longer than 3 characters.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":1,"max_val":5},"str_val":{"min_len":10,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n_val for word in result)"},{"assertion":"set(result).issubset(set(str_val.split()))"}],"assumptions":[]},{"id":"pc_2","description":"Edge case: n = 0, should return all words.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":0,"max_val":0},"str_val":{"min_len":5,"max_len":30,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n_val for word in result)"},{"assertion":"set(result) == set(str_val.split())"}],"assumptions":[]},{"id":"pc_3","description":"Edge case: n is very large, should return empty list.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":50,"max_val":100},"str_val":{"min_len":10,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"len(result) == 0"}],"assumptions":[]},{"id":"pc_4","description":"Edge case: Empty string input.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":1,"max_val":5},"str_val":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"len(result) == 0"}],"assumptions":[]},{"id":"pc_5","description":"Boundary case: n equals the length of some words.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":4,"max_val":4},"str_val":{"min_len":10,"max_len":30,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n_val for word in result)"},{"assertion":"set(result) == set(['test', 'case'])"}],"assumptions":["str_val.split() == ['word', 'test', 'case']"]},{"id":"pc_6","description":"String with only spaces.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":1,"max_val":5},"str_val":{"min_len":5,"max_len":10,"pattern":"^[ ]+$","max_codepoint":255}},"postconditions":[{"assertion":"len(result) == 0"}],"assumptions":[]},{"id":"pc_7","description":"String with duplicate words, some longer than n.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":3,"max_val":3},"str_val":{"min_len":10,"max_len":30,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n_val for word in result)"},{"assertion":"result.count('apple') == 2"},{"assertion":"result.count('banana') == 1"},{"assertion":"len(result) == 3"}],"assumptions":["str_val.split() == ['apple', 'banana', 'apple', 'grape']"]},{"id":"pc_8","description":"String with words of exactly length n+1.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":4,"max_val":4},"str_val":{"min_len":10,"max_len":30,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n_val for word in result)"},{"assertion":"set(result) == set(['apple', 'grape', 'lemon'])"}],"assumptions":["str_val.split() == ['apple', 'grape', 'lemon']"]},{"id":"pc_9","description":"String with words of exactly length n.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":5,"max_val":5},"str_val":{"min_len":10,"max_len":30,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"len(result) == 0"}],"assumptions":["str_val.split() == ['apple', 'grape', 'lemon']"]},{"id":"pc_10","description":"Long string with many words, mixed lengths.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":5,"max_val":10,"is_mixed":true},"str_val":{"min_len":50,"max_len":200,"pattern":"^[a-zA-Z ]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n_val for word in result)"},{"assertion":"set(result).issubset(set(str_val.split()))"}],"assumptions":[]},{"id":"pc_11","description":"String with only short words.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":10,"max_val":15},"str_val":{"min_len":10,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"len(result) == 0"}],"assumptions":["all(len(word) <= n_val for word in str_val.split())"]},{"id":"pc_12","description":"String with only long words.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":1,"max_val":5},"str_val":{"min_len":10,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n_val for word in result)"},{"assertion":"set(result) == set(str_val.split())"}],"assumptions":["all(len(word) > n_val for word in str_val.split())"]},{"id":"pc_13","description":"String with mixed case words.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":3,"max_val":3,"is_mixed":true},"str_val":{"min_len":10,"max_len":30,"pattern":"^[a-zA-Z ]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n_val for word in result)"},{"assertion":"set(result) == set(['Apple', 'banana', 'Grape'])"}],"assumptions":["str_val.split() == ['Apple', 'banana', 'Grape']"]},{"id":"pc_14","description":"String with leading/trailing spaces and multiple spaces between words.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":4,"max_val":4},"str_val":{"min_len":10,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n_val for word in result)"},{"assertion":"set(result) == set(['test', 'case'])"}],"assumptions":["str_val.split() == ['word', 'test', 'case']"]},{"id":"pc_15","description":"String with very long words.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":10,"max_val":10},"str_val":{"min_len":20,"max_len":100,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n_val for word in result)"},{"assertion":"set(result) == set(['supercalifragilisticexpialidocious', 'pneumonoultramicroscopicsilicovolcanoconiosis'])"}],"assumptions":["str_val.split() == ['supercalifragilisticexpialidocious', 'pneumonoultramicroscopicsilicovolcanoconiosis']"]},{"id":"pc_16","description":"String with words of length exactly n+1.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":5,"max_val":5},"str_val":{"min_len":10,"max_len":30,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n_val for word in result)"},{"assertion":"set(result) == set(['abcdef', 'ghijkl', 'mnopqr'])"}],"assumptions":["str_val.split() == ['abcdef', 'ghijkl', 'mnopqr']"]},{"id":"pc_17","description":"String with words of length exactly n.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":6,"max_val":6},"str_val":{"min_len":10,"max_len":30,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"len(result) == 0"}],"assumptions":["str_val.split() == ['abcdef', 'ghijkl', 'mnopqr']"]},{"id":"pc_18","description":"String with a mix of very short and very long words.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":5,"max_val":5},"str_val":{"min_len":10,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n_val for word in result)"},{"assertion":"set(result) == set(['ffffff', 'ggggggg'])"}],"assumptions":["str_val.split() == ['a', 'bb', 'ccc', 'dddd', 'eeeee', 'ffffff', 'ggggggg']"]},{"id":"pc_19","description":"String with only one word, which is longer than n.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":3,"max_val":3},"str_val":{"min_len":5,"max_len":10,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n_val for word in result)"},{"assertion":"set(result) == set(['longer'])"}],"assumptions":["str_val.split() == ['longer']"]},{"id":"pc_20","description":"String with only one word, which is shorter than or equal to n.","execution_statement":"result = long_words(n_val, str_val)","input_types":{"n_val":"int","str_val":"str"},"input_constraints":{"n_val":{"min_val":6,"max_val":6},"str_val":{"min_len":5,"max_len":10,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"len(result) == 0"}],"assumptions":["str_val.split() == ['shorter']"]}]}
{"_id":{"$oid":"692adffe1b18223597bc60eb"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with mixed word lengths.","execution_statement":"result = long_words(n, str_input)","input_types":{"n":"int","str_input":"str"},"input_constraints":{"n":{"min_val":1,"max_val":10,"is_mixed":true},"str_input":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z ]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"result == [word for word in str_input.split(' ') if len(word) > n]"}],"assumptions":["len(str_input.split(' ')) > 0"]},{"id":"pc_2","description":"Edge Case: Empty input string.","execution_statement":"result = long_words(n, str_input)","input_types":{"n":"int","str_input":"str"},"input_constraints":{"n":{"min_val":0,"max_val":10},"str_input":{"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: No words longer than n.","execution_statement":"result = long_words(n, str_input)","input_types":{"n":"int","str_input":"str"},"input_constraints":{"n":{"min_val":10,"max_val":20},"str_input":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":["all(len(word) <= n for word in str_input.split(' '))"]},{"id":"pc_4","description":"Boundary Value: n is 0, should return all non-empty words.","execution_statement":"result = long_words(n, str_input)","input_types":{"n":"int","str_input":"str"},"input_constraints":{"n":{"min_val":0,"max_val":0},"str_input":{"min_len":1,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == [word for word in str_input.split(' ') if len(word) > n]"}],"assumptions":["str_input != ''"]},{"id":"pc_5","description":"Invariant: All returned words must be longer than n.","execution_statement":"result = long_words(n, str_input)","input_types":{"n":"int","str_input":"str"},"input_constraints":{"n":{"min_val":1,"max_val":10},"str_input":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"}],"assumptions":["len(result) > 0"]},{"id":"pc_6","description":"Typical Case: String with multiple words, some longer than n.","execution_statement":"result = long_words(n, str_input)","input_types":{"n":"int","str_input":"str"},"input_constraints":{"n":{"min_val":3,"max_val":7},"str_input":{"min_len":10,"max_len":100,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"result == [word for word in str_input.split(' ') if len(word) > n]"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: String with only spaces.","execution_statement":"result = long_words(n, str_input)","input_types":{"n":"int","str_input":"str"},"input_constraints":{"n":{"min_val":0,"max_val":5},"str_input":{"min_len":1,"max_len":20,"pattern":"^[ ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_8","description":"Boundary Value: Large n, expecting empty list.","execution_statement":"result = long_words(n, str_input)","input_types":{"n":"int","str_input":"str"},"input_constraints":{"n":{"min_val":100,"max_val":200},"str_input":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_9","description":"Typical Case: String with words of exactly n length (should not be included).","execution_statement":"result = long_words(n, str_input)","input_types":{"n":"int","str_input":"str"},"input_constraints":{"n":{"min_val":5,"max_val":10},"str_input":{"min_len":10,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":["all(len(word) == n for word in str_input.split(' '))"]},{"id":"pc_10","description":"Negative Test: Non-string input for str parameter.","execution_statement":"try: result = long_words(n, str_input) except Exception as e: result = e","input_types":{"n":"int","str_input":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-integer input for n parameter.","execution_statement":"try: result = long_words(n, str_input) except Exception as e: result = e","input_types":{"n":"str","str_input":"str"},"input_constraints":{"n":{"min_len":1,"max_len":5,"max_codepoint":255},"str_input":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Typical Case: String with leading/trailing spaces.","execution_statement":"result = long_words(n, str_input)","input_types":{"n":"int","str_input":"str"},"input_constraints":{"n":{"min_val":3,"max_val":7},"str_input":{"min_len":10,"max_len":100,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"result == [word for word in str_input.split(' ') if len(word) > n]"}],"assumptions":["str_input.startswith(' ')","str_input.endswith(' ')"]},{"id":"pc_13","description":"Typical Case: String with multiple spaces between words.","execution_statement":"result = long_words(n, str_input)","input_types":{"n":"int","str_input":"str"},"input_constraints":{"n":{"min_val":3,"max_val":7},"str_input":{"min_len":10,"max_len":100,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"result == [word for word in str_input.split(' ') if len(word) > n]"}],"assumptions":["'  ' in str_input"]},{"id":"pc_14","description":"Boundary Value: Max integer for n.","execution_statement":"result = long_words(n, str_input)","input_types":{"n":"int","str_input":"str"},"input_constraints":{"n":{"min_val":2147483647,"max_val":2147483647},"str_input":{"min_len":1,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_15","description":"Typical Case: Long string with many words.","execution_statement":"result = long_words(n, str_input)","input_types":{"n":"int","str_input":"str"},"input_constraints":{"n":{"min_val":5,"max_val":15},"str_input":{"min_len":100,"max_len":500,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"result == [word for word in str_input.split(' ') if len(word) > n]"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60ec"},"test_cases":[{"id":"test_valid_magic_square_3x3","description":"Tests a standard 3x3 magic square.","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"unique":false}},"assumptions":["len(my_matrix) == 3","all(len(row) == 3 for row in my_matrix)","set(sum(row) for row in my_matrix) == {15}","set(sum(my_matrix[i][j] for i in range(3)) for j in range(3)) == {15}","sum(my_matrix[i][i] for i in range(3)) == 15","sum(my_matrix[i][2-i] for i in range(3)) == 15"],"postconditions":[{"assertion":"result == True"}]},{"id":"test_valid_magic_square_4x4","description":"Tests a standard 4x4 magic square.","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":4,"max_len":4,"unique":false}},"assumptions":["len(my_matrix) == 4","all(len(row) == 4 for row in my_matrix)","set(sum(row) for row in my_matrix) == {34}","set(sum(my_matrix[i][j] for i in range(4)) for j in range(4)) == {34}","sum(my_matrix[i][i] for i in range(4)) == 34","sum(my_matrix[i][3-i] for i in range(4)) == 34"],"postconditions":[{"assertion":"result == True"}]},{"id":"test_invalid_magic_square_non_equal_rows","description":"Tests a matrix where row sums are not equal.","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"unique":false}},"assumptions":["len(my_matrix) == 3","all(len(row) == 3 for row in my_matrix)","len(set(sum(row) for row in my_matrix)) > 1"],"postconditions":[{"assertion":"result == False"}]},{"id":"test_invalid_magic_square_non_equal_cols","description":"Tests a matrix where column sums are not equal.","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"unique":false}},"assumptions":["len(my_matrix) == 3","all(len(row) == 3 for row in my_matrix)","len(set(sum(my_matrix[i][j] for i in range(3)) for j in range(3))) > 1"],"postconditions":[{"assertion":"result == False"}]},{"id":"test_invalid_magic_square_unequal_diagonals","description":"Tests a matrix where diagonals sums are not equal to row/column sums.","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"unique":false}},"assumptions":["len(my_matrix) == 3","all(len(row) == 3 for row in my_matrix)","sum(my_matrix[0]) == sum(my_matrix[i][j] for i in range(3) for j in range(3) if i == j)","sum(my_matrix[0]) != sum(my_matrix[i][2-i] for i in range(3))"],"postconditions":[{"assertion":"result == False"}]},{"id":"test_boundary_1x1_magic","description":"Tests a 1x1 matrix which is a magic square.","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":1,"max_len":1,"unique":false}},"assumptions":["len(my_matrix) == 1","len(my_matrix[0]) == 1"],"postconditions":[{"assertion":"result == True"}]},{"id":"test_boundary_1x1_non_magic","description":"Tests a 1x1 matrix which is not a magic square (though trivially it is).","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":1,"max_len":1,"unique":false}},"assumptions":["len(my_matrix) == 1","len(my_matrix[0]) == 1"],"postconditions":[{"assertion":"result == True"}]},{"id":"test_edge_case_zeros","description":"Tests a matrix filled with zeros.","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"unique":false}},"assumptions":["len(my_matrix) == 3","all(len(row) == 3 for row in my_matrix)","all(all(x == 0 for x in row) for row in my_matrix)"],"postconditions":[{"assertion":"result == True"}]},{"id":"test_edge_case_negative_numbers","description":"Tests a magic square with negative numbers.","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"unique":false}},"assumptions":["len(my_matrix) == 3","all(len(row) == 3 for row in my_matrix)","set(sum(row) for row in my_matrix) == {-15}","set(sum(my_matrix[i][j] for i in range(3)) for j in range(3)) == {-15}","sum(my_matrix[i][i] for i in range(3)) == -15","sum(my_matrix[i][2-i] for i in range(3)) == -15"],"postconditions":[{"assertion":"result == True"}]},{"id":"test_non_square_matrix","description":"Tests a non-square matrix (should ideally raise an error or return False based on implementation).","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"unique":false}},"assumptions":["len(my_matrix) == 3","len(my_matrix[0]) != 3"],"postconditions":[{"assertion":"result == False"}]},{"id":"test_empty_matrix","description":"Tests an empty matrix.","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":0,"max_len":0}},"assumptions":["len(my_matrix) == 0"],"postconditions":[{"assertion":"result == False"}]},{"id":"test_matrix_with_empty_row","description":"Tests a matrix with an empty row.","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"unique":false}},"assumptions":["len(my_matrix) == 3","my_matrix[0] == []"],"postconditions":[{"assertion":"result == False"}]},{"id":"test_large_magic_square","description":"Tests a larger magic square (e.g., 5x5).","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":5,"max_len":5,"unique":false}},"assumptions":["len(my_matrix) == 5","all(len(row) == 5 for row in my_matrix)","len(set(sum(row) for row in my_matrix)) == 1","len(set(sum(my_matrix[i][j] for i in range(5)) for j in range(5))) == 1","len(set(sum(my_matrix[i][i] for i in range(5)) for _ in range(1))) == 1","len(set(sum(my_matrix[i][4-i] for i in range(5)) for _ in range(1))) == 1","sum(my_matrix[0]) == sum(my_matrix[i][i] for i in range(5))","sum(my_matrix[0]) == sum(my_matrix[i][4-i] for i in range(5))"],"postconditions":[{"assertion":"result == True"}]},{"id":"test_large_non_magic_square","description":"Tests a larger non-magic square (e.g., 5x5).","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":5,"max_len":5,"unique":false}},"assumptions":["len(my_matrix) == 5","all(len(row) == 5 for row in my_matrix)","len(set(sum(row) for row in my_matrix)) > 1"],"postconditions":[{"assertion":"result == False"}]},{"id":"test_matrix_with_duplicate_numbers","description":"Tests a magic square with duplicate numbers (if allowed by definition).","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"unique":false}},"assumptions":["len(my_matrix) == 3","all(len(row) == 3 for row in my_matrix)","set(sum(row) for row in my_matrix) == {15}","set(sum(my_matrix[i][j] for i in range(3)) for j in range(3)) == {15}","sum(my_matrix[i][i] for i in range(3)) == 15","sum(my_matrix[i][2-i] for i in range(3)) == 15"],"postconditions":[{"assertion":"result == True"}]},{"id":"test_matrix_with_large_numbers","description":"Tests a magic square with large integer values.","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"unique":false}},"assumptions":["len(my_matrix) == 3","all(len(row) == 3 for row in my_matrix)","set(sum(row) for row in my_matrix) == {1000}","set(sum(my_matrix[i][j] for i in range(3)) for j in range(3)) == {1000}","sum(my_matrix[i][i] for i in range(3)) == 1000","sum(my_matrix[i][2-i] for i in range(3)) == 1000"],"postconditions":[{"assertion":"result == True"}]},{"id":"test_matrix_with_mixed_row_lengths","description":"Tests a matrix with mixed row lengths (should be invalid).","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"unique":false,"is_mixed":true}},"assumptions":["len(my_matrix) == 3","my_matrix[1] != my_matrix[0]"],"postconditions":[{"assertion":"result == False"}]},{"id":"test_2x2_magic_square","description":"Tests a 2x2 magic square.","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":2,"max_len":2,"unique":false}},"assumptions":["len(my_matrix) == 2","all(len(row) == 2 for row in my_matrix)","set(sum(row) for row in my_matrix) == {3}","set(sum(my_matrix[i][j] for i in range(2)) for j in range(2)) == {3}","sum(my_matrix[i][i] for i in range(2)) == 3","sum(my_matrix[i][1-i] for i in range(2)) == 3"],"postconditions":[{"assertion":"result == True"}]},{"id":"test_2x2_non_magic_square","description":"Tests a 2x2 non-magic square.","execution_statement":"result = magic_square_test(my_matrix)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":2,"max_len":2,"unique":false}},"assumptions":["len(my_matrix) == 2","all(len(row) == 2 for row in my_matrix)","len(set(sum(row) for row in my_matrix)) > 1"],"postconditions":[{"assertion":"result == False"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60ed"},"test_cases":[{"id":"pc_1","description":"Basic Magic Square (3x3)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"unique":false,"sorted":false},"my_matrix[*]":{"min_len":3,"max_len":3,"unique":false,"sorted":false}},"assumptions":["len(set(sum(row) for row in my_matrix)) == 1","len(set(sum(my_matrix[r][c] for r in range(len(my_matrix)))) for c in range(len(my_matrix[0]))) == 1","sum(my_matrix[i][i] for i in range(len(my_matrix))) == sum(my_matrix[len(my_matrix)-1-i][i] for i in range(len(my_matrix)))","len(set(sum(row) for row in my_matrix)) == 1"],"execution_statement":"result = magic_square_test(my_matrix)","postconditions":[{"assertion":"result == True"}]},{"id":"pc_2","description":"Non-Magic Square (3x3)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"unique":false,"sorted":false},"my_matrix[*]":{"min_len":3,"max_len":3,"unique":false,"sorted":false}},"assumptions":["len(set(sum(row) for row in my_matrix)) > 1 or len(set(sum(my_matrix[r][c] for r in range(len(my_matrix)))) for c in range(len(my_matrix[0]))) > 1 or sum(my_matrix[i][i] for i in range(len(my_matrix))) != sum(my_matrix[len(my_matrix)-1-i][i] for i in range(len(my_matrix)))"],"execution_statement":"result = magic_square_test(my_matrix)","postconditions":[{"assertion":"result == False"}]},{"id":"pc_3","description":"1x1 Matrix","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":1,"max_len":1},"my_matrix[*]":{"min_len":1,"max_len":1}},"execution_statement":"result = magic_square_test(my_matrix)","postconditions":[{"assertion":"result == True"}]},{"id":"pc_4","description":"Matrix with zeros","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"elements":{"min_val":0,"max_val":0}},"my_matrix[*]":{"min_len":2,"max_len":5}},"assumptions":["len(my_matrix) == len(my_matrix[0])"],"execution_statement":"result = magic_square_test(my_matrix)","postconditions":[{"assertion":"result == True"}]},{"id":"pc_5","description":"Matrix with negative numbers (Magic Square)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3},"my_matrix[*]":{"min_len":3,"max_len":3}},"assumptions":["len(set(sum(row) for row in my_matrix)) == 1","len(set(sum(my_matrix[r][c] for r in range(len(my_matrix)))) for c in range(len(my_matrix[0]))) == 1","sum(my_matrix[i][i] for i in range(len(my_matrix))) == sum(my_matrix[len(my_matrix)-1-i][i] for i in range(len(my_matrix)))","len(set(sum(row) for row in my_matrix)) == 1"],"execution_statement":"result = magic_square_test(my_matrix)","postconditions":[{"assertion":"result == True"}]},{"id":"pc_6","description":"Matrix with negative numbers (Not Magic Square)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3},"my_matrix[*]":{"min_len":3,"max_len":3}},"assumptions":["len(set(sum(row) for row in my_matrix)) > 1 or len(set(sum(my_matrix[r][c] for r in range(len(my_matrix)))) for c in range(len(my_matrix[0]))) > 1 or sum(my_matrix[i][i] for i in range(len(my_matrix))) != sum(my_matrix[len(my_matrix)-1-i][i] for i in range(len(my_matrix)))"],"execution_statement":"result = magic_square_test(my_matrix)","postconditions":[{"assertion":"result == False"}]},{"id":"pc_7","description":"Edge Case: Empty Matrix","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":0,"max_len":0}},"execution_statement":"try: result = magic_square_test(my_matrix) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_8","description":"Edge Case: Matrix with empty row","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":1,"max_len":3},"my_matrix[*]":{"min_len":0,"max_len":0}},"execution_statement":"try: result = magic_square_test(my_matrix) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_9","description":"Non-square matrix (more rows than columns)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3},"my_matrix[*]":{"min_len":2,"max_len":2}},"execution_statement":"try: result = magic_square_test(my_matrix) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_10","description":"Non-square matrix (more columns than rows)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":2,"max_len":2},"my_matrix[*]":{"min_len":3,"max_len":3}},"execution_statement":"try: result = magic_square_test(my_matrix) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_11","description":"Larger Magic Square (4x4)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":4,"max_len":4},"my_matrix[*]":{"min_len":4,"max_len":4}},"assumptions":["len(set(sum(row) for row in my_matrix)) == 1","len(set(sum(my_matrix[r][c] for r in range(len(my_matrix)))) for c in range(len(my_matrix[0]))) == 1","sum(my_matrix[i][i] for i in range(len(my_matrix))) == sum(my_matrix[len(my_matrix)-1-i][i] for i in range(len(my_matrix)))","len(set(sum(row) for row in my_matrix)) == 1"],"execution_statement":"result = magic_square_test(my_matrix)","postconditions":[{"assertion":"result == True"}]},{"id":"pc_12","description":"Non-integer input (float)","input_types":{"my_matrix":"list[list[float]]"},"input_constraints":{"my_matrix":{"min_len":2,"max_len":3},"my_matrix[*]":{"min_len":2,"max_len":3}},"execution_statement":"try: result = magic_square_test(my_matrix) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Non-integer input (string)","input_types":{"my_matrix":"list[list[str]]"},"input_constraints":{"my_matrix":{"min_len":2,"max_len":3},"my_matrix[*]":{"min_len":2,"max_len":3}},"execution_statement":"try: result = magic_square_test(my_matrix) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Non-integer input (None)","input_types":{"my_matrix":"list[list[int | None]]"},"input_constraints":{"my_matrix":{"min_len":2,"max_len":3,"allow_none":true},"my_matrix[*]":{"min_len":2,"max_len":3,"allow_none":true}},"assumptions":["None not in [item for sublist in my_matrix for item in sublist]"],"execution_statement":"try: result = magic_square_test(my_matrix) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_15","description":"Matrix with large numbers (Magic Square)","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"elements":{"min_val":10000,"max_val":100000}},"my_matrix[*]":{"min_len":3,"max_len":3}},"assumptions":["len(set(sum(row) for row in my_matrix)) == 1","len(set(sum(my_matrix[r][c] for r in range(len(my_matrix)))) for c in range(len(my_matrix[0]))) == 1","sum(my_matrix[i][i] for i in range(len(my_matrix))) == sum(my_matrix[len(my_matrix)-1-i][i] for i in range(len(my_matrix)))","len(set(sum(row) for row in my_matrix)) == 1"],"execution_statement":"result = magic_square_test(my_matrix)","postconditions":[{"assertion":"result == True"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60ee"},"test_cases":[{"id":"TC001","description":"Typical case with integers, multiple occurrences, and a clear maximum.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"min_val":-100,"max_val":100}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result in nums"}]},{"id":"TC002","description":"Edge case: Empty list.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"assumptions":[],"postconditions":[{"assertion":"result is None"}]},{"id":"TC003","description":"Edge case: List with a single element.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1}},"assumptions":[],"postconditions":[{"assertion":"result == nums[0]"}]},{"id":"TC004","description":"Edge case: All elements in the list are the same.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"unique":true}},"assumptions":["len(set(nums)) == 1"],"postconditions":[{"assertion":"result == nums[0]"}]},{"id":"TC005","description":"Typical case with strings.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[str]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"min_len_str":1,"max_len_str":10}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"result in nums"}]},{"id":"TC006","description":"Typical case with mixed types (integers and strings).","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[Union[int, str]]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"hashable_mix":true,"is_mixed":true}},"assumptions":[],"postconditions":[{"assertion":"result in nums"}]},{"id":"TC007","description":"Edge case: Tie for maximum frequency.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":50}},"assumptions":["len(set(nums)) > 1","Counter(nums).most_common(1)[0][1] == Counter(nums).most_common(2)[1][1]"],"postconditions":[{"assertion":"result in nums"}]},{"id":"TC008","description":"Boundary case: List with negative integers.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"min_val":-1000,"max_val":-1}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result in nums"}]},{"id":"TC009","description":"Boundary case: List with large integers.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"min_val":1000,"max_val":1000000}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result in nums"}]},{"id":"TC010","description":"Typical case with boolean values.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[bool]"},"input_constraints":{"nums":{"min_len":1,"max_len":50}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, bool)"},{"assertion":"result in nums"}]},{"id":"TC011","description":"Typical case with None values.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[Optional[int]]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"allow_none":true}},"assumptions":[],"postconditions":[{"assertion":"result is None or isinstance(result, int)"},{"assertion":"result in nums"}]},{"id":"TC012","description":"Large list to test performance and correctness.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":1000,"max_len":5000,"min_val":-1000,"max_val":1000}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result in nums"}]},{"id":"TC013","description":"List with empty strings.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[str]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"min_len_str":0,"max_len_str":10}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"result in nums"}]},{"id":"TC014","description":"List with very long strings.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[str]"},"input_constraints":{"nums":{"min_len":1,"max_len":10,"min_len_str":100,"max_len_str":200}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"result in nums"}]},{"id":"TC015","description":"List with tuples.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[tuple]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"min_len_tuple":1,"max_len_tuple":3}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"result in nums"}]},{"id":"TC016","description":"List with frozensets.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[frozenset]"},"input_constraints":{"nums":{"min_len":1,"max_len":50}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, frozenset)"},{"assertion":"result in nums"}]},{"id":"TC017","description":"List with mixed hashable types including None.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[Union[int, str, None]]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"allow_none":true,"is_mixed":true}},"assumptions":[],"postconditions":[{"assertion":"result is None or isinstance(result, (int, str))"},{"assertion":"result in nums"}]},{"id":"TC018","description":"List with a single type repeated many times.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"unique":true}},"assumptions":["len(set(nums)) == 1"],"postconditions":[{"assertion":"result == nums[0]"}]},{"id":"TC019","description":"List with diverse integer values and frequencies.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"min_val":-50,"max_val":50}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result in nums"}]},{"id":"TC020","description":"List with diverse string values and frequencies.","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"List[str]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"min_len_str":1,"max_len_str":5}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"result in nums"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60ef"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with diverse numbers","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":100}},"postconditions":[{"assertion":"returned_value in nums"}]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"try: result = max_occurrences(nums) except Exception as e: result = e","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}]},{"id":"pc_3","description":"Edge Case: List with a single element","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == nums[0]"}]},{"id":"pc_4","description":"Edge Case: List with all identical elements","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50}},"assumptions":["len(set(nums)) == 1"],"postconditions":[{"assertion":"result == nums[0]"}]},{"id":"pc_5","description":"Typical Case: Multiple elements with the same max frequency","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":100}},"assumptions":["len(set(nums)) > 1"],"postconditions":[{"assertion":"returned_value in nums"}]},{"id":"pc_6","description":"Boundary Case: Large list","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1000,"max_len":1000}},"postconditions":[{"assertion":"returned_value in nums"}]},{"id":"pc_7","description":"Mixed Types: Integers and Floats","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"list[Union[int, float]]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"is_mixed":true}},"postconditions":[{"assertion":"returned_value in nums"}]},{"id":"pc_8","description":"Negative Test: Non-iterable input (int)","execution_statement":"try: result = max_occurrences(nums) except Exception as e: result = e","input_types":{"nums":"int"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: Non-iterable input (None)","execution_statement":"try: result = max_occurrences(nums) except Exception as e: result = e","input_types":{"nums":"None"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: List containing None (should raise TypeError during comparison if not handled)","execution_statement":"try: result = max_occurrences(nums) except Exception as e: result = e","input_types":{"nums":"list[Union[int, None]]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"allow_none":true}},"assumptions":["None in nums"],"postconditions":[{"assertion":"isinstance(result, TypeError) or result in nums"}]},{"id":"pc_11","description":"Test with negative numbers","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":-1,"min_len":5,"max_len":50}},"postconditions":[{"assertion":"returned_value in nums"}]},{"id":"pc_12","description":"Test with mixed positive and negative numbers","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-50,"max_val":50,"min_len":5,"max_len":50,"is_mixed":true}},"postconditions":[{"assertion":"returned_value in nums"}]},{"id":"pc_13","description":"Test with zero as the most frequent element","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50}},"assumptions":["nums.count(0) > nums.count(x) for x in set(nums) if x != 0"],"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_14","description":"Test with floating point numbers","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"list[float]"},"input_constraints":{"nums":{"min_len":5,"max_len":50}},"postconditions":[{"assertion":"returned_value in nums"}]},{"id":"pc_15","description":"Test with strings (assuming elements can be strings)","execution_statement":"result = max_occurrences(nums)","input_types":{"nums":"list[str]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z-9]+$"}},"postconditions":[{"assertion":"returned_value in nums"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60f0"},"test_cases":[{"id":"pc_1","description":"Typical case with mixed vowels and consonants, and mixed casing.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":50,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_2","description":"Boundary case: Empty string.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"assert result == ''"}],"assumptions":[]},{"id":"pc_3","description":"Boundary case: String with only vowels.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":20,"alphabet":"aeiouAEIOU","max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_4","description":"Boundary case: String with only consonants.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":20,"alphabet":"bcdfghjklmnpqrstvwxzBCDFGHJKLMNPQRSTVWXZ","max_codepoint":255}},"postconditions":[{"assertion":"assert result == str1"}],"assumptions":[]},{"id":"pc_5","description":"Edge case: String with repeated vowels.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":30,"alphabet":"aeiouAEIOUaeiouAEIOU","max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_6","description":"Edge case: String with 'y' and 'Y' (should not be reversed).","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":50,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZyY","max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_7","description":"String with non-alphabetic characters.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":50,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()","max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_8","description":"String with only one character (vowel).","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":1,"alphabet":"aeiouAEIOU","max_codepoint":255}},"postconditions":[{"assertion":"assert result == str1"}],"assumptions":[]},{"id":"pc_9","description":"String with only one character (consonant).","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":1,"alphabet":"bcdfghjklmnpqrstvwxzBCDFGHJKLMNPQRSTVWXZ","max_codepoint":255}},"postconditions":[{"assertion":"assert result == str1"}],"assumptions":[]},{"id":"pc_10","description":"Long string with mixed vowels and consonants.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":100,"max_len":200,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_11","description":"String with Unicode characters (non-vowels).","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":50,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ","max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_12","description":"String with Unicode vowels.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":50,"alphabet":"aeiouAEIOU","max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_13","description":"String with only vowels and 'y'/'Y'.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":30,"alphabet":"aeiouAEIOUyY","max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_14","description":"String with only consonants and 'y'/'Y'.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":30,"alphabet":"bcdfghjklmnpqrstvwxzBCDFGHJKLMNPQRSTVWXZyY","max_codepoint":255}},"postconditions":[{"assertion":"assert result == str1"}],"assumptions":[]},{"id":"pc_15","description":"String with numbers and vowels.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":30,"alphabet":"aeiouAEIOU0123456789","max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_16","description":"String with symbols and vowels.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":30,"alphabet":"aeiouAEIOU!@#$%^&*()","max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_17","description":"String with all vowels, mixed case.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":10,"max_len":40,"alphabet":"aEiOu","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_18","description":"String with all consonants, mixed case.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":10,"max_len":40,"alphabet":"bCdFgHjKlMnPqRsTvWxZ","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"assert result == str1"}],"assumptions":[]},{"id":"pc_19","description":"String with vowels and numbers.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":30,"alphabet":"aeiouAEIOU0123456789","max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_20","description":"String with vowels and symbols.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":30,"alphabet":"aeiouAEIOU!@#$%^&*()","max_codepoint":255}},"postconditions":[{"assertion":"assert len(result) == len(str1)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60f1"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with mixed vowels and consonants.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"pattern":"^[a-zA-Z]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"len(result) == len(str1)"},{"assertion":"sum(1 for c in result if c in 'aeiouAEIOU') == sum(1 for c in str1 if c in 'aeiouAEIOU')"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string input.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String with no vowels.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"pattern":"^[^aeiouAEIOU]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == str1"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: String with only vowels.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"pattern":"^[aeiouAEIOU]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == str1[::-1]"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Case: String with mixed case vowels.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"pattern":"^[a-zA-Z]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_6","description":"Invariant: Length of the output string must match the input string.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"len(result) == len(str1)"}],"assumptions":[]},{"id":"pc_7","description":"Invariant: Number of vowels in the output must equal the number of vowels in the input.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"sum(1 for c in result if c in 'aeiouAEIOU') == sum(1 for c in str1 if c in 'aeiouAEIOU')"}],"assumptions":[]},{"id":"pc_8","description":"Invariant: Consonant positions should remain unchanged.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"all(result[i] == str1[i] for i in range(len(str1)) if str1[i] not in 'aeiouAEIOU')"}],"assumptions":[]},{"id":"pc_9","description":"Typical Case: A common word like 'leetcode'.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"value":"leetcode","max_codepoint":255}},"postconditions":[{"assertion":"result == 'leotcede'"}],"assumptions":[]},{"id":"pc_10","description":"Typical Case: Another common word like 'programming'.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"value":"programming","max_codepoint":255}},"postconditions":[{"assertion":"result == 'prigrammong'"}],"assumptions":[]},{"id":"pc_11","description":"Edge Case: Single character string (vowel).","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"value":"a","max_codepoint":255}},"postconditions":[{"assertion":"result == 'a'"}],"assumptions":[]},{"id":"pc_12","description":"Edge Case: Single character string (consonant).","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"value":"b","max_codepoint":255}},"postconditions":[{"assertion":"result == 'b'"}],"assumptions":[]},{"id":"pc_13","description":"Boundary Case: String with all same vowels.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"pattern":"^a+$","max_codepoint":255}},"postconditions":[{"assertion":"result == str1"}],"assumptions":[]},{"id":"pc_14","description":"Boundary Case: String with all same consonants.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"pattern":"^b+$","max_codepoint":255}},"postconditions":[{"assertion":"result == str1"}],"assumptions":[]},{"id":"pc_15","description":"Complex Case: Alternating vowels and consonants.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"pattern":"^([aeiouAEIOU][^aeiouAEIOU]){2}[aeiouAEIOU]$|^[^aeiouAEIOU]([aeiouAEIOU][^aeiouAEIOU]){2}$","max_codepoint":255}},"postconditions":[{"assertion":"len(result) == len(str1)"},{"assertion":"sum(1 for c in result if c in 'aeiouAEIOU') == sum(1 for c in str1 if c in 'aeiouAEIOU')"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: Input is not a string (integer).","execution_statement":"try: result = reverse_vowels(str1) except Exception as e: result = e","input_types":{"str1":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Negative Test: Input is not a string (None).","execution_statement":"try: result = reverse_vowels(str1) except Exception as e: result = e","input_types":{"str1":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_18","description":"Invariant: Check with a longer string.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":50,"max_len":100,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"len(result) == len(str1)"},{"assertion":"sum(1 for c in result if c in 'aeiouAEIOU') == sum(1 for c in str1 if c in 'aeiouAEIOU')"}],"assumptions":[]},{"id":"pc_19","description":"Case Sensitivity Check: Ensure uppercase vowels are reversed correctly.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"pattern":"^[AEIOU]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == str1[::-1]"}],"assumptions":[]},{"id":"pc_20","description":"Mixed Case Vowels and Consonants.","execution_statement":"result = reverse_vowels(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"value":"aBcDeFgHiJkLmNoPqRsTuVwXyZ","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == 'aBcDeFgHiJkLmNoPqRsTuVwXyZ'"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60f2"},"test_cases":[{"id":"TC1","description":"Test with a tuple of integers.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[int]"},"input_constraints":{"tup1":{"min_len":1,"max_len":10,"unique":true}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC2","description":"Test with a tuple of strings.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":1,"max_len":10,"unique":true}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC3","description":"Test with a tuple of mixed types (integers and strings).","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[Union[int, str]]"},"input_constraints":{"tup1":{"min_len":1,"max_len":10,"allow_none":false,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC4","description":"Test with an empty tuple.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple"},"input_constraints":{"tup1":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == ''"}]},{"id":"TC5","description":"Test with a tuple containing a single integer.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[int]"},"input_constraints":{"tup1":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC6","description":"Test with a tuple containing a single string.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC7","description":"Test with a tuple of large integers.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[int]"},"input_constraints":{"tup1":{"min_val":1000000000,"max_val":9999999999,"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC8","description":"Test with a tuple of empty strings.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"pattern":"^$"}},"postconditions":[{"assertion":"result == ''"}]},{"id":"TC9","description":"Test with a tuple containing special characters in strings.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"pattern":"[!@#$%^&*()_+=-`~{}\\[\\]|;':\",./<>?\\]+"}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC10","description":"Test with a tuple containing unicode characters in strings.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"pattern":"[\\u0000-\\uFFFF]+"}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC11","description":"Test with a tuple of booleans.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[bool]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC12","description":"Test with a tuple containing None (expecting TypeError).","execution_statement":"try: result = tup_string(tup1) except Exception as e: result = e","input_types":{"tup1":"tuple"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC13","description":"Test with a tuple containing floats.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[float]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC14","description":"Test with a tuple containing a mix of integers and floats.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[Union[int, float]]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC15","description":"Test with a tuple containing a mix of strings and booleans.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[Union[str, bool]]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC16","description":"Test with a tuple containing a mix of integers, strings, and booleans.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[Union[int, str, bool]]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC17","description":"Test with a tuple containing a very long string.","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":1,"max_len":1,"max_len_str":1000}},"postconditions":[{"assertion":"isinstance(result, str)"}]},{"id":"TC18","description":"Test with a tuple containing a mix of types including None (expecting TypeError).","execution_statement":"try: result = tup_string(tup1) except Exception as e: result = e","input_types":{"tup1":"tuple[Union[int, str, None]]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"allow_none":true,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC19","description":"Test with a tuple containing a mix of types including floats and None (expecting TypeError).","execution_statement":"try: result = tup_string(tup1) except Exception as e: result = e","input_types":{"tup1":"tuple[Union[float, None]]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"allow_none":true,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC20","description":"Test with a tuple containing a mix of types including booleans and None (expecting TypeError).","execution_statement":"try: result = tup_string(tup1) except Exception as e: result = e","input_types":{"tup1":"tuple[Union[bool, None]]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"allow_none":true,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60f3"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic tuple of strings","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"result == ''.join(tup1)"}]},{"id":"pc_2","description":"Edge Case: Empty tuple","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == ''"}]},{"id":"pc_3","description":"Happy Path: Tuple with mixed string lengths","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":2,"max_len":5,"elements":{"min_len":0,"max_len":5},"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"result == ''.join(tup1)"}]},{"id":"pc_4","description":"Happy Path: Tuple with single element","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == ''.join(tup1)"}]},{"id":"pc_5","description":"Edge Case: Tuple with empty strings","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":3,"max_len":10,"elements":{"min_len":0,"max_len":0}}},"postconditions":[{"assertion":"result == ''"}]},{"id":"pc_6","description":"Negative Test: Non-iterable input (int)","execution_statement":"try: result = tup_string(tup1) except Exception as e: result = e","input_types":{"tup1":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_7","description":"Negative Test: Non-iterable input (None)","execution_statement":"try: result = tup_string(tup1) except Exception as e: result = e","input_types":{"tup1":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_8","description":"Happy Path: Tuple with numbers (implicitly converted to string)","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[int]"},"input_constraints":{"tup1":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"result == ''.join(map(str, tup1))"}]},{"id":"pc_9","description":"Happy Path: Tuple with mixed types (int, str, float)","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[Union[int, str, float]]"},"input_constraints":{"tup1":{"min_len":1,"max_len":10,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"result == ''.join(map(str, tup1))"}]},{"id":"pc_10","description":"Negative Test: Tuple containing a list (unhashable for set, but join should work)","execution_statement":"result = tup_string(tup1)","input_types":{"tup1":"tuple[Any]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"elements":{"is_mixed":true}}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"result == ''.join(map(str, tup1))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60f4"},"test_cases":[{"id":"pc_1","description":"Test with a list of only negative numbers.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":-1,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result == sum(n for n in nums if n < 0)"}],"assumptions":[]},{"id":"pc_2","description":"Test with a list of only positive numbers.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":100,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Test with a list containing mixed positive, negative, and zero numbers.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":100,"min_len":5,"max_len":20,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(n for n in nums if n < 0)"}],"assumptions":[]},{"id":"pc_4","description":"Test with an empty list.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_5","description":"Test with a list containing a single negative number.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-50,"max_val":-1,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == nums[0]"}],"assumptions":[]},{"id":"pc_6","description":"Test with a list containing a single positive number.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":50,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_7","description":"Test with a list containing only zeros.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":0,"max_val":0,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_8","description":"Test with large negative numbers.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-1000000,"max_val":-100000,"min_len":5,"max_len":15}},"postconditions":[{"assertion":"result == sum(n for n in nums if n < 0)"}],"assumptions":[]},{"id":"pc_9","description":"Test with large positive numbers.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":100000,"max_val":1000000,"min_len":5,"max_len":15}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_10","description":"Test with a mix of very large and very small numbers.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-1000000,"max_val":1000000,"min_len":10,"max_len":30}},"postconditions":[{"assertion":"result == sum(n for n in nums if n < 0)"}],"assumptions":[]},{"id":"pc_11","description":"Test with a list where all numbers are negative and close to zero.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-10,"max_val":-1,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result == sum(n for n in nums if n < 0)"}],"assumptions":[]},{"id":"pc_12","description":"Test with a list where all numbers are positive and close to zero.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":10,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_13","description":"Test with a list containing negative numbers and zeros.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-50,"max_val":0,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result == sum(n for n in nums if n < 0)"}],"assumptions":[]},{"id":"pc_14","description":"Test with a list containing positive numbers and zeros.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":0,"max_val":50,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_15","description":"Test with a list containing a single zero.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":0,"max_val":0,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_16","description":"Test with a list of negative numbers with duplicates.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-20,"max_val":-5,"min_len":10,"max_len":25,"unique":false}},"postconditions":[{"assertion":"result == sum(n for n in nums if n < 0)"}],"assumptions":[]},{"id":"pc_17","description":"Test with a list of positive numbers with duplicates.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":5,"max_val":20,"min_len":10,"max_len":25,"unique":false}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_18","description":"Test with a list containing negative numbers and duplicates.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-50,"max_val":50,"min_len":10,"max_len":30,"unique":false}},"postconditions":[{"assertion":"result == sum(n for n in nums if n < 0)"}],"assumptions":[]},{"id":"pc_19","description":"Test with a list of negative numbers, sorted.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":-1,"min_len":5,"max_len":20,"sorted":"ascending"}},"postconditions":[{"assertion":"result == sum(n for n in nums if n < 0)"}],"assumptions":[]},{"id":"pc_20","description":"Test with a list of mixed numbers, sorted.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":100,"min_len":5,"max_len":20,"sorted":"ascending","is_mixed":true}},"postconditions":[{"assertion":"result == sum(n for n in nums if n < 0)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60f5"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with mixed positive and negative numbers.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":20,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(x for x in nums if x < 0)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with only positive numbers and zero.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":0,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: List with only negative numbers.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"max_val":-1,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result == sum(nums)"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Value: List with large negative numbers.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-1000000,"max_val":-1,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result == sum(x for x in nums if x < 0)"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Value: List with large positive numbers and some negative numbers.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-1000000,"max_val":1000000,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result == sum(x for x in nums if x < 0)"}],"assumptions":[]},{"id":"pc_7","description":"Invariant: The result should always be less than or equal to zero.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":20}},"postconditions":[{"assertion":"result <= 0"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Input is not a list (should raise TypeError).","execution_statement":"try: result = sum_negativenum(nums) except Exception as e: result = e","input_types":{"nums":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Input contains non-numeric types (should raise TypeError during sum or filter).","execution_statement":"try: result = sum_negativenum(nums) except Exception as e: result = e","input_types":{"nums":"list[Any]"},"input_constraints":{"nums":{"min_len":1,"max_len":10,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Edge Case: List with a single negative number.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == nums[0]"}],"assumptions":[]},{"id":"pc_11","description":"Edge Case: List with a single positive number.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":100,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_12","description":"Boundary Value: List with minimum and maximum integer values (if supported by Hypothesis).","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-2147483648,"max_val":2147483647,"min_len":2,"max_len":5}},"postconditions":[{"assertion":"result == sum(x for x in nums if x < 0)"}],"assumptions":[]},{"id":"pc_13","description":"Happy Path: List with duplicate negative numbers.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":-1,"min_len":5,"max_len":15}},"postconditions":[{"assertion":"result == sum(x for x in nums if x < 0)"}],"assumptions":[]},{"id":"pc_14","description":"Happy Path: List with duplicate positive numbers and negative numbers.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":100,"min_len":5,"max_len":15}},"postconditions":[{"assertion":"result == sum(x for x in nums if x < 0)"}],"assumptions":[]},{"id":"pc_15","description":"Edge Case: List containing only zero.","execution_statement":"result = sum_negativenum(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":0,"max_val":0,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60f6"},"test_cases":[{"id":"pc_1","description":"Tests a typical mid-range integer input.","execution_statement":"result = hexagonal_num(n=500)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1000}},"postconditions":[{"assertion":"result >= 1"},{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_2","description":"Tests the minimum boundary value for n.","execution_statement":"result = hexagonal_num(n=1)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_3","description":"Tests the maximum boundary value for n.","execution_statement":"result = hexagonal_num(n=1000000)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000,"max_val":1000000}},"postconditions":[{"assertion":"result == 1999999000000"}],"assumptions":[]},{"id":"pc_4","description":"Tests small positive integer inputs.","execution_statement":"result = hexagonal_num(n=3)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":5}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":[]},{"id":"pc_5","description":"Tests medium positive integer inputs.","execution_statement":"result = hexagonal_num(n=15)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":20}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":[]},{"id":"pc_6","description":"Ensures hexagonal numbers are always positive.","execution_statement":"result = hexagonal_num(n=10)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_7","description":"Ensures hexagonal numbers are always integers.","execution_statement":"result = hexagonal_num(n=25)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_8","description":"Checks the linear increase in difference between consecutive hexagonal numbers.","execution_statement":"result = hexagonal_num(n=10)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1000}},"postconditions":[{"assertion":"(hexagonal_num(n) - hexagonal_num(n-1)) == (3*n - 2)"}],"assumptions":["n > 1"]},{"id":"pc_9","description":"Verifies that the result matches the formula n*(2n-1).","execution_statement":"result = hexagonal_num(n=12)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == n * (2*n - 1)"}],"assumptions":[]},{"id":"pc_10","description":"Tests with a large input value within the allowed range.","execution_statement":"result = hexagonal_num(n=500000)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100000,"max_val":1000000}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60f7"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic positive integer","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == n * (2 * n - 1)"},{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Zero input","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Value: Smallest positive integer","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Value: Large integer","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":10000}},"postconditions":[{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: Strictly increasing for n > 0","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1000}},"postconditions":[{"assertion":"result > hexagonal_num(n-1)"}],"assumptions":["n > 1"]},{"id":"pc_6","description":"Negative Test: Invalid type (string)","execution_statement":"try: result = hexagonal_num(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Invalid type (float)","execution_statement":"try: result = hexagonal_num(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Invalid type (None)","execution_statement":"try: result = hexagonal_num(n) except Exception as e: result = e","input_types":{"n":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60f8"},"test_cases":[{"id":"TC1","description":"Typical case with a mix of zeroes and non-zeroes.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":100,"min_len":5,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result >= 0"}]},{"id":"TC2","description":"Edge case: list with only zeroes.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":0,"max_val":0,"min_len":1,"max_len":20}},"postconditions":[{"assertion":"result == float('inf')"}]},{"id":"TC3","description":"Edge case: list with no zeroes.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":100,"min_len":1,"max_len":20}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == 0.0"}]},{"id":"TC4","description":"Edge case: list with a single zero.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":0,"max_val":0,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == float('inf')"}]},{"id":"TC5","description":"Edge case: list with a single non-zero.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":1,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 0.0"}]},{"id":"TC6","description":"Boundary case: large numbers, mix of zeroes and non-zeroes.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-1000000,"max_val":1000000,"min_len":10,"max_len":30}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result >= 0"}]},{"id":"TC7","description":"Boundary case: mixed signs, including zeroes.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-50,"max_val":50,"min_len":10,"max_len":30,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result >= 0"}]},{"id":"TC8","description":"Invariant test: ratio calculation correctness.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-10,"max_val":10,"min_len":2,"max_len":15}},"postconditions":[{"assertion":"sum(1 for x in nums if x == 0) / sum(1 for x in nums if x != 0) == result if sum(1 for x in nums if x != 0) != 0 else result == float('inf')"}]},{"id":"TC9","description":"Invariant test: zero count consistency.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-5,"max_val":5,"min_len":3,"max_len":10}},"postconditions":[{"assertion":"sum(1 for x in nums if x == 0) == (result * sum(1 for x in nums if x != 0)) if sum(1 for x in nums if x != 0) != 0 else result == float('inf')"}]},{"id":"TC10","description":"Invariant test: non-zero count consistency.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-20,"max_val":20,"min_len":4,"max_len":12}},"postconditions":[{"assertion":"sum(1 for x in nums if x != 0) == (len(nums) - sum(1 for x in nums if x == 0))"}]},{"id":"TC11","description":"Test with a list containing only one non-zero element and many zeroes.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":0,"max_val":10,"min_len":5,"max_len":10}},"assumptions":["sum(1 for x in nums if x != 0) == 1"],"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == 0.0"}]},{"id":"TC12","description":"Test with a list containing only one zero element and many non-zero elements.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-10,"max_val":10,"min_len":5,"max_len":10}},"assumptions":["sum(1 for x in nums if x == 0) == 1"],"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == (1.0 / (len(nums) - 1))"}]},{"id":"TC13","description":"Test with a list where zeroes and non-zeroes are roughly equal.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-10,"max_val":10,"min_len":10,"max_len":20}},"assumptions":["abs(sum(1 for x in nums if x == 0) - sum(1 for x in nums if x != 0)) <= 2"],"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result > 0"}]},{"id":"TC14","description":"Test with a list containing only negative non-zero numbers and zeroes.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":0,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result >= 0"}]},{"id":"TC15","description":"Test with a list containing only positive non-zero numbers and zeroes.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":0,"max_val":100,"min_len":5,"max_len":20}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result >= 0"}]},{"id":"TC16","description":"Test with a very long list of mixed numbers.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-50,"max_val":50,"min_len":100,"max_len":200,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result >= 0"}]},{"id":"TC17","description":"Test with a list containing only zeroes and one large non-zero number.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":0,"max_val":1000000,"min_len":5,"max_len":10}},"assumptions":["sum(1 for x in nums if x != 0) == 1"],"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == 0.0"}]},{"id":"TC18","description":"Test with a list containing only non-zeroes and one zero.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-1000000,"max_val":1000000,"min_len":5,"max_len":10}},"assumptions":["sum(1 for x in nums if x == 0) == 1"],"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == (1.0 / (len(nums) - 1))"}]},{"id":"TC19","description":"Test with a list containing only negative numbers (no zeroes).","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":20}},"postconditions":[{"assertion":"result == 0.0"}]},{"id":"TC20","description":"Test with a list containing only positive numbers (no zeroes).","execution_statement":"result = zero_count(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":1,"max_val":100,"min_len":1,"max_len":20}},"postconditions":[{"assertion":"result == 0.0"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60f9"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with mixed zeros and non-zeros.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":10,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result >= 0"}],"assumptions":["any(x == 0 for x in nums)","any(x != 0 for x in nums)"]},{"id":"pc_2","description":"Edge Case: Empty list should raise ZeroDivisionError.","execution_statement":"try: result = zero_count(nums) except Exception as e: result = e","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, ZeroDivisionError)"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with only zeros should raise ZeroDivisionError.","execution_statement":"try: result = zero_count(nums) except Exception as e: result = e","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, ZeroDivisionError)"}],"assumptions":["all(x == 0 for x in nums)"]},{"id":"pc_4","description":"Edge Case: List with no zeros should return 0.0.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":["all(x != 0 for x in nums)"]},{"id":"pc_5","description":"Boundary Case: List with one zero and one non-zero.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":2}},"postconditions":[{"assertion":"result == 1.0"}],"assumptions":["nums.count(0) == 1","nums.count(0) != len(nums)"]},{"id":"pc_6","description":"Boundary Case: List with many zeros and few non-zeros.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":20}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result >= 0"}],"assumptions":["nums.count(0) > len(nums) / 2","nums.count(0) != len(nums)"]},{"id":"pc_7","description":"Boundary Case: List with few zeros and many non-zeros.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":20}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result >= 0"}],"assumptions":["nums.count(0) < len(nums) / 2","nums.count(0) > 0"]},{"id":"pc_8","description":"Invariant: The number of zeros counted should not exceed the list length.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":2}},"postconditions":[{"assertion":"result * (len(nums) - (result * (len(nums) - n1))) <= len(nums)"}],"assumptions":["n - n1 != 0"]},{"id":"pc_9","description":"Negative Test: Input contains non-integer types (expect TypeError).","execution_statement":"try: result = zero_count(nums) except Exception as e: result = e","input_types":{"nums":"list[Any]"},"input_constraints":{"nums":{"min_len":1,"max_len":10,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["not all(isinstance(x, int) for x in nums)"]},{"id":"pc_10","description":"Large input list with mixed values.","execution_statement":"result = zero_count(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1000,"max_len":5000,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result >= 0"}],"assumptions":["any(x == 0 for x in nums)","any(x != 0 for x in nums)"]}]}
{"_id":{"$oid":"692adffe1b18223597bc60fa"},"test_cases":[{"id":"pc_1","description":"Test with a small even number.","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=6)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Test with a small odd number.","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=7)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_3","description":"Test with the smallest possible input (boundary).","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=1)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"Test with a power of 2.","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=8)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":8,"max_val":8}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_5","description":"Test with a number that is not a power of 2 but is even.","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=10)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":10}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Test with a large even number.","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=1000000)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000,"max_val":1000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_7","description":"Test with a large odd number.","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=999999)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":999999,"max_val":999999}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_8","description":"Test with a number just above a power of 2.","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=9)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":9,"max_val":9}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_9","description":"Test with a number just below a power of 2.","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=7)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":7,"max_val":7}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"Test with a number that is a sum of powers of 2 (e.g., 12 = 12).","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=12)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":12,"max_val":12}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_11","description":"Test with a number that is a sum of powers of 2 (e.g., 13 = 13).","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=13)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":13,"max_val":13}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_12","description":"Test with a number that is a sum of powers of 2 (e.g., 14 = 14).","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=14)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":14,"max_val":14}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_13","description":"Test with a number that is a sum of powers of 2 (e.g., 15 = 15).","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=15)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":15,"max_val":15}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"Test with a number that is a sum of powers of 2 (e.g., 20 = 20).","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=20)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":20,"max_val":20}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_15","description":"Test with a number that is a sum of powers of 2 (e.g., 21 = 21).","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=21)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":21,"max_val":21}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_16","description":"Test with a number that is a sum of powers of 2 (e.g., 22 = 22).","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=22)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":22,"max_val":22}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_17","description":"Test with a number that is a sum of powers of 2 (e.g., 23 = 23).","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=23)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":23,"max_val":23}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_18","description":"Test with a number that is a sum of powers of 2 (e.g., 24 = 24).","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=24)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":24,"max_val":24}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_19","description":"Test with a number that is a sum of powers of 2 (e.g., 25 = 25).","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=25)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":25,"max_val":25}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_20","description":"Test with a number that is a sum of powers of 2 (e.g., 26 = 26).","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n=26)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":26,"max_val":26}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60fb"},"test_cases":[{"id":"pc_1","description":"Happy Path: Even numbers","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":10000,"step":2}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Odd numbers","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":9999,"step":2}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Zero","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n)","input_types":{"n":"int"},"input_constraints":{"n":{"val":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Negative numbers","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-10000,"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Value: Large even number","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000,"max_val":2000000,"step":2}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Value: Large odd number","execution_statement":"result = is_Sum_Of_Powers_Of_Two(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000001,"max_val":2000001,"step":2}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Non-integer input (float)","execution_statement":"try: result = is_Sum_Of_Powers_Of_Two(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Non-integer input (string)","execution_statement":"try: result = is_Sum_Of_Powers_Of_Two(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Non-integer input (None)","execution_statement":"try: result = is_Sum_Of_Powers_Of_Two(n) except Exception as e: result = e","input_types":{"n":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60fc"},"test_cases":[{"id":"pc_1","description":"Test with a typical positive radius.","execution_statement":"result = circle_circumference(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":1.0,"max_val":1000.0}},"postconditions":[{"assertion":"result == 2 * 3.1415 * radius"}],"assumptions":[]},{"id":"pc_2","description":"Test with zero radius (boundary case).","execution_statement":"result = circle_circumference(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":0.0,"max_val":0.0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_3","description":"Test with a very small positive radius.","execution_statement":"result = circle_circumference(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":1E-09,"max_val":0.001}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_4","description":"Test with a large radius.","execution_statement":"result = circle_circumference(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":1E+10,"max_val":1E+20}},"postconditions":[{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_5","description":"Test with negative radius (expecting negative circumference).","execution_statement":"result = circle_circumference(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":-1000.0,"max_val":-1.0}},"postconditions":[{"assertion":"result < 0"}],"assumptions":[]},{"id":"pc_6","description":"Test with a mix of positive and negative radii.","execution_statement":"result = circle_circumference(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":-100.0,"max_val":100.0}},"postconditions":[{"assertion":"abs(result) == 2 * 3.1415 * abs(radius)"}],"assumptions":[]},{"id":"pc_7","description":"Test with a non-numeric type (expecting TypeError).","execution_statement":"try: result = circle_circumference(radius) except Exception as e: result = e","input_types":{"radius":"str"},"input_constraints":{"radius":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Test with None input (expecting TypeError).","execution_statement":"try: result = circle_circumference(radius) except Exception as e: result = e","input_types":{"radius":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Test with a very large positive radius to check precision.","execution_statement":"result = circle_circumference(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":1E+15,"max_val":1E+18}},"postconditions":[{"assertion":"isinstance(result, float)"}],"assumptions":[]},{"id":"pc_10","description":"Test with a very small negative radius.","execution_statement":"result = circle_circumference(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_val":-1000.0,"max_val":-1E-06}},"postconditions":[{"assertion":"result <= 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60fd"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive radius","execution_statement":"result = circle_circumference(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":0.1,"max_val":1000.0}},"postconditions":[{"assertion":"result > 0"},{"assertion":"abs(result - (2 * 3.1415 * r)) < 1e-9"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Zero radius","execution_statement":"result = circle_circumference(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":0.0,"max_val":0.0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Case: Large radius","execution_statement":"result = circle_circumference(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":1E+06,"max_val":1E+09}},"postconditions":[{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_4","description":"Invariant: Non-negative radius yields non-negative circumference","execution_statement":"result = circle_circumference(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":0.0,"max_val":1E+06}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_5","description":"Negative Test: Invalid input type (string)","execution_statement":"try: result = circle_circumference(r) except Exception as e: result = e","input_types":{"r":"str"},"input_constraints":{"r":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: Invalid input type (None)","execution_statement":"try: result = circle_circumference(r) except Exception as e: result = e","input_types":{"r":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Boundary Case: Small positive radius","execution_statement":"result = circle_circumference(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":1E-09,"max_val":0.001}},"postconditions":[{"assertion":"result > 0"},{"assertion":"abs(result - (2 * 3.1415 * r)) < 1e-12"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc60fe"},"test_cases":[{"id":"TC1","description":"Typical case with unique integers in nested lists.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_constraints":{"min_val":0,"max_val":100,"min_len":1,"max_len":5,"unique":true}}},"postconditions":[{"assertion":"len(result) == len(set(item for sublist in test_list for item in sublist))"},{"assertion":"all(isinstance(x, int) for x in result)"},{"assertion":"result == [item for sublist in test_list for item in sublist]"}]},{"id":"TC2","description":"Edge case: Empty outer list.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == []"}]},{"id":"TC3","description":"Edge case: Outer list with empty inner lists.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_constraints":{"min_len":0,"max_len":0}}},"postconditions":[{"assertion":"result == []"}]},{"id":"TC4","description":"Edge case: Lists with duplicate integers.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_constraints":{"min_val":0,"max_val":10,"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"len(result) == len(set(item for sublist in test_list for item in sublist))"},{"assertion":"all(x in set(item for sublist in test_list for item in sublist) for x in result)"}]},{"id":"TC5","description":"Boundary case: Single element in inner list.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_constraints":{"min_val":5,"max_val":5,"min_len":1,"max_len":1}}},"postconditions":[{"assertion":"result == [5]"}]},{"id":"TC6","description":"Boundary case: Large numbers.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":3,"inner_constraints":{"min_val":1000000,"max_val":2000000,"min_len":1,"max_len":3}}},"postconditions":[{"assertion":"len(result) == len(set(item for sublist in test_list for item in sublist))"},{"assertion":"all(x in set(item for sublist in test_list for item in sublist) for x in result)"}]},{"id":"TC7","description":"Mixed empty and non-empty inner lists.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5,"inner_constraints":{"min_val":0,"max_val":50,"min_len":0,"max_len":5},"is_mixed":true}},"postconditions":[{"assertion":"len(result) == len(set(item for sublist in test_list for item in sublist))"},{"assertion":"all(x in set(item for sublist in test_list for item in sublist) for x in result)"}]},{"id":"TC8","description":"Negative numbers.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_constraints":{"min_val":-100,"max_val":-1,"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"len(result) == len(set(item for sublist in test_list for item in sublist))"},{"assertion":"all(x in set(item for sublist in test_list for item in sublist) for x in result)"}]},{"id":"TC9","description":"Zero as an element.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_constraints":{"min_val":0,"max_val":0,"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"result == [0]"}]},{"id":"TC10","description":"Large number of nested lists.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":50,"max_len":100,"inner_constraints":{"min_val":0,"max_val":10,"min_len":1,"max_len":1}}},"postconditions":[{"assertion":"len(result) == len(set(item for sublist in test_list for item in sublist))"},{"assertion":"all(x in set(item for sublist in test_list for item in sublist) for x in result)"}]},{"id":"TC11","description":"Large number of elements in inner lists.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_constraints":{"min_val":0,"max_val":100,"min_len":50,"max_len":100}}},"postconditions":[{"assertion":"len(result) == len(set(item for sublist in test_list for item in sublist))"},{"assertion":"all(x in set(item for sublist in test_list for item in sublist) for x in result)"}]},{"id":"TC12","description":"All elements are the same.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5,"inner_constraints":{"min_val":7,"max_val":7,"min_len":1,"max_len":3}}},"postconditions":[{"assertion":"result == [7]"}]},{"id":"TC13","description":"Interleaving unique and duplicate elements.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5,"inner_constraints":{"min_val":0,"max_val":10,"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"len(result) == len(set(item for sublist in test_list for item in sublist))"},{"assertion":"all(x in set(item for sublist in test_list for item in sublist) for x in result)"}]},{"id":"TC14","description":"Test with a single inner list containing duplicates.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_constraints":{"min_val":1,"max_val":5,"min_len":5,"max_len":10}}},"postconditions":[{"assertion":"len(result) == len(set(item for sublist in test_list for item in sublist))"},{"assertion":"all(x in set(item for sublist in test_list for item in sublist) for x in result)"}]},{"id":"TC15","description":"Test with multiple inner lists, each with duplicates.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5,"inner_constraints":{"min_val":1,"max_val":10,"min_len":2,"max_len":5}}},"postconditions":[{"assertion":"len(result) == len(set(item for sublist in test_list for item in sublist))"},{"assertion":"all(x in set(item for sublist in test_list for item in sublist) for x in result)"}]},{"id":"TC16","description":"Test with a mix of positive and negative numbers.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5,"inner_constraints":{"min_val":-10,"max_val":10,"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"len(result) == len(set(item for sublist in test_list for item in sublist))"},{"assertion":"all(x in set(item for sublist in test_list for item in sublist) for x in result)"}]},{"id":"TC17","description":"Test with a single inner list containing only one unique element repeated.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_constraints":{"min_val":42,"max_val":42,"min_len":10,"max_len":20}}},"postconditions":[{"assertion":"result == [42]"}]},{"id":"TC18","description":"Test with multiple inner lists, each containing only one unique element repeated.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":3,"max_len":7,"inner_constraints":{"min_val":10,"max_val":10,"min_len":5,"max_len":10}}},"postconditions":[{"assertion":"result == [10]"}]},{"id":"TC19","description":"Test with a mix of empty and single-element inner lists.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5,"inner_constraints":{"min_val":1,"max_val":10,"min_len":0,"max_len":1}}},"postconditions":[{"assertion":"len(result) == len(set(item for sublist in test_list for item in sublist))"},{"assertion":"all(x in set(item for sublist in test_list for item in sublist) for x in result)"}]},{"id":"TC20","description":"Test with a large range of numbers and duplicates.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"List[List[int]]"},"input_constraints":{"test_list":{"min_len":5,"max_len":10,"inner_constraints":{"min_val":0,"max_val":1000,"min_len":5,"max_len":10}}},"postconditions":[{"assertion":"len(result) == len(set(item for sublist in test_list for item in sublist))"},{"assertion":"all(x in set(item for sublist in test_list for item in sublist) for x in result)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc60ff"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic flattening with unique elements","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"inner_list":{"min_len":1,"max_len":5}}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"set(element for inner_list in test_list for element in inner_list) == set(result)"},{"assertion":"len(result) == len(set(result))"}]},{"id":"pc_2","description":"Edge Case: Empty input list","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"not result"}]},{"id":"pc_3","description":"Edge Case: List with empty inner lists","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_list":{"min_len":0,"max_len":0}}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"not result"}]},{"id":"pc_4","description":"Typical Case: Mixed duplicates and unique elements","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":8,"inner_list":{"min_len":2,"max_len":6},"is_mixed":true}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"set(element for inner_list in test_list for element in inner_list) == set(result)"},{"assertion":"len(result) == len(set(result))"}]},{"id":"pc_5","description":"Boundary Case: Large number of inner lists","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":50,"max_len":100,"inner_list":{"min_len":1,"max_len":5}}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"set(element for inner_list in test_list for element in inner_list) == set(result)"},{"assertion":"len(result) == len(set(result))"}]},{"id":"pc_6","description":"Boundary Case: Large elements within inner lists","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5,"inner_list":{"min_len":50,"max_len":100}}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"set(element for inner_list in test_list for element in inner_list) == set(result)"},{"assertion":"len(result) == len(set(result))"}]},{"id":"pc_7","description":"Invariant: Order of first appearance is preserved","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"inner_list":{"min_len":1,"max_len":5}}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"seen_before = set(); [x for x in (element for inner_list in test_list for element in inner_list) if x not in seen_before and not seen_before.add(x)] == result"}]},{"id":"pc_8","description":"Negative Test: Input is not a list","input_types":{"test_list":"int"},"input_constraints":{},"execution_statement":"try: result = extract_singly(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: Inner element is not iterable","input_types":{"test_list":"list[int]"},"input_constraints":{},"execution_statement":"try: result = extract_singly(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Test with negative numbers","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"inner_list":{"min_len":1,"max_len":5}}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"set(element for inner_list in test_list for element in inner_list) == set(result)"},{"assertion":"len(result) == len(set(result))"}]},{"id":"pc_11","description":"Test with zero","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"inner_list":{"min_len":1,"max_len":5}}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"set(element for inner_list in test_list for element in inner_list) == set(result)"},{"assertion":"len(result) == len(set(result))"}]},{"id":"pc_12","description":"Test with mixed positive and negative numbers","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"inner_list":{"min_len":1,"max_len":5},"is_mixed":true}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"set(element for inner_list in test_list for element in inner_list) == set(result)"},{"assertion":"len(result) == len(set(result))"}]},{"id":"pc_13","description":"Test with a single inner list","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_list":{"min_len":1,"max_len":10}}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"set(element for inner_list in test_list for element in inner_list) == set(result)"},{"assertion":"len(result) == len(set(result))"}]},{"id":"pc_14","description":"Test with all duplicate elements across inner lists","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5,"inner_list":{"min_len":2,"max_len":5}}},"assumptions":["all(all(elem == test_list[0][0] for elem in inner) for inner in test_list)"],"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"len(result) == 1"},{"assertion":"result[0] == test_list[0][0]"}]},{"id":"pc_15","description":"Test with non-integer hashable types (e.g., strings)","input_types":{"test_list":"list[list[str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"inner_list":{"min_len":1,"max_len":5}}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"set(element for inner_list in test_list for element in inner_list) == set(result)"},{"assertion":"len(result) == len(set(result))"}]},{"id":"pc_16","description":"Test with mixed hashable types (int and str)","input_types":{"test_list":"list[list[Union[int, str]]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"inner_list":{"min_len":1,"max_len":5},"is_mixed":true}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"set(element for inner_list in test_list for element in inner_list) == set(result)"},{"assertion":"len(result) == len(set(result))"}]},{"id":"pc_17","description":"Test with None values (should be handled as hashable)","input_types":{"test_list":"list[list[Optional[int]]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"inner_list":{"min_len":1,"max_len":5,"allow_none":true}}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"set(element for inner_list in test_list for element in inner_list) == set(result)"},{"assertion":"len(result) == len(set(result))"}]},{"id":"pc_18","description":"Test with tuples as elements","input_types":{"test_list":"list[list[tuple[int]]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"inner_list":{"min_len":1,"max_len":5}}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"set(element for inner_list in test_list for element in inner_list) == set(result)"},{"assertion":"len(result) == len(set(result))"}]},{"id":"pc_19","description":"Negative Test: Inner element is a list (unhashable)","input_types":{"test_list":"list[list[list[int]]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":2,"inner_list":{"min_len":1,"max_len":2}}},"execution_statement":"try: result = extract_singly(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_20","description":"Test with large number of elements in a single inner list","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1,"inner_list":{"min_len":100,"max_len":200}}},"execution_statement":"result = extract_singly(test_list)","postconditions":[{"assertion":"set(element for inner_list in test_list for element in inner_list) == set(result)"},{"assertion":"len(result) == len(set(result))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6100"},"test_cases":[{"id":"test_typical_case","description":"Test with a typical list of integers.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-1000,"max_val":1000,"min_len":5,"max_len":50}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"test_empty_list","description":"Test with an empty list.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"assumptions":[],"postconditions":[{"assertion":"result == []"}]},{"id":"test_single_element_list","description":"Test with a list containing a single element.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1}},"assumptions":[],"postconditions":[{"assertion":"result == nums_original"}]},{"id":"test_already_sorted_list","description":"Test with a list that is already sorted.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"sorted":"ascending"}},"assumptions":[],"postconditions":[{"assertion":"result == nums_original"}]},{"id":"test_reverse_sorted_list","description":"Test with a list sorted in reverse order.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"sorted":"descending"}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"test_list_with_duplicates","description":"Test with a list containing duplicate elements.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":0,"max_val":10,"min_len":5,"max_len":50,"unique":false}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"test_list_with_negative_numbers","description":"Test with a list containing negative numbers.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-1000,"max_val":-1,"min_len":5,"max_len":50}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"test_list_with_zeros","description":"Test with a list containing zeros.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-10,"max_val":10,"min_len":5,"max_len":50}},"assumptions":["0 in nums_original"],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"test_large_list","description":"Test with a large list of integers.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-10000,"max_val":10000,"min_len":1000,"max_len":5000}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"test_boundary_values","description":"Test with integers at boundary values.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-1000,"max_val":1000,"min_len":5,"max_len":20}},"assumptions":["any(x in [-1000, 1000] for x in nums_original)"],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"test_all_same_elements","description":"Test with a list where all elements are the same.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":5,"max_val":5,"min_len":5,"max_len":50}},"assumptions":[],"postconditions":[{"assertion":"result == nums_original"}]},{"id":"test_two_elements_unsorted","description":"Test with a list of two unsorted elements.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":2}},"assumptions":["nums_original[0] != nums_original[1]"],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"test_two_elements_sorted","description":"Test with a list of two sorted elements.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":2,"sorted":"ascending"}},"assumptions":[],"postconditions":[{"assertion":"result == nums_original"}]},{"id":"test_mixed_sign_numbers","description":"Test with a list containing both positive and negative numbers.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":100,"min_len":5,"max_len":50}},"assumptions":["any(x > 0 for x in nums_original) and any(x < 0 for x in nums_original)"],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"test_max_int_value","description":"Test with the maximum integer value.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":2147483647,"max_val":2147483647,"min_len":1,"max_len":10}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"test_min_int_value","description":"Test with the minimum integer value.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-2147483648,"max_val":-2147483648,"min_len":1,"max_len":10}},"assumptions":[],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"test_large_numbers_and_small_numbers","description":"Test with a mix of very large and very small numbers.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-1000000,"max_val":1000000,"min_len":5,"max_len":50}},"assumptions":["any(abs(x) > 100000 for x in nums_original) and any(abs(x) < 100 for x in nums_original)"],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"test_list_with_one_large_element","description":"Test with a list containing one very large element and others small.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-10,"max_val":1000000,"min_len":5,"max_len":50}},"assumptions":["1000000 in nums_original"],"postconditions":[{"assertion":"result == sorted(nums_original)"}]},{"id":"test_list_with_one_small_element","description":"Test with a list containing one very small element and others large.","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"List[int]"},"input_constraints":{"nums":{"min_val":-1000000,"max_val":10,"min_len":5,"max_len":50}},"assumptions":["-1000000 in nums_original"],"postconditions":[{"assertion":"result == sorted(nums_original)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6101"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic sorting of integers","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":100,"unique":true}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result) - 1))"},{"assertion":"len(result) == len(nums)"},{"assertion":"sorted(result) == sorted(nums)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Single element list","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == nums"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: List with duplicate elements","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":50}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result) - 1))"},{"assertion":"sorted(result) == sorted(nums)"}],"assumptions":["len(set(nums)) < len(nums)"]},{"id":"pc_5","description":"Boundary Case: Large list","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":500,"max_len":1000,"unique":true}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result) - 1))"},{"assertion":"len(result) == len(nums)"},{"assertion":"sorted(result) == sorted(nums)"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Case: List with negative numbers","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-1000,"max_val":-1,"min_len":5,"max_len":50,"unique":true}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result) - 1))"},{"assertion":"sorted(result) == sorted(nums)"}],"assumptions":[]},{"id":"pc_7","description":"Boundary Case: List with mixed positive and negative numbers","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-500,"max_val":500,"min_len":5,"max_len":50,"unique":true,"is_mixed":true}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result) - 1))"},{"assertion":"sorted(result) == sorted(nums)"}],"assumptions":[]},{"id":"pc_8","description":"Invariant: Elements are preserved","execution_statement":"original_nums = list(nums); result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":100,"unique":true}},"postconditions":[{"assertion":"sorted(result) == sorted(original_nums)"}],"assumptions":[]},{"id":"pc_9","description":"Invariant: Length is preserved","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":100,"unique":true}},"postconditions":[{"assertion":"len(result) == len(nums)"}],"assumptions":[]},{"id":"pc_10","description":"Happy Path: Sorting strings","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[str]"},"input_constraints":{"nums":{"min_len":2,"max_len":50,"unique":true,"pattern":"^[a-z]{1,10}$"}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result) - 1))"},{"assertion":"sorted(result) == sorted(nums)"}],"assumptions":[]},{"id":"pc_11","description":"Edge Case: List with identical elements","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":20,"unique":false}},"postconditions":[{"assertion":"result == nums"}],"assumptions":["len(set(nums)) == 1"]},{"id":"pc_12","description":"Boundary Case: List with zero","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-10,"max_val":10,"min_len":5,"max_len":50}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result) - 1))"},{"assertion":"sorted(result) == sorted(nums)"}],"assumptions":["0 in nums"]},{"id":"pc_13","description":"Happy Path: Already sorted list","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"unique":true}},"postconditions":[{"assertion":"result == nums"}],"assumptions":["all(nums[i] <= nums[i+1] for i in range(len(nums) - 1))"]},{"id":"pc_14","description":"Happy Path: Reverse sorted list","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"unique":true}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result) - 1))"},{"assertion":"sorted(result) == sorted(nums)"}],"assumptions":["all(nums[i] >= nums[i+1] for i in range(len(nums) - 1))"]},{"id":"pc_15","description":"Boundary Case: List with large integers","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":1000000,"max_val":2000000,"min_len":5,"max_len":50,"unique":true}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result) - 1))"},{"assertion":"sorted(result) == sorted(nums)"}],"assumptions":[]},{"id":"pc_16","description":"Happy Path: Sorting floats","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[float]"},"input_constraints":{"nums":{"min_len":2,"max_len":50,"unique":true}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result) - 1))"},{"assertion":"sorted(result) == sorted(nums)"}],"assumptions":[]},{"id":"pc_17","description":"Edge Case: List with None (should fail if not handled)","execution_statement":"try: result = pancake_sort(nums) except Exception as e: result = e","input_types":{"nums":"list[Any]"},"input_constraints":{"nums":{"min_len":2,"max_len":10,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_18","description":"Negative Test: Non-list input (int)","execution_statement":"try: result = pancake_sort(nums) except Exception as e: result = e","input_types":{"nums":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_19","description":"Negative Test: Non-list input (str)","execution_statement":"try: result = pancake_sort(nums) except Exception as e: result = e","input_types":{"nums":"str"},"input_constraints":{"nums":{"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_20","description":"Boundary Case: List with very small negative numbers","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-2000000,"max_val":-1000000,"min_len":5,"max_len":50,"unique":true}},"postconditions":[{"assertion":"all(result[i] <= result[i+1] for i in range(len(result) - 1))"},{"assertion":"sorted(result) == sorted(nums)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6102"},"test_cases":[{"id":"pc_1","description":"Test with typical integer lists of equal length, some matching elements.","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"List[int]","list2":"List[int]","list3":"List[int]"},"input_constraints":{"list1":{"min_val":-100,"max_val":100,"min_len":5,"max_len":10},"list2":{"min_val":-100,"max_val":100,"min_len":5,"max_len":10},"list3":{"min_val":-100,"max_val":100,"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(list1)"}],"assumptions":["len(list1) == len(list2) == len(list3)"]},{"id":"pc_2","description":"Test with empty lists.","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"List[int]","list2":"List[int]","list3":"List[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":0},"list2":{"min_len":0,"max_len":0},"list3":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["len(list1) == len(list2) == len(list3)"]},{"id":"pc_3","description":"Test with single-element lists, all matching.","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"List[int]","list2":"List[int]","list3":"List[int]"},"input_constraints":{"list1":{"min_val":10,"max_val":10,"min_len":1,"max_len":1},"list2":{"min_val":10,"max_val":10,"min_len":1,"max_len":1},"list3":{"min_val":10,"max_val":10,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":["len(list1) == len(list2) == len(list3)"]},{"id":"pc_4","description":"Test with single-element lists, no matching elements.","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"List[int]","list2":"List[int]","list3":"List[int]"},"input_constraints":{"list1":{"min_val":1,"max_val":1,"min_len":1,"max_len":1},"list2":{"min_val":2,"max_val":2,"min_len":1,"max_len":1},"list3":{"min_val":3,"max_val":3,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["len(list1) == len(list2) == len(list3)"]},{"id":"pc_5","description":"Test with lists where all elements are identical across all lists.","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"List[int]","list2":"List[int]","list3":"List[int]"},"input_constraints":{"list1":{"min_val":5,"max_val":5,"min_len":10,"max_len":10},"list2":{"min_val":5,"max_val":5,"min_len":10,"max_len":10},"list3":{"min_val":5,"max_val":5,"min_len":10,"max_len":10}},"postconditions":[{"assertion":"result == 10"}],"assumptions":["len(list1) == len(list2) == len(list3)"]},{"id":"pc_6","description":"Test with lists where no elements match at any position.","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"List[int]","list2":"List[int]","list3":"List[int]"},"input_constraints":{"list1":{"min_val":1,"max_val":1,"min_len":10,"max_len":10},"list2":{"min_val":2,"max_val":2,"min_len":10,"max_len":10},"list3":{"min_val":3,"max_val":3,"min_len":10,"max_len":10}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["len(list1) == len(list2) == len(list3)"]},{"id":"pc_7","description":"Test with lists containing negative integers, some matching.","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"List[int]","list2":"List[int]","list3":"List[int]"},"input_constraints":{"list1":{"min_val":-100,"max_val":-1,"min_len":8,"max_len":8},"list2":{"min_val":-100,"max_val":-1,"min_len":8,"max_len":8},"list3":{"min_val":-100,"max_val":-1,"min_len":8,"max_len":8}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(list1)"}],"assumptions":["len(list1) == len(list2) == len(list3)"]},{"id":"pc_8","description":"Test with lists containing a mix of positive and negative integers, some matching.","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"List[int]","list2":"List[int]","list3":"List[int]"},"input_constraints":{"list1":{"min_val":-50,"max_val":50,"min_len":15,"max_len":15},"list2":{"min_val":-50,"max_val":50,"min_len":15,"max_len":15},"list3":{"min_val":-50,"max_val":50,"min_len":15,"max_len":15}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(list1)"}],"assumptions":["len(list1) == len(list2) == len(list3)"]},{"id":"pc_9","description":"Test with larger lists to check performance and boundary conditions.","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"List[int]","list2":"List[int]","list3":"List[int]"},"input_constraints":{"list1":{"min_val":-1000,"max_val":1000,"min_len":100,"max_len":100},"list2":{"min_val":-1000,"max_val":1000,"min_len":100,"max_len":100},"list3":{"min_val":-1000,"max_val":1000,"min_len":100,"max_len":100}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(list1)"}],"assumptions":["len(list1) == len(list2) == len(list3)"]},{"id":"pc_10","description":"Test with lists containing zero, some matching.","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"List[int]","list2":"List[int]","list3":"List[int]"},"input_constraints":{"list1":{"min_val":-10,"max_val":10,"min_len":7,"max_len":7},"list2":{"min_val":-10,"max_val":10,"min_len":7,"max_len":7},"list3":{"min_val":-10,"max_val":10,"min_len":7,"max_len":7}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(list1)"}],"assumptions":["len(list1) == len(list2) == len(list3)"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6103"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with matching elements","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"unique":true},"list2":{"min_len":5,"max_len":10,"unique":true},"list3":{"min_len":5,"max_len":10,"unique":true}},"postconditions":[{"assertion":"result == len(list1)"}],"assumptions":["list1 == list2 and list2 == list3"]},{"id":"pc_2","description":"Happy Path: No matching elements","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"unique":true},"list2":{"min_len":5,"max_len":10,"unique":true},"list3":{"min_len":5,"max_len":10,"unique":true}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["not any(list1[i] == list2[i] == list3[i] for i in range(min(len(list1), len(list2), len(list3))))"]},{"id":"pc_3","description":"Edge Case: One list is empty","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":5},"list2":{"min_len":0,"max_len":5},"list3":{"min_len":0,"max_len":5}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["len(list1) == 0 or len(list2) == 0 or len(list3) == 0"]},{"id":"pc_4","description":"Edge Case: All lists are empty","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":0},"list2":{"min_len":0,"max_len":0},"list3":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Case: Lists of different lengths, some matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":3,"max_len":7},"list2":{"min_len":3,"max_len":7},"list3":{"min_len":3,"max_len":7}},"postconditions":[{"assertion":"result <= min(len(list1), len(list2), len(list3))"}],"assumptions":["len(list1) != len(list2) or len(list2) != len(list3)"]},{"id":"pc_6","description":"Mixed Data Types: Integers and Strings with matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int | str]","list2":"list[int | str]","list3":"list[int | str]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"is_mixed":true,"max_codepoint":127},"list2":{"min_len":5,"max_len":10,"is_mixed":true,"max_codepoint":127},"list3":{"min_len":5,"max_len":10,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":["any(list1[i] == list2[i] == list3[i] for i in range(min(len(list1), len(list2), len(list3))))"]},{"id":"pc_7","description":"Mixed Data Types: Integers and Strings with no matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int | str]","list2":"list[int | str]","list3":"list[int | str]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"is_mixed":true,"max_codepoint":127},"list2":{"min_len":5,"max_len":10,"is_mixed":true,"max_codepoint":127},"list3":{"min_len":5,"max_len":10,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["not any(list1[i] == list2[i] == list3[i] for i in range(min(len(list1), len(list2), len(list3))))"]},{"id":"pc_8","description":"Large Lists: Many elements, few matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":100,"max_len":200},"list2":{"min_len":100,"max_len":200},"list3":{"min_len":100,"max_len":200}},"postconditions":[{"assertion":"result < 5"}],"assumptions":["sum(1 for i in range(min(len(list1), len(list2), len(list3))) if list1[i] == list2[i] == list3[i]) < 5"]},{"id":"pc_9","description":"Large Lists: Many elements, many matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":100,"max_len":200},"list2":{"min_len":100,"max_len":200},"list3":{"min_len":100,"max_len":200}},"postconditions":[{"assertion":"result == len(list1)"}],"assumptions":["list1 == list2 and list2 == list3"]},{"id":"pc_10","description":"Negative Test: Non-list input for list1","execution_statement":"try: result = count_samepair(list1, list2, list3) except Exception as e: result = e","input_types":{"list1":"int","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list2":{"min_len":5,"max_len":10},"list3":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-list input for list2","execution_statement":"try: result = count_samepair(list1, list2, list3) except Exception as e: result = e","input_types":{"list1":"list[int]","list2":"str","list3":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list3":{"min_len":5,"max_len":10},"list2":{"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Non-list input for list3","execution_statement":"try: result = count_samepair(list1, list2, list3) except Exception as e: result = e","input_types":{"list1":"list[int]","list2":"list[int]","list3":"None"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Mixed types including None, with matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int | None]","list2":"list[int | None]","list3":"list[int | None]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"allow_none":true,"is_mixed":true},"list2":{"min_len":5,"max_len":10,"allow_none":true,"is_mixed":true},"list3":{"min_len":5,"max_len":10,"allow_none":true,"is_mixed":true}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":["any(list1[i] == list2[i] == list3[i] for i in range(min(len(list1), len(list2), len(list3))))"]},{"id":"pc_14","description":"Mixed types including None, with no matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int | None]","list2":"list[int | None]","list3":"list[int | None]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"allow_none":true,"is_mixed":true},"list2":{"min_len":5,"max_len":10,"allow_none":true,"is_mixed":true},"list3":{"min_len":5,"max_len":10,"allow_none":true,"is_mixed":true}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["not any(list1[i] == list2[i] == list3[i] for i in range(min(len(list1), len(list2), len(list3))))"]},{"id":"pc_15","description":"Lists with negative numbers and matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_val":-100,"max_val":100,"min_len":5,"max_len":10},"list2":{"min_val":-100,"max_val":100,"min_len":5,"max_len":10},"list3":{"min_val":-100,"max_val":100,"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":["any(list1[i] == list2[i] == list3[i] for i in range(min(len(list1), len(list2), len(list3))))"]},{"id":"pc_16","description":"Lists with negative numbers and no matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_val":-100,"max_val":100,"min_len":5,"max_len":10},"list2":{"min_val":-100,"max_val":100,"min_len":5,"max_len":10},"list3":{"min_val":-100,"max_val":100,"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["not any(list1[i] == list2[i] == list3[i] for i in range(min(len(list1), len(list2), len(list3))))"]},{"id":"pc_17","description":"Lists with zero and matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_val":-10,"max_val":10,"min_len":5,"max_len":10},"list2":{"min_val":-10,"max_val":10,"min_len":5,"max_len":10},"list3":{"min_val":-10,"max_val":10,"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":["0 in list1 and 0 in list2 and 0 in list3 and list1.index(0) == list2.index(0) == list3.index(0)"]},{"id":"pc_18","description":"Lists with zero and no matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_val":-10,"max_val":10,"min_len":5,"max_len":10},"list2":{"min_val":-10,"max_val":10,"min_len":5,"max_len":10},"list3":{"min_val":-10,"max_val":10,"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["not any(list1[i] == list2[i] == list3[i] for i in range(min(len(list1), len(list2), len(list3))))"]},{"id":"pc_19","description":"Lists with boolean values and matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[bool]","list2":"list[bool]","list3":"list[bool]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":5,"max_len":10},"list3":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result == min(len(list1), len(list2), len(list3))"}],"assumptions":["all(list1[i] == list2[i] == list3[i] for i in range(min(len(list1), len(list2), len(list3))))"]},{"id":"pc_20","description":"Lists with boolean values and no matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[bool]","list2":"list[bool]","list3":"list[bool]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":5,"max_len":10},"list3":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["not all(list1[i] == list2[i] == list3[i] for i in range(min(len(list1), len(list2), len(list3))))"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6104"},"test_cases":[{"id":"pc_1","description":"Input is a list.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"list"},"input_constraints":{"input_arg":{"min_len":1,"max_len":10,"elements":{"type":"any","allow_none":true}}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_2","description":"Input is a tuple.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"tuple"},"input_constraints":{"input_arg":{"min_len":0,"max_len":10,"elements":{"type":"any","allow_none":true}}},"postconditions":[{"assertion":"result == len(input_arg)"}],"assumptions":[]},{"id":"pc_3","description":"Input is a string.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"str"},"input_constraints":{"input_arg":{"min_len":0,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"result == len(input_arg)"}],"assumptions":[]},{"id":"pc_4","description":"Input is an integer.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"int"},"input_constraints":{"input_arg":{"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"result == input_arg"}],"assumptions":[]},{"id":"pc_5","description":"Input is a float.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"float"},"input_constraints":{"input_arg":{"min_val":-100.0,"max_val":100.0}},"postconditions":[{"assertion":"result == input_arg"}],"assumptions":[]},{"id":"pc_6","description":"Input is a dictionary.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"dict"},"input_constraints":{"input_arg":{"min_len":0,"max_len":10,"keys":{"type":"any","allow_none":true},"values":{"type":"any","allow_none":true}}},"postconditions":[{"assertion":"result == len(input_arg)"}],"assumptions":[]},{"id":"pc_7","description":"Input is a set.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"set"},"input_constraints":{"input_arg":{"min_len":0,"max_len":10,"elements":{"type":"any","allow_none":true}}},"postconditions":[{"assertion":"result == len(input_arg)"}],"assumptions":[]},{"id":"pc_8","description":"Input is None.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"None"},"input_constraints":{},"postconditions":[{"assertion":"result is None"}],"assumptions":[]},{"id":"pc_9","description":"Input is an empty list.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"list"},"input_constraints":{"input_arg":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_10","description":"Input is an empty tuple.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"tuple"},"input_constraints":{"input_arg":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_11","description":"Input is an empty string.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"str"},"input_constraints":{"input_arg":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_12","description":"Input is zero.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"int"},"input_constraints":{"input_arg":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_13","description":"Input is zero float.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"float"},"input_constraints":{"input_arg":{"min_val":0.0,"max_val":0.0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_14","description":"Input is an empty dictionary.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"dict"},"input_constraints":{"input_arg":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_15","description":"Input is an empty set.","execution_statement":"result = find_lists(input_arg)","input_types":{"input_arg":"set"},"input_constraints":{"input_arg":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6105"},"test_cases":[{"id":"pc_1","description":"Happy Path: Input is a list","input_types":{"Input":"list[int]"},"input_constraints":{"Input":{"min_len":1}},"execution_statement":"result = find_lists(Input)","postconditions":[{"assertion":"result == 1"}]},{"id":"pc_2","description":"Happy Path: Input is a non-empty tuple","input_types":{"Input":"tuple[int]"},"input_constraints":{"Input":{"min_len":1}},"execution_statement":"result = find_lists(Input)","postconditions":[{"assertion":"result == len(Input)"}]},{"id":"pc_3","description":"Edge Case: Input is an empty list","input_types":{"Input":"list[int]"},"input_constraints":{"Input":{"min_len":0,"max_len":0}},"execution_statement":"result = find_lists(Input)","postconditions":[{"assertion":"result == 1"}]},{"id":"pc_4","description":"Edge Case: Input is an empty tuple","input_types":{"Input":"tuple[int]"},"input_constraints":{"Input":{"min_len":0,"max_len":0}},"execution_statement":"result = find_lists(Input)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_5","description":"Edge Case: Input is an empty string","input_types":{"Input":"str"},"input_constraints":{"Input":{"min_len":0,"max_len":0,"max_codepoint":255}},"execution_statement":"result = find_lists(Input)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_6","description":"Negative Test: Input is None","input_types":{"Input":"NoneType"},"input_constraints":{},"execution_statement":"try: result = find_lists(Input) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_7","description":"Negative Test: Input is an integer","input_types":{"Input":"int"},"input_constraints":{},"execution_statement":"try: result = find_lists(Input) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_8","description":"Negative Test: Input is a float","input_types":{"Input":"float"},"input_constraints":{},"execution_statement":"try: result = find_lists(Input) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Typical Case: Tuple with mixed types including lists","input_types":{"Input":"tuple[int | list[int]]"},"input_constraints":{"Input":{"min_len":1,"is_mixed":true}},"execution_statement":"result = find_lists(Input)","postconditions":[{"assertion":"result == len(Input)"}]},{"id":"pc_10","description":"Boundary Value: Large list input","input_types":{"Input":"list[int]"},"input_constraints":{"Input":{"min_len":1000}},"execution_statement":"result = find_lists(Input)","postconditions":[{"assertion":"result == 1"}]},{"id":"pc_11","description":"Boundary Value: Large tuple input","input_types":{"Input":"tuple[int]"},"input_constraints":{"Input":{"min_len":1000}},"execution_statement":"result = find_lists(Input)","postconditions":[{"assertion":"result == len(Input)"}]},{"id":"pc_12","description":"Typical Case: String input","input_types":{"Input":"str"},"input_constraints":{"Input":{"min_len":1,"max_codepoint":255}},"execution_statement":"result = find_lists(Input)","postconditions":[{"assertion":"result == len(Input)"}]},{"id":"pc_13","description":"Typical Case: Tuple with only non-list elements","input_types":{"Input":"tuple[int]"},"input_constraints":{"Input":{"min_len":1}},"execution_statement":"result = find_lists(Input)","postconditions":[{"assertion":"result == len(Input)"}]},{"id":"pc_14","description":"Edge Case: Input is a boolean True","input_types":{"Input":"bool"},"input_constraints":{"Input":{"value":true}},"execution_statement":"result = find_lists(Input)","postconditions":[{"assertion":"result == 1"}]},{"id":"pc_15","description":"Edge Case: Input is a boolean False","input_types":{"Input":"bool"},"input_constraints":{"Input":{"value":false}},"execution_statement":"result = find_lists(Input)","postconditions":[{"assertion":"result == 1"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6106"},"test_cases":[{"id":"pc_1","description":"Typical case with positive integers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":1,"max_val":100,"min_len":2,"max_len":10}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_2","description":"Typical case with negative integers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":-100,"max_val":-1,"min_len":2,"max_len":10}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_3","description":"Typical case with mixed positive and negative integers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":-100,"max_val":100,"min_len":2,"max_len":10,"is_mixed":true}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_4","description":"Edge case: Array with two elements.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":-50,"max_val":50,"min_len":2,"max_len":2}},"postconditions":[{"assertion":"result == abs(arr[0] - arr[1])"}],"assumptions":[]},{"id":"pc_5","description":"Edge case: Array with all identical elements.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":5,"max_val":5,"min_len":2,"max_len":10}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_6","description":"Boundary case: Large numbers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":1000000,"max_val":2000000,"min_len":2,"max_len":5}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_7","description":"Boundary case: Small numbers (close to zero).","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":-5,"max_val":5,"min_len":2,"max_len":10}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_8","description":"Typical case with floating point numbers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[float]"},"input_constraints":{"arr":{"min_val":-100.5,"max_val":100.5,"min_len":2,"max_len":10}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_9","description":"Edge case: Array with one element (should not happen based on min_len=2, but good to consider if min_len was 1).","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":1,"max_val":10,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_10","description":"Invariant test: Max difference should be less than or equal to the difference between max and min elements.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":-200,"max_val":200,"min_len":2,"max_len":15}},"postconditions":[{"assertion":"result <= (max(arr) - min(arr))"}],"assumptions":[]},{"id":"pc_11","description":"Typical case with zero included.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":-50,"max_val":50,"min_len":2,"max_len":10,"elements":[0]}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_12","description":"Negative test: Empty list (should raise IndexError or similar).","execution_statement":"try: result = max_Abs_Diff(arr) except Exception as e: result = e","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, IndexError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative test: Non-list input (e.g., int).","execution_statement":"try: result = max_Abs_Diff(arr) except Exception as e: result = e","input_types":{"arr":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative test: List with non-numeric types (e.g., string).","execution_statement":"try: result = max_Abs_Diff(arr) except Exception as e: result = e","input_types":{"arr":"List[str]"},"input_constraints":{"arr":{"min_len":2,"max_len":5,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Typical case with large range of integers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":-1000000,"max_val":1000000,"min_len":2,"max_len":20}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_16","description":"Typical case with floating point numbers including zero.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[float]"},"input_constraints":{"arr":{"min_val":-50.75,"max_val":50.75,"min_len":2,"max_len":10}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_17","description":"Invariant test: Difference should be between 0 and the range of the input values.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":-1000,"max_val":1000,"min_len":2,"max_len":10}},"postconditions":[{"assertion":"0 <= result <= (max(arr) - min(arr))"}],"assumptions":[]},{"id":"pc_18","description":"Typical case with a mix of integers and floats.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[Union[int, float]]"},"input_constraints":{"arr":{"min_val":-100,"max_val":100,"min_len":2,"max_len":10,"is_mixed":true}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_19","description":"Edge case: Array with two identical floating point numbers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[float]"},"input_constraints":{"arr":{"min_val":10.5,"max_val":10.5,"min_len":2,"max_len":2}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_20","description":"Typical case with a wide range of integers, including large positive and negative values.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"List[int]"},"input_constraints":{"arr":{"min_val":-1000000000,"max_val":1000000000,"min_len":2,"max_len":50}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6107"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list of integers","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result == max(arr) - min(arr)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: List with a single element","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with all identical elements","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["len(set(arr)) == 1"]},{"id":"pc_4","description":"Boundary Case: Large integers","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":5,"max_len":10,"min_val":-1000000000,"max_val":1000000000}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result == max(arr) - min(arr)"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Case: List with negative numbers","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"max_val":-1}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result == max(arr) - min(arr)"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Case: List with mixed positive and negative numbers","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"min_val":-500,"max_val":500,"is_mixed":true}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result == max(arr) - min(arr)"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: List with zero","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result == max(arr) - min(arr)"}],"assumptions":["0 in arr"]},{"id":"pc_8","description":"Happy Path: List of floats","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[float]"},"input_constraints":{"arr":{"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"abs(result - (max(arr) - min(arr))) < 1e-9"}],"assumptions":[]},{"id":"pc_9","description":"Edge Case: List with one positive and one negative number","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"max_len":2}},"postconditions":[{"assertion":"result == abs(arr[0] - arr[1])"}],"assumptions":["arr[0] > 0 and arr[1] < 0 or arr[0] < 0 and arr[1] > 0"]},{"id":"pc_10","description":"Boundary Case: Very large list","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":1000,"max_len":1000}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result == max(arr) - min(arr)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Empty list (expecting IndexError)","execution_statement":"try: result = max_Abs_Diff(arr) except Exception as e: result = e","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, IndexError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Non-list input (expecting TypeError)","execution_statement":"try: result = max_Abs_Diff(arr) except Exception as e: result = e","input_types":{"arr":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: List with None (expecting TypeError)","execution_statement":"try: result = max_Abs_Diff(arr) except Exception as e: result = e","input_types":{"arr":"list[int | None]"},"input_constraints":{"arr":{"min_len":0,"max_len":2}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["None in arr"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6108"},"test_cases":[{"id":"TC1","description":"Typical case: positive a, b, n where a solution exists.","execution_statement":"result = find_solution(a=5, b=3, n=7)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"assumptions":[],"postconditions":[{"assertion":"result is not None or (a * result[0] + b * result[1] == n)"}]},{"id":"TC2","description":"Typical case: positive a, b, n where no solution exists.","execution_statement":"result = find_solution(a=2, b=4, n=7)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"assumptions":["n % math.gcd(a, b) != 0"],"postconditions":[{"assertion":"result is None"}]},{"id":"TC3","description":"Edge case: a is zero, solution exists.","execution_statement":"result = find_solution(a=0, b=5, n=10)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"assumptions":[],"postconditions":[{"assertion":"result is not None and result[0] == 0 and (n - (0 * a)) % b == 0 and result[1] == (n - (0 * a)) // b"}]},{"id":"TC4","description":"Edge case: b is zero, solution exists.","execution_statement":"result = find_solution(a=7, b=0, n=14)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":0,"max_val":0},"n":{"min_val":1,"max_val":1000}},"assumptions":[],"postconditions":[{"assertion":"result is not None and result[1] == 0 and (n - (0 * a)) % b == 0 and result[0] == (n - (0 * a)) // b"}]},{"id":"TC5","description":"Edge case: a and b are zero, n is zero.","execution_statement":"result = find_solution(a=0, b=0, n=0)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0},"b":{"min_val":0,"max_val":0},"n":{"min_val":0,"max_val":0}},"assumptions":[],"postconditions":[{"assertion":"result is not None and result == (0, 0)"}]},{"id":"TC6","description":"Edge case: a and b are zero, n is non-zero (no solution).","execution_statement":"result = find_solution(a=0, b=0, n=5)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0},"b":{"min_val":0,"max_val":0},"n":{"min_val":1,"max_val":100}},"assumptions":[],"postconditions":[{"assertion":"result is None"}]},{"id":"TC7","description":"Typical case: negative coefficients, solution exists.","execution_statement":"result = find_solution(a=-5, b=3, n=7)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":-1},"b":{"min_val":1,"max_val":100},"n":{"min_val":-1000,"max_val":1000}},"assumptions":[],"postconditions":[{"assertion":"result is not None or (a * result[0] + b * result[1] == n)"}]},{"id":"TC8","description":"Typical case: negative n, solution exists.","execution_statement":"result = find_solution(a=5, b=3, n=-7)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"n":{"min_val":-1000,"max_val":-1}},"assumptions":[],"postconditions":[{"assertion":"result is not None or (a * result[0] + b * result[1] == n)"}]},{"id":"TC9","description":"Edge case: a is a multiple of b, solution exists.","execution_statement":"result = find_solution(a=6, b=3, n=12)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"assumptions":["a % b == 0","n % b == 0"],"postconditions":[{"assertion":"result is not None or (a * result[0] + b * result[1] == n)"}]},{"id":"TC10","description":"Edge case: b is a multiple of a, solution exists.","execution_statement":"result = find_solution(a=3, b=6, n=15)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"assumptions":["b % a == 0","n % a == 0"],"postconditions":[{"assertion":"result is not None or (a * result[0] + b * result[1] == n)"}]},{"id":"TC11","description":"Large values for a, b, n, solution exists.","execution_statement":"result = find_solution(a=1000, b=500, n=5000)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":100,"max_val":10000},"b":{"min_val":100,"max_val":10000},"n":{"min_val":100,"max_val":100000}},"assumptions":[],"postconditions":[{"assertion":"result is not None or (a * result[0] + b * result[1] == n)"}]},{"id":"TC12","description":"Large values for a, b, n, no solution exists.","execution_statement":"result = find_solution(a=1001, b=500, n=5000)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":100,"max_val":10000},"b":{"min_val":100,"max_val":10000},"n":{"min_val":100,"max_val":100000}},"assumptions":["n % math.gcd(a, b) != 0"],"postconditions":[{"assertion":"result is None"}]},{"id":"TC13","description":"Coprime coefficients, solution exists.","execution_statement":"result = find_solution(a=7, b=11, n=25)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":2,"max_val":100},"b":{"min_val":2,"max_val":100},"n":{"min_val":1,"max_val":1000}},"assumptions":["math.gcd(a, b) == 1"],"postconditions":[{"assertion":"result is not None or (a * result[0] + b * result[1] == n)"}]},{"id":"TC14","description":"Non-coprime coefficients, solution exists.","execution_statement":"result = find_solution(a=6, b=9, n=15)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":2,"max_val":100},"b":{"min_val":2,"max_val":100},"n":{"min_val":1,"max_val":1000}},"assumptions":["math.gcd(a, b) > 1","n % math.gcd(a, b) == 0"],"postconditions":[{"assertion":"result is not None or (a * result[0] + b * result[1] == n)"}]},{"id":"TC15","description":"Non-coprime coefficients, no solution exists.","execution_statement":"result = find_solution(a=6, b=9, n=10)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":2,"max_val":100},"b":{"min_val":2,"max_val":100},"n":{"min_val":1,"max_val":1000}},"assumptions":["math.gcd(a, b) > 1","n % math.gcd(a, b) != 0"],"postconditions":[{"assertion":"result is None"}]},{"id":"TC16","description":"Solution where i=0.","execution_statement":"result = find_solution(a=10, b=3, n=9)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"assumptions":["n % b == 0"],"postconditions":[{"assertion":"result is not None and result[0] == 0 and result[1] == n // b"}]},{"id":"TC17","description":"Solution where i is large.","execution_statement":"result = find_solution(a=3, b=10, n=99)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"assumptions":[],"postconditions":[{"assertion":"result is not None or (a * result[0] + b * result[1] == n)"}]},{"id":"TC18","description":"Negative a, positive b, negative n, solution exists.","execution_statement":"result = find_solution(a=-5, b=3, n=-7)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":-1},"b":{"min_val":1,"max_val":100},"n":{"min_val":-1000,"max_val":-1}},"assumptions":[],"postconditions":[{"assertion":"result is not None or (a * result[0] + b * result[1] == n)"}]},{"id":"TC19","description":"Positive a, negative b, positive n, solution exists.","execution_statement":"result = find_solution(a=5, b=-3, n=7)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":-100,"max_val":-1},"n":{"min_val":1,"max_val":1000}},"assumptions":[],"postconditions":[{"assertion":"result is not None or (a * result[0] + b * result[1] == n)"}]},{"id":"TC20","description":"Negative a, negative b, negative n, solution exists.","execution_statement":"result = find_solution(a=-5, b=-3, n=-7)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":-1},"b":{"min_val":-100,"max_val":-1},"n":{"min_val":-1000,"max_val":-1}},"assumptions":[],"postconditions":[{"assertion":"result is not None or (a * result[0] + b * result[1] == n)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6109"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic solution found","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None or (isinstance(result, tuple) and len(result) == 2 and isinstance(result[0], int) and result[0] >= 0 and isinstance(result[1], int) and result[1] >= 0 and a * result[0] + b * result[1] == n)"}]},{"id":"pc_2","description":"Edge Case: a is 0, solution exists","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"value":0},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"assumptions":["n % b == 0"],"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is not None and isinstance(result, tuple) and len(result) == 2 and result[0] >= 0 and result[1] == n // b and a * result[0] + b * result[1] == n"}]},{"id":"pc_3","description":"Edge Case: a is 0, no solution","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"value":0},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"assumptions":["n % b != 0"],"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None"}]},{"id":"pc_4","description":"Edge Case: b is 0, solution exists","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"value":0},"n":{"min_val":1,"max_val":1000}},"assumptions":["n % a == 0"],"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is not None and isinstance(result, tuple) and len(result) == 2 and result[0] == n // a and result[1] >= 0 and a * result[0] + b * result[1] == n"}]},{"id":"pc_5","description":"Edge Case: b is 0, no solution","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"value":0},"n":{"min_val":1,"max_val":1000}},"assumptions":["n % a != 0"],"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None"}]},{"id":"pc_6","description":"Edge Case: n is 0","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"n":{"value":0}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result == (0, 0)"}]},{"id":"pc_7","description":"Boundary: Large values for a, b, n","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1000,"max_val":10000},"b":{"min_val":1000,"max_val":10000},"n":{"min_val":10000,"max_val":100000}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None or (isinstance(result, tuple) and len(result) == 2 and isinstance(result[0], int) and result[0] >= 0 and isinstance(result[1], int) and result[1] >= 0 and a * result[0] + b * result[1] == n)"}]},{"id":"pc_8","description":"Invariant: n - (i * a) should be non-negative within loop","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"execution_statement":"i = 0\nwhile i * a <= n:\n    assert n - (i * a) >= 0\n    i = i + 1\nresult = find_solution(a, b, n)","postconditions":[{"assertion":"True"}]},{"id":"pc_9","description":"Negative Test: Invalid input type for a (string)","input_types":{"a":"str","b":"int","n":"int"},"input_constraints":{"a":{"min_len":1,"max_codepoint":255},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"execution_statement":"try: result = find_solution(a, b, n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Invalid input type for b (None)","input_types":{"a":"int","b":"Optional[int]","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"allow_none":true},"n":{"min_val":1,"max_val":1000}},"assumptions":["b is None"],"execution_statement":"try: result = find_solution(a, b, n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Negative Test: Invalid input type for n (float)","input_types":{"a":"int","b":"int","n":"float"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100}},"execution_statement":"try: result = find_solution(a, b, n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Case where i*a exactly equals n","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":50},"b":{"min_val":1,"max_val":50},"n":{"min_val":1,"max_val":1000}},"assumptions":["n % a == 0","(n // a) * b == 0"],"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is not None and isinstance(result, tuple) and len(result) == 2 and result[0] == n // a and result[1] == 0 and a * result[0] + b * result[1] == n"}]},{"id":"pc_13","description":"Case where n is large and a, b are small, potentially many iterations","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":5},"b":{"min_val":1,"max_val":5},"n":{"min_val":1000,"max_val":5000}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None or (isinstance(result, tuple) and len(result) == 2 and isinstance(result[0], int) and result[0] >= 0 and isinstance(result[1], int) and result[1] >= 0 and a * result[0] + b * result[1] == n)"}]},{"id":"pc_14","description":"Case where a and b are large and n is small","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":500,"max_val":1000},"b":{"min_val":500,"max_val":1000},"n":{"min_val":1,"max_val":499}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc610a"},"test_cases":[{"id":"TC001","description":"Typical case: lists with overlapping and non-overlapping elements.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":0,"max_val":100,"min_len":5,"max_len":20},"list2":{"min_val":0,"max_val":100,"min_len":3,"max_len":15}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(elem not in list2 for elem in result)"},{"assertion":"all(elem in result for elem in list1 if elem not in list2)"}]},{"id":"TC002","description":"Boundary case: list1 is empty.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":0},"list2":{"min_val":0,"max_val":100,"min_len":3,"max_len":15}},"assumptions":[],"postconditions":[{"assertion":"result == []"}]},{"id":"TC003","description":"Boundary case: list2 is empty.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":0,"max_val":100,"min_len":5,"max_len":20},"list2":{"min_len":0,"max_len":0}},"assumptions":[],"postconditions":[{"assertion":"result == list1"}]},{"id":"TC004","description":"Boundary case: both lists are empty.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":0},"list2":{"min_len":0,"max_len":0}},"assumptions":[],"postconditions":[{"assertion":"result == []"}]},{"id":"TC005","description":"Edge case: all elements in list1 are present in list2.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":0,"max_val":50,"min_len":5,"max_len":20},"list2":{"min_val":0,"max_val":50,"min_len":10,"max_len":30}},"assumptions":["set(list1).issubset(set(list2))"],"postconditions":[{"assertion":"result == []"}]},{"id":"TC006","description":"Edge case: no elements in list1 are present in list2.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":0,"max_val":50,"min_len":5,"max_len":20},"list2":{"min_val":51,"max_val":100,"min_len":3,"max_len":15}},"assumptions":[],"postconditions":[{"assertion":"result == list1"}]},{"id":"TC007","description":"Edge case: list1 contains duplicate elements.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":0,"max_val":100,"min_len":5,"max_len":20},"list2":{"min_val":0,"max_val":100,"min_len":3,"max_len":15}},"assumptions":["len(list1) > len(set(list1))"],"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(elem not in list2 for elem in result)"},{"assertion":"all(elem in result for elem in list1 if elem not in list2)"}]},{"id":"TC008","description":"Edge case: list2 contains duplicate elements.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":0,"max_val":100,"min_len":5,"max_len":20},"list2":{"min_val":0,"max_val":100,"min_len":3,"max_len":15}},"assumptions":["len(list2) > len(set(list2))"],"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(elem not in list2 for elem in result)"},{"assertion":"all(elem in result for elem in list1 if elem not in list2)"}]},{"id":"TC009","description":"Edge case: large numbers.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":-1000000,"max_val":1000000,"min_len":5,"max_len":20},"list2":{"min_val":-1000000,"max_val":1000000,"min_len":3,"max_len":15}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(elem not in list2 for elem in result)"},{"assertion":"all(elem in result for elem in list1 if elem not in list2)"}]},{"id":"TC010","description":"Invariant test: length of result should be <= length of list1.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":0,"max_val":100,"min_len":1,"max_len":50},"list2":{"min_val":0,"max_val":100,"min_len":1,"max_len":50}},"assumptions":[],"postconditions":[{"assertion":"len(result) <= len(list1)"}]},{"id":"TC011","description":"Test with negative numbers.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":-100,"max_val":-1,"min_len":5,"max_len":20},"list2":{"min_val":-100,"max_val":-1,"min_len":3,"max_len":15}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(elem not in list2 for elem in result)"},{"assertion":"all(elem in result for elem in list1 if elem not in list2)"}]},{"id":"TC012","description":"Test with mixed positive and negative numbers.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":-50,"max_val":50,"min_len":5,"max_len":20,"is_mixed":true},"list2":{"min_val":-50,"max_val":50,"min_len":3,"max_len":15,"is_mixed":true}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(elem not in list2 for elem in result)"},{"assertion":"all(elem in result for elem in list1 if elem not in list2)"}]},{"id":"TC013","description":"Test with zero in lists.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":-10,"max_val":10,"min_len":5,"max_len":20},"list2":{"min_val":-10,"max_val":10,"min_len":3,"max_len":15}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(elem not in list2 for elem in result)"},{"assertion":"all(elem in result for elem in list1 if elem not in list2)"}]},{"id":"TC014","description":"Test with large lists.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":0,"max_val":1000,"min_len":50,"max_len":100},"list2":{"min_val":0,"max_val":1000,"min_len":50,"max_len":100}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(elem not in list2 for elem in result)"},{"assertion":"all(elem in result for elem in list1 if elem not in list2)"}]},{"id":"TC015","description":"Test with list1 being a subset of list2 (ensured by constraints).","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":0,"max_val":20,"min_len":5,"max_len":10},"list2":{"min_val":0,"max_val":20,"min_len":10,"max_len":30}},"assumptions":["set(list1).issubset(set(list2))"],"postconditions":[{"assertion":"result == []"}]},{"id":"TC016","description":"Test with list2 being a subset of list1 (ensured by constraints).","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":0,"max_val":20,"min_len":10,"max_len":30},"list2":{"min_val":0,"max_val":20,"min_len":5,"max_len":10}},"assumptions":["set(list2).issubset(set(list1))"],"postconditions":[{"assertion":"all(elem in list1 for elem in result)"},{"assertion":"all(elem not in list2 for elem in result)"}]},{"id":"TC017","description":"Test with identical lists.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":0,"max_val":50,"min_len":5,"max_len":20},"list2":{"min_val":0,"max_val":50,"min_len":5,"max_len":20}},"assumptions":["list1 == list2"],"postconditions":[{"assertion":"result == []"}]},{"id":"TC018","description":"Test with unique elements in both lists and some overlap.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":0,"max_val":100,"min_len":5,"max_len":20,"unique":true},"list2":{"min_val":0,"max_val":100,"min_len":3,"max_len":15,"unique":true}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(elem not in list2 for elem in result)"},{"assertion":"all(elem in result for elem in list1 if elem not in list2)"}]},{"id":"TC019","description":"Test with non-integer elements (expecting TypeError).","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[str]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":1,"max_len":5},"list2":{"min_len":1,"max_len":5}},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"TC020","description":"Test with None as input (expecting TypeError).","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"None","list2":"list[int]"},"input_constraints":{},"assumptions":[],"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc610b"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic removal","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"all(item not in result for item in list2)"},{"assertion":"result == [x for x in list1 if x not in list2]"}],"assumptions":["any(item in list2 for item in list1)"]},{"id":"pc_2","description":"Edge Case: Empty list1","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":0},"list2":{"min_len":0,"max_len":5}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Empty list2","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == list1"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Both lists empty","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":0},"list2":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: All elements in result must be from list1","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"all(item in list1 for item in result)"}],"assumptions":["any(item in list2 for item in list1)"]},{"id":"pc_6","description":"Invariant: No element from list2 should be in the result","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"all(item not in list2 for item in result)"}],"assumptions":["any(item in list2 for item in list1)"]},{"id":"pc_7","description":"Invariant: Length of result <= length of list1","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"len(result) <= len(list1)"}],"assumptions":["any(item in list2 for item in list1)"]},{"id":"pc_8","description":"Scenario: list1 is a subset of list2","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":3,"max_len":5},"list2":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result == []"}],"assumptions":["all(item in list2 for item in list1)"]},{"id":"pc_9","description":"Scenario: list1 and list2 have no common elements","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_val":1,"max_val":100},"list2":{"min_val":101,"max_val":200}},"postconditions":[{"assertion":"result == list1"}],"assumptions":[]},{"id":"pc_10","description":"Mixed Types: Handling None in list1 (not in list2)","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"tuple[int | None]","list2":"tuple[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"allow_none":true,"is_mixed":true},"list2":{"min_len":1,"max_len":5,"is_mixed":true}},"postconditions":[{"assertion":"None in result"}],"assumptions":["None in list1","None not in list2"]},{"id":"pc_11","description":"Mixed Types: Handling None in list1 and list2","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"tuple[int | None]","list2":"tuple[int | None]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"allow_none":true,"is_mixed":true},"list2":{"min_len":1,"max_len":5,"allow_none":true,"is_mixed":true}},"postconditions":[{"assertion":"None not in result"}],"assumptions":["None in list1","None in list2"]},{"id":"pc_12","description":"Large lists: Ensure correctness with larger inputs","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":100,"max_len":200},"list2":{"min_len":50,"max_len":100}},"postconditions":[{"assertion":"result == [x for x in list1 if x not in list2]"}],"assumptions":["any(item in list2 for item in list1)"]},{"id":"pc_13","description":"List with duplicate elements in list1, some present in list2","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"unique":false},"list2":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == [x for x in list1 if x not in list2]"}],"assumptions":["any(item in list2 for item in list1)"]},{"id":"pc_14","description":"List with duplicate elements in list2","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":1,"max_len":5,"unique":false}},"postconditions":[{"assertion":"result == [x for x in list1 if x not in list2]"}],"assumptions":["any(item in list2 for item in list1)"]},{"id":"pc_15","description":"Mixed Types: Strings","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[str]","list2":"list[str]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"pattern":"^[a-z]+$","is_mixed":true},"list2":{"min_len":1,"max_len":5,"pattern":"^[a-z]+$","is_mixed":true}},"postconditions":[{"assertion":"result == [x for x in list1 if x not in list2]"}],"assumptions":["any(item in list2 for item in list1)"]},{"id":"pc_16","description":"Mixed Types: Strings and Integers (if supported by comparison)","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"tuple[int | str]","list2":"tuple[int | str]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"is_mixed":true,"max_codepoint":127},"list2":{"min_len":1,"max_len":5,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"result == [x for x in list1 if x not in list2]"}],"assumptions":["any(item in list2 for item in list1)"]},{"id":"pc_17","description":"Negative Test: list1 is not iterable","execution_statement":"try: result = remove_elements(list1, list2) except Exception as e: result = e","input_types":{"list1":"int","list2":"list[int]"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_18","description":"Negative Test: list2 is not iterable","execution_statement":"try: result = remove_elements(list1, list2) except Exception as e: result = e","input_types":{"list1":"list[int]","list2":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc610c"},"test_cases":[{"id":"test_sum_series_positive_integers","description":"Test with a range of positive integers for n.","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == sum(range(n, -1, -2))"}]},{"id":"test_sum_series_boundary_one","description":"Test the boundary case where n is 1.","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}]},{"id":"test_sum_series_boundary_two","description":"Test the boundary case where n is 2.","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == 2"}]},{"id":"test_sum_series_large_number","description":"Test with a large positive integer to check for performance or overflow.","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":20000}},"postconditions":[{"assertion":"result == sum(range(n, -1, -2))"}]},{"id":"test_sum_series_zero_input","description":"Test the case where n is 0.","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}]},{"id":"test_sum_series_negative_input","description":"Test with negative integers, which should return 0.","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result == 0"}]},{"id":"test_sum_series_odd_vs_even_formula","description":"Verify the recursive sum against the direct summation for both odd and even n.","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000}},"postconditions":[{"assertion":"result == sum(range(n, -1, -2))"}]},{"id":"test_sum_series_non_integer_float","description":"Test with a float input, expecting a TypeError.","execution_statement":"try: result = sum_series(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{"n":{"min_val":1.0,"max_val":1000.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"test_sum_series_non_integer_string","description":"Test with a string input, expecting a TypeError.","execution_statement":"try: result = sum_series(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"pattern":"[a-zA-Z]+","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"test_sum_series_non_integer_none","description":"Test with None input, expecting a TypeError.","execution_statement":"try: result = sum_series(n) except Exception as e: result = e","input_types":{"n":"Optional[int]"},"input_constraints":{"n":{"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc610d"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive integer input","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result == (n // 2) * (n // 3) if n % 2 == 0 else ((n + 1) // 2) ** 2"}]},{"id":"pc_2","description":"Edge Case: Zero input","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_3","description":"Edge Case: Small positive odd input","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1,"step":2}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_4","description":"Edge Case: Small positive even input","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2,"step":2}},"postconditions":[{"assertion":"result == 2"}]},{"id":"pc_5","description":"Edge Case: Negative integer input","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_6","description":"Boundary Value: Large positive integer input","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":10000}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result == (n // 2) * (n // 3) if n % 2 == 0 else ((n + 1) // 2) ** 2"}]},{"id":"pc_7","description":"Invariant: Result is always an integer","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-100,"max_val":10000}},"postconditions":[{"assertion":"isinstance(result, int)"}]},{"id":"pc_8","description":"Invariant: Result is non-negative","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-100,"max_val":10000}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"pc_9","description":"Test with a moderately large odd number","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":999,"max_val":999}},"postconditions":[{"assertion":"result == ((1000) // 2) ** 2"}]},{"id":"pc_10","description":"Test with a moderately large even number","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000,"max_val":1000}},"postconditions":[{"assertion":"result == (1000 // 2) * (1000 // 3)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc610e"},"test_cases":[{"id":"pc_1","description":"Typical case: Square with side length 5.","execution_statement":"result = area_polygon(s=4, l=5.0)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":4,"max_val":4},"l":{"min_val":5.0,"max_val":5.0}},"postconditions":[{"assertion":"abs(result - 25.0) < 1e-9"}],"assumptions":[]},{"id":"pc_2","description":"Typical case: Equilateral triangle with side length 10.","execution_statement":"result = area_polygon(s=3, l=10.0)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":3,"max_val":3},"l":{"min_val":10.0,"max_val":10.0}},"postconditions":[{"assertion":"abs(result - 43.301270189) < 1e-9"}],"assumptions":[]},{"id":"pc_3","description":"Boundary case: Minimum number of sides (3) with a moderate side length.","execution_statement":"result = area_polygon(s=3, l=1.0)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":3,"max_val":3},"l":{"min_val":1.0,"max_val":1.0}},"postconditions":[{"assertion":"abs(result - 0.43301270189) < 1e-9"}],"assumptions":[]},{"id":"pc_4","description":"Boundary case: Smallest possible positive side length with a square.","execution_statement":"result = area_polygon(s=4, l=1e-9)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":4,"max_val":4},"l":{"min_val":1E-09,"max_val":1E-09}},"postconditions":[{"assertion":"abs(result - 2.5e-19) < 1e-30"}],"assumptions":[]},{"id":"pc_5","description":"Edge case: Large number of sides (approaching a circle) with a moderate side length.","execution_statement":"result = area_polygon(s=1000, l=1.0)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":1000,"max_val":1000},"l":{"min_val":1.0,"max_val":1.0}},"postconditions":[{"assertion":"abs(result - 79577.4715459) < 1e-5"}],"assumptions":[]},{"id":"pc_6","description":"Invariant test: Area should increase with side length for a fixed number of sides (hexagon).","execution_statement":"result = area_polygon(s=6, l=2.0)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":6,"max_val":6},"l":{"min_val":2.0,"max_val":2.0}},"postconditions":[{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_7","description":"Invariant test: Area should increase with number of sides for a fixed side length (side=1).","execution_statement":"result = area_polygon(s=5, l=1.0)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":5,"max_val":5},"l":{"min_val":1.0,"max_val":1.0}},"postconditions":[{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_8","description":"Typical case: Pentagon with side length 7.","execution_statement":"result = area_polygon(s=5, l=7.0)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":5,"max_val":5},"l":{"min_val":7.0,"max_val":7.0}},"postconditions":[{"assertion":"abs(result - 84.3033926) < 1e-6"}],"assumptions":[]},{"id":"pc_9","description":"Edge case: Very large side length with a square.","execution_statement":"result = area_polygon(s=4, l=1e6)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":4,"max_val":4},"l":{"min_val":1E+06,"max_val":1E+06}},"postconditions":[{"assertion":"abs(result - 1e12) < 1e6"}],"assumptions":[]},{"id":"pc_10","description":"Edge case: Large number of sides with a very small side length.","execution_statement":"result = area_polygon(s=5000, l=1e-5)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":5000,"max_val":5000},"l":{"min_val":1E-05,"max_val":1E-05}},"postconditions":[{"assertion":"abs(result - 0.000079577) < 1e-10"}],"assumptions":[]},{"id":"pc_11","description":"Invariant test: Area(s, n) should be approximately equal to Area(s * k, n) / k^2 for k=2.","execution_statement":"result = area_polygon(s=6, l=3.0)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":6,"max_val":2},"l":{"min_val":3.0,"max_val":3.0}},"postconditions":[],"assumptions":["abs(area_polygon(s=6, l=1.5) * 4 - result) < 1e-9"]},{"id":"pc_12","description":"Typical case: Octagon with side length 3.","execution_statement":"result = area_polygon(s=8, l=3.0)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":8,"max_val":8},"l":{"min_val":3.0,"max_val":3.0}},"postconditions":[{"assertion":"abs(result - 43.45584412) < 1e-6"}],"assumptions":[]},{"id":"pc_13","description":"Boundary case: Side length close to zero.","execution_statement":"result = area_polygon(s=5, l=1e-12)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":5,"max_val":5},"l":{"min_val":1E-12,"max_val":1E-12}},"postconditions":[{"assertion":"abs(result - 1.720477400588967e-25) < 1e-35"}],"assumptions":[]},{"id":"pc_14","description":"Edge case: Large number of sides with a large side length.","execution_statement":"result = area_polygon(s=2000, l=100.0)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":2000,"max_val":2000},"l":{"min_val":100.0,"max_val":100.0}},"postconditions":[{"assertion":"abs(result - 795774.715459) < 1e-4"}],"assumptions":[]},{"id":"pc_15","description":"Typical case: Hexagon with side length 2.","execution_statement":"result = area_polygon(s=6, l=2.0)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":6,"max_val":6},"l":{"min_val":2.0,"max_val":2.0}},"postconditions":[{"assertion":"abs(result - 10.392304845) < 1e-6"}],"assumptions":[]},{"id":"pc_16","description":"Invariant test: Area should be positive for valid inputs.","execution_statement":"result = area_polygon(s=7, l=1.5)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":7,"max_val":7},"l":{"min_val":1.5,"max_val":1.5}},"postconditions":[{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_17","description":"Edge case: Minimum sides with a very small side length.","execution_statement":"result = area_polygon(s=3, l=1e-7)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":3,"max_val":3},"l":{"min_val":1E-07,"max_val":1E-07}},"postconditions":[{"assertion":"abs(result - 1.924500897e-14) < 1e-25"}],"assumptions":[]},{"id":"pc_18","description":"Typical case: Square with a fractional side length.","execution_statement":"result = area_polygon(s=4, l=2.5)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":4,"max_val":4},"l":{"min_val":2.5,"max_val":2.5}},"postconditions":[{"assertion":"abs(result - 6.25) < 1e-9"}],"assumptions":[]},{"id":"pc_19","description":"Edge case: Large number of sides with side length 1.","execution_statement":"result = area_polygon(s=10000, l=1.0)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":10000,"max_val":10000},"l":{"min_val":1.0,"max_val":1.0}},"postconditions":[{"assertion":"abs(result - 79577.4715459) < 1e-5"}],"assumptions":[]},{"id":"pc_20","description":"Invariant test: Area should increase with number of sides for a fixed side length (side=2).","execution_statement":"result = area_polygon(s=10, l=2.0)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":10,"max_val":10},"l":{"min_val":2.0,"max_val":2.0}},"postconditions":[{"assertion":"result > 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc610f"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical valid inputs for a regular polygon.","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":3,"max_val":100},"l":{"min_val":1.0,"max_val":1000.0}},"execution_statement":"result = area_polygon(s, l)","postconditions":[{"assertion":"result > 0"},{"assertion":"isinstance(result, float)"}]},{"id":"pc_2","description":"Edge Case: Minimum number of sides (3) with varying lengths.","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":3,"max_val":3},"l":{"min_val":0.1,"max_val":10.0}},"execution_statement":"result = area_polygon(s, l)","postconditions":[{"assertion":"result > 0"}]},{"id":"pc_3","description":"Edge Case: Zero length for a valid number of sides.","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":3,"max_val":50},"l":{"min_val":0.0,"max_val":0.0}},"execution_statement":"result = area_polygon(s, l)","postconditions":[{"assertion":"result == 0.0"}]},{"id":"pc_4","description":"Boundary Case: Large number of sides with moderate length.","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":1000,"max_val":10000},"l":{"min_val":10.0,"max_val":50.0}},"execution_statement":"result = area_polygon(s, l)","postconditions":[{"assertion":"result > 0"},{"assertion":"isinstance(result, float)"}]},{"id":"pc_5","description":"Boundary Case: Large side length with a moderate number of sides.","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":5,"max_val":20},"l":{"min_val":1000.0,"max_val":10000.0}},"execution_statement":"result = area_polygon(s, l)","postconditions":[{"assertion":"result > 0"},{"assertion":"isinstance(result, float)"}]},{"id":"pc_6","description":"Negative Test: Number of sides less than 3 (invalid polygon).","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":0,"max_val":2},"l":{"min_val":1.0,"max_val":10.0}},"execution_statement":"try: result = area_polygon(s, l) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, ValueError) or isinstance(result, ZeroDivisionError) or 'nan' in str(result).lower() or 'inf' in str(result).lower()"}]},{"id":"pc_7","description":"Negative Test: Zero sides (invalid polygon).","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":0,"max_val":0},"l":{"min_val":1.0,"max_val":10.0}},"execution_statement":"try: result = area_polygon(s, l) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, ValueError) or isinstance(result, ZeroDivisionError) or 'nan' in str(result).lower() or 'inf' in str(result).lower()"}]},{"id":"pc_8","description":"Negative Test: Non-numeric sides (expect TypeError).","input_types":{"s":"str","l":"float"},"input_constraints":{"s":{"min_len":1,"max_codepoint":255},"l":{"min_val":1.0,"max_val":10.0}},"execution_statement":"try: result = area_polygon(s, l) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: Non-numeric length (expect TypeError).","input_types":{"s":"int","l":"str"},"input_constraints":{"s":{"min_val":3,"max_val":10},"l":{"min_len":1,"max_codepoint":255}},"execution_statement":"try: result = area_polygon(s, l) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Invariant Test: Area should increase with length for fixed sides.","input_types":{"s":"int","l":"tuple[float, float]"},"input_constraints":{"s":{"min_val":3,"max_val":10},"l":{"min_len":2,"max_len":2,"unique":true,"sorted":"ascending","min_val":1.0,"max_val":100.0}},"execution_statement":"l1, l2 = l; result1 = area_polygon(s, l1); result2 = area_polygon(s, l2)","postconditions":[{"assertion":"result1 < result2"}]},{"id":"pc_11","description":"Invariant Test: Area should generally increase with sides for fixed length.","input_types":{"s":"tuple[int, int]","l":"float"},"input_constraints":{"s":{"min_len":2,"max_len":2,"unique":true,"sorted":"ascending","min_val":3,"max_val":50},"l":{"min_val":1.0,"max_val":10.0}},"execution_statement":"s1, s2 = s; result1 = area_polygon(s1, l); result2 = area_polygon(s2, l)","postconditions":[{"assertion":"result1 < result2"}]},{"id":"pc_12","description":"Negative Test: null for sides (expect TypeError).","input_types":{"s":"None","l":"float"},"input_constraints":{"l":{"min_val":1.0,"max_val":10.0}},"execution_statement":"try: result = area_polygon(s, l) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Negative Test: null for length (expect TypeError).","input_types":{"s":"int","l":"None"},"input_constraints":{"s":{"min_val":3,"max_val":10}},"execution_statement":"try: result = area_polygon(s, l) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Boundary Case: Very small positive length.","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":4,"max_val":10},"l":{"min_val":1E-09,"max_val":1E-05}},"execution_statement":"result = area_polygon(s, l)","postconditions":[{"assertion":"result >= 0"},{"assertion":"isinstance(result, float)"}]},{"id":"pc_15","description":"Invariant: Area should be finite for valid inputs.","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":3,"max_val":100},"l":{"min_val":0.0,"max_val":1000.0}},"execution_statement":"result = area_polygon(s, l)","postconditions":[{"assertion":"result != float('inf') and result != float('-inf') and not isinstance(result, float('nan'))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6110"},"test_cases":[{"id":"pc_1","description":"Typical case: two numbers with equal sum of divisors.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":2,"max_val":1000},"num2":{"min_val":2,"max_val":1000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["div_sum(num1) == div_sum(num2)"]},{"id":"pc_2","description":"Typical case: two numbers with different sum of divisors.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":2,"max_val":1000},"num2":{"min_val":2,"max_val":1000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["div_sum(num1) != div_sum(num2)"]},{"id":"pc_3","description":"Boundary case: smallest possible inputs (1, 1).","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":1,"max_val":1},"num2":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Edge case: perfect numbers (6, 28).","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":6,"max_val":2},"num2":{"min_val":28,"max_val":2}},"postconditions":[{"assertion":"result == True"}],"assumptions":["div_sum(num1) == div_sum(num2)"]},{"id":"pc_5","description":"Edge case: prime numbers (e.g., 7, 11).","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":2,"max_val":100},"num2":{"min_val":2,"max_val":100}},"postconditions":[{"assertion":"result == False"}],"assumptions":["num1 != num2","is_prime(num1)","is_prime(num2)"]},{"id":"pc_6","description":"Edge case: numbers with many divisors (e.g., 12, 18).","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":12,"max_val":2},"num2":{"min_val":18,"max_val":2}},"postconditions":[{"assertion":"result == True"}],"assumptions":["div_sum(num1) == div_sum(num2)"]},{"id":"pc_7","description":"Edge case: identical numbers.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["num1 == num2"]},{"id":"pc_8","description":"Large numbers with equal sum of divisors.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":10000,"max_val":50000},"num2":{"min_val":10000,"max_val":50000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["div_sum(num1) == div_sum(num2)"]},{"id":"pc_9","description":"Large numbers with different sum of divisors.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":10000,"max_val":50000},"num2":{"min_val":10000,"max_val":50000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["div_sum(num1) != div_sum(num2)"]},{"id":"pc_10","description":"Numbers that are powers of the same prime.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":2,"max_val":7},"num2":{"min_val":2,"max_val":7}},"postconditions":[{"assertion":"result == False"}],"assumptions":["num1 != num2","is_power_of_prime(num1)","is_power_of_prime(num2)","get_prime_base(num1) == get_prime_base(num2)"]},{"id":"pc_11","description":"Amicable numbers (e.g., 220, 284) - sum of proper divisors are equal.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":220,"max_val":2},"num2":{"min_val":284,"max_val":2}},"postconditions":[{"assertion":"result == True"}],"assumptions":["div_sum(num1) == div_sum(num2)"]},{"id":"pc_12","description":"Numbers with a single divisor (1).","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":1,"max_val":1},"num2":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_13","description":"One number is 1, the other is not.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":1,"max_val":1},"num2":{"min_val":2,"max_val":100}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"Numbers that are products of two distinct primes.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":6,"max_val":7},"num2":{"min_val":6,"max_val":7}},"postconditions":[{"assertion":"result == False"}],"assumptions":["num1 != num2","is_semiprime(num1)","is_semiprime(num2)","get_prime_factors(num1) != get_prime_factors(num2)"]},{"id":"pc_15","description":"Numbers that are products of two distinct primes with same sum of divisors.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":6,"max_val":7},"num2":{"min_val":6,"max_val":7}},"postconditions":[{"assertion":"result == True"}],"assumptions":["is_semiprime(num1)","is_semiprime(num2)","div_sum(num1) == div_sum(num2)"]},{"id":"pc_16","description":"Numbers with a large number of divisors.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":720,"max_val":5},"num2":{"min_val":840,"max_val":6}},"postconditions":[{"assertion":"result == True"}],"assumptions":["div_sum(num1) == div_sum(num2)"]},{"id":"pc_17","description":"Numbers with a large number of divisors, different sums.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":720,"max_val":720},"num2":{"min_val":840,"max_val":840}},"postconditions":[{"assertion":"result == False"}],"assumptions":["div_sum(num1) != div_sum(num2)"]},{"id":"pc_18","description":"Numbers that are powers of 2.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":2,"max_val":8},"num2":{"min_val":2,"max_val":8}},"postconditions":[{"assertion":"result == (num1 == num2)"}],"assumptions":["is_power_of_two(num1)","is_power_of_two(num2)"]},{"id":"pc_19","description":"Numbers that are powers of 2, with equal sum of divisors.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":2,"max_val":8},"num2":{"min_val":2,"max_val":8}},"postconditions":[{"assertion":"result == True"}],"assumptions":["is_power_of_two(num1)","is_power_of_two(num2)","div_sum(num1) == div_sum(num2)"]},{"id":"pc_20","description":"Maximum integer value test.","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":2147483647,"max_val":2147483647},"num2":{"min_val":2147483647,"max_val":2147483647}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6111"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic equivalence","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":2,"max_val":1000},"num2":{"min_val":2,"max_val":1000}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Identical numbers","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":2,"max_val":1000}},"postconditions":[{"assertion":"result is True"}],"assumptions":["num1 == num2"]},{"id":"pc_3","description":"Edge Case: Input of 1","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":1,"max_val":1},"num2":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Case: Large numbers","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":10000,"max_val":50000},"num2":{"min_val":10000,"max_val":50000}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: Divisor sum is always positive for positive input","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":1,"max_val":1000},"num2":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"div_sum(num1) > 0 and div_sum(num2) > 0"}],"assumptions":[]},{"id":"pc_6","description":"Test Case: Known non-equivalent numbers","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":10,"max_val":20},"num2":{"min_val":21,"max_val":30}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":[]},{"id":"pc_7","description":"Test Case: Known equivalent numbers (e.g., amicable numbers if applicable, or numbers with same divisor sum)","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":220,"max_val":220},"num2":{"min_val":284,"max_val":284}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Non-integer input for num1","execution_statement":"try: result = are_equivalent(num1, num2) except Exception as e: result = e","input_types":{"num1":"str","num2":"int"},"input_constraints":{"num1":{"min_len":1,"max_codepoint":255},"num2":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Non-integer input for num2","execution_statement":"try: result = are_equivalent(num1, num2) except Exception as e: result = e","input_types":{"num1":"int","num2":"float"},"input_constraints":{"num1":{"min_val":1,"max_val":1000},"num2":{}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: null input for num1","execution_statement":"try: result = are_equivalent(num1, num2) except Exception as e: result = e","input_types":{"num1":"Optional[int]","num2":"int"},"input_constraints":{"num1":{"allow_none":true},"num2":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["num1 is None"]},{"id":"pc_11","description":"Negative Test: null input for num2","execution_statement":"try: result = are_equivalent(num1, num2) except Exception as e: result = e","input_types":{"num1":"int","num2":"Optional[int]"},"input_constraints":{"num1":{"min_val":1,"max_val":1000},"num2":{"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["num2 is None"]},{"id":"pc_12","description":"Invariant: are_equivalent(a, b) should be same as are_equivalent(b, a)","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":2,"max_val":1000},"num2":{"min_val":2,"max_val":1000}},"postconditions":[{"assertion":"result == are_equivalent(num2, num1)"}],"assumptions":[]},{"id":"pc_13","description":"Test Case: Numbers with common factors","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":6,"max_val":100},"num2":{"min_val":12,"max_val":100}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":["num1 % 2 == 0 and num2 % 2 == 0"]},{"id":"pc_14","description":"Test Case: Prime numbers","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":2,"max_val":7},"num2":{"min_val":2,"max_val":7}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":["all(num1 % i != 0 for i in range(2, int(num1.5) + 1))","all(num2 % i != 0 for i in range(2, int(num1.5) + 1))"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6112"},"test_cases":[{"id":"pc_1","description":"Test with an empty string.","execution_statement":"result = count_char_position('')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_2","description":"Test with a single character string that matches alphabet position.","execution_statement":"result = count_char_position('a')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":1,"pattern":"^[aA]$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Test with a single character string that does not match alphabet position.","execution_statement":"result = count_char_position('b')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":1,"pattern":"^[bB]$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Test with a string where characters match their alphabet position (case-insensitive).","execution_statement":"result = count_char_position('aBcDeFg')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":2,"pattern":"^[a-zA-Z]{7}$","max_codepoint":255}},"postconditions":[{"assertion":"result == 3"}],"assumptions":["count_char_position('aBcDeFg') == 3"]},{"id":"pc_5","description":"Test with a string where no characters match their alphabet position.","execution_statement":"result = count_char_position('xyz')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":3,"max_len":3,"pattern":"^[x-zX-Z]{3}$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_6","description":"Test with a longer string containing mixed matches and non-matches.","execution_statement":"result = count_char_position('AbCdEfGhIjKlMnOpQrStUvWxYz')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":2,"pattern":"^[a-zA-Z]{26}$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == 13"}],"assumptions":["count_char_position('AbCdEfGhIjKlMnOpQrStUvWxYz') == 13"]},{"id":"pc_7","description":"Test with a string containing only uppercase letters that match.","execution_statement":"result = count_char_position('ACEGI')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":5,"pattern":"^[ACEGI]$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_8","description":"Test with a string containing only lowercase letters that match.","execution_statement":"result = count_char_position('acegi')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":5,"pattern":"^[acegi]$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_9","description":"Test with a string containing non-alphabetic characters.","execution_statement":"result = count_char_position('a1b2C3d4')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":8,"max_len":8,"pattern":"^[a-zA-Z-9]{8}$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_10","description":"Test with a string containing special characters.","execution_statement":"result = count_char_position('a!b@c#d$')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":8,"max_len":8,"pattern":"^[a-zA-Z!@#$%^&*()_+={}\\[\\]:;\"'<>?,./|\\-]{8}$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_11","description":"Test with a string of maximum length (1000 characters).","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1000,"max_len":1000,"pattern":"^[a-zA-Z]{1000}$","max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= 1000"}],"assumptions":[]},{"id":"pc_12","description":"Test with a string where index and character value align (e.g., 'a' at index 0, 'b' at index 1).","execution_statement":"result = count_char_position('ab')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":2,"max_len":2,"pattern":"^[aA][bB]$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_13","description":"Test with a string where index and character value align (case insensitive).","execution_statement":"result = count_char_position('aB')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":2,"max_len":2,"pattern":"^[aA][bB]$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_14","description":"Test with a string where index and character value align (e.g., 'b' at index 1).","execution_statement":"result = count_char_position('cb')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":2,"max_len":2,"pattern":"^[c-zC-Z][bB]$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_15","description":"Test with a string where index and character value align (e.g., 'c' at index 2).","execution_statement":"result = count_char_position('xxc')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":3,"max_len":3,"pattern":"^[a-zA-Z]{2}[cC]$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_16","description":"Test with a string containing only 'a's.","execution_statement":"result = count_char_position('aaaaa')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":5,"pattern":"^a{5}$","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_17","description":"Test with a string containing only 'b's.","execution_statement":"result = count_char_position('bbbbb')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":5,"pattern":"^b{5}$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_18","description":"Test with a string containing only 'z's.","execution_statement":"result = count_char_position('zzzzz')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":5,"max_len":5,"pattern":"^z{5}$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_19","description":"Test with a string where the character's position in the alphabet matches its index.","execution_statement":"result = count_char_position('a')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":1,"pattern":"^a$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_20","description":"Test with a string where the character's position in the alphabet matches its index (case insensitive).","execution_statement":"result = count_char_position('A')","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":1,"max_len":1,"pattern":"^A$","max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6113"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical string with matches","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[a-zA-Z]+$","min_len":5,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(str1)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty String","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String with only non-matching characters","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[^aAoObBcC...zZ]$","min_len":5,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Case: String with all matching characters (lowercase)","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[a-z]$","min_len":26,"max_len":26,"max_codepoint":255}},"postconditions":[{"assertion":"result == len(str1)"}],"assumptions":["all(i == ord(str1[i]) - ord('a') for i in range(len(str1)))"]},{"id":"pc_5","description":"Boundary Case: String with all matching characters (uppercase)","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[A-Z]$","min_len":26,"max_len":26,"max_codepoint":255}},"postconditions":[{"assertion":"result == len(str1)"}],"assumptions":["all(i == ord(str1[i]) - ord('A') for i in range(len(str1)))"]},{"id":"pc_6","description":"Mixed Case String with matches","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[a-zA-Z]+$","min_len":10,"max_len":30,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(str1)"}],"assumptions":[]},{"id":"pc_7","description":"String with special characters (should not match)","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[^a-zA-Z]+$","min_len":5,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_8","description":"Long String with mixed characters","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[a-zA-Z-9]+$","min_len":100,"max_len":500,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(str1)"}],"assumptions":[]},{"id":"pc_9","description":"String with only one character, matching position","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[a-zA-Z]$","min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":["ord(str1[0]) - ord('A') == 0 or ord(str1[0]) - ord('a') == 0"]},{"id":"pc_10","description":"String with only one character, not matching position","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[a-zA-Z]$","min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["not (ord(str1[0]) - ord('A') == 0 or ord(str1[0]) - ord('a') == 0)"]},{"id":"pc_11","description":"String with numbers (should not match)","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[-9]+$","min_len":5,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_12","description":"String with mixed alphanumeric and symbols","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[a-zA-Z-9!@#$%^&*()_+]+$","min_len":10,"max_len":30,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(str1)"}],"assumptions":[]},{"id":"pc_13","description":"String with unicode characters (should not match alphabet positions)","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[\\u0080-\\uFFFF]+$","min_len":5,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_14","description":"String with spaces","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[a-zA-Z ]+$","min_len":5,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(str1)"}],"assumptions":[]},{"id":"pc_15","description":"String with leading/trailing spaces","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^\\s*[a-zA-Z]+\\s*$","min_len":5,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(str1)"}],"assumptions":[]},{"id":"pc_16","description":"String with repeated characters","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[a-zA-Z]+$","min_len":5,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(str1)"}],"assumptions":["len(set(str1)) < len(str1)"]},{"id":"pc_17","description":"String with characters that could be confused with positions (e.g., 'o' at index 14, 'l' at index 11)","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[a-zA-Z]+$","min_len":5,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(str1)"}],"assumptions":[]},{"id":"pc_18","description":"String with maximum length","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[a-zA-Z]+$","min_len":500,"max_len":500,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(str1)"}],"assumptions":[]},{"id":"pc_19","description":"String with minimum length (greater than 0)","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[a-zA-Z]+$","min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(str1)"}],"assumptions":[]},{"id":"pc_20","description":"String with characters that are close to their alphabetical position but not exact","execution_statement":"result = count_char_position(str1)","input_types":{"str1":"str"},"input_constraints":{"str1":{"pattern":"^[a-zA-Z]+$","min_len":5,"max_len":20,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["not any(((i == ord(str1[i]) - ord('A')) or (i == ord(str1[i]) - ord('a'))) for i in range(len(str1)))"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6114"},"test_cases":[{"id":"TC001","description":"Test with an empty list.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}]},{"id":"TC002","description":"Test with a single element list.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 0"}]},{"id":"TC003","description":"Test with two elements, both even.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":2,"elements":{"min_val":0,"max_val":100,"even":true}}},"postconditions":[{"assertion":"result == 1"}]},{"id":"TC004","description":"Test with two elements, both odd.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":2,"elements":{"min_val":1,"max_val":100,"even":false}}},"postconditions":[{"assertion":"result == 1"}]},{"id":"TC005","description":"Test with two elements, one even, one odd.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":2,"elements":{"min_val":0,"max_val":100}}},"assumptions":["A[0] % 2 != A[1] % 2"],"postconditions":[{"assertion":"result == 0"}]},{"id":"TC006","description":"Test with a list of all zeros.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":10,"elements":{"value":0}}},"postconditions":[{"assertion":"result == len(A) * (len(A) - 1) // 2"}]},{"id":"TC007","description":"Test with a list of identical even numbers.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":10,"elements":{"min_val":2,"max_val":100,"even":true}}},"assumptions":["len(set(A)) == 1"],"postconditions":[{"assertion":"result == len(A) * (len(A) - 1) // 2"}]},{"id":"TC008","description":"Test with a list of identical odd numbers.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":10,"elements":{"min_val":1,"max_val":99,"even":false}}},"assumptions":["len(set(A)) == 1"],"postconditions":[{"assertion":"result == len(A) * (len(A) - 1) // 2"}]},{"id":"TC009","description":"Test with a mixed list of even and odd numbers.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":15,"elements":{"min_val":0,"max_val":100},"is_mixed":true}},"postconditions":[{"assertion":"result == sum(1 for i in range(len(A)) for j in range(i + 1, len(A)) if (A[i] ^ A[j]) % 2 == 0)"}]},{"id":"TC010","description":"Test with large numbers.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":3,"max_len":7,"elements":{"min_val":10000,"max_val":100000}}},"postconditions":[{"assertion":"result == sum(1 for i in range(len(A)) for j in range(i + 1, len(A)) if (A[i] ^ A[j]) % 2 == 0)"}]},{"id":"TC011","description":"Test with negative numbers.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":3,"max_len":7,"elements":{"min_val":-100,"max_val":-1}}},"postconditions":[{"assertion":"result == sum(1 for i in range(len(A)) for j in range(i + 1, len(A)) if (A[i] ^ A[j]) % 2 == 0)"}]},{"id":"TC012","description":"Test with mixed positive and negative numbers.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":3,"max_len":7,"elements":{"min_val":-100,"max_val":100},"is_mixed":true}},"postconditions":[{"assertion":"result == sum(1 for i in range(len(A)) for j in range(i + 1, len(A)) if (A[i] ^ A[j]) % 2 == 0)"}]},{"id":"TC013","description":"Test with a larger list.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":20,"max_len":50,"elements":{"min_val":0,"max_val":1000}}},"postconditions":[{"assertion":"result == sum(1 for i in range(len(A)) for j in range(i + 1, len(A)) if (A[i] ^ A[j]) % 2 == 0)"}]},{"id":"TC014","description":"Test with numbers that XOR to even.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":4,"max_len":8,"elements":{"min_val":0,"max_val":10}}},"assumptions":["all((x % 2 == 0 and y % 2 == 0) or (x % 2 != 0 and y % 2 != 0) for x in A for y in A if x != y)"],"postconditions":[{"assertion":"result == len(A) * (len(A) - 1) // 2"}]},{"id":"TC015","description":"Test with numbers that XOR to odd.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":4,"max_len":8,"elements":{"min_val":0,"max_val":10}}},"assumptions":["all((x % 2 == 0 and y % 2 != 0) or (x % 2 != 0 and y % 2 == 0) for x in A for y in A if x != y)"],"postconditions":[{"assertion":"result == 0"}]},{"id":"TC016","description":"Test with a list containing duplicates.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":10,"elements":{"min_val":0,"max_val":50}}},"assumptions":["len(A) > len(set(A))"],"postconditions":[{"assertion":"result == sum(1 for i in range(len(A)) for j in range(i + 1, len(A)) if (A[i] ^ A[j]) % 2 == 0)"}]},{"id":"TC017","description":"Test with a list where all pairs XOR to even.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":3,"max_len":6,"elements":{"min_val":0,"max_val":100,"even":true}}},"postconditions":[{"assertion":"result == len(A) * (len(A) - 1) // 2"}]},{"id":"TC018","description":"Test with a list where all pairs XOR to odd.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":3,"max_len":6,"elements":{"min_val":1,"max_val":100,"even":false}}},"postconditions":[{"assertion":"result == 0"}]},{"id":"TC019","description":"Test with a list containing a mix of small and large numbers.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":10,"elements":{"min_val":-1000,"max_val":1000}}},"postconditions":[{"assertion":"result == sum(1 for i in range(len(A)) for j in range(i + 1, len(A)) if (A[i] ^ A[j]) % 2 == 0)"}]},{"id":"TC020","description":"Test with a list where elements are powers of 2.","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":3,"max_len":7,"elements":{"min_val":1,"max_val":1024}}},"assumptions":["all(x > 0 and (x & (x - 1) == 0) for x in A)"],"postconditions":[{"assertion":"result == sum(1 for i in range(len(A)) for j in range(i + 1, len(A)) if (A[i] ^ A[j]) % 2 == 0)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6115"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list of integers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":20}},"postconditions":[{"assertion":"count >= 0"},{"assertion":"count <= (len(A) * (len(A) - 1)) // 2"},{"assertion":"count == (num_even * (num_even - 1) // 2) + (num_odd * (num_odd - 1) // 2)","setup_template":"num_even = sum(1 for x in A if x % 2 == 0)\nnum_odd = len(A) - num_even"}]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"count == 0"}]},{"id":"pc_3","description":"Edge Case: Single element list","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"count == 0"}]},{"id":"pc_4","description":"Boundary Case: List with only even numbers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":20,"elements":{"strategy":"integers","even":true}}},"postconditions":[{"assertion":"count == (len(A) * (len(A) - 1)) // 2"}]},{"id":"pc_5","description":"Boundary Case: List with only odd numbers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":20,"elements":{"strategy":"integers","odd":true}}},"postconditions":[{"assertion":"count == (len(A) * (len(A) - 1)) // 2"}]},{"id":"pc_6","description":"Boundary Case: List with zeros","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":20,"elements":{"strategy":"integers","max_value":0}}},"postconditions":[{"assertion":"count == (num_even * (num_even - 1) // 2) + (num_odd * (num_odd - 1) // 2)","setup_template":"num_even = sum(1 for x in A if x % 2 == 0)\nnum_odd = len(A) - num_even"}]},{"id":"pc_7","description":"Boundary Case: List with negative numbers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":20,"elements":{"strategy":"integers","max_value":-1}}},"postconditions":[{"assertion":"count == (num_even * (num_even - 1) // 2) + (num_odd * (num_odd - 1) // 2)","setup_template":"num_even = sum(1 for x in A if x % 2 == 0)\nnum_odd = len(A) - num_even"}]},{"id":"pc_8","description":"Boundary Case: Large list","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":100,"max_len":200}},"postconditions":[{"assertion":"count >= 0"},{"assertion":"count <= (len(A) * (len(A) - 1)) // 2"},{"assertion":"count == (num_even * (num_even - 1) // 2) + (num_odd * (num_odd - 1) // 2)","setup_template":"num_even = sum(1 for x in A if x % 2 == 0)\nnum_odd = len(A) - num_even"}]},{"id":"pc_9","description":"Invariant: Count is always non-negative","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":0,"max_len":50}},"postconditions":[{"assertion":"count >= 0"}]},{"id":"pc_10","description":"Invariant: Count does not exceed total possible pairs","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":0,"max_len":50}},"postconditions":[{"assertion":"count <= (len(A) * (len(A) - 1)) // 2"}]},{"id":"pc_11","description":"Mixed parity with negative and positive numbers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":20,"elements":{"strategy":"integers","min_val":-100,"max_val":100},"is_mixed":true}},"postconditions":[{"assertion":"count == (num_even * (num_even - 1) // 2) + (num_odd * (num_odd - 1) // 2)","setup_template":"num_even = sum(1 for x in A if x % 2 == 0)\nnum_odd = len(A) - num_even"}]},{"id":"pc_12","description":"List with large integers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":20,"elements":{"strategy":"integers","min_val":1000000000,"max_val":2000000000}}},"postconditions":[{"assertion":"count == (num_even * (num_even - 1) // 2) + (num_odd * (num_odd - 1) // 2)","setup_template":"num_even = sum(1 for x in A if x % 2 == 0)\nnum_odd = len(A) - num_even"}]},{"id":"pc_13","description":"List with duplicate numbers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":20,"unique":false}},"postconditions":[{"assertion":"count == (num_even * (num_even - 1) // 2) + (num_odd * (num_odd - 1) // 2)","setup_template":"num_even = sum(1 for x in A if x % 2 == 0)\nnum_odd = len(A) - num_even"}]},{"id":"pc_14","description":"List with unique numbers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":5,"max_len":20,"unique":true}},"postconditions":[{"assertion":"count == (num_even * (num_even - 1) // 2) + (num_odd * (num_odd - 1) // 2)","setup_template":"num_even = sum(1 for x in A if x % 2 == 0)\nnum_odd = len(A) - num_even"}]},{"id":"pc_15","description":"Test with a mix of positive, negative, and zero integers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":10,"max_len":30,"elements":{"strategy":"integers","min_val":-50,"max_val":50}}},"postconditions":[{"assertion":"count == (num_even * (num_even - 1) // 2) + (num_odd * (num_odd - 1) // 2)","setup_template":"num_even = sum(1 for x in A if x % 2 == 0)\nnum_odd = len(A) - num_even"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6116"},"test_cases":[{"id":"TC1","description":"Test with 0, expecting 1.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"TC2","description":"Test with 1, expecting 1.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}]},{"id":"TC3","description":"Test with a power of 2, expecting itself.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1024,"step":2}},"assumptions":["n > 0 and (n & (n - 1) == 0)"],"postconditions":[{"assertion":"result == n"}]},{"id":"TC4","description":"Test with a number just above a power of 2.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":3,"max_val":1025}},"assumptions":["n > 1 and (n & (n - 1) != 0)"],"postconditions":[{"assertion":"result == 2 * n_prev_power_of_2"}],"dependent_variables":{"n_prev_power_of_2":"lambda n: 1 << (n.bit_length() - 1)"}},{"id":"TC5","description":"Test with a number just below a power of 2.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1023}},"assumptions":["n > 0 and (n & (n - 1) != 0)"],"postconditions":[{"assertion":"result == 1 << n.bit_length()"}]},{"id":"TC6","description":"Test with a large number.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000,"max_val":1000000000}},"postconditions":[{"assertion":"(result > 0) and (result & (result - 1) == 0)"},{"assertion":"result >= n"},{"assertion":"(result // 2 < n) or (result == 1 and n == 0)"}]},{"id":"TC7","description":"Test with a number that requires multiple shifts.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":65,"max_val":127}},"postconditions":[{"assertion":"result == 128"}]},{"id":"TC8","description":"Test with a number that is a power of 2 minus 1.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1023}},"assumptions":["n > 0 and (n & (n - 1) != 0) and (n + 1) & n == 0"],"postconditions":[{"assertion":"result == n + 1"}]},{"id":"TC9","description":"Test with a number that is a power of 2 plus 1.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1025}},"assumptions":["n > 1 and (n & (n - 1) != 0) and (n - 1) & (n - 2) == 0"],"postconditions":[{"assertion":"result == n"}]},{"id":"TC10","description":"Test with a number that is a power of 2.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":4,"max_val":4096}},"assumptions":["n > 0 and (n & (n - 1) == 0)"],"postconditions":[{"assertion":"result == n"}]},{"id":"TC11","description":"Test with a number that is not a power of 2.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":5,"max_val":4095}},"assumptions":["n > 0 and (n & (n - 1) != 0)"],"postconditions":[{"assertion":"result == 1 << n.bit_length()"}]},{"id":"TC12","description":"Test with a number that is a power of 2, but large.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":65536,"max_val":65536}},"assumptions":["n > 0 and (n & (n - 1) == 0)"],"postconditions":[{"assertion":"result == n"}]},{"id":"TC13","description":"Test with a number that is not a power of 2, but large.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":65537,"max_val":131071}},"assumptions":["n > 0 and (n & (n - 1) != 0)"],"postconditions":[{"assertion":"result == 1 << n.bit_length()"}]},{"id":"TC14","description":"Test with a number that is a power of 2 minus 1, large.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":65535,"max_val":65535}},"assumptions":["n > 0 and (n & (n - 1) != 0) and (n + 1) & n == 0"],"postconditions":[{"assertion":"result == n + 1"}]},{"id":"TC15","description":"Test with a number that is a power of 2 plus 1, large.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":65537,"max_val":65537}},"assumptions":["n > 1 and (n & (n - 1) != 0) and (n - 1) & (n - 2) == 0"],"postconditions":[{"assertion":"result == n"}]},{"id":"TC16","description":"Test with a number that requires many shifts.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100000,"max_val":200000}},"postconditions":[{"assertion":"(result > 0) and (result & (result - 1) == 0)"},{"assertion":"result >= n"},{"assertion":"(result // 2 < n) or (result == 1 and n == 0)"}]},{"id":"TC17","description":"Test with a number that is a power of 2, very large.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1073741824,"max_val":1073741824}},"assumptions":["n > 0 and (n & (n - 1) == 0)"],"postconditions":[{"assertion":"result == n"}]},{"id":"TC18","description":"Test with a number that is not a power of 2, very large.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1073741825,"max_val":2147483647}},"assumptions":["n > 0 and (n & (n - 1) != 0)"],"postconditions":[{"assertion":"result == 1 << n.bit_length()"}]},{"id":"TC19","description":"Test with a number that is a power of 2 minus 1, very large.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1073741823,"max_val":1073741823}},"assumptions":["n > 0 and (n & (n - 1) != 0) and (n + 1) & n == 0"],"postconditions":[{"assertion":"result == n + 1"}]},{"id":"TC20","description":"Test with a number that is a power of 2 plus 1, very large.","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1073741825,"max_val":1073741825}},"assumptions":["n > 1 and (n & (n - 1) != 0) and (n - 1) & (n - 2) == 0"],"postconditions":[{"assertion":"result == n"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6117"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical positive integer","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000}},"postconditions":[{"assertion":"result >= n and (result > 0 and (result & (result - 1) == 0))"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Input is 0","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Input is 1","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_4","description":"Boundary: Input is already a power of 2","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2147483648,"step":2}},"postconditions":[{"assertion":"result == n"}],"assumptions":["n > 0 and (n & (n - 1) == 0)"]},{"id":"pc_5","description":"Boundary: Large number close to max int","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2147483647,"max_val":2147483647}},"postconditions":[{"assertion":"result >= n and (result > 0 and (result & (result - 1) == 0))"}],"assumptions":[]},{"id":"pc_6","description":"Invariant: Result is always positive for non-negative input","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000000}},"postconditions":[{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_7","description":"Invariant: Result is always a power of 2","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":1000000}},"postconditions":[{"assertion":"(result > 0 and (result & (result - 1) == 0))"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Input is None","execution_statement":"try: result = next_power_of_2(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Input is a string","execution_statement":"try: result = next_power_of_2(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Input is a float","execution_statement":"try: result = next_power_of_2(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{"n":{"min_val":0.0,"max_val":1E+06}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Boundary: Very large power of 2","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1073741824,"max_val":1073741824}},"postconditions":[{"assertion":"result == n"}],"assumptions":[]},{"id":"pc_12","description":"Boundary: Number just below a power of 2","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1023,"max_val":1023}},"postconditions":[{"assertion":"result == 1024"}],"assumptions":[]},{"id":"pc_13","description":"Boundary: Number just above a power of 2","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1025,"max_val":1025}},"postconditions":[{"assertion":"result == 2048"}],"assumptions":[]},{"id":"pc_14","description":"Happy Path: Another typical positive integer","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":500,"max_val":1500}},"postconditions":[{"assertion":"result >= n and (result > 0 and (result & (result - 1) == 0))"}],"assumptions":[]},{"id":"pc_15","description":"Invariant: Result is always greater than or equal to input for positive inputs","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000}},"postconditions":[{"assertion":"result >= n"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6118"},"test_cases":[{"id":"pc_1","description":"Typical case: list with multiple occurrences of the target number.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":1,"max_val":10,"min_len":5,"max_len":10},"x":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":["x in a"]},{"id":"pc_2","description":"Edge case: empty list.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"max_len":0},"x":{}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge case: list with a single element that matches the target.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":5,"max_val":5,"min_len":1,"max_len":1},"x":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_4","description":"Edge case: list with a single element that does not match the target.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":1,"max_val":10,"min_len":1,"max_len":1},"x":{"min_val":11,"max_val":20}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_5","description":"Boundary case: large list with many occurrences of the target number.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100,"min_len":1000,"max_len":1000},"x":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":["x in a"]},{"id":"pc_6","description":"Boundary case: large list with no occurrences of the target number.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100,"min_len":1000,"max_len":1000},"x":{"min_val":101,"max_val":200}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_7","description":"Edge case: target number is zero.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":-10,"max_val":10},"x":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":[]},{"id":"pc_8","description":"Edge case: target number is negative.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":100},"x":{"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":[]},{"id":"pc_9","description":"Edge case: list contains only the target number.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":5,"max_val":5,"min_len":10,"max_len":10},"x":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"result == 10"}],"assumptions":[]},{"id":"pc_10","description":"Edge case: list contains numbers, but none match the target.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":1,"max_val":10,"min_len":10,"max_len":10},"x":{"min_val":11,"max_val":20}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_11","description":"Invariant test: count is less than or equal to list length.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100,"min_len":1,"max_len":100},"x":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result <= len(a)"}],"assumptions":[]},{"id":"pc_12","description":"Invariant test: empty list yields zero count.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"max_len":0},"x":{}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_13","description":"Invariant test: target not present yields zero count.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100,"min_len":1,"max_len":100},"x":{"min_val":101,"max_val":200}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_14","description":"Typical case: list with mixed positive and negative numbers, target within range.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":-10,"max_val":10,"min_len":5,"max_len":10,"is_mixed":true},"x":{"min_val":-10,"max_val":10,"is_mixed":true}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":[]},{"id":"pc_15","description":"Typical case: list with only one occurrence of the target number.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":1,"max_val":10,"min_len":5,"max_len":10},"x":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == 1"}],"assumptions":["a.count(x) == 1"]},{"id":"pc_16","description":"Typical case: list with no occurrences of the target number.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":1,"max_val":10,"min_len":5,"max_len":10},"x":{"min_val":11,"max_val":20}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_17","description":"Large list with target at the beginning.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100,"min_len":1000,"max_len":1000},"x":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":["a[0] == x"]},{"id":"pc_18","description":"Large list with target at the end.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100,"min_len":1000,"max_len":1000},"x":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result >= 1"}],"assumptions":["a[-1] == x"]},{"id":"pc_19","description":"List with all elements equal to target, including negative numbers.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":-50,"max_val":-50,"min_len":20,"max_len":20},"x":{"min_val":-50,"max_val":-50}},"postconditions":[{"assertion":"result == 20"}],"assumptions":[]},{"id":"pc_20","description":"List with mixed positive and negative numbers, target is positive.","execution_statement":"result = frequency(a, x)","input_types":{"a":"List[int]","x":"int"},"input_constraints":{"a":{"min_val":-10,"max_val":10,"min_len":10,"max_len":10,"is_mixed":true},"x":{"min_val":1,"max_val":10,"is_mixed":true}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6119"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic frequency count","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":100},"x":{"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"result == sum(1 for item in a if item == x)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":0,"max_len":0},"x":{"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Element not present in list","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":100},"x":{"min_val":101,"max_val":200}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["x not in a"]},{"id":"pc_4","description":"Edge Case: All elements in list match x","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50},"x":{"min_val":-50,"max_val":50}},"postconditions":[{"assertion":"result == len(a)"}],"assumptions":["all(item == x for item in a)"]},{"id":"pc_5","description":"Boundary Value: Large list with some occurrences","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":500,"max_len":1000},"x":{"min_val":0,"max_val":10}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(a)"},{"assertion":"result == sum(1 for item in a if item == x)"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Value: Large list with no occurrences","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":500,"max_len":1000},"x":{"min_val":101,"max_val":110}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["x not in a"]},{"id":"pc_7","description":"Invariant: Count is always non-negative","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":0,"max_len":200},"x":{"min_val":-200,"max_val":200}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_8","description":"Invariant: Count does not exceed list length","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":0,"max_len":200},"x":{"min_val":-200,"max_val":200}},"postconditions":[{"assertion":"result <= len(a)"}],"assumptions":[]},{"id":"pc_9","description":"Mixed Types: List with different integer types (positive, negative, zero)","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":100,"unique":true,"is_mixed":true},"x":{"min_val":-100,"max_val":100,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(1 for item in a if item == x)"}],"assumptions":[]},{"id":"pc_10","description":"List with duplicate elements, searching for a duplicate","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":5,"max_len":50},"x":{"min_val":0,"max_val":10}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":["a.count(x) > 1"]},{"id":"pc_11","description":"List with duplicate elements, searching for a non-duplicate","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":5,"max_len":50},"x":{"min_val":11,"max_val":20}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["x not in a"]},{"id":"pc_12","description":"List containing zero, searching for zero","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50},"x":{"value":0}},"postconditions":[{"assertion":"result == a.count(0)"}],"assumptions":["0 in a"]},{"id":"pc_13","description":"List containing zero, searching for non-zero","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50},"x":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == sum(1 for item in a if item == x)"}],"assumptions":["0 in a"]},{"id":"pc_14","description":"List with negative numbers, searching for a negative number","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50},"x":{"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"result == sum(1 for item in a if item == x)"}],"assumptions":["any(item < 0 for item in a)"]},{"id":"pc_15","description":"List with negative numbers, searching for a positive number","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50},"x":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == sum(1 for item in a if item == x)"}],"assumptions":["any(item < 0 for item in a)"]},{"id":"pc_16","description":"List with mixed positive, negative, and zero, searching for zero","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50,"is_mixed":true},"x":{"value":0,"is_mixed":true}},"postconditions":[{"assertion":"result == a.count(0)"}],"assumptions":["any(item < 0 for item in a) and any(item > 0 for item in a)"]},{"id":"pc_17","description":"List with mixed positive, negative, and zero, searching for a positive number","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50,"is_mixed":true},"x":{"min_val":1,"max_val":100,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(1 for item in a if item == x)"}],"assumptions":["any(item < 0 for item in a) and any(item == 0 for item in a)"]},{"id":"pc_18","description":"List with mixed positive, negative, and zero, searching for a negative number","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50,"is_mixed":true},"x":{"min_val":-100,"max_val":-1,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(1 for item in a if item == x)"}],"assumptions":["any(item > 0 for item in a) and any(item == 0 for item in a)"]},{"id":"pc_19","description":"Invariant: Sum of frequencies of all unique elements equals list length","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":100},"x":{"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"sum(frequency(a, val) for val in set(a)) == len(a)"}],"assumptions":[]},{"id":"pc_20","description":"Negative Test: Non-iterable input for 'a'","execution_statement":"try: result = frequency(a, x) except Exception as e: result = e","input_types":{"a":"int","x":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc611a"},"test_cases":[{"id":"pc_1","description":"Basic functionality with overlapping elements","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[int]","test_list2":"list[int]"},"input_constraints":{"test_list1":{"min_len":1,"max_len":100,"unique":true},"test_list2":{"min_len":1,"max_len":100,"unique":true}},"postconditions":[{"assertion":"set(result) == set(test_list1) & set(test_list2)"}],"assumptions":[]},{"id":"pc_2","description":"Edge case: One list is empty","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[int]","test_list2":"list[int]"},"input_constraints":{"test_list1":{"min_len":0,"max_len":100,"unique":true},"test_list2":{"min_len":0,"max_len":100,"unique":true}},"postconditions":[{"assertion":"result == ()"}],"assumptions":["not test_list1 or not test_list2"]},{"id":"pc_3","description":"Edge case: Both lists are empty","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[int]","test_list2":"list[int]"},"input_constraints":{"test_list1":{"min_len":0,"max_len":0,"unique":true},"test_list2":{"min_len":0,"max_len":0,"unique":true}},"postconditions":[{"assertion":"result == ()"}],"assumptions":[]},{"id":"pc_4","description":"Invariant: No duplicates in result","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[int]","test_list2":"list[int]"},"input_constraints":{"test_list1":{"min_len":1,"max_len":100,"unique":true},"test_list2":{"min_len":1,"max_len":100,"unique":true}},"postconditions":[{"assertion":"len(result) == len(set(result))"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: Elements in result are from inputs","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[int]","test_list2":"list[int]"},"input_constraints":{"test_list1":{"min_len":1,"max_len":100,"unique":true},"test_list2":{"min_len":1,"max_len":100,"unique":true}},"postconditions":[{"assertion":"all(elem in test_list1 or elem in test_list2 for elem in result)"}],"assumptions":[]},{"id":"pc_6","description":"Typical case with some overlap","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[int]","test_list2":"list[int]"},"input_constraints":{"test_list1":{"min_val":1,"max_val":10,"min_len":5,"max_len":20,"unique":true},"test_list2":{"min_val":1,"max_val":10,"min_len":5,"max_len":20,"unique":true}},"postconditions":[{"assertion":"set(result) == set(test_list1) & set(test_list2)"}],"assumptions":["bool(set(test_list1) & set(test_list2))"]},{"id":"pc_7","description":"Boundary: Large lists with overlap","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[int]","test_list2":"list[int]"},"input_constraints":{"test_list1":{"min_len":1000,"max_len":2000,"unique":true},"test_list2":{"min_len":1000,"max_len":2000,"unique":true}},"postconditions":[{"assertion":"set(result) == set(test_list1) & set(test_list2)"}],"assumptions":[]},{"id":"pc_8","description":"Elements of different hashable types","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[Any]","test_list2":"list[Any]"},"input_constraints":{"test_list1":{"min_len":5,"max_len":50,"hashable_mix":true,"unique":true},"test_list2":{"min_len":5,"max_len":50,"hashable_mix":true,"unique":true}},"postconditions":[{"assertion":"set(result) == set(test_list1) & set(test_list2)"}],"assumptions":[]},{"id":"pc_9","description":"No overlap between lists","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[int]","test_list2":"list[int]"},"input_constraints":{"test_list1":{"min_val":1,"max_val":10,"min_len":5,"max_len":10,"unique":true},"test_list2":{"min_val":11,"max_val":20,"min_len":5,"max_len":10,"unique":true}},"postconditions":[{"assertion":"result == ()"}],"assumptions":[]},{"id":"pc_10","description":"One list is a subset of the other","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[int]","test_list2":"list[int]"},"input_constraints":{"test_list1":{"min_val":1,"max_val":20,"min_len":10,"max_len":20,"unique":true},"test_list2":{"min_val":1,"max_val":20,"min_len":5,"max_len":10,"unique":true}},"postconditions":[{"assertion":"set(result) == set(test_list2)"}],"assumptions":["set(test_list2).issubset(set(test_list1))"]},{"id":"pc_11","description":"Lists with string elements","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[str]","test_list2":"list[str]"},"input_constraints":{"test_list1":{"min_len":5,"max_len":50,"unique":true,"max_codepoint":127},"test_list2":{"min_len":5,"max_len":50,"unique":true,"max_codepoint":127}},"postconditions":[{"assertion":"set(result) == set(test_list1) & set(test_list2)"}],"assumptions":[]},{"id":"pc_12","description":"Lists with mixed numeric types (int and float)","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[Union[int, float]]","test_list2":"list[Union[int, float]]"},"input_constraints":{"test_list1":{"min_len":5,"max_len":50,"unique":true,"is_mixed":true},"test_list2":{"min_len":5,"max_len":50,"unique":true,"is_mixed":true}},"postconditions":[{"assertion":"set(result) == set(test_list1) & set(test_list2)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Invalid type for list1 (int)","execution_statement":"try: result = similar_elements(test_list1, test_list2) except Exception as e: result = e","input_types":{"test_list1":"int","test_list2":"list[int]"},"input_constraints":{"test_list2":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Invalid type for list2 (float)","execution_statement":"try: result = similar_elements(test_list1, test_list2) except Exception as e: result = e","input_types":{"test_list1":"list[int]","test_list2":"float"},"input_constraints":{"test_list1":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: Unhashable type in list1 (list)","execution_statement":"try: result = similar_elements(test_list1, test_list2) except Exception as e: result = e","input_types":{"test_list1":"list[list[int]]","test_list2":"list[int]"},"input_constraints":{"test_list1":{"min_len":1,"max_len":5},"test_list2":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: Unhashable type in list2 (dict)","execution_statement":"try: result = similar_elements(test_list1, test_list2) except Exception as e: result = e","input_types":{"test_list1":"list[int]","test_list2":"list[dict]"},"input_constraints":{"test_list1":{"min_len":1,"max_len":10},"test_list2":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Lists with None values","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[Optional[int]]","test_list2":"list[Optional[int]]"},"input_constraints":{"test_list1":{"min_len":5,"max_len":50,"allow_none":true,"unique":true},"test_list2":{"min_len":5,"max_len":50,"allow_none":true,"unique":true}},"postconditions":[{"assertion":"set(result) == set(test_list1) & set(test_list2)"}],"assumptions":[]},{"id":"pc_18","description":"Lists with boolean values","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[bool]","test_list2":"list[bool]"},"input_constraints":{"test_list1":{"min_len":5,"max_len":50,"unique":true},"test_list2":{"min_len":5,"max_len":50,"unique":true}},"postconditions":[{"assertion":"set(result) == set(test_list1) & set(test_list2)"}],"assumptions":[]},{"id":"pc_19","description":"Lists with tuple elements","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[tuple[int]]","test_list2":"list[tuple[int]]"},"input_constraints":{"test_list1":{"min_len":5,"max_len":50,"unique":true},"test_list2":{"min_len":5,"max_len":50,"unique":true}},"postconditions":[{"assertion":"set(result) == set(test_list1) & set(test_list2)"}],"assumptions":[]},{"id":"pc_20","description":"Large lists with no overlap","execution_statement":"result = similar_elements(test_list1, test_list2)","input_types":{"test_list1":"list[int]","test_list2":"list[int]"},"input_constraints":{"test_list1":{"min_val":1,"max_val":10000,"min_len":5000,"max_len":10000,"unique":true},"test_list2":{"min_val":10001,"max_val":20000,"min_len":5000,"max_len":10000,"unique":true}},"postconditions":[{"assertion":"result == ()"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc611b"},"test_cases":[{"id":"pc_1","description":"Happy Path: Composite numbers","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":4,"max_val":1000}},"assumptions":["any(n % i == 0 for i in range(2, int(n**0.5) + 1))"],"postconditions":[{"assertion":"result == True"}]},{"id":"pc_2","description":"Happy Path: Prime numbers (should return False)","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1000}},"assumptions":["all(n % i != 0 for i in range(2, int(n**0.5) + 1))"],"postconditions":[{"assertion":"result == False"}]},{"id":"pc_3","description":"Edge Case: 0 (not prime)","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_4","description":"Edge Case: 1 (not prime)","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_5","description":"Edge Case: 2 (prime)","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_6","description":"Edge Case: 3 (prime)","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_7","description":"Edge Case: 4 (composite)","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":4,"max_val":4}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_8","description":"Negative Test: Float input","execution_statement":"try: result = is_not_prime(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: String input","execution_statement":"try: result = is_not_prime(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: null input","execution_statement":"try: result = is_not_prime(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Large composite number","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":100000}},"assumptions":["any(n % i == 0 for i in range(2, int(n**0.5) + 1))"],"postconditions":[{"assertion":"result == True"}]},{"id":"pc_12","description":"Large prime number","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10007,"max_val":100000}},"assumptions":["all(n % i != 0 for i in range(2, int(n**0.5) + 1))"],"postconditions":[{"assertion":"result == False"}]},{"id":"pc_13","description":"Negative number (not prime)","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_14","description":"Number with a small prime factor","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":6,"max_val":100}},"assumptions":["n % 2 == 0 or n % 3 == 0"],"postconditions":[{"assertion":"result == True"}]},{"id":"pc_15","description":"Number with a large prime factor","execution_statement":"result = is_not_prime(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100,"max_val":1000}},"assumptions":["any(n % i == 0 for i in range(int(n**0.5) + 1, n))"],"postconditions":[{"assertion":"result == True"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc611c"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list and n","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":5,"max_size":20,"elements":{"min_val":-100,"max_val":100}},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"all(isinstance(item, int) for item in result)"},{"assertion":"result == sorted(nums, reverse=True)[:n]"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: n equals list length","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":5,"max_size":10,"elements":{"min_val":-50,"max_val":50}},"n":{}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"result == sorted(nums, reverse=True)"}],"assumptions":["n == len(nums)"]},{"id":"pc_3","description":"Edge Case: List with all identical elements","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":5,"max_size":10},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"result == [nums[0]] * n"}],"assumptions":["len(set(nums)) == 1"]},{"id":"pc_4","description":"Edge Case: List with negative numbers","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":5,"max_size":15,"elements":{"min_val":-200,"max_val":-1}},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"result == sorted(nums, reverse=True)[:n]"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: List with mixed positive and negative numbers","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":5,"max_size":15,"elements":{"min_val":-100,"max_val":100},"is_mixed":true},"n":{"min_val":1,"max_val":5,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"result == sorted(nums, reverse=True)[:n]"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: List with zeros","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":5,"max_size":10,"elements":{"min_val":0,"max_val":0}},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"result == [0] * n"}],"assumptions":[]},{"id":"pc_7","description":"Large list, small n","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":100,"max_size":200,"elements":{"min_val":-1000,"max_val":1000}},"n":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"result == sorted(nums, reverse=True)[:n]"}],"assumptions":[]},{"id":"pc_8","description":"Small list, large n (n=list length)","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":1,"max_size":5,"elements":{"min_val":-100,"max_val":100}},"n":{}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"result == sorted(nums, reverse=True)"}],"assumptions":["n == len(nums)"]},{"id":"pc_9","description":"List with large integer values","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":5,"max_size":10,"elements":{"min_val":1000000,"max_val":2000000}},"n":{"min_val":1,"max_val":3}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"result == sorted(nums, reverse=True)[:n]"}],"assumptions":[]},{"id":"pc_10","description":"List with very small integer values","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":5,"max_size":10,"elements":{"min_val":-2000000,"max_val":-1000000}},"n":{"min_val":1,"max_val":3}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"result == sorted(nums, reverse=True)[:n]"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: n is zero (should be handled by precondition)","execution_statement":"try: result = heap_queue_largest(nums, n) except Exception as e: result = e","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":1,"max_size":5},"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: n is negative (should be handled by precondition)","execution_statement":"try: result = heap_queue_largest(nums, n) except Exception as e: result = e","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":1,"max_size":5},"n":{"min_val":-5,"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: nums is not a list (float)","execution_statement":"try: result = heap_queue_largest(nums, n) except Exception as e: result = e","input_types":{"nums":"float","n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: nums is not a list (None)","execution_statement":"try: result = heap_queue_largest(nums, n) except Exception as e: result = e","input_types":{"nums":"None","n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: nums contains non-integers (float)","execution_statement":"try: result = heap_queue_largest(nums, n) except Exception as e: result = e","input_types":{"nums":"list[Union[int, float]]","n":"int"},"input_constraints":{"nums":{"min_size":1,"max_size":5,"elements":{"is_mixed":true}},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: nums contains non-integers (string)","execution_statement":"try: result = heap_queue_largest(nums, n) except Exception as e: result = e","input_types":{"nums":"list[Union[int, str]]","n":"int"},"input_constraints":{"nums":{"min_size":1,"max_size":5,"elements":{"is_mixed":true,"max_codepoint":127},"max_codepoint":127},"n":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Test with n larger than list size (should be handled by precondition)","execution_statement":"try: result = heap_queue_largest(nums, n) except Exception as e: result = e","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":1,"max_size":5},"n":{"min_val":6,"max_val":10}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_18","description":"List with duplicate values, n smaller than list size","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":5,"max_size":10,"elements":{"min_val":1,"max_val":5}},"n":{"min_val":1,"max_val":3}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"result == sorted(nums, reverse=True)[:n]"}],"assumptions":[]},{"id":"pc_19","description":"List with duplicate values, n equal to list size","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":5,"max_size":10,"elements":{"min_val":1,"max_val":5}},"n":{}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"result == sorted(nums, reverse=True)"}],"assumptions":["n == len(nums)"]},{"id":"pc_20","description":"Single element list, n=1","execution_statement":"result = heap_queue_largest(nums, n)","input_types":{"nums":"list[int]","n":"int"},"input_constraints":{"nums":{"min_size":1,"max_size":1,"elements":{"min_val":-100,"max_val":100}},"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"len(result) == n"},{"assertion":"result == nums"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc611d"},"test_cases":[{"id":"pc_1","description":"Happy Path: Numbers differing by exactly one bit.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":1},"num2":{"min_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":["differ_At_One_Bit_Pos(num1, num2) == True"]},{"id":"pc_2","description":"Happy Path: Numbers not differing by exactly one bit.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":0},"num2":{"min_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":["differ_At_One_Bit_Pos(num1, num2) == False"]},{"id":"pc_3","description":"Edge Case: Identical numbers.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":0},"num2":{"min_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":["num1 == num2"]},{"id":"pc_4","description":"Edge Case: Zero and a power of two.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":0},"num2":{"min_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":["is_Power_Of_Two(num2)"]},{"id":"pc_5","description":"Edge Case: Zero and a non-power of two.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":0},"num2":{"min_val":1}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not is_Power_Of_Two(num2)"]},{"id":"pc_6","description":"Large numbers differing by one bit.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":1000000000},"num2":{"min_val":1000000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["differ_At_One_Bit_Pos(num1, num2) == True"]},{"id":"pc_7","description":"Large numbers not differing by one bit.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":1000000000},"num2":{"min_val":1000000000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["differ_At_One_Bit_Pos(num1, num2) == False"]},{"id":"pc_8","description":"Negative Test: Invalid type for num1 (string).","execution_statement":"try: result = differ_At_One_Bit_Pos(num1, num2) except Exception as e: result = e","input_types":{"num1":"str","num2":"int"},"input_constraints":{"num1":{"min_len":1,"max_codepoint":255},"num2":{"min_val":0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Invalid type for num2 (float).","execution_statement":"try: result = differ_At_One_Bit_Pos(num1, num2) except Exception as e: result = e","input_types":{"num1":"int","num2":"float"},"input_constraints":{"num1":{"min_val":0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Invalid type for both (None).","execution_statement":"try: result = differ_At_One_Bit_Pos(num1, num2) except Exception as e: result = e","input_types":{"num1":"None","num2":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Numbers differing by a single bit, one is zero.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":0},"num2":{"min_val":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":["(num1 == 0 and is_Power_Of_Two(num2)) or (num2 == 0 and is_Power_Of_Two(num1))"]},{"id":"pc_12","description":"Numbers differing by more than one bit, one is zero.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":0},"num2":{"min_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":["(num1 == 0 and not is_Power_Of_Two(num2) and num2 != 0) or (num2 == 0 and not is_Power_Of_Two(num1) and num1 != 0)"]},{"id":"pc_13","description":"Numbers differing by one bit, where one number is 1.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":0},"num2":{"min_val":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":["(num1 == 1 and is_Power_Of_Two(num2 ^ 1)) or (num2 == 1 and is_Power_Of_Two(num1 ^ 1))"]},{"id":"pc_14","description":"Numbers differing by one bit, where one number is a large power of two.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":0},"num2":{"min_val":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":["is_Power_Of_Two(num1) and is_Power_Of_Two(num1 ^ num2)"]},{"id":"pc_15","description":"Numbers differing by more than one bit, one is a large power of two.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":0},"num2":{"min_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":["is_Power_Of_Two(num1) and not is_Power_Of_Two(num1 ^ num2)"]},{"id":"pc_16","description":"Numbers differing by one bit, both are large.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":2147483648,"max_val":4294967295},"num2":{"min_val":2147483648,"max_val":4294967295}},"postconditions":[{"assertion":"result == True"}],"assumptions":["differ_At_One_Bit_Pos(num1, num2) == True"]},{"id":"pc_17","description":"Numbers differing by more than one bit, both are large.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_val":2147483648,"max_val":4294967295},"num2":{"min_val":2147483648,"max_val":4294967295}},"postconditions":[{"assertion":"result == False"}],"assumptions":["differ_At_One_Bit_Pos(num1, num2) == False"]},{"id":"pc_18","description":"Test with maximum integer value.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"max_val":9223372036854775807},"num2":{"max_val":9223372036854775807}},"postconditions":[{"assertion":"result == True"}],"assumptions":["differ_At_One_Bit_Pos(num1, num2) == True"]},{"id":"pc_19","description":"Test with maximum integer value and a value differing by one bit.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"max_val":9223372036854775807},"num2":{"max_val":9223372036854775807}},"postconditions":[{"assertion":"result == True"}],"assumptions":["differ_At_One_Bit_Pos(num1, num2) == True"]},{"id":"pc_20","description":"Test with maximum integer value and a value not differing by one bit.","execution_statement":"result = differ_At_One_Bit_Pos(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"max_val":9223372036854775807},"num2":{"max_val":9223372036854775807}},"postconditions":[{"assertion":"result == False"}],"assumptions":["differ_At_One_Bit_Pos(num1, num2) == False"]}]}
{"_id":{"$oid":"692adffe1b18223597bc611e"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical string with mixed word lengths.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":1,"max_len":100,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"result == [word for word in text.split() if len(word) >= 4]"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String with only short words.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^([a-zA-Z-9]{1,3}\\s)+[a-zA-Z-9]{1,3}$","max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: String with only long words.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-zA-Z-9]{4}$","max_codepoint":255}},"postconditions":[{"assertion":"result == text.split()"},{"assertion":"all(len(word) >= 4 for word in result)"}],"assumptions":[]},{"id":"pc_5","description":"String with punctuation and numbers.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,!?;:","min_len":1,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"result == [word.strip('.,!?;:') for word in text.split() if len(word.strip('.,!?;:')) >= 4]"}],"assumptions":[]},{"id":"pc_6","description":"String with repeated long words.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":12,"max_len":30,"max_codepoint":255}},"postconditions":[{"assertion":"result == [word for word in text.split() if len(word) >= 4]"}],"assumptions":["len(text.split()) > 1","all(len(w) >= 4 for w in text.split())"]},{"id":"pc_7","description":"String with Unicode characters.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 - -","min_len":1,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"}],"assumptions":[]},{"id":"pc_8","description":"String with only spaces.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"alphabet":" ","min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_9","description":"String with words separated by multiple spaces.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":10,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"},{"assertion":"result == [word for word in re.split(r'\\s+', text) if len(word) >= 4]"}],"assumptions":["text.count('  ') > 0"]},{"id":"pc_10","description":"String with words containing hyphens.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789- ","min_len":1,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"}],"assumptions":[]},{"id":"pc_11","description":"String with words containing apostrophes.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' ","min_len":1,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"}],"assumptions":[]},{"id":"pc_12","description":"String with very long words.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":50,"max_len":200,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"}],"assumptions":["len(text.split()) > 0","all(len(w) >= 4 for w in text.split())"]},{"id":"pc_13","description":"String with a mix of letters, numbers, and symbols.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+=-`~[]{}|;':,./<>?","min_len":1,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"}],"assumptions":[]},{"id":"pc_14","description":"String with words that are exactly 4 characters long.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^([a-zA-Z-9]{4}\\s)+[a-zA-Z-9]{4}$","max_codepoint":255}},"postconditions":[{"assertion":"result == text.split()"},{"assertion":"all(len(word) == 4 for word in result)"}],"assumptions":[]},{"id":"pc_15","description":"String with words that are just over 4 characters long.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^([a-zA-Z-9]{5}\\s)+[a-zA-Z-9]{5}$","max_codepoint":255}},"postconditions":[{"assertion":"result == text.split()"},{"assertion":"all(len(word) == 5 for word in result)"}],"assumptions":[]},{"id":"pc_16","description":"String with a mix of short and long words, including numbers.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ","min_len":1,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"}],"assumptions":["any(len(w) < 4 for w in text.split())","any(len(w) >= 4 for w in text.split())"]},{"id":"pc_17","description":"String with only numbers, some of which are 4+ digits.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"alphabet":"0123456789 ","min_len":1,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) >= 4 for word in result)"}],"assumptions":[]},{"id":"pc_18","description":"String with words that are exactly 3 characters long.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^([a-zA-Z-9]{3}\\s)+[a-zA-Z-9]{3}$","max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_19","description":"String with a single word of length 4.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-zA-Z-9]{4}$","max_codepoint":255}},"postconditions":[{"assertion":"result == [text]"}],"assumptions":[]},{"id":"pc_20","description":"String with a single word of length 5.","execution_statement":"result = find_char_long(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-zA-Z-9]{5}$","max_codepoint":255}},"postconditions":[{"assertion":"result == [text]"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc611f"},"test_cases":[{"id":"pc_1","description":"Happy Path: List of positive integers","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":10,"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == [x**2 for x in nums]"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: List of negative integers","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":10,"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"result == [x**2 for x in nums]"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: List with zeros","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":10,"min_val":-50,"max_val":50}},"postconditions":[{"assertion":"result == [x**2 for x in nums]"}],"assumptions":[]},{"id":"pc_4","description":"Happy Path: List with floats","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[float]"},"input_constraints":{"nums":{"min_len":1,"max_len":10,"min_val":-100.0,"max_val":100.0,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"result == [x**2 for x in nums]"}],"assumptions":[]},{"id":"pc_5","description":"Happy Path: Mixed integers and floats","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[Union[int, float]]"},"input_constraints":{"nums":{"min_len":1,"max_len":10,"min_val":-100,"max_val":100,"allow_nan":false,"allow_infinity":false,"is_mixed":true}},"postconditions":[{"assertion":"result == [x**2 for x in nums]"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Empty list","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: List with only zero","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1,"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == [0]"}],"assumptions":[]},{"id":"pc_8","description":"Edge Case: List with only one","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1,"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == [1]"}],"assumptions":[]},{"id":"pc_9","description":"Edge Case: List with only negative one","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1,"min_val":-1,"max_val":-1}},"postconditions":[{"assertion":"result == [1]"}],"assumptions":[]},{"id":"pc_10","description":"Large numbers: Integers","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":5,"min_val":1000000000,"max_val":1000000000000000000}},"postconditions":[{"assertion":"result == [x**2 for x in nums]"}],"assumptions":[]},{"id":"pc_11","description":"Large numbers: Floats","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[float]"},"input_constraints":{"nums":{"min_len":1,"max_len":5,"min_val":1E+15,"max_val":1E+30,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"result == [x**2 for x in nums]"}],"assumptions":[]},{"id":"pc_12","description":"Postcondition: All squared values are non-negative","execution_statement":"result = square_nums(nums)","input_types":{"nums":"list[Union[int, float]]"},"input_constraints":{"nums":{"min_len":1,"max_len":10,"min_val":-1000,"max_val":1000,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"all(x >= 0 for x in result)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = square_nums(nums) except Exception as e: result = e","input_types":{"nums":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Input is not a list (float)","execution_statement":"try: result = square_nums(nums) except Exception as e: result = e","input_types":{"nums":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = square_nums(nums) except Exception as e: result = e","input_types":{"nums":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: List contains non-numeric type (string)","execution_statement":"try: result = square_nums(nums) except Exception as e: result = e","input_types":{"nums":"list[str]"},"input_constraints":{"nums":{"min_len":1,"max_len":5,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Negative Test: List contains non-numeric type (None)","execution_statement":"try: result = square_nums(nums) except Exception as e: result = e","input_types":{"nums":"list[Union[int, float, None]]"},"input_constraints":{"nums":{"min_len":1,"max_len":5,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6120"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic rotation","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":2,"max_len":20,"pattern":"^(.)\\1*|^(.)(.)\\2*$","max_codepoint":255}},"postconditions":[{"assertion":"result != -1"},{"assertion":"result > 0"},{"assertion":"result <= len(s)"},{"assertion":"s[result:] + s[:result] == s"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == -1"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Single character string","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: String with all same characters","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":2,"max_len":20,"pattern":"^(.)\\1+$","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: String with no repeating pattern (should return -1)","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":2,"max_len":20,"pattern":"^(.)(.)(?<!\\1\\1)(?<!\\2\\2)(?<!\\1\\2)(?<!\\2\\1).+$","max_codepoint":255}},"postconditions":[{"assertion":"result == -1"}],"assumptions":[]},{"id":"pc_6","description":"Periodic string: 'ababab'","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"value":"ababab","max_codepoint":255}},"postconditions":[{"assertion":"result == 2"}],"assumptions":[]},{"id":"pc_7","description":"Periodic string: 'abcabcabc'","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"value":"abcabcabc","max_codepoint":255}},"postconditions":[{"assertion":"result == 3"}],"assumptions":[]},{"id":"pc_8","description":"Longer periodic string","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":10,"max_len":50,"pattern":"^(.)(.)(.)\\1\\2\\3$","max_codepoint":255}},"postconditions":[{"assertion":"result == 3"}],"assumptions":[]},{"id":"pc_9","description":"String with a repeating unit that is not the smallest","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":4,"max_len":20,"pattern":"^(.)(.)\\1\\2(.)(.)\\5\\6$","max_codepoint":255}},"postconditions":[{"assertion":"result == 2"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Non-string input (int)","execution_statement":"try: result = find_Rotations(s) except Exception as e: result = e","input_types":{"s":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-string input (float)","execution_statement":"try: result = find_Rotations(s) except Exception as e: result = e","input_types":{"s":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Non-string input (None)","execution_statement":"try: result = find_Rotations(s) except Exception as e: result = e","input_types":{"s":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Invariant: Rotation count is positive for non-empty strings","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result != -1"},{"assertion":"result > 0"}],"assumptions":["len(s) > 0"]},{"id":"pc_14","description":"Invariant: Rotation count is within string length","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result != -1"},{"assertion":"result <= len(s)"}],"assumptions":["len(s) > 0"]},{"id":"pc_15","description":"Invariant: Rotated string matches original if rotation found","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == -1 or (s[result:] + s[:result] == s)"}],"assumptions":["len(s) > 0"]},{"id":"pc_16","description":"Invariant: Smallest rotation found","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":2,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == -1 or all((s[j:] + s[:j] != s) for j in range(1, result))"}],"assumptions":["len(s) > 0"]},{"id":"pc_17","description":"Long string with a simple repeating pattern","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":100,"max_len":500,"pattern":"^(abc){10,100}$","max_codepoint":255}},"postconditions":[{"assertion":"result == 3"}],"assumptions":[]},{"id":"pc_18","description":"String with a very long repeating unit","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":50,"max_len":200,"pattern":"^(abcdefghijklmnopqrstuvwxyz){2,5}$","max_codepoint":255}},"postconditions":[{"assertion":"result == 26"}],"assumptions":[]},{"id":"pc_19","description":"String with a repeating pattern that is almost the full string length","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":10,"max_len":50,"pattern":"^(.)(.){1,4}\\1$","max_codepoint":255}},"postconditions":[{"assertion":"result == len(s) - 1 or result == -1"}],"assumptions":[]},{"id":"pc_20","description":"String with a complex repeating pattern","execution_statement":"result = find_Rotations(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_len":10,"max_len":50,"pattern":"^(abacaba){1,5}$","max_codepoint":255}},"postconditions":[{"assertion":"result == 7"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6121"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic removal","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":5,"max_len":20,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda s, ch, result: (lambda first_idx: (lambda last_idx: s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:] == result if first_idx != -1 and last_idx != -1 and first_idx != last_idx else (s.replace(ch, '', 1) if first_idx != -1 and last_idx == first_idx else s))(s.rfind(ch)))(s.find(ch))"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Character not present","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":5,"max_len":20,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == s"}],"assumptions":["ch not in s"]},{"id":"pc_3","description":"Edge Case: Character appears only once","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":5,"max_len":20,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == s.replace(ch, '', 1)"}],"assumptions":["s.count(ch) == 1"]},{"id":"pc_4","description":"Edge Case: String consists only of the character to remove (multiple occurrences)","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":2,"max_len":10,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":["all(c == ch for c in s)"]},{"id":"pc_5","description":"Edge Case: Empty string input","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"max_len":0,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: String with leading and trailing spaces, removing space","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":5,"max_len":20,"max_codepoint":255},"ch":{"const":" ","max_codepoint":255}},"postconditions":[{"assertion":"lambda s, ch, result: (lambda first_idx: (lambda last_idx: s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:] == result if first_idx != -1 and last_idx != -1 and first_idx != last_idx else (s.replace(ch, '', 1) if first_idx != -1 and last_idx == first_idx else s))(s.rfind(ch)))(s.find(ch))"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: String with special characters, removing a special character","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":5,"max_len":20,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"pattern":"[^a-zA-Z-9]","max_codepoint":255}},"postconditions":[{"assertion":"lambda s, ch, result: (lambda first_idx: (lambda last_idx: s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:] == result if first_idx != -1 and last_idx != -1 and first_idx != last_idx else (s.replace(ch, '', 1) if first_idx != -1 and last_idx == first_idx else s))(s.rfind(ch)))(s.find(ch))"}],"assumptions":[]},{"id":"pc_8","description":"Edge Case: String with only one character, which is the one to remove","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":1,"max_len":1,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":["s == ch"]},{"id":"pc_9","description":"Edge Case: Character to remove is at the beginning and end","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":2,"max_len":20,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda s, ch, result: s[1:-1] == result"}],"assumptions":["s.startswith(ch) and s.endswith(ch) and s.count(ch) > 1"]},{"id":"pc_10","description":"Edge Case: Character to remove is at the beginning, but not at the end","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":2,"max_len":20,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda s, ch, result: (lambda first_idx: (lambda last_idx: s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:] == result if first_idx != -1 and last_idx != -1 and first_idx != last_idx else (s.replace(ch, '', 1) if first_idx != -1 and last_idx == first_idx else s))(s.rfind(ch)))(s.find(ch))"}],"assumptions":["s.startswith(ch) and not s.endswith(ch) and s.count(ch) >= 1"]},{"id":"pc_11","description":"Edge Case: Character to remove is at the end, but not at the beginning","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":2,"max_len":20,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda s, ch, result: (lambda first_idx: (lambda last_idx: s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:] == result if first_idx != -1 and last_idx != -1 and first_idx != last_idx else (s.replace(ch, '', 1) if first_idx != -1 and last_idx == first_idx else s))(s.rfind(ch)))(s.find(ch))"}],"assumptions":["not s.startswith(ch) and s.endswith(ch) and s.count(ch) >= 1"]},{"id":"pc_12","description":"Mixed characters, removing a character that appears multiple times in the middle","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":5,"max_len":20,"is_mixed":true,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"lambda s, ch, result: (lambda first_idx: (lambda last_idx: s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:] == result if first_idx != -1 and last_idx != -1 and first_idx != last_idx else (s.replace(ch, '', 1) if first_idx != -1 and last_idx == first_idx else s))(s.rfind(ch)))(s.find(ch))"}],"assumptions":["s.count(ch) > 1 and s.find(ch) != 0 and s.rfind(ch) != len(s) - 1"]},{"id":"pc_13","description":"String with unicode characters, removing a unicode character","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":5,"max_len":20,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda s, ch, result: (lambda first_idx: (lambda last_idx: s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:] == result if first_idx != -1 and last_idx != -1 and first_idx != last_idx else (s.replace(ch, '', 1) if first_idx != -1 and last_idx == first_idx else s))(s.rfind(ch)))(s.find(ch))"}],"assumptions":["ch in s"]},{"id":"pc_14","description":"Negative Test: Invalid type for string input (int)","execution_statement":"try: result = remove_Occ(s, ch) except Exception as e: result = e","input_types":{"s":"int","ch":"str"},"input_constraints":{"ch":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: Invalid type for character input (float)","execution_statement":"try: result = remove_Occ(s, ch) except Exception as e: result = e","input_types":{"s":"str","ch":"float"},"input_constraints":{"s":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: Invalid type for character input (None)","execution_statement":"try: result = remove_Occ(s, ch) except Exception as e: result = e","input_types":{"s":"str","ch":"None"},"input_constraints":{"s":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Edge Case: Character to remove is the same as the first and last character, but only one occurrence","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":0,"max_len":5,"max_codepoint":255},"ch":{"min_len":0,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == s.replace(ch, '', 1)"}],"assumptions":["s.startswith(ch) and s.endswith(ch) and s.count(ch) == 1"]},{"id":"pc_18","description":"Long string with character at beginning, middle, and end","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":50,"max_len":100,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda s, ch, result: (lambda first_idx: (lambda last_idx: s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:] == result if first_idx != -1 and last_idx != -1 and first_idx != last_idx else (s.replace(ch, '', 1) if first_idx != -1 and last_idx == first_idx else s))(s.rfind(ch)))(s.find(ch))"}],"assumptions":["s.startswith(ch) and s.endswith(ch) and s.count(ch) > 2"]},{"id":"pc_19","description":"String with repeated characters, removing one of them","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":0,"max_len":2,"max_codepoint":255},"ch":{"min_len":0,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == s.replace(ch, '', 1)"}],"assumptions":["s.count(ch) > 1 and s.find(ch) == s.rfind(ch)"]},{"id":"pc_20","description":"String with only two occurrences of the character to remove","execution_statement":"result = remove_Occ(s, ch)","input_types":{"s":"str","ch":"str"},"input_constraints":{"s":{"min_len":2,"max_len":20,"max_codepoint":255},"ch":{"min_len":1,"max_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"lambda s, ch, result: (lambda first_idx: (lambda last_idx: s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:] == result if first_idx != -1 and last_idx != -1 and first_idx != last_idx else (s.replace(ch, '', 1) if first_idx != -1 and last_idx == first_idx else s))(s.rfind(ch)))(s.find(ch))"}],"assumptions":["s.count(ch) == 2"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6122"},"test_cases":[{"id":"pc_1","description":"Happy Path: Standard matrix sorting","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":10,"inner_list_constraints":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100}}}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_2","description":"Edge Case: Empty matrix","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":0,"max_len":0}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == []"}]},{"id":"pc_3","description":"Edge Case: Matrix with a single row","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":1,"inner_list_constraints":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100}}}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == M"}]},{"id":"pc_4","description":"Edge Case: Matrix with empty rows","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":1,"max_len":5,"inner_list_constraints":{"min_len":0,"max_len":5,"elements":{"min_val":-100,"max_val":100}}}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_5","description":"Handles matrix with negative numbers","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"inner_list_constraints":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":-1}}}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_6","description":"Handles matrix with zeros","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"inner_list_constraints":{"min_len":1,"max_len":10,"elements":{"min_val":0,"max_val":0}}}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_7","description":"Handles matrix with mixed positive and negative numbers","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"inner_list_constraints":{"min_len":1,"max_len":10,"elements":{"min_val":-50,"max_val":50}},"is_mixed":true}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_8","description":"Handles matrix with large numbers","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":5,"inner_list_constraints":{"min_len":2,"max_len":5,"elements":{"min_val":10000,"max_val":100000}}}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_9","description":"Handles matrix with floating point numbers","input_types":{"M":"list[list[float]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"inner_list_constraints":{"min_len":1,"max_len":10,"elements":{"min_val":-100.5,"max_val":100.5}}}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_10","description":"Handles matrix with mixed int and float numbers","input_types":{"M":"list[list[Union[int, float]]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"inner_list_constraints":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100}},"is_mixed":true}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_11","description":"Negative Test: Input is not a list","input_types":{"M":"int"},"input_constraints":{},"execution_statement":"try: result = sort_matrix(M) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: Input is a list but contains non-list elements","input_types":{"M":"list[Union[list[int], int]]"},"input_constraints":{"M":{"min_len":2,"max_len":5,"elements":{"min_val":1,"max_val":10}}},"execution_statement":"try: result = sort_matrix(M) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Negative Test: Matrix contains non-numeric types in rows","input_types":{"M":"list[list[Union[int, str]]]"},"input_constraints":{"M":{"min_len":2,"max_len":5,"inner_list_constraints":{"min_len":1,"max_len":5}}},"execution_statement":"try: result = sort_matrix(M) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Test with rows having equal sums","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"inner_list_constraints":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":5}}}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_15","description":"Test with rows having sums that are close","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"inner_list_constraints":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":10}}}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_16","description":"Test with a matrix where rows are already sorted","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"inner_list_constraints":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100},"sorted":"ascending"}}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_17","description":"Test with a matrix where rows are reverse sorted","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"inner_list_constraints":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100},"sorted":"descending"}}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_18","description":"Test with a matrix containing only one element per row","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"inner_list_constraints":{"min_len":1,"max_len":1,"elements":{"min_val":-100,"max_val":100}}}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_19","description":"Test with a matrix containing duplicate rows","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"inner_list_constraints":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":10}},"unique":false}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]},{"id":"pc_20","description":"Test with a matrix containing rows with identical sums but different elements","input_types":{"M":"list[list[int]]"},"input_constraints":{"M":{"min_len":2,"max_len":10,"inner_list_constraints":{"min_len":2,"max_len":5,"elements":{"min_val":1,"max_val":10}}}},"execution_statement":"result = sort_matrix(M)","postconditions":[{"assertion":"result == sorted(M, key=sum)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6123"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive integers for all dimensions.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":1},"b":{"min_val":1},"h":{"min_val":1}},"postconditions":[{"assertion":"result == (l * b * h) / 2"},{"assertion":"isinstance(result, float)"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Positive floats for all dimensions.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"float","h":"float"},"input_constraints":{"l":{"min_val":0.1,"allow_nan":false,"allow_infinity":false},"b":{"min_val":0.1,"allow_nan":false,"allow_infinity":false},"h":{"min_val":0.1,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"result == (l * b * h) / 2"},{"assertion":"isinstance(result, float)"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: Mixed positive integers and floats.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"Union[int, float]","b":"Union[int, float]","h":"Union[int, float]"},"input_constraints":{"l":{"min_val":0.1,"allow_nan":false,"allow_infinity":false,"is_mixed":true},"b":{"min_val":0.1,"allow_nan":false,"allow_infinity":false,"is_mixed":true},"h":{"min_val":0.1,"allow_nan":false,"allow_infinity":false,"is_mixed":true}},"postconditions":[{"assertion":"result == (l * b * h) / 2"},{"assertion":"isinstance(result, float)"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Large positive integer values.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":1000000000},"b":{"min_val":1000000000},"h":{"min_val":1000000000}},"postconditions":[{"assertion":"result == (l * b * h) / 2"},{"assertion":"isinstance(result, float)"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Small positive float values.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"float","b":"float","h":"float"},"input_constraints":{"l":{"min_val":1E-09,"max_val":1.0,"allow_nan":false,"allow_infinity":false},"b":{"min_val":1E-09,"max_val":1.0,"allow_nan":false,"allow_infinity":false},"h":{"min_val":1E-09,"max_val":1.0,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"result == (l * b * h) / 2"},{"assertion":"isinstance(result, float)"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: Invalid type for 'l' (string).","execution_statement":"try: result = find_Volume(l, b, h) except Exception as e: result = e","input_types":{"l":"str","b":"int","h":"int"},"input_constraints":{"l":{"min_len":1,"max_codepoint":255},"b":{"min_val":1},"h":{"min_val":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Invalid type for 'b' (None).","execution_statement":"try: result = find_Volume(l, b, h) except Exception as e: result = e","input_types":{"l":"int","b":"NoneType","h":"int"},"input_constraints":{"l":{"min_val":1},"h":{"min_val":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Invalid type for 'h' (float).","execution_statement":"try: result = find_Volume(l, b, h) except Exception as e: result = e","input_types":{"l":"int","b":"int","h":"float"},"input_constraints":{"l":{"min_val":1},"b":{"min_val":1},"h":{"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Test with zero values (should result in zero volume).","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"max_val":0},"b":{"max_val":0},"h":{"max_val":0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_10","description":"Test with one dimension as zero.","execution_statement":"result = find_Volume(l, b, h)","input_types":{"l":"int","b":"int","h":"int"},"input_constraints":{"l":{"min_val":1},"b":{"min_val":1},"h":{"max_val":0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6124"},"test_cases":[{"id":"pc_1","description":"Happy Path: Valid lowercase underscore separated string","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+_[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Multiple lowercase underscore separated sequences","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^([a-z]+_[a-z]+)+$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_3","description":"Negative Test: Empty string","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"Negative Test: String with no underscores","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"Negative Test: String with only underscores","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^_+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: String with uppercase letters and underscores","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[A-Z_]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: String with numbers and underscores","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[-9_]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: String with mixed case and underscores","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-zA-Z-9_]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Underscore at the beginning","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^_[a-z]+_[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Underscore at the end","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+_[a-z]+_$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Consecutive underscores","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+__+[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Single lowercase letter","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: String with special characters and underscores","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[!@#$%^&*()_+=-`~ ]+_[!@#$%^&*()_+=-`~ ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: String with lowercase letters and other symbols but no valid underscore sequence","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z!@#]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: String with a single lowercase letter and an underscore","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]_$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: String with an underscore and a single lowercase letter","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^_[a-z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_17","description":"Negative Test: String with only one lowercase letter and an underscore at the end","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]_$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_18","description":"Negative Test: String with only one lowercase letter and an underscore at the beginning","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^_[a-z]$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_19","description":"Negative Test: String with mixed characters and a single underscore","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-zA-Z-9_]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_20","description":"Negative Test: String with only lowercase letters and a single underscore in the middle","execution_statement":"result = text_lowercase_underscore(text)","input_types":{"text":"str"},"input_constraints":{"text":{"pattern":"^[a-z]+_[a-z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6125"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive float side length","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"float"},"input_constraints":{"side_length":{"min_value":0.0,"allow_infinity":false,"allow_nan":false}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result == 4 * side_length"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Positive integer side length","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"int"},"input_constraints":{"side_length":{"min_value":0}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result == 4 * side_length"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Zero side length","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"float"},"input_constraints":{"side_length":{"min_value":0.0,"max_value":0.0,"allow_infinity":false,"allow_nan":false}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Property: Perimeter scales linearly with side length","execution_statement":"result = square_perimeter(side_length * 2)","input_types":{"side_length":"float"},"input_constraints":{"side_length":{"min_value":0.0,"allow_infinity":false,"allow_nan":false}},"postconditions":[{"assertion":"result == 2 * square_perimeter(side_length)"}],"assumptions":["square_perimeter(side_length * 2) == 2 * square_perimeter(side_length)"]},{"id":"pc_5","description":"Negative Test: Negative side length (expecting ValueError)","execution_statement":"try: result = square_perimeter(side_length) except Exception as e: result = e","input_types":{"side_length":"float"},"input_constraints":{"side_length":{"max_value":-1E-06,"allow_infinity":false,"allow_nan":false}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: Non-numeric type (string)","execution_statement":"try: result = square_perimeter(side_length) except Exception as e: result = e","input_types":{"side_length":"str"},"input_constraints":{"side_length":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Non-numeric type (None)","execution_statement":"try: result = square_perimeter(side_length) except Exception as e: result = e","input_types":{"side_length":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Large positive float side length","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"float"},"input_constraints":{"side_length":{"min_value":1E+10,"allow_infinity":false,"allow_nan":false}},"postconditions":[{"assertion":"result == 4 * side_length"}],"assumptions":[]},{"id":"pc_9","description":"Large positive integer side length","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"int"},"input_constraints":{"side_length":{"min_value":1000000000}},"postconditions":[{"assertion":"result == 4 * side_length"}],"assumptions":[]},{"id":"pc_10","description":"Very small positive float side length","execution_statement":"result = square_perimeter(side_length)","input_types":{"side_length":"float"},"input_constraints":{"side_length":{"max_value":1E-10,"min_value":0.0,"allow_infinity":false,"allow_nan":false}},"postconditions":[{"assertion":"result == 4 * side_length"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6126"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic removal","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"max_codepoint":255},"second_string":{"min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) <= len(string)"},{"assertion":"all(char not in second_string for char in result)"},{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty first string","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":0,"max_len":0,"max_codepoint":255},"second_string":{"min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Empty second string","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"max_codepoint":255},"second_string":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == string"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Both strings empty","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":0,"max_len":0,"max_codepoint":255},"second_string":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":[]},{"id":"pc_5","description":"All characters in first string are in second string","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"max_codepoint":255},"second_string":{"min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":["set(string).issubset(set(second_string))"]},{"id":"pc_6","description":"No characters in first string are in second string","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"max_codepoint":255},"second_string":{"min_len":1,"max_len":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == string"}],"assumptions":["set(string).isdisjoint(set(second_string))"]},{"id":"pc_7","description":"First string with repeated characters, second string removes some","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":100,"alphabet":"abcde","max_codepoint":255},"second_string":{"min_len":1,"max_len":5,"alphabet":"ace","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":[]},{"id":"pc_8","description":"Second string with repeated characters","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":50,"max_codepoint":255},"second_string":{"min_len":5,"max_len":20,"alphabet":"xyz","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":[]},{"id":"pc_9","description":"Strings with special characters","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":50,"alphabet":"!@#$%^&*()_+=-`~[]{}|;':\",./<>?","max_codepoint":255},"second_string":{"min_len":1,"max_len":10,"alphabet":"@#$%^","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":[]},{"id":"pc_10","description":"Long strings","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":100,"max_len":500,"max_codepoint":255},"second_string":{"min_len":10,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":[]},{"id":"pc_11","description":"Unicode characters","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":50,"alphabet":"abc123","max_codepoint":255},"second_string":{"min_len":1,"max_len":10,"alphabet":"","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":[]},{"id":"pc_12","description":"Case sensitivity check","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":50,"alphabet":"aAbBcC","max_codepoint":255},"second_string":{"min_len":1,"max_len":10,"alphabet":"aBc","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":[]},{"id":"pc_13","description":"String with spaces","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":50,"alphabet":"a b c d e","max_codepoint":255},"second_string":{"min_len":1,"max_len":5,"alphabet":"a c","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":[]},{"id":"pc_14","description":"String with numbers","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":50,"alphabet":"1234567890","max_codepoint":255},"second_string":{"min_len":1,"max_len":5,"alphabet":"13579","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":[]},{"id":"pc_15","description":"String with mixed alphanumeric and special characters","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":50,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()","is_mixed":true,"max_codepoint":255},"second_string":{"min_len":1,"max_len":10,"alphabet":"aBcDeFgHiJkLmNoPqRsTuVwXyZ02468!@#$%","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":[]},{"id":"pc_16","description":"First string is a subset of second string characters","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":20,"alphabet":"abc","max_codepoint":255},"second_string":{"min_len":5,"max_len":50,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":["set(string).issubset(set(second_string))"]},{"id":"pc_17","description":"Second string is a subset of first string characters","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":5,"max_len":50,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255},"second_string":{"min_len":1,"max_len":20,"alphabet":"abc","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":["set(second_string).issubset(set(string))"]},{"id":"pc_18","description":"Test with control characters (if allowed by st.text)","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":50,"max_codepoint":255},"second_string":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":[]},{"id":"pc_19","description":"Test with very long strings","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":1000,"max_len":2000,"max_codepoint":255},"second_string":{"min_len":100,"max_len":200,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":[]},{"id":"pc_20","description":"Test with characters that might be problematic for ord() if not standard ASCII/Unicode","execution_statement":"result = remove_dirty_chars(string, second_string)","input_types":{"string":"str","second_string":"str"},"input_constraints":{"string":{"min_len":10,"max_len":50,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789","max_codepoint":255},"second_string":{"min_len":1,"max_len":10,"alphabet":"aeiou","max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join([c for c in string if c not in second_string])"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6127"},"test_cases":[{"id":"pc_1","description":"Happy Path: List with duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":2,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: List without duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":1,"unique":true}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Empty list","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Single element list","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"List with duplicates at the beginning","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":2,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["arraynums[0] == arraynums[1]"]},{"id":"pc_6","description":"List with duplicates at the end","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":2,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["arraynums[-1] == arraynums[-2]"]},{"id":"pc_7","description":"List with duplicates in the middle","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":3,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["arraynums[1] == arraynums[2]"]},{"id":"pc_8","description":"List with all duplicate elements","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":2,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(set(arraynums)) == 1"]},{"id":"pc_9","description":"List with negative numbers and duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-1000,"max_val":-1,"min_len":2,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_10","description":"List with zeros and duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":0,"max_val":0,"min_len":2,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_11","description":"List with large positive numbers and duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":1000000,"max_val":2000000,"min_len":2,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_12","description":"List with large negative numbers and duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-2000000,"max_val":-1000000,"min_len":2,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_13","description":"List with mixed positive and negative numbers, no duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-1000,"max_val":1000,"min_len":5,"unique":true,"is_mixed":true}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"List with mixed positive and negative numbers, with duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_val":-1000,"max_val":1000,"min_len":2,"unique":false,"is_mixed":true}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = test_duplicate(arraynums) except Exception as e: result = e","input_types":{"arraynums":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: Input is not a list (float)","execution_statement":"try: result = test_duplicate(arraynums) except Exception as e: result = e","input_types":{"arraynums":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = test_duplicate(arraynums) except Exception as e: result = e","input_types":{"arraynums":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_18","description":"List with many elements, no duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":100,"max_len":500,"unique":true}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_19","description":"List with many elements, with duplicates","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":100,"max_len":500,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_20","description":"List with duplicates of zero","execution_statement":"result = test_duplicate(arraynums)","input_types":{"arraynums":"list[int]"},"input_constraints":{"arraynums":{"min_len":2,"unique":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["0 in arraynums and arraynums.count(0) > 1"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6128"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical positive integers","input_types":{"x":"int"},"input_constraints":{"x":{"min_value":0,"max_value":1000000}},"execution_statement":"result = is_woodall(x)","postconditions":[{"assertion":"isinstance(result, bool)"}]},{"id":"pc_2","description":"Edge Case: Zero","input_types":{"x":"int"},"input_constraints":{"x":{"min_value":0,"max_value":0}},"execution_statement":"result = is_woodall(x)","postconditions":[{"assertion":"result == False"}]},{"id":"pc_3","description":"Edge Case: One","input_types":{"x":"int"},"input_constraints":{"x":{"min_value":1,"max_value":1}},"execution_statement":"result = is_woodall(x)","postconditions":[{"assertion":"result == True"}]},{"id":"pc_4","description":"Edge Case: Small even number","input_types":{"x":"int"},"input_constraints":{"x":{"min_value":2,"max_value":10,"step":2}},"execution_statement":"result = is_woodall(x)","postconditions":[{"assertion":"result == False"}]},{"id":"pc_5","description":"Edge Case: Small odd number (not 1)","input_types":{"x":"int"},"input_constraints":{"x":{"min_value":3,"max_value":11,"step":2}},"execution_statement":"result = is_woodall(x)","postconditions":[{"assertion":"result == False"}]},{"id":"pc_6","description":"Numbers where x+1 is a power of 2","input_types":{"x":"int"},"input_constraints":{"x":{"min_value":1,"max_value":1000}},"assumptions":["(x + 1) & x == 0"],"execution_statement":"result = is_woodall(x)","postconditions":[{"assertion":"result == True"}]},{"id":"pc_7","description":"Numbers where x+1 is not a power of 2","input_types":{"x":"int"},"input_constraints":{"x":{"min_value":0,"max_value":1000}},"assumptions":["(x + 1) & x != 0"],"execution_statement":"result = is_woodall(x)","postconditions":[{"assertion":"result == False"}]},{"id":"pc_8","description":"Negative Test: Float input","input_types":{"x":"float"},"input_constraints":{},"execution_statement":"try: result = is_woodall(x) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: String input","input_types":{"x":"str"},"input_constraints":{"x":{"min_len":1,"max_codepoint":255}},"execution_statement":"try: result = is_woodall(x) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: null input","input_types":{"x":"NoneType"},"input_constraints":{},"execution_statement":"try: result = is_woodall(x) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Large number test","input_types":{"x":"int"},"input_constraints":{"x":{"min_value":1000001,"max_value":10000000}},"execution_statement":"result = is_woodall(x)","postconditions":[{"assertion":"isinstance(result, bool)"}]},{"id":"pc_12","description":"Numbers that result in p == x after increment","input_types":{"x":"int"},"input_constraints":{"x":{"min_value":1,"max_value":100}},"assumptions":["x > 1 and (x + 1) % 2 == 0 and (x + 1) // 2 == (x + 1)"],"execution_statement":"result = is_woodall(x)","postconditions":[{"assertion":"result == True"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6129"},"test_cases":[{"id":"pc_1","description":"Happy Path: Numbers satisfying the condition","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":100000}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Numbers not satisfying the condition","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":100000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not (2 * rev(n) == n + 1)"]},{"id":"pc_3","description":"Edge Case: Single digit numbers (-9)","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":9}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Number 1 (should satisfy)","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Numbers with trailing zeros (e.g., 10, 120)","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":10000,"pattern":"^[-8]0+$"}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Palindromic numbers","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":10000}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":["str(n) == str(n)[::-1]"]},{"id":"pc_7","description":"Large numbers","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":100000,"max_val":10000000}},"postconditions":[{"assertion":"result == (2 * rev(n) == n + 1)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Invalid Type (float)","execution_statement":"try: result = check(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Invalid Type (string)","execution_statement":"try: result = check(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Invalid Type (None)","execution_statement":"try: result = check(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Invalid Type (list)","execution_statement":"try: result = check(n) except Exception as e: result = e","input_types":{"n":"list"},"input_constraints":{"n":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Test case for number 73 (known to satisfy)","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":73,"max_val":73}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_13","description":"Test case for number 21 (does not satisfy)","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":21,"max_val":21}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"Test case for number 10 (does not satisfy)","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":10}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_15","description":"Test case for number 0 (does not satisfy)","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_16","description":"Test case for negative numbers (should return False)","execution_statement":"result = check(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-100000,"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc612a"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic list of digits","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":2,"max_len":5}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == int(''.join(sorted([str(x) for x in arr], reverse=True)))"}]},{"id":"pc_2","description":"Edge Case: List with all zeros","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":0,"min_len":1,"max_len":5}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_3","description":"Edge Case: List with single digit","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":1,"max_len":1}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == arr[0]"}]},{"id":"pc_4","description":"Happy Path: List with duplicate digits","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":3,"max_len":7,"unique":false}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == int(''.join(sorted([str(x) for x in arr], reverse=True)))"}]},{"id":"pc_5","description":"Happy Path: Larger non-digit numbers (treated as strings)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":10,"max_val":99,"min_len":2,"max_len":5}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == int(''.join(sorted([str(x) for x in arr], key=lambda s1, s2: -1 if s1 + s2 > s2 + s1 else (1 if s1 + s2 < s2 + s1 else 0))))"}]},{"id":"pc_6","description":"Edge Case: Empty list","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":0,"max_len":0}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_7","description":"Happy Path: Mixed single and double digits","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":99,"min_len":3,"max_len":6,"is_mixed":true}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == int(''.join(sorted([str(x) for x in arr], key=lambda s1, s2: -1 if s1 + s2 > s2 + s1 else (1 if s1 + s2 < s2 + s1 else 0))))"}]},{"id":"pc_8","description":"Negative Test: Input is not a list (int)","input_types":{"arr":"int"},"input_constraints":{},"execution_statement":"try: result = find_Max_Num(arr) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: Input is not a list (None)","input_types":{"arr":"None"},"input_constraints":{},"execution_statement":"try: result = find_Max_Num(arr) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: List contains negative numbers","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":-10,"max_val":9,"min_len":2,"max_len":5}},"execution_statement":"try: result = find_Max_Num(arr) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, ValueError)"}]},{"id":"pc_11","description":"Happy Path: List with large numbers","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":100,"max_val":999,"min_len":2,"max_len":4}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == int(''.join(sorted([str(x) for x in arr], key=lambda s1, s2: -1 if s1 + s2 > s2 + s1 else (1 if s1 + s2 < s2 + s1 else 0))))"}]},{"id":"pc_12","description":"Happy Path: List with numbers that require custom sorting","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"values":[3,30,34,5,9]}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == 9534330"}]},{"id":"pc_13","description":"Happy Path: Another custom sorting case","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"values":[1,34,3,98,9,76,45,4]}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == 998764543431"}]},{"id":"pc_14","description":"Negative Test: List contains non-integer types (float)","input_types":{"arr":"list[Union[int, float]]"},"input_constraints":{"arr":{"min_len":2,"max_len":5,"is_mixed":true}},"execution_statement":"try: result = find_Max_Num(arr) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_15","description":"Negative Test: List contains non-integer types (string)","input_types":{"arr":"list[Union[int, str]]"},"input_constraints":{"arr":{"min_len":2,"max_len":5,"is_mixed":true}},"execution_statement":"try: result = find_Max_Num(arr) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_16","description":"Happy Path: List with large number of digits","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":0,"max_val":9,"min_len":10,"max_len":20}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == int(''.join(sorted([str(x) for x in arr], reverse=True)))"}]},{"id":"pc_17","description":"Happy Path: List with numbers that are powers of 10","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"values":[10,100,1,1000]}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == 100010010"}]},{"id":"pc_18","description":"Happy Path: List with numbers that are close in string representation","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":1,"max_val":100,"min_len":4,"max_len":8}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == int(''.join(sorted([str(x) for x in arr], key=lambda s1, s2: -1 if s1 + s2 > s2 + s1 else (1 if s1 + s2 < s2 + s1 else 0))))"}]},{"id":"pc_19","description":"Negative Test: Input is not a list (tuple)","input_types":{"arr":"tuple[int]"},"input_constraints":{"arr":{"min_len":1,"max_len":5}},"execution_statement":"try: result = find_Max_Num(arr) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_20","description":"Happy Path: List with only large numbers","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_val":1000,"max_val":9999,"min_len":2,"max_len":4}},"execution_statement":"result = find_Max_Num(arr)","postconditions":[{"assertion":"result == int(''.join(sorted([str(x) for x in arr], key=lambda s1, s2: -1 if s1 + s2 > s2 + s1 else (1 if s1 + s2 < s2 + s1 else 0))))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc612b"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive and Negative Integers","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1},"b":{"max_val":-1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Negative and Positive Integers","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"max_val":-1},"b":{"min_val":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_3","description":"Negative Test: Two Positive Integers","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1},"b":{"min_val":1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"Negative Test: Two Negative Integers","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"max_val":-1},"b":{"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Zero and Positive Integer","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0},"b":{"min_val":1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Positive Integer and Zero","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1},"b":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: Zero and Negative Integer","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0},"b":{"max_val":-1}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_8","description":"Edge Case: Negative Integer and Zero","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"max_val":-1},"b":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_9","description":"Edge Case: Two Zeros","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":0,"max_val":0},"b":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"Large Positive and Negative Integers","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1000000000},"b":{"max_val":-1000000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_11","description":"Large Negative and Positive Integers","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"max_val":-1000000000},"b":{"min_val":1000000000}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_12","description":"Large Positive and Positive Integers","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1000000000},"b":{"min_val":1000000000}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_13","description":"Large Negative and Negative Integers","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"max_val":-1000000000},"b":{"max_val":-1000000000}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Integer and String","execution_statement":"try: result = opposite_Signs(a, b) except Exception as e: result = e","input_types":{"a":"int","b":"str"},"input_constraints":{"b":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: String and Integer","execution_statement":"try: result = opposite_Signs(a, b) except Exception as e: result = e","input_types":{"a":"str","b":"int"},"input_constraints":{"a":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: Integer and Float","execution_statement":"try: result = opposite_Signs(a, b) except Exception as e: result = e","input_types":{"a":"int","b":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Negative Test: Float and Integer","execution_statement":"try: result = opposite_Signs(a, b) except Exception as e: result = e","input_types":{"a":"float","b":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_18","description":"Negative Test: Integer and None","execution_statement":"try: result = opposite_Signs(a, b) except Exception as e: result = e","input_types":{"a":"int","b":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_19","description":"Negative Test: null and Integer","execution_statement":"try: result = opposite_Signs(a, b) except Exception as e: result = e","input_types":{"a":"NoneType","b":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_20","description":"Max Integer and Min Integer","execution_statement":"result = opposite_Signs(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":9223372036854775807},"b":{"max_val":9223372036854775807}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc612c"},"test_cases":[{"id":"pc_1","description":"Happy Path: Valid positive integer input","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":100000}},"postconditions":[{"assertion":"result == 3 * n * n - 2 * n"}],"assumptions":[]},{"id":"pc_2","description":"Boundary Test: Smallest valid input (n=1)","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Test: Largest valid input","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":100000,"max_value":100000}},"postconditions":[{"assertion":"result == 29999800000"}],"assumptions":[]},{"id":"pc_4","description":"Typical Case: n=2","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":2,"max_value":2}},"postconditions":[{"assertion":"result == 10"}],"assumptions":[]},{"id":"pc_5","description":"Typical Case: n=5","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":5,"max_value":5}},"postconditions":[{"assertion":"result == 65"}],"assumptions":[]},{"id":"pc_6","description":"Typical Case: n=10","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":10,"max_value":10}},"postconditions":[{"assertion":"result == 290"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Input is a float","execution_statement":"try: result = is_octagonal(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{"n":{"min_value":1.0,"max_value":100000.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Input is a string","execution_statement":"try: result = is_octagonal(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Input is None","execution_statement":"try: result = is_octagonal(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Input is a list","execution_statement":"try: result = is_octagonal(n) except Exception as e: result = e","input_types":{"n":"list"},"input_constraints":{"n":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Invariant Test: Result is always non-negative for n >= 1","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":100000}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_12","description":"Invariant Test: Result is always an integer","execution_statement":"result = is_octagonal(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":100000}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc612d"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical string with digits and non-digits","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":50,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":0,"max_size":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String with no digits","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"alphabet":"abcdefghijklmnopqrstuvwxyz","min_size":1,"max_size":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: String with only digits","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"alphabet":"0123456789","min_size":1,"max_size":50,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: String with '1' characters","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"alphabet":"1","min_size":1,"max_size":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == len(s)"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: String with '0' characters","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"alphabet":"0","min_size":1,"max_size":50,"max_codepoint":255}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_7","description":"Specific pattern: '123'","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"just":"123","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_8","description":"Specific pattern: '111'","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"just":"111","max_codepoint":255}},"postconditions":[{"assertion":"result == 3"}],"assumptions":[]},{"id":"pc_9","description":"Specific pattern: '21'","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"just":"21","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_10","description":"Specific pattern: '12'","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"just":"12","max_codepoint":255}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_11","description":"Long string of digits","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"alphabet":"0123456789","min_size":100,"max_size":200,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_12","description":"String with mixed digits and symbols","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"alphabet":"0123456789!@#$%^&*()","min_size":1,"max_size":50,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_13","description":"String with leading zeros that might form valid substrings","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"alphabet":"01","min_size":1,"max_size":50,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Invalid input type (int)","execution_statement":"try: result = count_Substrings(s) except Exception as e: result = e","input_types":{"s":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: Invalid input type (float)","execution_statement":"try: result = count_Substrings(s) except Exception as e: result = e","input_types":{"s":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: Invalid input type (None)","execution_statement":"try: result = count_Substrings(s) except Exception as e: result = e","input_types":{"s":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Invariant Check: Output count should not exceed total possible substrings","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":100,"max_codepoint":255}},"postconditions":[{"assertion":"result <= (len(s) * (len(s) + 1)) // 2"}],"assumptions":[]},{"id":"pc_18","description":"String with digits that sum to length","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"alphabet":"123456789","min_size":1,"max_size":20,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_19","description":"String with digits that do not sum to length","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"alphabet":"89","min_size":1,"max_size":20,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_20","description":"String with a mix of digits and letters, ensuring only digit substrings are counted","execution_statement":"result = count_Substrings(s)","input_types":{"s":"str"},"input_constraints":{"s":{"alphabet":"abcdefghijklmnopqrstuvwxyz0123456789","min_size":1,"max_size":50,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc612e"},"test_cases":[{"id":"pc_1","description":"Happy Path: List of positive integers","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == min(xs)"},{"assertion":"result in xs"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: List of negative integers","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result == min(xs)"},{"assertion":"result in xs"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: List of mixed positive and negative integers","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"min_val":-1000,"max_val":1000,"is_mixed":true}},"postconditions":[{"assertion":"result == min(xs)"},{"assertion":"result in xs"}],"assumptions":[]},{"id":"pc_4","description":"Happy Path: List with zero","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"result == min(xs)"},{"assertion":"result in xs"}],"assumptions":["0 in xs"]},{"id":"pc_5","description":"Happy Path: List with duplicate smallest elements","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":2,"max_len":100,"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == min(xs)"},{"assertion":"result in xs"}],"assumptions":["xs.count(min(xs)) > 1"]},{"id":"pc_6","description":"Happy Path: Single element list","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":1,"max_len":1,"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == xs[0]"}],"assumptions":[]},{"id":"pc_7","description":"Happy Path: List of floats","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[float]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"min_val":-1000.0,"max_val":1000.0}},"postconditions":[{"assertion":"result == min(xs)"},{"assertion":"result in xs"}],"assumptions":[]},{"id":"pc_8","description":"Happy Path: List of strings","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[str]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"min_val":"a","max_val":"z","unique":true,"max_codepoint":127}},"postconditions":[{"assertion":"result == min(xs)"},{"assertion":"result in xs"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Empty list","execution_statement":"try: result = smallest_num(xs) except Exception as e: result = e","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"max_len":0}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: List with incompatible types (int and string)","execution_statement":"try: result = smallest_num(xs) except Exception as e: result = e","input_types":{"xs":"list[int | str]"},"input_constraints":{"xs":{"min_len":0,"max_len":2,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["any(isinstance(x, int) for x in xs) and any(isinstance(x, str) for x in xs)"]},{"id":"pc_11","description":"Negative Test: Non-list input (integer)","execution_statement":"try: result = smallest_num(xs) except Exception as e: result = e","input_types":{"xs":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Non-list input (None)","execution_statement":"try: result = smallest_num(xs) except Exception as e: result = e","input_types":{"xs":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Happy Path: List with large integers","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[int]"},"input_constraints":{"xs":{"min_len":1,"max_len":10,"min_val":1000000000,"max_val":1000000000000000000}},"postconditions":[{"assertion":"result == min(xs)"},{"assertion":"result in xs"}],"assumptions":[]},{"id":"pc_14","description":"Happy Path: List with very small floats","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[float]"},"input_constraints":{"xs":{"min_len":1,"max_len":100,"min_val":-1E-09,"max_val":1E-09}},"postconditions":[{"assertion":"result == min(xs)"},{"assertion":"result in xs"}],"assumptions":[]},{"id":"pc_15","description":"Happy Path: List of strings with varying lengths","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[str]"},"input_constraints":{"xs":{"min_len":1,"max_len":50,"min_val":"a","max_val":"z","min_len_str":1,"max_len_str":20,"max_codepoint":127}},"postconditions":[{"assertion":"result == min(xs)"},{"assertion":"result in xs"}],"assumptions":[]},{"id":"pc_16","description":"Happy Path: List of strings with numbers and symbols","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[str]"},"input_constraints":{"xs":{"min_len":1,"max_len":50,"pattern":"^[a-zA-Z-9!@#$%^&*()_+=-]+$","min_len_str":1,"max_len_str":20}},"postconditions":[{"assertion":"result == min(xs)"},{"assertion":"result in xs"}],"assumptions":[]},{"id":"pc_17","description":"Happy Path: List with only one type of element (e.g., all floats)","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[float]"},"input_constraints":{"xs":{"min_len":5,"max_len":50,"min_val":0.1,"max_val":10.0}},"postconditions":[{"assertion":"result == min(xs)"},{"assertion":"result in xs"}],"assumptions":[]},{"id":"pc_18","description":"Happy Path: List with only one type of element (e.g., all strings)","execution_statement":"result = smallest_num(xs)","input_types":{"xs":"list[str]"},"input_constraints":{"xs":{"min_len":5,"max_len":50,"min_val":"apple","max_val":"zebra","min_len_str":3,"max_len_str":10,"max_codepoint":127}},"postconditions":[{"assertion":"result == min(xs)"},{"assertion":"result in xs"}],"assumptions":[]},{"id":"pc_19","description":"Negative Test: Non-list input (string)","execution_statement":"try: result = smallest_num(xs) except Exception as e: result = e","input_types":{"xs":"str"},"input_constraints":{"xs":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_20","description":"Negative Test: List with incompatible types (float and string)","execution_statement":"try: result = smallest_num(xs) except Exception as e: result = e","input_types":{"xs":"list[float | str]"},"input_constraints":{"xs":{"min_len":0,"max_len":2,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["any(isinstance(x, float) for x in xs) and any(isinstance(x, str) for x in xs)"]}]}
{"_id":{"$oid":"692adffe1b18223597bc612f"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with positive integers","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":2,"elements":{"min_val":1,"max_val":100}}}},"postconditions":[{"assertion":"result == max([abs(b - a) for a, b in test_list])"}]},{"id":"pc_2","description":"Happy Path: With negative integers","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":2,"elements":{"min_val":-100,"max_val":-1}}}},"postconditions":[{"assertion":"result == max([abs(b - a) for a, b in test_list])"}]},{"id":"pc_3","description":"Happy Path: Mixed positive and negative integers","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":2,"elements":{"min_val":-100,"max_val":100}},"is_mixed":true}},"postconditions":[{"assertion":"result == max([abs(b - a) for a, b in test_list])"}]},{"id":"pc_4","description":"Edge Case: List with a single pair","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_size":1,"max_size":1,"elements":{"min_size":2,"max_size":2,"elements":{"min_val":1,"max_val":100}}}},"postconditions":[{"assertion":"result == max([abs(b - a) for a, b in test_list])"}]},{"id":"pc_5","description":"Edge Case: All numbers in pairs are the same","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":2,"max_size":2,"elements":{"value":5}}}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_6","description":"Edge Case: Large numbers","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":2,"max_size":2,"elements":{"min_val":1000000,"max_val":2000000}}}},"postconditions":[{"assertion":"result == max([abs(b - a) for a, b in test_list])"}]},{"id":"pc_7","description":"Edge Case: Floating point numbers","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[float, float]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":2,"max_size":2,"elements":{"allow_nan":false,"allow_infinity":false,"min_val":0.1,"max_val":100.5}}}},"postconditions":[{"assertion":"abs(result - max([abs(b - a) for a, b in test_list])) < 1e-9"}]},{"id":"pc_8","description":"Negative Test: Input is not a list","execution_statement":"try: result = max_difference(test_input) except Exception as e: result = e","input_types":{"test_input":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: List contains non-tuple elements","execution_statement":"try: result = max_difference(test_list) except Exception as e: result = e","input_types":{"test_list":"list[int]"},"input_constraints":{"test_list":{"min_size":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Tuple has less than two elements","execution_statement":"try: result = max_difference(test_list) except Exception as e: result = e","input_types":{"test_list":"list[tuple[int]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":1,"max_size":1}}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}]},{"id":"pc_11","description":"Negative Test: Tuple contains non-numeric types","execution_statement":"try: result = max_difference(test_list) except Exception as e: result = e","input_types":{"test_list":"list[tuple[int, str]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":2,"max_size":2}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Edge Case: Empty list input","execution_statement":"try: result = max_difference(test_list) except Exception as e: result = e","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_size":0,"max_size":0}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}]},{"id":"pc_13","description":"Happy Path: Tuples with more than two elements (only first two considered by function)","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int, int]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":3,"max_size":3,"elements":{"min_val":1,"max_val":100}}}},"postconditions":[{"assertion":"result == max([abs(b - a) for a, b in test_list])"}]},{"id":"pc_14","description":"Happy Path: Large list of pairs","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_size":100,"max_size":200,"elements":{"min_size":2,"max_size":2,"elements":{"min_val":1,"max_val":1000}}}},"postconditions":[{"assertion":"result == max([abs(b - a) for a, b in test_list])"}]},{"id":"pc_15","description":"Edge Case: Zero difference within pairs","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":2,"max_size":2,"elements":{"value":10}}}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_16","description":"Happy Path: Floating point numbers with negative values","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[float, float]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":2,"max_size":2,"elements":{"allow_nan":false,"allow_infinity":false,"min_val":-100.5,"max_val":100.5}}}},"postconditions":[{"assertion":"abs(result - max([abs(b - a) for a, b in test_list])) < 1e-9"}]},{"id":"pc_17","description":"Negative Test: List contains None","execution_statement":"try: result = max_difference(test_list) except Exception as e: result = e","input_types":{"test_list":"list[int]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"allow_none":true}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_18","description":"Negative Test: Tuple contains None","execution_statement":"try: result = max_difference(test_list) except Exception as e: result = e","input_types":{"test_list":"list[tuple[int, None]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":2,"max_size":2}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_19","description":"Happy Path: Very small differences","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[float, float]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":2,"max_size":2,"elements":{"allow_nan":false,"allow_infinity":false,"min_val":0.9999999,"max_val":1.0000001}}}},"postconditions":[{"assertion":"abs(result - max([abs(b - a) for a, b in test_list])) < 1e-9"}]},{"id":"pc_20","description":"Happy Path: Mix of tuple sizes (min 2 elements)","execution_statement":"result = max_difference(test_list)","input_types":{"test_list":"list[tuple[int]]"},"input_constraints":{"test_list":{"min_size":1,"elements":{"min_size":2,"max_size":5,"elements":{"min_val":1,"max_val":100}}}},"postconditions":[{"assertion":"result == max([abs(t[0] - t[1]) for t in test_list])"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6130"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list of tuples with integers","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":5,"max_len":20,"elements":{"0":{"type":"str","min_len":1,"max_len":10},"1":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"},{"assertion":"result == subjectmarks"}]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == []"}]},{"id":"pc_3","description":"Edge Case: List with a single tuple","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":1,"max_len":1,"elements":{"0":{"type":"str","min_len":1,"max_len":10},"1":{"type":"int","min_val":0,"max_val":100}}}},"postconditions":[{"assertion":"result == subjectmarks"}]},{"id":"pc_4","description":"Edge Case: All tuples have the same second element","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":5,"max_len":15,"elements":{"0":{"type":"str","min_len":1,"max_len":10},"1":{"type":"int","min_val":50,"max_val":50}}}},"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"},{"assertion":"result == subjectmarks"}]},{"id":"pc_5","description":"Handles tuples with duplicate second elements (stable sort check)","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":10,"max_len":30,"elements":{"0":{"type":"str","min_len":1,"max_len":10},"1":{"type":"int","min_val":0,"max_val":10}}}},"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"},{"assertion":"result == subjectmarks"}]},{"id":"pc_6","description":"Handles tuples with negative integers as second element","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":5,"max_len":20,"elements":{"0":{"type":"str","min_len":1,"max_len":10},"1":{"type":"int","min_val":-100,"max_val":0}}}},"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"},{"assertion":"result == subjectmarks"}]},{"id":"pc_7","description":"Handles tuples with mixed positive and negative integers","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":5,"max_len":20,"elements":{"0":{"type":"str","min_len":1,"max_len":10},"1":{"type":"int","min_val":-50,"max_val":50}},"is_mixed":true}},"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"},{"assertion":"result == subjectmarks"}]},{"id":"pc_8","description":"Handles tuples with floats as second element","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, float]]"},"input_constraints":{"subjectmarks":{"min_len":5,"max_len":20,"elements":{"0":{"type":"str","min_len":1,"max_len":10},"1":{"type":"float","min_val":-100.0,"max_val":100.0}}}},"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"},{"assertion":"result == subjectmarks"}]},{"id":"pc_9","description":"Handles lists with large number of elements","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, int]]"},"input_constraints":{"subjectmarks":{"min_len":100,"max_len":500,"elements":{"0":{"type":"str","min_len":1,"max_len":10},"1":{"type":"int","min_val":0,"max_val":1000}}}},"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"},{"assertion":"result == subjectmarks"}]},{"id":"pc_10","description":"Handles tuples with strings as second element","execution_statement":"result = subject_marks(subjectmarks)","input_types":{"subjectmarks":"list[tuple[str, str]]"},"input_constraints":{"subjectmarks":{"min_len":5,"max_len":20,"elements":{"0":{"type":"str","min_len":1,"max_len":10},"1":{"type":"str","min_len":1,"max_len":10}}}},"postconditions":[{"assertion":"all(subjectmarks[i][1] <= subjectmarks[i+1][1] for i in range(len(subjectmarks)-1))"},{"assertion":"result == subjectmarks"}]},{"id":"pc_11","description":"Negative Test: Input is not a list (e.g., int)","execution_statement":"try: result = subject_marks(subjectmarks) except Exception as e: result = e","input_types":{"subjectmarks":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: List contains non-tuple elements (e.g., int)","execution_statement":"try: result = subject_marks(subjectmarks) except Exception as e: result = e","input_types":{"subjectmarks":"list[int]"},"input_constraints":{"subjectmarks":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Negative Test: Tuples have fewer than two elements","execution_statement":"try: result = subject_marks(subjectmarks) except Exception as e: result = e","input_types":{"subjectmarks":"list[tuple[str]]"},"input_constraints":{"subjectmarks":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_14","description":"Negative Test: Second element of tuple is not comparable (e.g., None)","execution_statement":"try: result = subject_marks(subjectmarks) except Exception as e: result = e","input_types":{"subjectmarks":"list[tuple[str, None]]"},"input_constraints":{"subjectmarks":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6131"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical nested list of integers","input_types":{"data_list":"list[Union[int, list]]"},"input_constraints":{"data_list":{"min_size":1,"max_size":10,"elements":{"strategy":"integers(min_value=-100, max_value=100)","allow_none":false},"nested_lists":{"min_size":1,"max_size":3,"elements":{"strategy":"integers(min_value=-100, max_value=100)","allow_none":false}}}},"execution_statement":"result = recursive_list_sum(data_list)","postconditions":[{"assertion":"result == sum(flatten_for_assertion(data_list))"}]},{"id":"pc_2","description":"Edge Case: Empty list","input_types":{"data_list":"list"},"input_constraints":{"data_list":{"min_size":0,"max_size":0}},"execution_statement":"result = recursive_list_sum(data_list)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_3","description":"Edge Case: List with only integers","input_types":{"data_list":"list[int]"},"input_constraints":{"data_list":{"min_size":1,"max_size":10,"elements":{"strategy":"integers(min_value=-100, max_value=100)"}}},"execution_statement":"result = recursive_list_sum(data_list)","postconditions":[{"assertion":"result == sum(data_list)"}]},{"id":"pc_4","description":"Edge Case: List with only nested empty lists","input_types":{"data_list":"list[list]"},"input_constraints":{"data_list":{"min_size":1,"max_size":5,"nested_lists":{"min_size":0,"max_size":0}}},"execution_statement":"result = recursive_list_sum(data_list)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_5","description":"Edge Case: Deeply nested lists","input_types":{"data_list":"list"},"input_constraints":{"data_list":{"min_size":1,"max_size":5,"nested_lists":{"min_size":1,"max_size":5,"elements":{"strategy":"integers(min_value=-10, max_value=10)","allow_none":false}}}},"execution_statement":"result = recursive_list_sum(data_list)","postconditions":[{"assertion":"result == sum(flatten_for_assertion(data_list))"}]},{"id":"pc_6","description":"Edge Case: List with large integers","input_types":{"data_list":"list[int]"},"input_constraints":{"data_list":{"min_size":1,"max_size":10,"elements":{"strategy":"integers(min_value=-1000000, max_value=1000000)"}}},"execution_statement":"result = recursive_list_sum(data_list)","postconditions":[{"assertion":"result == sum(data_list)"}]},{"id":"pc_7","description":"Edge Case: List with negative integers","input_types":{"data_list":"list[int]"},"input_constraints":{"data_list":{"min_size":1,"max_size":10,"elements":{"strategy":"integers(min_value=-100, max_value=-1)"}}},"execution_statement":"result = recursive_list_sum(data_list)","postconditions":[{"assertion":"result == sum(data_list)"}]},{"id":"pc_8","description":"Mixed types: Integers and nested lists with integers","input_types":{"data_list":"list"},"input_constraints":{"data_list":{"min_size":1,"max_size":10,"elements":{"strategy":"integers(min_value=-50, max_value=50)","allow_none":false},"nested_lists":{"min_size":1,"max_size":2,"elements":{"strategy":"integers(min_value=-50, max_value=50)","allow_none":false}},"is_mixed":true}},"execution_statement":"result = recursive_list_sum(data_list)","postconditions":[{"assertion":"result == sum(flatten_for_assertion(data_list))"}]},{"id":"pc_9","description":"Negative Test: Input is not a list (int)","input_types":{"data_list":"int"},"input_constraints":{},"execution_statement":"try: result = recursive_list_sum(data_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Input is not a list (str)","input_types":{"data_list":"str"},"input_constraints":{"data_list":{"max_codepoint":255}},"execution_statement":"try: result = recursive_list_sum(data_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Negative Test: Input is not a list (None)","input_types":{"data_list":"None"},"input_constraints":{},"execution_statement":"try: result = recursive_list_sum(data_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Mixed types: Integers and nested lists with None (should fail if None is not allowed in nested lists)","input_types":{"data_list":"list"},"input_constraints":{"data_list":{"min_size":1,"max_size":5,"elements":{"strategy":"integers(min_value=-50, max_value=50)","allow_none":false},"nested_lists":{"min_size":1,"max_size":2,"elements":{"strategy":"integers(min_value=-50, max_value=50)","allow_none":true}},"is_mixed":true}},"execution_statement":"try: result = recursive_list_sum(data_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"List containing a single nested list with integers","input_types":{"data_list":"list[list[int]]"},"input_constraints":{"data_list":{"min_size":1,"max_size":1,"nested_lists":{"min_size":1,"max_size":5,"elements":{"strategy":"integers(min_value=-100, max_value=100)"}}}},"execution_statement":"result = recursive_list_sum(data_list)","postconditions":[{"assertion":"result == sum(flatten_for_assertion(data_list))"}]},{"id":"pc_14","description":"List containing a single integer","input_types":{"data_list":"list[int]"},"input_constraints":{"data_list":{"min_size":1,"max_size":1,"elements":{"strategy":"integers(min_value=-100, max_value=100)"}}},"execution_statement":"result = recursive_list_sum(data_list)","postconditions":[{"assertion":"result == data_list[0]"}]},{"id":"pc_15","description":"List with mixed types including non-numeric","input_types":{"data_list":"list"},"input_constraints":{"data_list":{"min_size":1,"max_size":5,"elements":{"strategy":"one_of(integers(min_value=-100, max_value=100), just('a'), just(None))","allow_none":true},"nested_lists":{"min_size":1,"max_size":2,"elements":{"strategy":"integers(min_value=-100, max_value=100)","allow_none":false}},"is_mixed":true}},"execution_statement":"try: result = recursive_list_sum(data_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6132"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list with mixed positive, negative, and zero numbers.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":5,"max_len":20,"min_val":-100,"max_val":100,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(1 for num in list if num >= 0)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with only positive numbers.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":5,"max_len":20,"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == len(list)"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: List with only non-positive numbers (zero and negative).","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":5,"max_len":20,"min_val":-100,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Values: List with minimum and maximum allowed integer values.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":1,"max_len":5,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"result == sum(1 for num in list if num >= 0)"}],"assumptions":[]},{"id":"pc_6","description":"Mixed List Sizes: Testing with lists of significantly different sizes.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_size":1,"max_size":100,"min_val":-100,"max_val":100,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(1 for num in list if num >= 0)"}],"assumptions":[]},{"id":"pc_7","description":"List with duplicate numbers.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":10,"max_len":30,"min_val":-50,"max_val":50}},"postconditions":[{"assertion":"result == sum(1 for num in list if num >= 0)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Input is not a list (e.g., integer).","execution_statement":"try: result = pos_count(list) except Exception as e: result = e","input_types":{"list":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Input is not a list (e.g., string).","execution_statement":"try: result = pos_count(list) except Exception as e: result = e","input_types":{"list":"str"},"input_constraints":{"list":{"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Input is None.","execution_statement":"try: result = pos_count(list) except Exception as e: result = e","input_types":{"list":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"List with large positive numbers.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":5,"max_len":20,"min_val":1000000,"max_val":2000000}},"postconditions":[{"assertion":"result == len(list)"}],"assumptions":[]},{"id":"pc_12","description":"List with large negative numbers.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":5,"max_len":20,"min_val":-2000000,"max_val":-1000000}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_13","description":"List with a mix of very large positive and negative numbers.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":5,"max_len":20,"min_val":-2000000,"max_val":2000000}},"postconditions":[{"assertion":"result == sum(1 for num in list if num >= 0)"}],"assumptions":[]},{"id":"pc_14","description":"List with only zeros.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":5,"max_len":20,"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_15","description":"List with alternating positive and negative numbers.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":10,"max_len":30,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"result == sum(1 for num in list if num >= 0)"}],"assumptions":[]},{"id":"pc_16","description":"List with a single positive number.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":1,"max_len":1,"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_17","description":"List with a single negative number.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":1,"max_len":1,"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_18","description":"List with a single zero.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":1,"max_len":1,"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_19","description":"List with very small negative numbers.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":5,"max_len":20,"min_val":-1000000,"max_val":-1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_20","description":"List with very small positive numbers.","execution_statement":"result = pos_count(list)","input_types":{"list":"list[int]"},"input_constraints":{"list":{"min_len":5,"max_len":20,"min_val":1,"max_val":1000000}},"postconditions":[{"assertion":"result == len(list)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6133"},"test_cases":[{"id":"pc_1","description":"Happy Path: Small non-negative integer input","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":10}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result == [1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975][n]"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Larger non-negative integer input","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":11,"max_val":20}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result == [678570, 4213597, 27644423, 190899322, 1382958545, 10480142147, 82864869804, 682076306147, 5832742205057, 51724158235372][n-11]"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Input is 0","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Input is 1","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Input is 2","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == 2"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: Input is a negative integer","execution_statement":"try: result = bell_number(n) except Exception as e: result = e","input_types":{"n":"int"},"input_constraints":{"n":{"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, IndexError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Input is a float","execution_statement":"try: result = bell_number(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Input is a string","execution_statement":"try: result = bell_number(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Input is None","execution_statement":"try: result = bell_number(n) except Exception as e: result = e","input_types":{"n":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Invariant Test: Output is always an integer","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":30}},"postconditions":[{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_11","description":"Invariant Test: Output is always non-negative","execution_statement":"result = bell_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":30}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6134"},"test_cases":[{"id":"pc_1","description":"Happy Path: Empty list","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"max_len":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Single element list","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: All elements are the same","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"unique":true}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Happy Path: Strictly increasing list","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"sorted":"ascending"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_5","description":"Happy Path: Strictly decreasing list","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"sorted":"descending"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Happy Path: Non-decreasing list with duplicates","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":5,"sorted":"ascending"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_7","description":"Happy Path: Non-increasing list with duplicates","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":5,"sorted":"descending"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Not monotonic (increasing then decreasing)","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":3}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not (all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) or all(arr[i] >= arr[i + 1] for i in range(len(arr) - 1)))"]},{"id":"pc_9","description":"Negative Test: Not monotonic (decreasing then increasing)","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":3}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not (all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) or all(arr[i] >= arr[i + 1] for i in range(len(arr) - 1)))"]},{"id":"pc_10","description":"Negative Test: Mixed numbers (float and int)","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[Union[int, float]]"},"input_constraints":{"arr":{"min_len":2,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, bool)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = is_Monotonic(arr) except Exception as e: result = e","input_types":{"arr":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = is_Monotonic(arr) except Exception as e: result = e","input_types":{"arr":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: List with non-comparable types (int and str)","execution_statement":"try: result = is_Monotonic(arr) except Exception as e: result = e","input_types":{"arr":"list[Union[int, str]]"},"input_constraints":{"arr":{"min_len":2,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Large numbers: Increasing","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"min_val":-1000000000,"max_val":1000000000,"sorted":"ascending"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_15","description":"Large numbers: Decreasing","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"min_val":-1000000000,"max_val":1000000000,"sorted":"descending"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_16","description":"Large numbers: Not monotonic","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":3,"min_val":-1000000000,"max_val":1000000000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not (all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) or all(arr[i] >= arr[i + 1] for i in range(len(arr) - 1)))"]},{"id":"pc_17","description":"Floating point numbers: Increasing","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[float]"},"input_constraints":{"arr":{"min_len":2,"sorted":"ascending"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_18","description":"Floating point numbers: Decreasing","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[float]"},"input_constraints":{"arr":{"min_len":2,"sorted":"descending"}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_19","description":"Floating point numbers: Not monotonic","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[float]"},"input_constraints":{"arr":{"min_len":3}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not (all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) or all(arr[i] >= arr[i + 1] for i in range(len(arr) - 1)))"]},{"id":"pc_20","description":"Invariant: Monotonicity check matches definition","execution_statement":"result = is_Monotonic(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":0,"max_len":100}},"postconditions":[{"assertion":"result == (all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) or all(arr[i] >= arr[i + 1] for i in range(len(arr) - 1)))"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6135"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic sublist found","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":2,"max_len":10},"sub_list":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(sub_list) <= len(main_list)"]},{"id":"pc_2","description":"Happy Path: Basic sublist not found","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":2,"max_len":10},"sub_list":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(sub_list) <= len(main_list)","not any(main_list[i:i+len(sub_list)] == sub_list for i in range(len(main_list) - len(sub_list) + 1))"]},{"id":"pc_3","description":"Edge Case: Empty sublist","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":0,"max_len":10}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Empty main list, non-empty sublist","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"sub_list":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(main_list) == 0"]},{"id":"pc_5","description":"Edge Case: Empty main list and empty sublist","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":0,"max_len":0},"sub_list":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Sublist is identical to main list","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"result == True"}],"assumptions":["main_list == sub_list"]},{"id":"pc_7","description":"Edge Case: Sublist longer than main list","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":1,"max_len":10},"sub_list":{"min_len":1,"max_len":15}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(sub_list) > len(main_list)"]},{"id":"pc_8","description":"Mixed Types: Main list with strings, sublist with strings","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[str]","sub_list":"list[str]"},"input_constraints":{"main_list":{"min_len":2,"max_len":10,"is_mixed":true,"max_codepoint":127},"sub_list":{"min_len":1,"max_len":5,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(sub_list) <= len(main_list)"]},{"id":"pc_9","description":"Mixed Types: Main list with mixed comparable types","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[object]","sub_list":"list[object]"},"input_constraints":{"main_list":{"min_len":2,"max_len":10,"hashable_mix":true,"is_mixed":true},"sub_list":{"min_len":1,"max_len":5,"hashable_mix":true,"is_mixed":true}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(sub_list) <= len(main_list)"]},{"id":"pc_10","description":"Negative Test: Main list is not iterable (int)","execution_statement":"try: result = is_sublist(main_list, sub_list) except Exception as e: result = e","input_types":{"main_list":"int","sub_list":"list[int]"},"input_constraints":{"sub_list":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Sublist is not iterable (float)","execution_statement":"try: result = is_sublist(main_list, sub_list) except Exception as e: result = e","input_types":{"main_list":"list[int]","sub_list":"float"},"input_constraints":{"main_list":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Sublist is None","execution_statement":"try: result = is_sublist(main_list, sub_list) except Exception as e: result = e","input_types":{"main_list":"list[int]","sub_list":"None"},"input_constraints":{"main_list":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Invariant: Original lists are not modified","execution_statement":"original_main_list = list(main_list); original_sub_list = list(sub_list); result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":1,"max_len":10},"sub_list":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"main_list == original_main_list"},{"assertion":"sub_list == original_sub_list"}],"assumptions":["len(sub_list) <= len(main_list)"]},{"id":"pc_14","description":"Large lists: Sublist found","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":100,"max_len":1000},"sub_list":{"min_len":10,"max_len":50}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(sub_list) <= len(main_list)"]},{"id":"pc_15","description":"Large lists: Sublist not found","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":100,"max_len":1000},"sub_list":{"min_len":10,"max_len":50}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(sub_list) <= len(main_list)","not any(main_list[i:i+len(sub_list)] == sub_list for i in range(len(main_list) - len(sub_list) + 1))"]},{"id":"pc_16","description":"List with duplicate elements: Sublist found","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":5,"max_len":20,"elements":{"integers":{"min_val":0,"max_val":5}}},"sub_list":{"min_len":2,"max_len":5,"elements":{"integers":{"min_val":0,"max_val":5}}}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(sub_list) <= len(main_list)"]},{"id":"pc_17","description":"List with duplicate elements: Sublist not found","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":5,"max_len":20,"elements":{"integers":{"min_val":0,"max_val":5}}},"sub_list":{"min_len":2,"max_len":5,"elements":{"integers":{"min_val":0,"max_val":5}}}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(sub_list) <= len(main_list)","not any(main_list[i:i+len(sub_list)] == sub_list for i in range(len(main_list) - len(sub_list) + 1))"]},{"id":"pc_18","description":"Main list contains only one element, sublist is that element","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":1,"max_len":1},"sub_list":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == True"}],"assumptions":["main_list == sub_list"]},{"id":"pc_19","description":"Main list contains only one element, sublist is different","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":1,"max_len":1},"sub_list":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == False"}],"assumptions":["main_list != sub_list"]},{"id":"pc_20","description":"Main list contains only one element, sublist is longer","execution_statement":"result = is_sublist(main_list, sub_list)","input_types":{"main_list":"list[int]","sub_list":"list[int]"},"input_constraints":{"main_list":{"min_len":1,"max_len":1},"sub_list":{"min_len":2,"max_len":2}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6136"},"test_cases":[{"id":"pc_1","description":"Happy Path: List with tuples of equal length","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int, int, int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_2","description":"Happy Path: List with tuples of varying lengths","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int, str]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_3","description":"Edge Case: Empty list","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple]"},"input_constraints":{"Input":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_4","description":"Edge Case: List with a single tuple","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int, str, bool]]"},"input_constraints":{"Input":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_5","description":"Edge Case: List with tuples of length zero","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_6","description":"Mixed Types: Tuples with different lengths and types","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":["integers","text","booleans","floats"],"is_mixed":true}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_7","description":"Mixed Types: Tuples with same lengths and mixed types","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int, str, bool]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"is_mixed":true}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_8","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = get_equal(Input) except Exception as e: result = e","input_types":{"Input":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: Input is not a list (str)","execution_statement":"try: result = get_equal(Input) except Exception as e: result = e","input_types":{"Input":"str"},"input_constraints":{"Input":{"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = get_equal(Input) except Exception as e: result = e","input_types":{"Input":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"List with tuples containing None, same length","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int | None, str | None]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"allow_none":true}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_12","description":"List with tuples containing None, different lengths","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":["integers","None","text"]}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_13","description":"List with tuples containing empty strings, same length","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[str, str]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":[{"min_len":0,"max_len":0}]}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_14","description":"List with tuples containing empty strings, different lengths","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":[{"min_len":0,"max_len":0},{"min_len":1,"max_len":1}]}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_15","description":"List with tuples containing large numbers, same length","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[int, int]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":[{"min_val":-2147483648,"max_val":2147483647}]}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_16","description":"List with tuples containing large numbers, different lengths","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":[{"min_val":-2147483648,"max_val":2147483647},{"min_val":-2147483648,"max_val":2147483647},{"min_val":-2147483648,"max_val":2147483647}]}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_17","description":"List with tuples containing floats, same length","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[float, float]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_18","description":"List with tuples containing floats, different lengths","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":["floats","integers"]}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_19","description":"List with tuples containing booleans, same length","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple[bool, bool, bool]]"},"input_constraints":{"Input":{"min_len":2,"max_len":5}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_20","description":"List with tuples containing booleans, different lengths","execution_statement":"result = get_equal(Input)","input_types":{"Input":"list[tuple]"},"input_constraints":{"Input":{"min_len":2,"max_len":5,"elements":["booleans","integers"]}},"postconditions":[{"assertion":"result == False"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6137"},"test_cases":[{"id":"pc_1","description":"Happy Path: General list of integers","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"},{"assertion":"sorted(result) == sorted(nums)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with one element","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == nums"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: List with two elements (already sorted)","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":2,"sorted":"descending"}},"postconditions":[{"assertion":"result == nums"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: List with two elements (reverse sorted)","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":2,"sorted":"ascending"}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)"}],"assumptions":[]},{"id":"pc_6","description":"List with duplicate elements","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"unique":false}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)"},{"assertion":"all(result[i] >= result[i+1] for i in range(len(result)-1))"}],"assumptions":[]},{"id":"pc_7","description":"List with all identical elements","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50}},"postconditions":[{"assertion":"result == nums"}],"assumptions":["len(set(nums)) == 1"]},{"id":"pc_8","description":"List with negative numbers","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-100,"max_val":-1,"min_len":5,"max_len":50}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)"}],"assumptions":[]},{"id":"pc_9","description":"List with mixed positive and negative numbers","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-50,"max_val":50,"min_len":5,"max_len":50,"is_mixed":true}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)"}],"assumptions":[]},{"id":"pc_10","description":"List with large numbers","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":1000000,"max_val":2000000,"min_len":5,"max_len":50}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)"}],"assumptions":[]},{"id":"pc_11","description":"List with numbers close to zero","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_val":-5,"max_val":5,"min_len":5,"max_len":50}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)"}],"assumptions":[]},{"id":"pc_12","description":"List with many elements","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":100,"max_len":200}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)"}],"assumptions":[]},{"id":"pc_13","description":"List with few elements","execution_statement":"result = comb_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":3,"max_len":4}},"postconditions":[{"assertion":"result == sorted(nums, reverse=True)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Input is not a list (float)","execution_statement":"try: result = comb_sort(nums) except Exception as e: result = e","input_types":{"nums":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: Input is not a list (string)","execution_statement":"try: result = comb_sort(nums) except Exception as e: result = e","input_types":{"nums":"str"},"input_constraints":{"nums":{"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: Input is not a list (integer)","execution_statement":"try: result = comb_sort(nums) except Exception as e: result = e","input_types":{"nums":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Negative Test: List contains non-comparable types (int and string)","execution_statement":"try: result = comb_sort(nums) except Exception as e: result = e","input_types":{"nums":"list[Union[int, str]]"},"input_constraints":{"nums":{"min_len":2,"max_len":10,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_18","description":"Negative Test: List contains None","execution_statement":"try: result = comb_sort(nums) except Exception as e: result = e","input_types":{"nums":"list[Union[int, None]]"},"input_constraints":{"nums":{"min_len":2,"max_len":10,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6138"},"test_cases":[{"id":"pc_1","description":"Happy Path: Odd numbers","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000,"odd":true}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Multiples of 4","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":4,"max_val":1000,"multiple_of":4}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_3","description":"Negative Path: Numbers of the form 4k+2","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":1000,"step":4}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Zero","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Smallest multiple of 4","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":4,"max_val":4}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Smallest number of form 4k+2","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Large odd number","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":999999,"max_val":999999,"odd":true}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_8","description":"Large multiple of 4","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000,"max_val":1000000,"multiple_of":4}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_9","description":"Large number of form 4k+2","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":999998,"max_val":999998,"step":4}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"Test with a range of numbers including odd, even, and multiples of 4","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":500}},"postconditions":[{"assertion":"result == (n % 2 != 0 or n % 4 == 0)"}],"assumptions":[]},{"id":"pc_11","description":"Test with a different range of numbers","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":501,"max_val":1000}},"postconditions":[{"assertion":"result == (n % 2 != 0 or n % 4 == 0)"}],"assumptions":[]},{"id":"pc_12","description":"Test with numbers around a multiple of 4","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":20}},"postconditions":[{"assertion":"result == (n % 2 != 0 or n % 4 == 0)"}],"assumptions":[]},{"id":"pc_13","description":"Test with numbers around an odd number","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":11,"max_val":19}},"postconditions":[{"assertion":"result == (n % 2 != 0 or n % 4 == 0)"}],"assumptions":[]},{"id":"pc_14","description":"Test with numbers around a number of form 4k+2","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":14,"max_val":18}},"postconditions":[{"assertion":"result == (n % 2 != 0 or n % 4 == 0)"}],"assumptions":[]},{"id":"pc_15","description":"Test with a very large number (odd)","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000000,"max_val":7812500,"odd":true}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_16","description":"Test with a very large number (multiple of 4)","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000000,"max_val":1000000000,"multiple_of":4}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_17","description":"Test with a very large number (4k+2)","execution_statement":"result = dif_Square(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000000002,"max_val":1000000002,"step":4}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_18","description":"Test with a float input (expecting TypeError)","execution_statement":"try: result = dif_Square(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{"n":{"min_val":0.0,"max_val":1000.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_19","description":"Test with a string input (expecting TypeError)","execution_statement":"try: result = dif_Square(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_20","description":"Test with None input (expecting TypeError)","execution_statement":"try: result = dif_Square(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6139"},"test_cases":[{"id":"pc_1","description":"Happy Path: Identical lists, same length, matching patterns","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["colors == patterns"]},{"id":"pc_2","description":"Happy Path: Identical lists, same length, different patterns but same structure","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":5,"elements":{"type":"strings","min_len":0,"max_len":2,"pattern":"^[a-z]+$"},"max_codepoint":127},"patterns":{"min_len":0,"max_len":5,"elements":{"type":"strings","min_len":0,"max_len":2,"pattern":"^[a-z]+$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(set(colors)) == 1","len(set(patterns)) == 1","colors[0] != patterns[0]"]},{"id":"pc_3","description":"Negative Test: Different lengths of colors and patterns","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":1,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127},"patterns":{"min_len":1,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(colors) != len(patterns)"]},{"id":"pc_4","description":"Happy Path: Same length, same number of unique elements, but different mapping","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(colors) == len(patterns)","len(set(colors)) == len(set(patterns))","colors != patterns"]},{"id":"pc_5","description":"Happy Path: Same length, same number of unique elements, same mapping structure","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["len(colors) == len(patterns)","len(set(colors)) == len(set(patterns))","all(colors[i] == colors[0] for i in range(len(colors)))","all(patterns[i] == patterns[0] for i in range(len(patterns)))","colors[0] == patterns[0]"]},{"id":"pc_6","description":"Negative Test: Same length, same number of unique elements, but different internal structure","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(colors) == len(patterns)","len(set(colors)) == len(set(patterns))","not all(colors[i] == colors[0] for i in range(len(colors)))","not all(patterns[i] == patterns[0] for i in range(len(patterns)))","colors != patterns"]},{"id":"pc_7","description":"Edge Case: Empty lists","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":0,"max_codepoint":127},"patterns":{"min_len":0,"max_len":0,"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_8","description":"Edge Case: Empty colors, non-empty patterns","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":0,"max_len":0,"max_codepoint":127},"patterns":{"min_len":1,"max_len":5,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_9","description":"Edge Case: Non-empty colors, empty patterns","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":1,"max_len":5,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127},"patterns":{"min_len":0,"max_len":0,"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"Happy Path: All colors are the same, all patterns are the same, and they match","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":1,"pattern":"^a$"},"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":1,"pattern":"^a$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["colors == patterns"]},{"id":"pc_11","description":"Happy Path: All colors are the same, all patterns are the same, but they differ","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":1,"pattern":"^a$"},"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":1,"pattern":"^b$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Invalid type for colors (int)","execution_statement":"try: result = is_samepatterns(colors, patterns) except Exception as e: result = e","input_types":{"colors":"int","patterns":"list[str]"},"input_constraints":{"patterns":{"min_len":1,"max_len":5,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Invalid type for patterns (int)","execution_statement":"try: result = is_samepatterns(colors, patterns) except Exception as e: result = e","input_types":{"colors":"list[str]","patterns":"int"},"input_constraints":{"colors":{"min_len":1,"max_len":5,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-z]+$"},"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Happy Path: Mixed case strings, should be treated as distinct","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-zA-Z]+$"},"is_mixed":true,"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-zA-Z]+$"},"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["colors == patterns"]},{"id":"pc_15","description":"Happy Path: Patterns with numbers, colors with numbers","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-zA-Z-9]+$"},"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":5,"pattern":"^[a-zA-Z-9]+$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["colors == patterns"]},{"id":"pc_16","description":"Happy Path: Longer lists with repeating patterns","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":15,"max_len":20,"elements":{"type":"strings","min_len":1,"max_len":3,"pattern":"^[a-z]+$"},"max_codepoint":127},"patterns":{"min_len":15,"max_len":20,"elements":{"type":"strings","min_len":1,"max_len":3,"pattern":"^[a-z]+$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["colors == patterns"]},{"id":"pc_17","description":"Happy Path: Lists with only one unique element each, matching","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":1,"pattern":"^x$"},"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":1,"pattern":"^x$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_18","description":"Happy Path: Lists with only one unique element each, not matching","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":1,"pattern":"^x$"},"max_codepoint":127},"patterns":{"min_len":5,"max_len":10,"elements":{"type":"strings","min_len":1,"max_len":1,"pattern":"^y$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_19","description":"Happy Path: Complex structure, should return True","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":7,"max_len":12,"elements":{"type":"strings","min_len":1,"max_len":4,"pattern":"^[abc]+$"},"max_codepoint":127},"patterns":{"min_len":7,"max_len":12,"elements":{"type":"strings","min_len":1,"max_len":4,"pattern":"^[abc]+$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == True"}],"assumptions":["colors == patterns"]},{"id":"pc_20","description":"Happy Path: Complex structure, should return False","execution_statement":"result = is_samepatterns(colors, patterns)","input_types":{"colors":"list[str]","patterns":"list[str]"},"input_constraints":{"colors":{"min_len":7,"max_len":12,"elements":{"type":"strings","min_len":1,"max_len":4,"pattern":"^[abc]+$"},"max_codepoint":127},"patterns":{"min_len":7,"max_len":12,"elements":{"type":"strings","min_len":1,"max_len":4,"pattern":"^[abc]+$"},"max_codepoint":127}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(colors) == len(patterns)","colors != patterns"]}]}
{"_id":{"$oid":"692adffe1b18223597bc613a"},"test_cases":[{"id":"pc_1","description":"Happy Path: All elements divisible by K","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":100,"strategy":"lambda x: x % K == 0"}}},"K":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in t) for t in result)"},{"assertion":"all(t in test_list for t in result)"}]},{"id":"pc_2","description":"Edge Case: No elements divisible by K","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":100,"strategy":"lambda x: x % K != 0"}}},"K":{"min_val":2,"max_val":10}},"postconditions":[{"assertion":"result == []"}]},{"id":"pc_3","description":"Edge Case: Empty input list","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":0,"max_len":0},"K":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == []"}]},{"id":"pc_4","description":"Edge Case: List with empty tuples","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":0,"max_len":0}},"K":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == []"}]},{"id":"pc_5","description":"Edge Case: K = 1 (all elements should be divisible)","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":100}}},"K":{"value":1}},"postconditions":[{"assertion":"set(result) == set(test_list)"}]},{"id":"pc_6","description":"Mixed tuples: some divisible, some not","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":2,"max_len":10,"elements":[{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":50,"strategy":"lambda x: x % K == 0"}},{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":50,"strategy":"lambda x: x % K != 0"}}],"is_mixed":true},"K":{"min_val":3,"max_val":15,"is_mixed":true}},"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in t) for t in result)"},{"assertion":"all(t in test_list for t in result)"}]},{"id":"pc_7","description":"Large numbers, divisible by K","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":100000,"max_val":1000000,"strategy":"lambda x: x % K == 0"}}},"K":{"min_val":10,"max_val":50}},"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in t) for t in result)"},{"assertion":"all(t in test_list for t in result)"}]},{"id":"pc_8","description":"Negative numbers, divisible by K","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":-1000,"max_val":-1,"strategy":"lambda x: x % K == 0"}}},"K":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in t) for t in result)"},{"assertion":"all(t in test_list for t in result)"}]},{"id":"pc_9","description":"Mixed positive and negative numbers, divisible by K","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":2,"max_len":10,"elements":[{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":100,"strategy":"lambda x: x % K == 0"}},{"min_len":1,"max_len":5,"elements":{"min_val":-100,"max_val":-1,"strategy":"lambda x: x % K == 0"}}],"is_mixed":true},"K":{"min_val":2,"max_val":10,"is_mixed":true}},"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in t) for t in result)"},{"assertion":"all(t in test_list for t in result)"}]},{"id":"pc_10","description":"Zero as an element, divisible by K","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":0,"max_val":100,"strategy":"lambda x: x % K == 0"}}},"K":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in t) for t in result)"},{"assertion":"all(t in test_list for t in result)"}]},{"id":"pc_11","description":"Negative Test: K is zero (division by zero)","execution_statement":"try: result = find_tuples(test_list, K) except Exception as e: result = e","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":100}}},"K":{"value":0}},"postconditions":[{"assertion":"isinstance(result, ZeroDivisionError)"}]},{"id":"pc_12","description":"Negative Test: K is negative","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":100}}},"K":{"min_val":-10,"max_val":-1}},"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in t) for t in result)"},{"assertion":"all(t in test_list for t in result)"}]},{"id":"pc_13","description":"Negative Test: K is not an integer (float)","execution_statement":"try: result = find_tuples(test_list, K) except Exception as e: result = e","input_types":{"test_list":"list[tuple[int]]","K":"float"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":100}}},"K":{"min_val":1.0,"max_val":10.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Negative Test: K is not an integer (string)","execution_statement":"try: result = find_tuples(test_list, K) except Exception as e: result = e","input_types":{"test_list":"list[tuple[int]]","K":"str"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":100}}},"K":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_15","description":"Negative Test: Input list contains non-tuple elements","execution_statement":"try: result = find_tuples(test_list, K) except Exception as e: result = e","input_types":{"test_list":"list","K":"int"},"input_constraints":{"test_list":{"min_len":2,"max_len":5,"elements":[{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":100,"strategy":"lambda x: x % K == 0"}},{"value":"not a tuple"}]},"K":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_16","description":"Negative Test: Tuple elements are not integers","execution_statement":"try: result = find_tuples(test_list, K) except Exception as e: result = e","input_types":{"test_list":"list[tuple]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":[{"min_val":1,"max_val":100,"strategy":"lambda x: x % K == 0"},{"value":"not an integer"}]}},"K":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_17","description":"Large K value","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":1000000,"strategy":"lambda x: x % K == 0"}}},"K":{"min_val":1000,"max_val":500000}},"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in t) for t in result)"},{"assertion":"all(t in test_list for t in result)"}]},{"id":"pc_18","description":"Tuples with varying lengths","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":10,"elements":{"min_val":1,"max_val":100,"strategy":"lambda x: x % K == 0"}}},"K":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in t) for t in result)"},{"assertion":"all(t in test_list for t in result)"}]},{"id":"pc_19","description":"All elements in a tuple are zero","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"value":0}}},"K":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"all(all(ele % K == 0 for ele in t) for t in result)"},{"assertion":"all(t in test_list for t in result)"}]},{"id":"pc_20","description":"Check if original tuples are preserved","execution_statement":"result = find_tuples(test_list, K)","input_types":{"test_list":"list[tuple[int]]","K":"int"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":100,"strategy":"lambda x: x % K == 0"}}},"K":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"set(result) == set(test_list)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc613b"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive integer divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":11,"max_val":1000000,"step":11}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Positive integer not divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000000,"exclude":[0]}},"postconditions":[{"assertion":"result is False"}],"assumptions":["n % 11 != 0"]},{"id":"pc_3","description":"Edge Case: Zero is divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"value":0}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_4","description":"Happy Path: Negative integer divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1000000,"max_val":-11,"step":11}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_5","description":"Happy Path: Negative integer not divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1000000,"max_val":-1,"exclude":[0]}},"postconditions":[{"assertion":"result is False"}],"assumptions":["n % 11 != 0"]},{"id":"pc_6","description":"Large positive integer divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1100000000000000000,"max_val":1100000000000000000,"step":11}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_7","description":"Large negative integer divisible by 11","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-1100000000000000000,"max_val":-1100000000000000000,"step":11}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Float input","execution_statement":"try: result = is_Diff(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{"n":{"min_val":-1000.0,"max_val":1000.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: String input","execution_statement":"try: result = is_Diff(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: null input","execution_statement":"try: result = is_Diff(n) except Exception as e: result = e","input_types":{"n":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Check for consistency with modulo operator for positive numbers","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":100000}},"postconditions":[{"assertion":"result == (n % 11 == 0)"}],"assumptions":[]},{"id":"pc_12","description":"Check for consistency with modulo operator for negative numbers","execution_statement":"result = is_Diff(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-100000,"max_val":-1}},"postconditions":[{"assertion":"result == (n % 11 == 0)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc613c"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic odd length word","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[a-zA-Z]{3}$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Basic even length word","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[a-zA-Z]{2}$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Empty string","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"max_size":0,"max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Single character string (odd length)","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":1,"max_size":1,"max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: String with spaces, first word odd length","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[a-zA-Z]{3}\\s[a-zA-Z]{2}$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: String with spaces, first word even length","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[a-zA-Z]{2}\\s[a-zA-Z]{3}$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_7","description":"Mixed characters, odd length","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[a-zA-Z-9!@#$%^&*()_+=-]{5}$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_8","description":"Mixed characters, even length","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[a-zA-Z-9!@#$%^&*()_+=-]{4}$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_9","description":"String with multiple spaces, first word odd","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[a-zA-Z]{3}(\\s+)[a-zA-Z]{2}$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_10","description":"String with multiple spaces, first word even","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[a-zA-Z]{2}(\\s+)[a-zA-Z]{3}$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_11","description":"Long string, first word odd","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":50,"max_size":100,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_12","description":"Long string, first word even","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"min_size":50,"max_size":100,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Input is an integer (TypeError)","execution_statement":"try: result = word_len(s) except Exception as e: result = e","input_types":{"s":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Input is a float (TypeError)","execution_statement":"try: result = word_len(s) except Exception as e: result = e","input_types":{"s":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: Input is None (TypeError)","execution_statement":"try: result = word_len(s) except Exception as e: result = e","input_types":{"s":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"String with only spaces (effectively empty after split)","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^\\s+$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_17","description":"String with leading/trailing spaces, first word odd","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^\\s+[a-zA-Z]{3}\\s*$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_18","description":"String with leading/trailing spaces, first word even","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^\\s+[a-zA-Z]{2}\\s*$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]},{"id":"pc_19","description":"String with special characters, odd length","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[^ ]{7}$","max_codepoint":255}},"postconditions":[{"assertion":"result is True"}],"assumptions":[]},{"id":"pc_20","description":"String with special characters, even length","execution_statement":"result = word_len(s)","input_types":{"s":"str"},"input_constraints":{"s":{"pattern":"^[^ ]{6}$","max_codepoint":255}},"postconditions":[{"assertion":"result is False"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc613d"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical positive integer","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == (n * (n + 1) * (n + 2)) / 6"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: n = 0","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"just":0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: n = 1","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"just":1}},"postconditions":[{"assertion":"result == 1.0"}],"assumptions":[]},{"id":"pc_4","description":"Large positive integer","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":1000000}},"postconditions":[{"assertion":"result == (n * (n + 1) * (n + 2)) / 6"}],"assumptions":[]},{"id":"pc_5","description":"Negative Test: Float input","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: String input","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: null input","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Boolean input (True)","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"bool"},"input_constraints":{"n":{"just":true}},"postconditions":[{"assertion":"result == 1.0"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Boolean input (False)","execution_statement":"try: result = tetrahedral_number(n) except Exception as e: result = e","input_types":{"n":"bool"},"input_constraints":{"n":{"just":false}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_10","description":"Test with a moderately large number","execution_statement":"result = tetrahedral_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":500,"max_val":1500}},"postconditions":[{"assertion":"result == (n * (n + 1) * (n + 2)) / 6"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc613e"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical positive radius","execution_statement":"result = volume_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_value":0.1,"max_value":100.0}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_2","description":"Boundary Case: Radius is zero","execution_statement":"result = volume_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"just":0.0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Case: Large radius","execution_statement":"result = volume_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_value":1E+06,"max_value":1E+09}},"postconditions":[{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Case: Small positive radius","execution_statement":"result = volume_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_value":1E-09,"max_value":0.001}},"postconditions":[{"assertion":"result > 0"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: Volume formula check","execution_statement":"result = volume_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_value":0.1,"max_value":100.0}},"postconditions":[{"assertion":"abs(result - (4/3) * math.pi * (radius ** 3)) < 1e-6"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: Invalid Type (string)","execution_statement":"try: result = volume_sphere(radius) except Exception as e: result = e","input_types":{"radius":"str"},"input_constraints":{"radius":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Invalid Type (None)","execution_statement":"try: result = volume_sphere(radius) except Exception as e: result = e","input_types":{"radius":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Invalid Type (list)","execution_statement":"try: result = volume_sphere(radius) except Exception as e: result = e","input_types":{"radius":"list"},"input_constraints":{"radius":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Invalid Type (integer)","execution_statement":"try: result = volume_sphere(radius) except Exception as e: result = e","input_types":{"radius":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Test with a very large number of decimal places","execution_statement":"result = volume_sphere(radius)","input_types":{"radius":"float"},"input_constraints":{"radius":{"min_value":1E-15,"max_value":1E-10}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc613f"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic string","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":1,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) == 1"},{"assertion":"'a' <= result <= 'z'"},{"assertion":"result == chr( (sum(ord(c) - ord('a') + 1 for c in strr) % 26) if (sum(ord(c) - ord('a') + 1 for c in strr) % 26) != 0 else ord('z') )"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == 'z'"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String where sum of (ord(c) - ord('a') + 1) is a multiple of 26","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":1,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == 'z'"}],"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) % 26 == 0"]},{"id":"pc_4","description":"Edge Case: String where sum of (ord(c) - ord('a') + 1) is 1","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":1,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == 'a'"}],"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) % 26 == 1"]},{"id":"pc_5","description":"Edge Case: String where sum of (ord(c) - ord('a') + 1) is 25","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":1,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == 'y'"}],"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) % 26 == 25"]},{"id":"pc_6","description":"Test with uppercase letters","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":1,"alphabet":"ABCDEFGHIJKLMNOPQRSTUVWXYZ","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) == 1"},{"assertion":"'a' <= result <= 'z'"},{"assertion":"result == chr( (sum(ord(c) - ord('a') + 1 for c in strr) % 26) if (sum(ord(c) - ord('a') + 1 for c in strr) % 26) != 0 else ord('z') )"}],"assumptions":[]},{"id":"pc_7","description":"Test with mixed case letters","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":1,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) == 1"},{"assertion":"'a' <= result <= 'z'"},{"assertion":"result == chr( (sum(ord(c) - ord('a') + 1 for c in strr) % 26) if (sum(ord(c) - ord('a') + 1 for c in strr) % 26) != 0 else ord('z') )"}],"assumptions":[]},{"id":"pc_8","description":"Test with numbers and symbols","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":1,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) == 1"},{"assertion":"'a' <= result <= 'z'"},{"assertion":"result == chr( (sum(ord(c) - ord('a') + 1 for c in strr) % 26) if (sum(ord(c) - ord('a') + 1 for c in strr) % 26) != 0 else ord('z') )"}],"assumptions":[]},{"id":"pc_9","description":"Test with a longer string","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":10,"max_len":50,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) == 1"},{"assertion":"'a' <= result <= 'z'"},{"assertion":"result == chr( (sum(ord(c) - ord('a') + 1 for c in strr) % 26) if (sum(ord(c) - ord('a') + 1 for c in strr) % 26) != 0 else ord('z') )"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Non-string input (integer)","execution_statement":"try: result = get_Char(strr) except Exception as e: result = e","input_types":{"strr":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Non-string input (float)","execution_statement":"try: result = get_Char(strr) except Exception as e: result = e","input_types":{"strr":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Non-string input (None)","execution_statement":"try: result = get_Char(strr) except Exception as e: result = e","input_types":{"strr":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Test with characters having higher ASCII values","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":1,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, str)"},{"assertion":"len(result) == 1"},{"assertion":"'a' <= result <= 'z'"},{"assertion":"result == chr( (sum(ord(c) - ord('a') + 1 for c in strr) % 26) if (sum(ord(c) - ord('a') + 1 for c in strr) % 26) != 0 else ord('z') )"}],"assumptions":[]},{"id":"pc_14","description":"Test with a string that sums to exactly 26","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":2,"max_len":2,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"postconditions":[{"assertion":"result == 'z'"}],"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) == 26"]},{"id":"pc_15","description":"Test with a string that sums to exactly 52","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":2,"max_len":2,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"postconditions":[{"assertion":"result == 'z'"}],"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) == 52"]},{"id":"pc_16","description":"Test with a string that sums to 27","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":2,"max_len":2,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"postconditions":[{"assertion":"result == 'a'"}],"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) == 27"]},{"id":"pc_17","description":"Test with a string that sums to 25","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":2,"max_len":2,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"postconditions":[{"assertion":"result == 'y'"}],"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) == 25"]},{"id":"pc_18","description":"Test with a string that sums to 1","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":1,"max_len":1,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"postconditions":[{"assertion":"result == 'a'"}],"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) == 1"]},{"id":"pc_19","description":"Test with a string that sums to 2","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":1,"max_len":1,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"postconditions":[{"assertion":"result == 'b'"}],"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) == 2"]},{"id":"pc_20","description":"Test with a string that sums to 25","execution_statement":"result = get_Char(strr)","input_types":{"strr":"str"},"input_constraints":{"strr":{"min_len":1,"max_len":1,"alphabet":"abcdefghijklmnopqrstuvwxyz","max_codepoint":255}},"postconditions":[{"assertion":"result == 'y'"}],"assumptions":["sum(ord(c) - ord('a') + 1 for c in strr) == 25"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6140"},"test_cases":[{"id":"pc_1","description":"Base case n=1","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_2","description":"Base case n=2","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_3","description":"Small n > 2","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":3,"max_val":5}},"postconditions":[{"assertion":"result == sequence(sequence(n-1)) + sequence(n-sequence(n-1))"}]},{"id":"pc_4","description":"Typical case: n=10","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":10}},"postconditions":[{"assertion":"result == sequence(sequence(n-1)) + sequence(n-sequence(n-1))"}]},{"id":"pc_5","description":"Larger n to test recursion depth and memoization","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":15,"max_val":20}},"postconditions":[{"assertion":"result == sequence(sequence(n-1)) + sequence(n-sequence(n-1))"}]},{"id":"pc_6","description":"Postcondition: Result is always positive","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":25}},"postconditions":[{"assertion":"isinstance(result, int) and result > 0"}]},{"id":"pc_7","description":"Postcondition: Result for n=0 (if allowed by constraints)","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_8","description":"Negative Test: Invalid type (float)","execution_statement":"try: result = sequence(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: Invalid type (string)","execution_statement":"try: result = sequence(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Invalid type (None)","execution_statement":"try: result = sequence(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Check for exponential growth behavior (indirectly)","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":25,"max_val":30}},"postconditions":[{"assertion":"result == sequence(sequence(n-1)) + sequence(n-sequence(n-1))"}]},{"id":"pc_12","description":"Invariance: result for n=3","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"result == 2"}]},{"id":"pc_13","description":"Invariance: result for n=4","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":4,"max_val":4}},"postconditions":[{"assertion":"result == 4"}]},{"id":"pc_14","description":"Invariance: result for n=5","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"result == 6"}]},{"id":"pc_15","description":"Test with a slightly larger range to ensure recursion doesn't break","execution_statement":"result = sequence(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":20,"max_val":25}},"postconditions":[{"assertion":"result == sequence(sequence(n-1)) + sequence(n-sequence(n-1))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6141"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical positive integer radius","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"int"},"input_constraints":{"r":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"abs(result - (4 * math.pi * r**2)) < 1e-9"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Typical positive float radius","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":0.1,"max_val":1000.0,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"abs(result - (4 * math.pi * r**2)) < 1e-9"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Case: Radius of 0","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"int"},"input_constraints":{"r":{"value":0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Case: Radius of 1","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"int"},"input_constraints":{"r":{"value":1}},"postconditions":[{"assertion":"abs(result - (4 * math.pi)) < 1e-9"}],"assumptions":[]},{"id":"pc_5","description":"Boundary Case: Very small positive float radius","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":1E-09,"max_val":1E-09,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"abs(result - (4 * math.pi * r**2)) < 1e-18"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Case: Very large float radius","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":1E+09,"max_val":1E+09,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"abs(result - (4 * math.pi * r**2)) < 1e9"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Radius is a string","execution_statement":"try: result = surfacearea_sphere(r) except Exception as e: result = e","input_types":{"r":"str"},"input_constraints":{"r":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Radius is None","execution_statement":"try: result = surfacearea_sphere(r) except Exception as e: result = e","input_types":{"r":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Radius is a boolean","execution_statement":"try: result = surfacearea_sphere(r) except Exception as e: result = e","input_types":{"r":"bool"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Test with a list as input (should fail)","execution_statement":"try: result = surfacearea_sphere(r) except Exception as e: result = e","input_types":{"r":"list"},"input_constraints":{"r":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Test with a dictionary as input (should fail)","execution_statement":"try: result = surfacearea_sphere(r) except Exception as e: result = e","input_types":{"r":"dict"},"input_constraints":{"r":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Large integer radius","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"int"},"input_constraints":{"r":{"min_val":1000000,"max_val":1000000000}},"postconditions":[{"assertion":"abs(result - (4 * math.pi * r**2)) < 1e10"}],"assumptions":[]},{"id":"pc_13","description":"Smallest possible positive integer radius","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"int"},"input_constraints":{"r":{"value":1}},"postconditions":[{"assertion":"abs(result - (4 * math.pi)) < 1e-9"}],"assumptions":[]},{"id":"pc_14","description":"Radius close to zero (float)","execution_statement":"result = surfacearea_sphere(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_val":1E-15,"max_val":1E-15,"allow_nan":false,"allow_infinity":false}},"postconditions":[{"assertion":"abs(result - (4 * math.pi * r**2)) < 1e-30"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6142"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic calculation","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":0,"max_value":100}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: n = 0","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":0,"max_value":0}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: n = 1","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_4","description":"Happy Path: Larger n","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":100,"max_value":1000}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]},{"id":"pc_5","description":"Happy Path: Very large n","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":10000,"max_value":100000}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]},{"id":"pc_6","description":"Invariant: Monotonically increasing","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":1000}},"postconditions":[{"assertion":"result >= centered_hexagonal_number(n - 1)"}],"assumptions":[]},{"id":"pc_7","description":"Invariant: Difference between consecutive terms","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":1000}},"postconditions":[{"assertion":"result - centered_hexagonal_number(n - 1) == 6 * (n - 1)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Float input","execution_statement":"try: result = centered_hexagonal_number(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: String input","execution_statement":"try: result = centered_hexagonal_number(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: null input","execution_statement":"try: result = centered_hexagonal_number(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Negative integer input","execution_statement":"try: result = centered_hexagonal_number(n) except Exception as e: result = e","input_types":{"n":"int"},"input_constraints":{"n":{"max_value":-1}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_12","description":"Invariant: Relationship to triangular numbers (n>0)","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":1000}},"postconditions":[{"assertion":"result == (n * (n - 1) // 2) + (n * (n + 1) // 2)"}],"assumptions":[]},{"id":"pc_13","description":"Happy Path: Edge case n=2","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":2,"max_value":2}},"postconditions":[{"assertion":"result == 7"}],"assumptions":[]},{"id":"pc_14","description":"Happy Path: Edge case n=3","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":3,"max_value":3}},"postconditions":[{"assertion":"result == 19"}],"assumptions":[]},{"id":"pc_15","description":"Happy Path: Large n for formula check","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":500,"max_value":500}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]},{"id":"pc_16","description":"Invariant: Check formula with a specific large value","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":100000,"max_value":100000}},"postconditions":[{"assertion":"result == 3 * n * (n - 1) + 1"}],"assumptions":[]},{"id":"pc_17","description":"Invariant: Monotonicity check with consecutive large values","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":99999,"max_value":100000}},"postconditions":[{"assertion":"result >= centered_hexagonal_number(n - 1)"}],"assumptions":[]},{"id":"pc_18","description":"Invariant: Difference check with consecutive large values","execution_statement":"result = centered_hexagonal_number(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":100000,"max_value":100000}},"postconditions":[{"assertion":"result - centered_hexagonal_number(n - 1) == 6 * (n - 1)"}],"assumptions":[]},{"id":"pc_19","description":"Negative Test: Boolean input","execution_statement":"try: result = centered_hexagonal_number(n) except Exception as e: result = e","input_types":{"n":"bool"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_20","description":"Negative Test: List input","execution_statement":"try: result = centered_hexagonal_number(n) except Exception as e: result = e","input_types":{"n":"list"},"input_constraints":{"n":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6143"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic merge with distinct keys","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"integers","min_value":0,"max_value":100},"min_size":2,"max_size":5},"dict2":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"integers","min_value":0,"max_value":100},"min_size":2,"max_size":5},"dict3":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"integers","min_value":0,"max_value":100},"min_size":2,"max_size":5}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"},{"assertion":"len(result) == len(dict1) + len(dict2) + len(dict3)"}],"assumptions":["set(dict1.keys()).isdisjoint(dict2.keys())","set(dict1.keys()).isdisjoint(dict3.keys())","set(dict2.keys()).isdisjoint(dict3.keys())"]},{"id":"pc_2","description":"Happy Path: Merge with overlapping keys (dict3 precedence)","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"integers","min_value":0,"max_value":100},"min_size":2,"max_size":5},"dict2":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"integers","min_value":0,"max_value":100},"min_size":2,"max_size":5},"dict3":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"integers","min_value":0,"max_value":100},"min_size":2,"max_size":5}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"}],"assumptions":["not set(dict1.keys()).isdisjoint(dict2.keys())","not set(dict2.keys()).isdisjoint(dict3.keys())","not set(dict1.keys()).isdisjoint(dict3.keys())"]},{"id":"pc_3","description":"Edge Case: All dictionaries are empty","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_size":0,"max_size":0},"dict2":{"min_size":0,"max_size":0},"dict3":{"min_size":0,"max_size":0}},"postconditions":[{"assertion":"result == {}"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: First dictionary is empty","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_size":0,"max_size":0},"dict2":{"min_size":1,"max_size":5},"dict3":{"min_size":1,"max_size":5}},"postconditions":[{"assertion":"result == {**dict2, **dict3}"}],"assumptions":["set(dict2.keys()).isdisjoint(dict3.keys())"]},{"id":"pc_5","description":"Edge Case: Second dictionary is empty","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_size":1,"max_size":5},"dict2":{"min_size":0,"max_size":0},"dict3":{"min_size":1,"max_size":5}},"postconditions":[{"assertion":"result == {**dict1, **dict3}"}],"assumptions":["set(dict1.keys()).isdisjoint(dict3.keys())"]},{"id":"pc_6","description":"Edge Case: Third dictionary is empty","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"min_size":1,"max_size":5},"dict2":{"min_size":1,"max_size":5},"dict3":{"min_size":0,"max_size":0}},"postconditions":[{"assertion":"result == {**dict1, **dict2}"}],"assumptions":["set(dict1.keys()).isdisjoint(dict2.keys())"]},{"id":"pc_7","description":"Invariant: Original dictionaries are not modified","execution_statement":"original_dict1, original_dict2, original_dict3 = dict1.copy(), dict2.copy(), dict3.copy(); result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"integers","min_value":0,"max_value":100},"min_size":1,"max_size":5},"dict2":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"integers","min_value":0,"max_value":100},"min_size":1,"max_size":5},"dict3":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"integers","min_value":0,"max_value":100},"min_size":1,"max_size":5}},"postconditions":[{"assertion":"dict1 == original_dict1"},{"assertion":"dict2 == original_dict2"},{"assertion":"dict3 == original_dict3"}],"assumptions":[]},{"id":"pc_8","description":"Happy Path: Mixed value types","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":"any","is_mixed":true,"min_size":1,"max_size":5},"dict2":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":"any","is_mixed":true,"min_size":1,"max_size":5},"dict3":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":"any","is_mixed":true,"min_size":1,"max_size":5}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"}],"assumptions":[]},{"id":"pc_9","description":"Happy Path: Mixed key types (hashable)","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":"any","is_hashable_mix":true,"min_size":1,"max_size":5,"is_mixed":true},"dict2":{"keys":"any","is_hashable_mix":true,"min_size":1,"max_size":5,"is_mixed":true},"dict3":{"keys":"any","is_hashable_mix":true,"min_size":1,"max_size":5,"is_mixed":true}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"}],"assumptions":[]},{"id":"pc_10","description":"Edge Case: Large number of keys","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":{"elements":"integers","min_value":0,"max_value":10000},"values":{"elements":"integers","min_value":0,"max_value":10000},"min_size":500,"max_size":1000},"dict2":{"keys":{"elements":"integers","min_value":0,"max_value":10000},"values":{"elements":"integers","min_value":0,"max_value":10000},"min_size":500,"max_size":1000},"dict3":{"keys":{"elements":"integers","min_value":0,"max_value":10000},"values":{"elements":"integers","min_value":0,"max_value":10000},"min_size":500,"max_size":1000}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"}],"assumptions":[]},{"id":"pc_11","description":"Happy Path: Overlapping keys across all three dictionaries","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":{"elements":"integers","min_value":1,"max_value":10},"values":{"elements":"integers","min_value":0,"max_value":100},"min_size":3,"max_size":5},"dict2":{"keys":{"elements":"integers","min_value":1,"max_value":10},"values":{"elements":"integers","min_value":0,"max_value":100},"min_size":3,"max_size":5},"dict3":{"keys":{"elements":"integers","min_value":1,"max_value":10},"values":{"elements":"integers","min_value":0,"max_value":100},"min_size":3,"max_size":5}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Invalid type for dict1 (int)","execution_statement":"try: result = merge_dictionaries_three(dict1, dict2, dict3) except Exception as e: result = e","input_types":{"dict1":"int","dict2":"dict","dict3":"dict"},"input_constraints":{"dict2":{"min_size":1,"max_size":5},"dict3":{"min_size":1,"max_size":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Invalid type for dict2 (None)","execution_statement":"try: result = merge_dictionaries_three(dict1, dict2, dict3) except Exception as e: result = e","input_types":{"dict1":"dict","dict2":"None","dict3":"dict"},"input_constraints":{"dict1":{"min_size":1,"max_size":5},"dict3":{"min_size":1,"max_size":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Invalid type for dict3 (float)","execution_statement":"try: result = merge_dictionaries_three(dict1, dict2, dict3) except Exception as e: result = e","input_types":{"dict1":"dict","dict2":"dict","dict3":"float"},"input_constraints":{"dict1":{"min_size":1,"max_size":5},"dict2":{"min_size":1,"max_size":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Happy Path: Dictionaries with tuple values","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"tuples","min_size":1,"max_size":3},"min_size":1,"max_size":5},"dict2":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"tuples","min_size":1,"max_size":3},"min_size":1,"max_size":5},"dict3":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"tuples","min_size":1,"max_size":3},"min_size":1,"max_size":5}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"}],"assumptions":[]},{"id":"pc_16","description":"Happy Path: Dictionaries with nested dictionary values","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"dictionaries","min_size":1,"max_size":2},"min_size":1,"max_size":3},"dict2":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"dictionaries","min_size":1,"max_size":2},"min_size":1,"max_size":3},"dict3":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"dictionaries","min_size":1,"max_size":2},"min_size":1,"max_size":3}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"}],"assumptions":[]},{"id":"pc_17","description":"Happy Path: Dictionaries with None values","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"allow_none":true},"min_size":1,"max_size":5},"dict2":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"allow_none":true},"min_size":1,"max_size":5},"dict3":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"allow_none":true},"min_size":1,"max_size":5}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"}],"assumptions":[]},{"id":"pc_18","description":"Happy Path: Dictionaries with boolean values","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"booleans"},"min_size":1,"max_size":5},"dict2":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"booleans"},"min_size":1,"max_size":5},"dict3":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":{"elements":"booleans"},"min_size":1,"max_size":5}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"}],"assumptions":[]},{"id":"pc_19","description":"Happy Path: Dictionaries with mixed hashable keys and mixed values","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":"any","is_hashable_mix":true,"min_size":1,"max_size":5,"is_mixed":true},"dict2":{"keys":"any","is_hashable_mix":true,"min_size":1,"max_size":5,"is_mixed":true},"dict3":{"keys":"any","is_hashable_mix":true,"min_size":1,"max_size":5,"is_mixed":true}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"}],"assumptions":[]},{"id":"pc_20","description":"Happy Path: Dictionaries with overlapping keys and mixed value types","execution_statement":"result = merge_dictionaries_three(dict1, dict2, dict3)","input_types":{"dict1":"dict","dict2":"dict","dict3":"dict"},"input_constraints":{"dict1":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":"any","is_mixed":true,"min_size":2,"max_size":5},"dict2":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":"any","is_mixed":true,"min_size":2,"max_size":5},"dict3":{"keys":{"elements":"text","min_value":1,"max_value":5},"values":"any","is_mixed":true,"min_size":2,"max_size":5}},"postconditions":[{"assertion":"result == {**dict1, **dict2, **dict3}"}],"assumptions":["not set(dict1.keys()).isdisjoint(dict2.keys())","not set(dict2.keys()).isdisjoint(dict3.keys())"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6144"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list with integers","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[int]"},"input_constraints":{"list1":{"min_len":1,"max_len":50,"unique":false}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"set(result.keys()) == set(list1)"},{"assertion":"all(isinstance(count, int) and count > 0 for count in result.values())"},{"assertion":"sum(result.values()) == len(list1)"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: List with strings","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":1,"max_len":50,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"set(result.keys()) == set(list1)"},{"assertion":"all(isinstance(count, int) and count > 0 for count in result.values())"},{"assertion":"sum(result.values()) == len(list1)"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Empty list","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == {}"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: List with a single element","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[int]"},"input_constraints":{"list1":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == {list1[0]: 1}"}],"assumptions":[]},{"id":"pc_5","description":"Happy Path: List with mixed hashable types","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[Any]"},"input_constraints":{"list1":{"min_len":1,"max_len":50,"is_hashable_mix":true,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"set(result.keys()) == set(list1)"},{"assertion":"all(isinstance(count, int) and count > 0 for count in result.values())"},{"assertion":"sum(result.values()) == len(list1)"}],"assumptions":[]},{"id":"pc_6","description":"Happy Path: List with all duplicate elements","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":10,"unique":false}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"len(result) == 1"},{"assertion":"list(result.values())[0] == len(list1)"}],"assumptions":["len(set(list1)) == 1"]},{"id":"pc_7","description":"Happy Path: List with tuples","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[tuple[int, str]]"},"input_constraints":{"list1":{"min_len":1,"max_len":30,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"set(result.keys()) == set(list1)"},{"assertion":"all(isinstance(count, int) and count > 0 for count in result.values())"},{"assertion":"sum(result.values()) == len(list1)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = freq_count(list1) except Exception as e: result = e","input_types":{"list1":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = freq_count(list1) except Exception as e: result = e","input_types":{"list1":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: List contains unhashable type (list)","execution_statement":"try: result = freq_count(list1) except Exception as e: result = e","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: List contains unhashable type (dict)","execution_statement":"try: result = freq_count(list1) except Exception as e: result = e","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Happy Path: Large list of integers","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[int]"},"input_constraints":{"list1":{"min_len":100,"max_len":500}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"set(result.keys()) == set(list1)"},{"assertion":"all(isinstance(count, int) and count > 0 for count in result.values())"},{"assertion":"sum(result.values()) == len(list1)"}],"assumptions":[]},{"id":"pc_13","description":"Happy Path: List with boolean values","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[bool]"},"input_constraints":{"list1":{"min_len":1,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"set(result.keys()) == set(list1)"},{"assertion":"all(isinstance(count, int) and count > 0 for count in result.values())"},{"assertion":"sum(result.values()) == len(list1)"}],"assumptions":[]},{"id":"pc_14","description":"Happy Path: List with None values","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[Optional[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":50,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"set(result.keys()) == set(list1)"},{"assertion":"all(isinstance(count, int) and count > 0 for count in result.values())"},{"assertion":"sum(result.values()) == len(list1)"}],"assumptions":[]},{"id":"pc_15","description":"Happy Path: List with floats","execution_statement":"result = freq_count(list1)","input_types":{"list1":"list[float]"},"input_constraints":{"list1":{"min_len":1,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, dict)"},{"assertion":"set(result.keys()) == set(list1)"},{"assertion":"all(isinstance(count, int) and count > 0 for count in result.values())"},{"assertion":"sum(result.values()) == len(list1)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6145"},"test_cases":[{"id":"pc_1","description":"Happy Path: Small positive integer","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Larger positive integer","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":100,"max_val":1000}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Input is 1","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Input is 0","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == -1"}],"assumptions":[]},{"id":"pc_5","description":"Negative Test: Float input","execution_statement":"try: result = closest_num(N) except Exception as e: result = e","input_types":{"N":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: String input","execution_statement":"try: result = closest_num(N) except Exception as e: result = e","input_types":{"N":"str"},"input_constraints":{"N":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: null input","execution_statement":"try: result = closest_num(N) except Exception as e: result = e","input_types":{"N":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Large integer input","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":1000000,"max_val":2000000}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_9","description":"Input near maximum integer value (if applicable)","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"max_val":2147483647}},"postconditions":[{"assertion":"result == N - 1"}],"assumptions":[]},{"id":"pc_10","description":"Input near minimum integer value (positive)","execution_statement":"result = closest_num(N)","input_types":{"N":"int"},"input_constraints":{"N":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6146"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list of strings","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":20}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_2","description":"Edge Case: List with empty strings","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":0,"max_len":20}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_3","description":"Edge Case: List with single-character strings","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":1}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_4","description":"Edge Case: List with very long strings","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":5,"elements":{"min_len":50,"max_len":100}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_5","description":"Edge Case: List with all strings of the same length","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":5,"max_len":5}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_6","description":"Edge Case: List with mixed string lengths","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":20},"is_mixed":true}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_7","description":"Negative Test: Input is not a list","execution_statement":"try: result = len_log(list1) except Exception as e: result = e","input_types":{"list1":"int"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_8","description":"Negative Test: Input is a list with non-string elements (integers)","execution_statement":"try: result = len_log(list1) except Exception as e: result = e","input_types":{"list1":"list[int]"},"input_constraints":{"list1":{"min_len":2,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: Input is a list with non-string elements (floats)","execution_statement":"try: result = len_log(list1) except Exception as e: result = e","input_types":{"list1":"list[float]"},"input_constraints":{"list1":{"min_len":2,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Input is a list with non-string elements (None)","execution_statement":"try: result = len_log(list1) except Exception as e: result = e","input_types":{"list1":"list[Optional[str]]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Edge Case: List with only one string","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":1,"max_len":1,"elements":{"min_len":1,"max_len":20}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_12","description":"Edge Case: List with strings containing special characters","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":20,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{};':\",./<>?"}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_13","description":"Edge Case: List with very short strings and one very long string","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":50}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_14","description":"Edge Case: List with strings containing only whitespace","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":5,"alphabet":" \t\n\r"}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_15","description":"Edge Case: List with a mix of empty and non-empty strings","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":0,"max_len":20}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_16","description":"Edge Case: List with very few elements but long strings","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":2,"elements":{"min_len":100,"max_len":200}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_17","description":"Edge Case: List with many elements but very short strings","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":50,"max_len":100,"elements":{"min_len":1,"max_len":1}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_18","description":"Negative Test: Input is an empty list","execution_statement":"try: result = len_log(list1) except Exception as e: result = e","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_19","description":"Edge Case: List with strings containing unicode characters","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":1,"max_len":20,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{};':\",./<>?"}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]},{"id":"pc_20","description":"Edge Case: List with strings of varying lengths including zero","execution_statement":"result = len_log(list1)","input_types":{"list1":"list[str]"},"input_constraints":{"list1":{"min_len":2,"max_len":10,"elements":{"min_len":0,"max_len":30}}},"postconditions":[{"assertion":"result == max(len(s) for s in list1)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6147"},"test_cases":[{"id":"pc_1","description":"Happy Path: Substring present in one of the list elements","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":1,"max_len":10,"max_codepoint":127},"substring":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["substring in string_list[0]"]},{"id":"pc_2","description":"Happy Path: Substring present in multiple list elements","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":2,"max_len":10,"max_codepoint":127},"substring":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["substring in string_list[0]","substring in string_list[1]"]},{"id":"pc_3","description":"Happy Path: Substring not present in any list element","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":1,"max_len":10,"max_codepoint":127},"substring":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["substring not in string_list[0]"]},{"id":"pc_4","description":"Edge Case: Empty string list","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":0,"max_len":0,"max_codepoint":127},"substring":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Empty substring","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":1,"max_len":10,"max_codepoint":127},"substring":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Empty substring and empty string list","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":0,"max_len":0,"max_codepoint":127},"substring":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: Substring is longer than any string in the list","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":1,"max_len":10,"max_codepoint":127},"substring":{"min_len":6,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["len(substring) > len(s) for s in string_list"]},{"id":"pc_8","description":"Edge Case: List contains empty strings, substring is not empty","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":1,"max_len":10,"max_codepoint":127},"substring":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["'' in string_list"]},{"id":"pc_9","description":"Edge Case: List contains empty strings, substring is empty","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":1,"max_len":10,"max_codepoint":127},"substring":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["'' in string_list"]},{"id":"pc_10","description":"Typical Case: Mixed length strings and substring","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":3,"max_len":15,"is_mixed":true,"max_codepoint":127},"substring":{"min_len":1,"max_len":7,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == any(substring in s for s in string_list)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Invalid type for string_list (int)","execution_statement":"try: result = find_substring(string_list, substring) except Exception as e: result = e","input_types":{"string_list":"int","substring":"str"},"input_constraints":{"substring":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Invalid type for substring (int)","execution_statement":"try: result = find_substring(string_list, substring) except Exception as e: result = e","input_types":{"string_list":"list[str]","substring":"int"},"input_constraints":{"string_list":{"min_len":1,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Invalid type for elements in string_list (int)","execution_statement":"try: result = find_substring(string_list, substring) except Exception as e: result = e","input_types":{"string_list":"list[int]","substring":"str"},"input_constraints":{"substring":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Edge Case: Substring is the entire string in the list","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":1,"max_len":10,"max_codepoint":127},"substring":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["substring in string_list"]},{"id":"pc_15","description":"Edge Case: Substring at the beginning of a list element","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":1,"max_len":10,"max_codepoint":127},"substring":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["string_list[0].startswith(substring)"]},{"id":"pc_16","description":"Edge Case: Substring at the end of a list element","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":1,"max_len":10,"max_codepoint":127},"substring":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["string_list[0].endswith(substring)"]},{"id":"pc_17","description":"Typical Case: Long strings and substring","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":5,"max_len":20,"max_codepoint":127},"substring":{"min_len":3,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"result == any(substring in s for s in string_list)"}],"assumptions":[]},{"id":"pc_18","description":"Edge Case: List with only one element, substring present","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":1,"max_len":1,"max_codepoint":127},"substring":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":["substring in string_list[0]"]},{"id":"pc_19","description":"Edge Case: List with only one element, substring not present","execution_statement":"result = find_substring(string_list, substring)","input_types":{"string_list":"list[str]","substring":"str"},"input_constraints":{"string_list":{"min_len":1,"max_len":1,"max_codepoint":127},"substring":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["substring not in string_list[0]"]},{"id":"pc_20","description":"Negative Test: Invalid type for string_list (None)","execution_statement":"try: result = find_substring(string_list, substring) except Exception as e: result = e","input_types":{"string_list":"None","substring":"str"},"input_constraints":{"substring":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6148"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic undulating number","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":101,"max_val":999}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Longer undulating number","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10101,"max_val":99999}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: Undulating number with negative sign","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-999,"max_val":-101}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Negative Test: Non-undulating number (consecutive digits)","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":110,"max_val":999}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"Negative Test: Non-undulating number (pattern break)","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":123,"max_val":987}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Single digit number (should be False based on code)","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":9}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: Two digit number (should be False based on code)","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":99}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_8","description":"Edge Case: Two digit number with same digits (should be False)","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":11,"max_val":99}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Zero","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Invalid Type (float)","execution_statement":"try: result = is_undulating(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Invalid Type (string)","execution_statement":"try: result = is_undulating(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Invalid Type (None)","execution_statement":"try: result = is_undulating(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Happy Path: Large undulating number","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1010101,"max_val":9999999}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Large non-undulating number (pattern break)","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1234567,"max_val":9876543}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: Large non-undulating number (consecutive digits)","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1122334,"max_val":9988776}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_16","description":"Happy Path: Alternating pattern with zeros (e.g., 10101)","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10101,"max_val":90909}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_17","description":"Negative Test: Pattern break with zeros (e.g., 10201)","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10201,"max_val":90809}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_18","description":"Negative Test: Number with only two distinct digits alternating but not undulating (e.g., 12131)","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":12131,"max_val":98979}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_19","description":"Happy Path: Undulating number with negative sign and zeros","execution_statement":"result = is_undulating(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":-90909,"max_val":-10101}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_20","description":"Negative Test: Invalid Type (list)","execution_statement":"try: result = is_undulating(n) except Exception as e: result = e","input_types":{"n":"list"},"input_constraints":{"n":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6149"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical positive base and exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":2,"max_val":100},"b":{"min_val":2,"max_val":10}},"postconditions":[{"assertion":"result == a ** b"}]},{"id":"pc_2","description":"Happy Path: Base is 1","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"value":1},"b":{"min_val":0,"max_val":100}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_3","description":"Happy Path: Exponent is 0","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":100},"b":{"value":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_4","description":"Happy Path: Base is 0, positive exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"value":0},"b":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_5","description":"Happy Path: Negative base, even exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":-2},"b":{"min_val":2,"max_val":10,"step":2}},"postconditions":[{"assertion":"result == a ** b"},{"assertion":"result > 0"}]},{"id":"pc_6","description":"Happy Path: Negative base, odd exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":-2},"b":{"min_val":1,"max_val":9,"step":2}},"postconditions":[{"assertion":"result == a ** b"},{"assertion":"result < 0"}]},{"id":"pc_7","description":"Happy Path: Base is -1, even exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"value":-1},"b":{"min_val":2,"max_val":100,"step":2}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_8","description":"Happy Path: Base is -1, odd exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"value":-1},"b":{"min_val":1,"max_val":99,"step":2}},"postconditions":[{"assertion":"result == -1"}]},{"id":"pc_9","description":"Edge Case: Large exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":2,"max_val":5},"b":{"min_val":11,"max_val":20}},"postconditions":[{"assertion":"result == a ** b"}]},{"id":"pc_10","description":"Edge Case: Large base","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":101,"max_val":1000},"b":{"min_val":2,"max_val":5}},"postconditions":[{"assertion":"result == a ** b"}]},{"id":"pc_11","description":"Negative Test: Invalid type for exponent (float)","execution_statement":"try: result = power(a, b) except Exception as e: result = e","input_types":{"a":"int","b":"float"},"input_constraints":{"a":{"min_val":1,"max_val":10},"b":{"min_val":1.0,"max_val":5.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: Invalid type for exponent (string)","execution_statement":"try: result = power(a, b) except Exception as e: result = e","input_types":{"a":"int","b":"str"},"input_constraints":{"a":{"min_val":1,"max_val":10},"b":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Negative Test: Invalid type for base (None)","execution_statement":"try: result = power(a, b) except Exception as e: result = e","input_types":{"a":"None","b":"int"},"input_constraints":{"b":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Negative Test: Exponent is negative (violates precondition)","execution_statement":"try: result = power(a, b) except Exception as e: result = e","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":2,"max_val":10},"b":{"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, ValueError) or isinstance(result, TypeError)"}]},{"id":"pc_15","description":"Edge Case: Base is 0, exponent is 0","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"value":0},"b":{"value":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_16","description":"Edge Case: Base is 1, exponent is 0","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"value":1},"b":{"value":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_17","description":"Edge Case: Base is -1, exponent is 0","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"value":-1},"b":{"value":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_18","description":"Large numbers: Base and exponent","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":1000,"max_val":10000},"b":{"min_val":5,"max_val":10}},"postconditions":[{"assertion":"result == a ** b"}]},{"id":"pc_19","description":"Very large exponent (potential for overflow if not handled)","execution_statement":"result = power(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"value":2},"b":{"min_val":30,"max_val":60}},"postconditions":[{"assertion":"result == a ** b"}]},{"id":"pc_20","description":"Negative Test: Invalid type for base (list)","execution_statement":"try: result = power(a, b) except Exception as e: result = e","input_types":{"a":"list","b":"int"},"input_constraints":{"a":{"min_len":1,"max_len":5},"b":{"min_val":1,"max_val":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc614a"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list of tuples","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":0,"max_val":100}}},"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == min(test_list, key=lambda x: x[1])[0]"}]},{"id":"pc_2","description":"Edge Case: Empty list","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"max_len":0}},"execution_statement":"try: result = index_minimum(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, ValueError)"}]},{"id":"pc_3","description":"Edge Case: Single element list","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":1}},"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == test_list[0][0]"}]},{"id":"pc_4","description":"Edge Case: All second values are the same","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":10,"elements":{"min_val":5,"max_val":5}}},"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == test_list[0][0]"}]},{"id":"pc_5","description":"Edge Case: Smallest second value is negative","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":-100,"max_val":100}}},"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == min(test_list, key=lambda x: x[1])[0]"}]},{"id":"pc_6","description":"Edge Case: Smallest second value is zero","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":0,"max_val":0}}},"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == test_list[0][0]"}]},{"id":"pc_7","description":"Edge Case: Multiple tuples with the same smallest second value","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":10,"elements":{"min_val":5,"max_val":10}}},"assumptions":["test_list[0][1] == 5","test_list[1][1] == 5"],"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == test_list[0][0]"}]},{"id":"pc_8","description":"Edge Case: First element of tuple is not an integer","input_types":{"test_list":"list[tuple[str, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":0,"max_val":100}}},"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == min(test_list, key=lambda x: x[1])[0]"}]},{"id":"pc_9","description":"Negative Test: Invalid type for second element (float)","input_types":{"test_list":"list[tuple[int, float]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5}},"execution_statement":"try: result = index_minimum(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Invalid type for second element (string)","input_types":{"test_list":"list[tuple[int, str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5}},"execution_statement":"try: result = index_minimum(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Negative Test: Invalid type for second element (None)","input_types":{"test_list":"list[tuple[int, None]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5}},"execution_statement":"try: result = index_minimum(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: Input is not a list (int)","input_types":{"test_list":"int"},"execution_statement":"try: result = index_minimum(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Negative Test: Input is not a list (None)","input_types":{"test_list":"None"},"execution_statement":"try: result = index_minimum(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Edge Case: Large numbers for second value","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"elements":{"min_val":1000000000,"max_val":2000000000}}},"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == min(test_list, key=lambda x: x[1])[0]"}]},{"id":"pc_15","description":"Edge Case: First element of tuple is a different hashable type (float)","input_types":{"test_list":"list[tuple[float, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":0,"max_val":100}}},"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == min(test_list, key=lambda x: x[1])[0]"}]},{"id":"pc_16","description":"Edge Case: First element of tuple is a different hashable type (string)","input_types":{"test_list":"list[tuple[str, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":0,"max_val":100}}},"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == min(test_list, key=lambda x: x[1])[0]"}]},{"id":"pc_17","description":"Edge Case: First element of tuple is None","input_types":{"test_list":"list[tuple[None, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":0,"max_val":100}}},"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == min(test_list, key=lambda x: x[1])[0]"}]},{"id":"pc_18","description":"Edge Case: Mixed hashable types for first element","input_types":{"test_list":"list[tuple[any, int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"elements":{"min_val":0,"max_val":100},"hashable_mix":true,"is_mixed":true}},"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == min(test_list, key=lambda x: x[1])[0]"}]},{"id":"pc_19","description":"Edge Case: Smallest second value is at the beginning","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":10,"elements":{"min_val":10,"max_val":20}}},"assumptions":["test_list[0][1] == 5"],"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == test_list[0][0]"}]},{"id":"pc_20","description":"Edge Case: Smallest second value is at the end","input_types":{"test_list":"list[tuple[int, int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":10,"elements":{"min_val":10,"max_val":20}}},"assumptions":["test_list[-1][1] == 5"],"execution_statement":"result = index_minimum(test_list)","postconditions":[{"assertion":"result == test_list[-1][0]"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc614b"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list of lists with varying lengths","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"list[list[int]]"},"input_constraints":{"list_of_lists":{"min_len":1,"max_len":10,"items":{"min_len":1,"max_len":10}}},"postconditions":[{"assertion":"result == min(len(sublist) for sublist in list_of_lists)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty outer list","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"list[list[int]]"},"input_constraints":{"list_of_lists":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List contains empty sublists","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"list[list[int]]"},"input_constraints":{"list_of_lists":{"min_len":1,"max_len":10,"items":{"min_len":0,"max_len":10}}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: All sublists are empty","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"list[list[int]]"},"input_constraints":{"list_of_lists":{"min_len":1,"max_len":10,"items":{"min_len":0,"max_len":0}}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_5","description":"Happy Path: All sublists have the same length","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"list[list[int]]"},"input_constraints":{"list_of_lists":{"min_len":1,"max_len":10,"items":{"min_len":5,"max_len":5}}},"postconditions":[{"assertion":"result == 5"}],"assumptions":[]},{"id":"pc_6","description":"Happy Path: Sublists with single elements","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"list[list[int]]"},"input_constraints":{"list_of_lists":{"min_len":1,"max_len":10,"items":{"min_len":1,"max_len":1}}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_7","description":"Large number of sublists","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"list[list[int]]"},"input_constraints":{"list_of_lists":{"min_len":100,"max_len":200,"items":{"min_len":1,"max_len":5}}},"postconditions":[{"assertion":"result == min(len(sublist) for sublist in list_of_lists)"}],"assumptions":[]},{"id":"pc_8","description":"Sublists with large number of elements","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"list[list[int]]"},"input_constraints":{"list_of_lists":{"min_len":1,"max_len":5,"items":{"min_len":100,"max_len":200}}},"postconditions":[{"assertion":"result == min(len(sublist) for sublist in list_of_lists)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = Find_Min_Length(list_of_lists) except Exception as e: result = e","input_types":{"list_of_lists":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = Find_Min_Length(list_of_lists) except Exception as e: result = e","input_types":{"list_of_lists":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Outer list contains non-list element (int)","execution_statement":"try: result = Find_Min_Length(list_of_lists) except Exception as e: result = e","input_types":{"list_of_lists":"list"},"input_constraints":{"list_of_lists":{"min_len":2,"max_len":5,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Outer list contains non-list element (str)","execution_statement":"try: result = Find_Min_Length(list_of_lists) except Exception as e: result = e","input_types":{"list_of_lists":"list"},"input_constraints":{"list_of_lists":{"min_len":2,"max_len":5,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Mixed types in sublists (should still work if sublists are lists)","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"list[list]"},"input_constraints":{"list_of_lists":{"min_len":1,"max_len":10,"items":{"min_len":1,"max_len":10,"is_mixed":true},"is_mixed":true}},"postconditions":[{"assertion":"result == min(len(sublist) for sublist in list_of_lists)"}],"assumptions":[]},{"id":"pc_14","description":"List with one sublist of length 0","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"list[list[int]]"},"input_constraints":{"list_of_lists":{"min_len":1,"max_len":1,"items":{"min_len":0,"max_len":0}}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_15","description":"List with one sublist of length 1","execution_statement":"result = Find_Min_Length(list_of_lists)","input_types":{"list_of_lists":"list[list[int]]"},"input_constraints":{"list_of_lists":{"min_len":1,"max_len":1,"items":{"min_len":1,"max_len":1}}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc614c"},"test_cases":[{"id":"pc_1","description":"Happy Path: Small positive integer","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":10}},"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == len([i for i in range(1, n + 1) if n % i == 0])"}]},{"id":"pc_2","description":"Happy Path: Prime number (should have 2 divisors)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":2,"max_value":100}},"assumptions":["all(n % i != 0 for i in range(2, int(n**0.5) + 1))"],"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == 2"}]},{"id":"pc_3","description":"Happy Path: Perfect square (should have odd number of divisors)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":100}},"assumptions":["int(n**0.5)**2 == n"],"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result % 2 == 1"}]},{"id":"pc_4","description":"Happy Path: Larger positive integer","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":100,"max_value":1000}},"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == len([i for i in range(1, n + 1) if n % i == 0])"}]},{"id":"pc_5","description":"Edge Case: Smallest valid input (n=1)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":1}},"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == 1"}]},{"id":"pc_6","description":"Edge Case: Highly composite number","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":100}},"assumptions":["n in [12, 24, 36, 48, 60, 72, 84, 96]"],"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == len([i for i in range(1, n + 1) if n % i == 0])"}]},{"id":"pc_7","description":"Negative Test: Zero input (expecting TypeError due to range)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":0,"max_value":0}},"execution_statement":"try: result = divisor(n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, ZeroDivisionError)"}]},{"id":"pc_8","description":"Negative Test: Float input (expecting TypeError)","input_types":{"n":"float"},"input_constraints":{},"execution_statement":"try: result = divisor(n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: String input (expecting TypeError)","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"execution_statement":"try: result = divisor(n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: null input (expecting TypeError)","input_types":{"n":"None"},"input_constraints":{},"execution_statement":"try: result = divisor(n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Large input to check performance and correctness","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1000,"max_value":10000}},"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == len([i for i in range(1, n + 1) if n % i == 0])"}]},{"id":"pc_12","description":"Input with many divisors","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":500}},"assumptions":["n in [720, 840, 960, 1080, 1200]"],"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == len([i for i in range(1, n + 1) if n % i == 0])"}]},{"id":"pc_13","description":"Input that is a power of 2","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":1024}},"assumptions":["(n > 0) and (n & (n - 1) == 0)"],"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == (n.bit_length())"}]},{"id":"pc_14","description":"Input that is a power of a prime","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":1000}},"assumptions":["n in [8, 16, 27, 32, 64, 81, 125, 243, 256, 343, 512, 625, 729, 1000]"],"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == len([i for i in range(1, n + 1) if n % i == 0])"}]},{"id":"pc_15","description":"Input with a large number of divisors","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":5000}},"assumptions":["n in [2520, 5040, 7560, 10080]"],"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == len([i for i in range(1, n + 1) if n % i == 0])"}]},{"id":"pc_16","description":"Input with a small number of divisors (prime)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":2,"max_value":1000}},"assumptions":["all(n % i != 0 for i in range(2, int(n**0.5) + 1))"],"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == 2"}]},{"id":"pc_17","description":"Input with exactly 3 divisors (square of a prime)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":100}},"assumptions":["n in [4, 9, 25, 49]"],"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == 3"}]},{"id":"pc_18","description":"Input with exactly 4 divisors (p^3 or p*q)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":100}},"assumptions":["n in [6, 8, 10, 14, 15, 21, 22, 26, 27, 33, 34, 35, 38, 39, 46, 51, 55, 57, 58, 62, 65, 69, 77, 82, 85, 86, 87, 91, 93, 94, 95]"],"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == 4"}]},{"id":"pc_19","description":"Input with a large prime number","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1000,"max_value":5000}},"assumptions":["all(n % i != 0 for i in range(2, int(n**0.5) + 1))"],"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result == 2"}]},{"id":"pc_20","description":"Input with a large perfect square","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":10000,"max_value":20000}},"assumptions":["int(n**0.5)**2 == n"],"execution_statement":"result = divisor(n)","postconditions":[{"assertion":"result % 2 == 1"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc614d"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list of lists with integers","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"element_type":"int","min_val":-100,"max_val":100}}},"execution_statement":"result = frequency_lists(list1)","postconditions":[{"assertion":"all(isinstance(key, int) for key in result.keys()) and all(isinstance(value, int) for value in result.values()) and all(value >= 0 for value in result.values())"}]},{"id":"pc_2","description":"Edge Case: Empty list of lists","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":0,"max_len":0}},"execution_statement":"result = frequency_lists(list1)","postconditions":[{"assertion":"result == {}"}]},{"id":"pc_3","description":"Edge Case: List with empty sublists","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_len":0,"max_len":0}}},"execution_statement":"result = frequency_lists(list1)","postconditions":[{"assertion":"result == {}"}]},{"id":"pc_4","description":"Edge Case: List with mixed empty and non-empty sublists","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_len":0,"max_len":5,"element_type":"int","min_val":-100,"max_val":100},"is_mixed":true}},"execution_statement":"result = frequency_lists(list1)","postconditions":[{"assertion":"all(isinstance(key, int) for key in result.keys()) and all(isinstance(value, int) for value in result.values()) and all(value >= 0 for value in result.values())"}]},{"id":"pc_5","description":"Edge Case: List with single element sublists","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_len":1,"max_len":1,"element_type":"int","min_val":-100,"max_val":100}}},"execution_statement":"result = frequency_lists(list1)","postconditions":[{"assertion":"all(isinstance(key, int) for key in result.keys()) and all(isinstance(value, int) for value in result.values()) and all(value >= 0 for value in result.values())"}]},{"id":"pc_6","description":"Edge Case: All elements are the same","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"element_type":"int","min_val":5,"max_val":5}}},"execution_statement":"result = frequency_lists(list1)","postconditions":[{"assertion":"all(isinstance(key, int) for key in result.keys()) and all(isinstance(value, int) for value in result.values()) and all(value >= 0 for value in result.values())"}]},{"id":"pc_7","description":"Edge Case: Large integer values","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"element_type":"int","min_val":-1000000,"max_val":1000000}}},"execution_statement":"result = frequency_lists(list1)","postconditions":[{"assertion":"all(isinstance(key, int) for key in result.keys()) and all(isinstance(value, int) for value in result.values()) and all(value >= 0 for value in result.values())"}]},{"id":"pc_8","description":"Happy Path: Mixed data types (integers, strings, booleans, floats, None)","input_types":{"list1":"list[list[Any]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"is_hashable_mix":true},"is_mixed":true}},"execution_statement":"result = frequency_lists(list1)","postconditions":[{"assertion":"all(isinstance(key, (int, str, float, bool, type(None))) for key in result.keys()) and all(isinstance(value, int) for value in result.values()) and all(value >= 0 for value in result.values())"}]},{"id":"pc_9","description":"Edge Case: List with strings, including empty strings","input_types":{"list1":"list[list[str]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_len":0,"max_len":10}}},"execution_statement":"result = frequency_lists(list1)","postconditions":[{"assertion":"all(isinstance(key, str) for key in result.keys()) and all(isinstance(value, int) for value in result.values()) and all(value >= 0 for value in result.values())"}]},{"id":"pc_10","description":"Edge Case: List with only booleans and None","input_types":{"list1":"list[list[Any]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"element_type":"one_of","values":["True","False","None"]}}},"execution_statement":"result = frequency_lists(list1)","postconditions":[{"assertion":"all(isinstance(key, (bool, type(None))) for key in result.keys()) and all(isinstance(value, int) for value in result.values()) and all(value >= 0 for value in result.values())"}]},{"id":"pc_11","description":"Negative Test: Invalid input type (integer instead of list)","input_types":{"list1":"int"},"input_constraints":{},"execution_statement":"try: result = frequency_lists(list1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: Invalid input type (None instead of list)","input_types":{"list1":"None"},"input_constraints":{},"execution_statement":"try: result = frequency_lists(list1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Negative Test: Sublist contains unhashable type (list)","input_types":{"list1":"list[list[Any]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_len":1,"max_len":5,"element_type":"one_of","values":["integers(min_val=-100, max_val=100)","lists(integers(min_val=-100, max_val=100), min_size=1, max_size=1)"]}}},"execution_statement":"result = frequency_lists(list1)","postconditions":[{"assertion":"all(isinstance(key, (int, tuple)) for key in result.keys()) and all(isinstance(value, int) for value in result.values()) and all(value >= 0 for value in result.values())"}]},{"id":"pc_14","description":"Happy Path: Deeply nested lists","input_types":{"list1":"list[list[list[int]]]"},"input_constraints":{"list1":{"min_len":1,"max_len":2,"element_constraints":{"min_len":1,"max_len":2,"element_type":"list","element_constraints":{"min_len":1,"max_len":2,"element_type":"int","min_val":-50,"max_val":50}}}},"execution_statement":"result = frequency_lists(list1)","postconditions":[{"assertion":"all(isinstance(key, int) for key in result.keys()) and all(isinstance(value, int) for value in result.values()) and all(value >= 0 for value in result.values())"}]},{"id":"pc_15","description":"Happy Path: Large number of elements","input_types":{"list1":"list[list[int]]"},"input_constraints":{"list1":{"min_len":10,"max_len":20,"element_constraints":{"min_len":10,"max_len":20,"element_type":"int","min_val":-10,"max_val":10}}},"execution_statement":"result = frequency_lists(list1)","postconditions":[{"assertion":"all(isinstance(key, int) for key in result.keys()) and all(isinstance(value, int) for value in result.values()) and all(value >= 0 for value in result.values())"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc614e"},"test_cases":[{"id":"pc_1","description":"Happy Path: List of positive integers","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":1,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == expected_product / len(numbers)"}]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"try: result = multiply_num(numbers) except Exception as e: result = e","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"max_len":0}},"postconditions":[{"assertion":"isinstance(result, ZeroDivisionError)"}]},{"id":"pc_3","description":"Edge Case: List with zero","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":0,"max_val":100}},"assumptions":["0 in numbers"],"postconditions":[{"assertion":"result == 0.0"}]},{"id":"pc_4","description":"Happy Path: List with negative integers","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == expected_product / len(numbers)"}]},{"id":"pc_5","description":"Happy Path: Mixed positive and negative integers","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":-100,"max_val":100,"is_mixed":true}},"assumptions":["not (all(n > 0 for n in numbers) or all(n < 0 for n in numbers))"],"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == expected_product / len(numbers)"}]},{"id":"pc_6","description":"Happy Path: List with floating-point numbers","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":0.1,"max_val":100.0}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"abs(result - (expected_product / len(numbers))) < 1e-9"}]},{"id":"pc_7","description":"Edge Case: List with a single element","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == numbers[0]"}]},{"id":"pc_8","description":"Invariant: Result is non-negative if all inputs are non-negative","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":0,"max_val":100}},"assumptions":["all(n >= 0 for n in numbers)"],"postconditions":[{"assertion":"result >= 0"}]},{"id":"pc_9","description":"Negative Test: Invalid input type (string)","execution_statement":"try: result = multiply_num(numbers) except Exception as e: result = e","input_types":{"numbers":"str"},"input_constraints":{"numbers":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Invalid input type (float)","execution_statement":"try: result = multiply_num(numbers) except Exception as e: result = e","input_types":{"numbers":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Negative Test: Invalid input type (None)","execution_statement":"try: result = multiply_num(numbers) except Exception as e: result = e","input_types":{"numbers":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Happy Path: List with large positive integers","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":5,"min_val":1000000,"max_val":10000000}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"result == expected_product / len(numbers)"}]},{"id":"pc_13","description":"Happy Path: List with small positive floats","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":1E-06,"max_val":0.01}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"abs(result - (expected_product / len(numbers))) < 1e-9"}]},{"id":"pc_14","description":"Invariant: Result is zero if list contains zero and is not empty","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10,"min_val":-100,"max_val":100}},"assumptions":["0 in numbers"],"postconditions":[{"assertion":"result == 0.0"}]},{"id":"pc_15","description":"Happy Path: List with only zeros","execution_statement":"result = multiply_num(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":10}},"assumptions":["all(n == 0 for n in numbers)"],"postconditions":[{"assertion":"result == 0.0"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc614f"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic conversion","execution_statement":"result = decimal_to_binary(decimal_number)","input_types":{"decimal_number":"int"},"input_constraints":{"decimal_number":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == bin(decimal_number).replace('0b', '')"},{"assertion":"result.startswith('1')"},{"assertion":"all(c in '01' for c in result)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Input is zero","execution_statement":"result = decimal_to_binary(decimal_number)","input_types":{"decimal_number":"int"},"input_constraints":{"decimal_number":{"just":0}},"postconditions":[{"assertion":"result == '0'"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Power of two","execution_statement":"result = decimal_to_binary(decimal_number)","input_types":{"decimal_number":"int"},"input_constraints":{"decimal_number":{"min_val":2,"max_val":1024,"step":2}},"postconditions":[{"assertion":"result == bin(decimal_number).replace('0b', '')"},{"assertion":"result.startswith('1')"},{"assertion":"result.endswith('0')"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: One less than a power of two","execution_statement":"result = decimal_to_binary(decimal_number)","input_types":{"decimal_number":"int"},"input_constraints":{"decimal_number":{"min_val":1,"max_val":1023,"step":2}},"postconditions":[{"assertion":"result == bin(decimal_number).replace('0b', '')"},{"assertion":"result.startswith('1')"},{"assertion":"result.endswith('1')"}],"assumptions":[]},{"id":"pc_5","description":"Large number conversion","execution_statement":"result = decimal_to_binary(decimal_number)","input_types":{"decimal_number":"int"},"input_constraints":{"decimal_number":{"min_val":10000,"max_val":1000000}},"postconditions":[{"assertion":"result == bin(decimal_number).replace('0b', '')"},{"assertion":"result.startswith('1')"},{"assertion":"all(c in '01' for c in result)"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: Float input","execution_statement":"try: result = decimal_to_binary(decimal_number) except Exception as e: result = e","input_types":{"decimal_number":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: String input","execution_statement":"try: result = decimal_to_binary(decimal_number) except Exception as e: result = e","input_types":{"decimal_number":"str"},"input_constraints":{"decimal_number":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: null input","execution_statement":"try: result = decimal_to_binary(decimal_number) except Exception as e: result = e","input_types":{"decimal_number":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Invariant: Output contains only '0' and '1'","execution_statement":"result = decimal_to_binary(decimal_number)","input_types":{"decimal_number":"int"},"input_constraints":{"decimal_number":{"min_val":0,"max_val":10000}},"postconditions":[{"assertion":"all(c in '01' for c in result)"}],"assumptions":[]},{"id":"pc_10","description":"Invariant: Positive input does not start with '0'","execution_statement":"result = decimal_to_binary(decimal_number)","input_types":{"decimal_number":"int"},"input_constraints":{"decimal_number":{"min_val":1,"max_val":10000}},"postconditions":[{"assertion":"not result.startswith('0')"}],"assumptions":[]},{"id":"pc_11","description":"Invariant: Value preservation for positive numbers","execution_statement":"result = decimal_to_binary(decimal_number)","input_types":{"decimal_number":"int"},"input_constraints":{"decimal_number":{"min_val":1,"max_val":10000}},"postconditions":[{"assertion":"int(result, 2) == decimal_number"}],"assumptions":[]},{"id":"pc_12","description":"Invariant: Value preservation for zero","execution_statement":"result = decimal_to_binary(decimal_number)","input_types":{"decimal_number":"int"},"input_constraints":{"decimal_number":{"just":0}},"postconditions":[{"assertion":"result == '0'"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6150"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic integer","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Integer that is already a palindrome","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":10,"max_val":1000,"pattern":"^(101|111|121|131|141|151|161|171|181|191|202|212|222|232|242|252|262|272|282|292|303|313|323|333|343|353|363|373|383|393|404|414|424|434|444|454|464|474|484|494|505|515|525|535|545|555|565|575|585|595|606|616|626|636|646|656|666|676|686|696|707|717|727|737|747|757|767|777|787|797|808|818|828|838|848|858|868|878|888|898|909|919|929|939|949|959|969|979|989|999)$"}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: Numbers ending in 9","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":1,"max_val":1000,"pattern":".*9$"}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_4","description":"Happy Path: All 9s","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":9,"max_val":999,"pattern":"^9+$"}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_5","description":"Happy Path: Larger numbers","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":1000,"max_val":100000}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_6","description":"Happy Path: Numbers close to a palindrome boundary","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":120,"max_val":130}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_7","description":"Happy Path: Numbers requiring carry-over","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":199,"max_val":201}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_8","description":"Happy Path: Single digit numbers","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":1,"max_val":8}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_9","description":"Happy Path: Smallest palindrome after single digit","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":9,"max_val":9}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_10","description":"Happy Path: Smallest palindrome after two digit palindrome","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":11,"max_val":11}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_11","description":"Happy Path: Smallest palindrome after three digit palindrome","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":121,"max_val":121}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_12","description":"Happy Path: Large number with many digits","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":123456789,"max_val":1234567890}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_13","description":"Happy Path: Number close to sys.maxsize","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":2147483640,"max_val":2147483647}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Zero input","execution_statement":"try: result = next_smallest_palindrome(num) except Exception as e: result = e","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: Float input","execution_statement":"try: result = next_smallest_palindrome(num) except Exception as e: result = e","input_types":{"num":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: String input","execution_statement":"try: result = next_smallest_palindrome(num) except Exception as e: result = e","input_types":{"num":"str"},"input_constraints":{"num":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Negative Test: null input","execution_statement":"try: result = next_smallest_palindrome(num) except Exception as e: result = e","input_types":{"num":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_18","description":"Negative Test: List input","execution_statement":"try: result = next_smallest_palindrome(num) except Exception as e: result = e","input_types":{"num":"list[int]"},"input_constraints":{"num":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_19","description":"Happy Path: Smallest palindrome after 8","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":8,"max_val":8}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]},{"id":"pc_20","description":"Happy Path: Smallest palindrome after 98","execution_statement":"result = next_smallest_palindrome(num)","input_types":{"num":"int"},"input_constraints":{"num":{"min_val":98,"max_val":98}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result > num"},{"assertion":"str(result) == str(result)[::-1]"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6151"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list and k","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"min_value":-1000,"max_value":1000},"k":{"min_value":1,"max_value":10}},"assumptions":["k <= len(arr)"],"execution_statement":"result = kth_element(arr, k)","postconditions":[{"assertion":"result == sorted(arr)[k-1]"}]},{"id":"pc_2","description":"Edge Case: k is 1 (smallest element)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"min_value":-1000,"max_value":1000},"k":{"min_value":1,"max_value":1}},"assumptions":["k <= len(arr)"],"execution_statement":"result = kth_element(arr, k)","postconditions":[{"assertion":"result == sorted(arr)[k-1]"}]},{"id":"pc_3","description":"Edge Case: k is equal to list length (largest element)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"min_value":-1000,"max_value":1000}},"assumptions":["k == len(arr)"],"execution_statement":"result = kth_element(arr, k)","postconditions":[{"assertion":"result == sorted(arr)[k-1]"}]},{"id":"pc_4","description":"Edge Case: List with all same elements","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"min_value":5,"max_value":5},"k":{"min_value":1,"max_value":10}},"assumptions":["k <= len(arr)"],"execution_statement":"result = kth_element(arr, k)","postconditions":[{"assertion":"result == sorted(arr)[k-1]"}]},{"id":"pc_5","description":"Edge Case: List with negative numbers","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"min_value":-1000,"max_value":-1},"k":{"min_value":1,"max_value":10}},"assumptions":["k <= len(arr)"],"execution_statement":"result = kth_element(arr, k)","postconditions":[{"assertion":"result == sorted(arr)[k-1]"}]},{"id":"pc_6","description":"Edge Case: List with duplicate elements","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"min_value":-1000,"max_value":1000},"k":{"min_value":1,"max_value":10}},"assumptions":["k <= len(arr)"],"execution_statement":"result = kth_element(arr, k)","postconditions":[{"assertion":"result == sorted(arr)[k-1]"}]},{"id":"pc_7","description":"Edge Case: Single element list","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":1,"max_len":1,"min_value":-1000,"max_value":1000},"k":{"min_value":1,"max_value":1}},"assumptions":["k <= len(arr)"],"execution_statement":"result = kth_element(arr, k)","postconditions":[{"assertion":"result == sorted(arr)[k-1]"}]},{"id":"pc_8","description":"Negative Test: k is out of bounds (too large)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":10,"min_value":-1000,"max_value":1000},"k":{"min_value":11,"max_value":20}},"execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_9","description":"Negative Test: k is out of bounds (zero)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":10,"min_value":-1000,"max_value":1000},"k":{"min_value":0,"max_value":0}},"execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_10","description":"Negative Test: Empty list","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":0,"max_len":0},"k":{"min_value":1,"max_value":1}},"execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_11","description":"Negative Test: Invalid type for arr (string)","input_types":{"arr":"str","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":10,"max_codepoint":255},"k":{"min_value":1,"max_value":5}},"execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: Invalid type for k (float)","input_types":{"arr":"list[int]","k":"float"},"input_constraints":{"arr":{"min_len":5,"max_len":10,"min_value":-1000,"max_value":1000},"k":{"min_value":1.0,"max_value":5.0}},"execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Negative Test: Invalid type for k (string)","input_types":{"arr":"list[int]","k":"str"},"input_constraints":{"arr":{"min_len":5,"max_len":10,"min_value":-1000,"max_value":1000},"k":{"min_len":1,"max_len":5,"max_codepoint":255}},"execution_statement":"try: result = kth_element(arr, k) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Edge Case: Large numbers","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"min_value":1000000,"max_value":10000000},"k":{"min_value":1,"max_value":10}},"assumptions":["k <= len(arr)"],"execution_statement":"result = kth_element(arr, k)","postconditions":[{"assertion":"result == sorted(arr)[k-1]"}]},{"id":"pc_15","description":"Edge Case: Small numbers (close to zero)","input_types":{"arr":"list[int]","k":"int"},"input_constraints":{"arr":{"min_len":5,"max_len":20,"min_value":-10,"max_value":10},"k":{"min_value":1,"max_value":10}},"assumptions":["k <= len(arr)"],"execution_statement":"result = kth_element(arr, k)","postconditions":[{"assertion":"result == sorted(arr)[k-1]"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6152"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical snake_case string","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+(?:_[a-z-9]+)*$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() or '_' for x in word.split('_'))"},{"assertion":"not result.startswith('_') and not result.endswith('_')"},{"assertion":"all(w.lower() in result.lower() for w in word.split('_'))"},{"assertion":"'_' not in result"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Single word (no underscores)","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == word"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: String with numbers","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9_]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() or '_' for x in word.split('_'))"},{"assertion":"'_' not in result"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: String starting with underscore","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^_[a-z-9_]*$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() or '_' for x in word.split('_'))"},{"assertion":"not result.startswith('_')"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: String ending with underscore","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9_]*_$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() or '_' for x in word.split('_'))"},{"assertion":"not result.endswith('_')"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: String with consecutive underscores","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9_]*__+[a-z-9_]*$","min_len":2,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() or '_' for x in word.split('_'))"},{"assertion":"'_' not in result"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Integer input","execution_statement":"try: result = snake_to_camel(word) except Exception as e: result = e","input_types":{"word":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Float input","execution_statement":"try: result = snake_to_camel(word) except Exception as e: result = e","input_types":{"word":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: null input","execution_statement":"try: result = snake_to_camel(word) except Exception as e: result = e","input_types":{"word":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_11","description":"Edge Case: Mixed numbers and underscores","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9_]+$","min_len":1,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() or '_' for x in word.split('_'))"},{"assertion":"'_' not in result"},{"assertion":"any(c.isdigit() for c in word) == any(c.isdigit() for c in result)"}],"assumptions":[]},{"id":"pc_12","description":"Long snake_case string","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-z-9]+(?:_[a-z-9]+)*$","min_len":50,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() or '_' for x in word.split('_'))"},{"assertion":"'_' not in result"}],"assumptions":[]},{"id":"pc_13","description":"Snake_case with only numbers","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[-9_]+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() or '_' for x in word.split('_'))"},{"assertion":"'_' not in result"}],"assumptions":[]},{"id":"pc_14","description":"Snake_case with only underscores (should result in empty string)","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^_+$","min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''"}],"assumptions":[]},{"id":"pc_15","description":"Snake_case with mixed case letters (should be converted to lowercase first by split)","execution_statement":"result = snake_to_camel(word)","input_types":{"word":"str"},"input_constraints":{"word":{"pattern":"^[a-zA-Z-9_]+$","min_len":1,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == ''.join(x.capitalize() or '_' for x in word.lower().split('_'))"},{"assertion":"'_' not in result"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6153"},"test_cases":[{"id":"pc_1","description":"Typical case: n=5, m=2","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":0,"max_val":15},"m":{"min_val":0,"max_val":15}},"postconditions":[{"assertion":"result == 16"}],"assumptions":[]},{"id":"pc_2","description":"Boundary case: m > n","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":1,"max_val":15},"m":{"min_val":16,"max_val":30}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Boundary case: m = 0, n > 0","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":1,"max_val":15},"m":{"just":0}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_4","description":"Boundary case: n = 0","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"just":0},"m":{"min_val":0,"max_val":15}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_5","description":"Symmetry check: a(n, k) == a(n, n - 1 - k)","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":2,"max_val":15},"m":{"min_val":0,"max_val":15}},"postconditions":[{"assertion":"result == eulerian_num(n, n - 1 - m)"}],"assumptions":["m < n"]},{"id":"pc_6","description":"Sum of Eulerian numbers equals n!","execution_statement":"result = sum(eulerian_num(n, k) for k in range(n))","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == math.factorial(n)"}],"assumptions":[]},{"id":"pc_7","description":"Large n, small m","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":10,"max_val":20},"m":{"min_val":0,"max_val":2}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_8","description":"Large n, m close to n","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":10,"max_val":20},"m":{"min_val":8,"max_val":15}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":["m < n"]},{"id":"pc_9","description":"Negative Test: Invalid type for n (float)","execution_statement":"try: result = eulerian_num(n, m) except Exception as e: result = e","input_types":{"n":"float","m":"int"},"input_constraints":{"n":{"min_val":0.0,"max_val":15.0},"m":{"min_val":0,"max_val":15}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Invalid type for m (string)","execution_statement":"try: result = eulerian_num(n, m) except Exception as e: result = e","input_types":{"n":"int","m":"str"},"input_constraints":{"n":{"min_val":0,"max_val":15},"m":{"min_len":1,"max_len":5,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Boundary case: n=1, m=0","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"just":1},"m":{"just":0}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_12","description":"Boundary case: n=1, m=1 (m >= n)","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"just":1},"m":{"just":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_13","description":"Large n, m = n-1","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":10,"max_val":20},"m":{"builds":"lambda n_val: n_val - 1","n_val":{"min_val":10,"max_val":20}}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_14","description":"Symmetry check with m=0","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":2,"max_val":15},"m":{"just":0}},"postconditions":[{"assertion":"result == eulerian_num(n, n - 1 - m)"}],"assumptions":[]},{"id":"pc_15","description":"Symmetry check with m=n-1","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":2,"max_val":15},"m":{"builds":"lambda n_val: n_val - 1","n_val":{"min_val":2,"max_val":15}}},"postconditions":[{"assertion":"result == eulerian_num(n, n - 1 - m)"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: Invalid type for n (None)","execution_statement":"try: result = eulerian_num(n, m) except Exception as e: result = e","input_types":{"n":"None","m":"int"},"input_constraints":{"m":{"min_val":0,"max_val":15}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Negative Test: Invalid type for m (None)","execution_statement":"try: result = eulerian_num(n, m) except Exception as e: result = e","input_types":{"n":"int","m":"None"},"input_constraints":{"n":{"min_val":0,"max_val":15}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_18","description":"Large n, m slightly less than n","execution_statement":"result = eulerian_num(n, m)","input_types":{"n":"int","m":"int"},"input_constraints":{"n":{"min_val":15,"max_val":25},"m":{"builds":"lambda n_val: n_val - 2","n_val":{"min_val":15,"max_val":25}}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":["m >= 0"]},{"id":"pc_19","description":"Sum of Eulerian numbers for n=1","execution_statement":"result = sum(eulerian_num(n, k) for k in range(n))","input_types":{"n":"int"},"input_constraints":{"n":{"just":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_20","description":"Sum of Eulerian numbers for n=2","execution_statement":"result = sum(eulerian_num(n, k) for k in range(n))","input_types":{"n":"int"},"input_constraints":{"n":{"just":2}},"postconditions":[{"assertion":"result == 2"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6154"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list of lists with strings","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":10,"max_codepoint":127},"input_list_of_lists.item":{"min_len":0,"max_len":5},"input_list_of_lists.item.item":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, list) and all(isinstance(sublist, list) for sublist in result)"},{"assertion":"all(isinstance(item, str) for sublist in result for item in sublist)"},{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"},{"assertion":"len(result) == len(input_list_of_lists)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty outer list","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":0,"max_len":0,"max_codepoint":127}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Inner lists are empty","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"max_codepoint":127},"input_list_of_lists.item":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == [[] for _ in input_list_of_lists]"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Mixed empty and non-empty inner lists","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"is_mixed":true,"max_codepoint":127},"input_list_of_lists.item":{"min_len":0,"max_len":5,"is_mixed":true},"input_list_of_lists.item.item":{"min_len":1,"max_len":10,"is_mixed":true}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"},{"assertion":"len(result) == len(input_list_of_lists)"}],"assumptions":[]},{"id":"pc_5","description":"Strings with numbers and special characters","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"max_codepoint":127},"input_list_of_lists.item":{"min_len":1,"max_len":5},"input_list_of_lists.item.item":{"min_len":1,"max_len":10,"pattern":"^[a-zA-Z-9_!@#$%^&*()+-=<>?,./;':\"{}\\[\\]|\\~` ]+$"}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"}],"assumptions":[]},{"id":"pc_6","description":"Strings with mixed case","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"is_mixed":true,"max_codepoint":127},"input_list_of_lists.item":{"min_len":1,"max_len":5,"is_mixed":true},"input_list_of_lists.item.item":{"min_len":1,"max_len":10,"pattern":"^[a-zA-Z]+$","is_mixed":true}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"}],"assumptions":[]},{"id":"pc_7","description":"Long strings and many sublists","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":50,"max_len":100,"max_codepoint":127},"input_list_of_lists.item":{"min_len":10,"max_len":20},"input_list_of_lists.item.item":{"min_len":50,"max_len":100}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"},{"assertion":"len(result) == len(input_list_of_lists)"}],"assumptions":[]},{"id":"pc_8","description":"List with duplicate strings within sublists","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"max_codepoint":127},"input_list_of_lists.item":{"min_len":2,"max_len":5},"input_list_of_lists.item.item":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"}],"assumptions":[]},{"id":"pc_9","description":"List with single-element sublists","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"max_codepoint":127},"input_list_of_lists.item":{"min_len":1,"max_len":1},"input_list_of_lists.item.item":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"}],"assumptions":[]},{"id":"pc_10","description":"List with sublists containing only one type of character","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"max_codepoint":127},"input_list_of_lists.item":{"min_len":1,"max_len":5},"input_list_of_lists.item.item":{"min_len":1,"max_len":10,"pattern":"^[a]+$"}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"}],"assumptions":[]},{"id":"pc_11","description":"List with sublists containing only numbers as strings","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"max_codepoint":127},"input_list_of_lists.item":{"min_len":1,"max_len":5},"input_list_of_lists.item.item":{"min_len":1,"max_len":10,"pattern":"^[-9]+$"}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"}],"assumptions":[]},{"id":"pc_12","description":"List with sublists containing unicode characters","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"max_codepoint":127},"input_list_of_lists.item":{"min_len":1,"max_len":5},"input_list_of_lists.item.item":{"min_len":1,"max_len":10,"pattern":"^[\\w\\s\\p{L}\\p{N}]+$"}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"}],"assumptions":[]},{"id":"pc_13","description":"List with sublists containing strings that are already sorted","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"max_codepoint":127},"input_list_of_lists.item":{"min_len":1,"max_len":5},"input_list_of_lists.item.item":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"result == input_list_of_lists"}],"assumptions":["all(sublist == sorted(sublist) for sublist in input_list_of_lists)"]},{"id":"pc_14","description":"List with sublists containing strings that are reverse sorted","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"max_codepoint":127},"input_list_of_lists.item":{"min_len":1,"max_len":5},"input_list_of_lists.item.item":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"},{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"}],"assumptions":["all(sublist == sorted(sublist, reverse=True) for sublist in input_list_of_lists)"]},{"id":"pc_15","description":"List with sublists containing strings with leading/trailing spaces","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"max_codepoint":127},"input_list_of_lists.item":{"min_len":1,"max_len":5},"input_list_of_lists.item.item":{"min_len":1,"max_len":10,"pattern":"^\\s*[a-zA-Z-9_]+\\s*$"}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"}],"assumptions":[]},{"id":"pc_16","description":"List with sublists containing strings with internal spaces","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"max_codepoint":127},"input_list_of_lists.item":{"min_len":1,"max_len":5},"input_list_of_lists.item.item":{"min_len":1,"max_len":10,"pattern":"^[a-zA-Z-9_ ]+$"}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"}],"assumptions":[]},{"id":"pc_17","description":"List with sublists containing very short strings","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"max_codepoint":127},"input_list_of_lists.item":{"min_len":1,"max_len":5},"input_list_of_lists.item.item":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"}],"assumptions":[]},{"id":"pc_18","description":"List with sublists containing very long strings","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":5,"max_codepoint":127},"input_list_of_lists.item":{"min_len":1,"max_len":5},"input_list_of_lists.item.item":{"min_len":100,"max_len":200}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"}],"assumptions":[]},{"id":"pc_19","description":"List with a single large sublist","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":1,"max_len":1,"max_codepoint":127},"input_list_of_lists.item":{"min_len":50,"max_len":100},"input_list_of_lists.item.item":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"}],"assumptions":[]},{"id":"pc_20","description":"List with many small sublists","execution_statement":"result = sort_sublists(input_list_of_lists)","input_types":{"input_list_of_lists":"list[list[str]]"},"input_constraints":{"input_list_of_lists":{"min_len":50,"max_len":100,"max_codepoint":127},"input_list_of_lists.item":{"min_len":1,"max_len":3},"input_list_of_lists.item.item":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"all(set(sublist_in) == set(sublist_out) for sublist_in, sublist_out in zip(input_list_of_lists, result))"},{"assertion":"all(sublist_out == sorted(sublist_out) for sublist_out in result)"},{"assertion":"len(result) == len(input_list_of_lists)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6155"},"test_cases":[{"id":"pc_1","description":"Happy Path: List of booleans","execution_statement":"result = count(lst)","input_types":{"lst":"list[bool]"},"input_constraints":{"lst":{"min_len":1,"max_len":100}},"postconditions":[{"assertion":"result == sum(1 for x in lst if x is True)"},{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result <= len(lst)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = count(lst)","input_types":{"lst":"list[bool]"},"input_constraints":{"lst":{"max_len":0}},"postconditions":[{"assertion":"result == 0"},{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with only True values","execution_statement":"result = count(lst)","input_types":{"lst":"list[bool]"},"input_constraints":{"lst":{"min_len":1,"max_len":50,"elements":"st.just(True)"}},"postconditions":[{"assertion":"result == len(lst)"},{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: List with only False values","execution_statement":"result = count(lst)","input_types":{"lst":"list[bool]"},"input_constraints":{"lst":{"min_len":1,"max_len":50,"elements":"st.just(False)"}},"postconditions":[{"assertion":"result == 0"},{"assertion":"isinstance(result, int)"}],"assumptions":[]},{"id":"pc_5","description":"Large list with mixed booleans","execution_statement":"result = count(lst)","input_types":{"lst":"list[bool]"},"input_constraints":{"lst":{"min_len":100,"max_len":1000,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(1 for x in lst if x is True)"},{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result <= len(lst)"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = count(lst) except Exception as e: result = e","input_types":{"lst":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = count(lst) except Exception as e: result = e","input_types":{"lst":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: List contains non-boolean types (string)","execution_statement":"try: result = count(lst) except Exception as e: result = e","input_types":{"lst":"list[str]"},"input_constraints":{"lst":{"min_len":1,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: List contains non-boolean types (integer)","execution_statement":"try: result = count(lst) except Exception as e: result = e","input_types":{"lst":"list[int]"},"input_constraints":{"lst":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: List contains mixed types including non-booleans","execution_statement":"try: result = count(lst) except Exception as e: result = e","input_types":{"lst":"list[Any]"},"input_constraints":{"lst":{"min_len":1,"max_len":10,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6156"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic list and tuple addition","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10},"test_tup":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"max_len":0},"test_tup":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_tup)"},{"assertion":"result == tuple(list(test_tup))"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Empty tuple","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10},"test_tup":{"max_len":0}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list)"},{"assertion":"result == tuple(test_list)"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Both empty","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"max_len":0},"test_tup":{"max_len":0}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == 0"},{"assertion":"result == tuple()"}],"assumptions":[]},{"id":"pc_5","description":"Mixed Types: List with strings and integers","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[Union[int, str]]","test_tup":"tuple[Union[int, str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"is_mixed":true,"max_codepoint":127},"test_tup":{"min_len":1,"max_len":10,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_6","description":"Mixed Types: Tuple with strings and integers","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[Union[int, str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"is_mixed":true},"test_tup":{"min_len":1,"max_len":10,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_7","description":"Mixed Types: Both list and tuple with mixed types","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[Union[int, str, bool]]","test_tup":"tuple[Union[int, str, bool]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"is_mixed":true,"max_codepoint":127},"test_tup":{"min_len":1,"max_len":10,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Invalid type for test_list (float)","execution_statement":"try: result = add_lists(test_list, test_tup) except Exception as e: result = e","input_types":{"test_list":"float","test_tup":"tuple[int]"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Invalid type for test_tup (string)","execution_statement":"try: result = add_lists(test_list, test_tup) except Exception as e: result = e","input_types":{"test_list":"list[int]","test_tup":"str"},"input_constraints":{"test_tup":{"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Invalid type for test_list (None)","execution_statement":"try: result = add_lists(test_list, test_tup) except Exception as e: result = e","input_types":{"test_list":"None","test_tup":"tuple[int]"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Invalid type for test_tup (integer)","execution_statement":"try: result = add_lists(test_list, test_tup) except Exception as e: result = e","input_types":{"test_list":"list[int]","test_tup":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Large inputs: Long list and tuple","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1000,"max_len":5000},"test_tup":{"min_len":1000,"max_len":5000}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_13","description":"List with None values","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[Optional[int]]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"allow_none":true},"test_tup":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_14","description":"Tuple with None values","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[Optional[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10},"test_tup":{"min_len":1,"max_len":10,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_15","description":"List with booleans","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[bool]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10},"test_tup":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_16","description":"Tuple with booleans","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[bool]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10},"test_tup":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_17","description":"List with floats","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[float]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10},"test_tup":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_18","description":"Tuple with floats","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[float]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10},"test_tup":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_19","description":"List with tuples","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[tuple[int]]","test_tup":"tuple[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"test_tup":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]},{"id":"pc_20","description":"Tuple with lists","execution_statement":"result = add_lists(test_list, test_tup)","input_types":{"test_list":"list[int]","test_tup":"tuple[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5},"test_tup":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, tuple)"},{"assertion":"len(result) == len(test_list) + len(test_tup)"},{"assertion":"result == tuple(list(test_tup) + test_list)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6157"},"test_cases":[{"id":"pc_1","description":"Happy Path: Three typical sorted integer lists.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: One or more empty lists.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"max_len":0,"sorted":"ascending"},"num2":{"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Two empty lists.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"max_len":0,"sorted":"ascending"},"num2":{"max_len":0,"sorted":"ascending"},"num3":{"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: All three lists are empty.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"max_len":0,"sorted":"ascending"},"num2":{"max_len":0,"sorted":"ascending"},"num3":{"max_len":0,"sorted":"ascending"}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_5","description":"Lists with duplicate elements.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_len":1,"max_len":10,"sorted":"ascending","unique":false},"num2":{"min_len":1,"max_len":10,"sorted":"ascending","unique":false},"num3":{"min_len":1,"max_len":10,"sorted":"ascending","unique":false}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":[]},{"id":"pc_6","description":"Lists with negative numbers.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_val":-100,"max_val":100,"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_val":-100,"max_val":100,"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_val":-100,"max_val":100,"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":[]},{"id":"pc_7","description":"Lists with large numbers.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_val":1000000,"max_val":10000000,"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_val":1000000,"max_val":10000000,"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_val":1000000,"max_val":10000000,"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":[]},{"id":"pc_8","description":"Lists with mixed comparable types (int and float).","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[Union[int, float]]","num2":"list[Union[int, float]]","num3":"list[Union[int, float]]"},"input_constraints":{"num1":{"min_len":1,"max_len":10,"sorted":"ascending","elements":{"type":"one_of","values":["int","float"]},"is_mixed":true},"num2":{"min_len":1,"max_len":10,"sorted":"ascending","elements":{"type":"one_of","values":["int","float"]},"is_mixed":true},"num3":{"min_len":1,"max_len":10,"sorted":"ascending","elements":{"type":"one_of","values":["int","float"]},"is_mixed":true}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":[]},{"id":"pc_9","description":"Lists with string elements.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[str]","num2":"list[str]","num3":"list[str]"},"input_constraints":{"num1":{"min_len":1,"max_len":10,"sorted":"ascending","max_codepoint":127},"num2":{"min_len":1,"max_len":10,"sorted":"ascending","max_codepoint":127},"num3":{"min_len":1,"max_len":10,"sorted":"ascending","max_codepoint":127}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":[]},{"id":"pc_10","description":"Lists with single element.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_len":1,"max_len":1,"sorted":"ascending"},"num2":{"min_len":1,"max_len":1,"sorted":"ascending"},"num3":{"min_len":1,"max_len":1,"sorted":"ascending"}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Invalid input type (int for num1).","execution_statement":"try: result = merge_sorted_list(num1, num2, num3) except Exception as e: result = e","input_types":{"num1":"int","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num2":{"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Invalid input type (None for num2).","execution_statement":"try: result = merge_sorted_list(num1, num2, num3) except Exception as e: result = e","input_types":{"num1":"list[int]","num2":"None","num3":"list[int]"},"input_constraints":{"num1":{"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Invalid input type (float for num3).","execution_statement":"try: result = merge_sorted_list(num1, num2, num3) except Exception as e: result = e","input_types":{"num1":"list[int]","num2":"list[int]","num3":"float"},"input_constraints":{"num1":{"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Lists with elements that are not directly comparable (e.g., int and str).","execution_statement":"try: result = merge_sorted_list(num1, num2, num3) except Exception as e: result = e","input_types":{"num1":"list[Union[int, str]]","num2":"list[Union[int, str]]","num3":"list[Union[int, str]]"},"input_constraints":{"num1":{"min_len":1,"max_len":5,"elements":{"type":"one_of","values":["int","str"],"max_codepoint":127},"max_codepoint":127},"num2":{"min_len":1,"max_len":5,"elements":{"type":"one_of","values":["int","str"],"max_codepoint":127},"max_codepoint":127},"num3":{"min_len":1,"max_len":5,"elements":{"type":"one_of","values":["int","str"],"max_codepoint":127},"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Large lists with many elements.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_len":0,"max_len":2500,"sorted":"ascending"},"num2":{"min_len":0,"max_len":2500,"sorted":"ascending"},"num3":{"min_len":0,"max_len":2500,"sorted":"ascending"}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":[]},{"id":"pc_16","description":"Lists with zero.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_val":-10,"max_val":10,"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_val":-10,"max_val":10,"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_val":-10,"max_val":10,"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":[]},{"id":"pc_17","description":"Lists with identical elements across all three.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_val":1,"max_val":5,"min_len":3,"max_len":5,"sorted":"ascending","unique":true},"num2":{"min_val":1,"max_val":5,"min_len":3,"max_len":5,"sorted":"ascending","unique":true},"num3":{"min_val":1,"max_val":5,"min_len":3,"max_len":5,"sorted":"ascending","unique":true}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":["num1 == num2","num2 == num3"]},{"id":"pc_18","description":"Lists with some overlapping elements.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_val":1,"max_val":20,"min_len":5,"max_len":10,"sorted":"ascending"},"num2":{"min_val":1,"max_val":20,"min_len":5,"max_len":10,"sorted":"ascending"},"num3":{"min_val":1,"max_val":20,"min_len":5,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":["len(set(num1) & set(num2)) > 0","len(set(num1) & set(num3)) > 0","len(set(num2) & set(num3)) > 0"]},{"id":"pc_19","description":"Lists with disjoint elements.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_val":1,"max_val":10,"min_len":5,"max_len":5,"sorted":"ascending","unique":true},"num2":{"min_val":11,"max_val":20,"min_len":5,"max_len":5,"sorted":"ascending","unique":true},"num3":{"min_val":21,"max_val":30,"min_len":5,"max_len":5,"sorted":"ascending","unique":true}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":[]},{"id":"pc_20","description":"Lists with a mix of positive, negative, and zero values.","execution_statement":"result = merge_sorted_list(num1, num2, num3)","input_types":{"num1":"list[int]","num2":"list[int]","num3":"list[int]"},"input_constraints":{"num1":{"min_val":-50,"max_val":50,"min_len":1,"max_len":10,"sorted":"ascending"},"num2":{"min_val":-50,"max_val":50,"min_len":1,"max_len":10,"sorted":"ascending"},"num3":{"min_val":-50,"max_val":50,"min_len":1,"max_len":10,"sorted":"ascending"}},"postconditions":[{"assertion":"result == sorted(num1 + num2 + num3)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6158"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic binary string and rotations","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"alphabet":"01","min_len":1,"max_codepoint":255},"n":{"min_val":0}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == sum(1 for i in range(min(len(s), n)) if s[i] == '1')"},{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}]},{"id":"pc_2","description":"Edge Case: Zero rotations","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"alphabet":"01","min_len":1,"max_codepoint":255},"n":{"value":0}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == sum(1 for i in range(min(len(s), n)) if s[i] == '1')"},{"assertion":"result == 0"}]},{"id":"pc_3","description":"Edge Case: Rotations equal to string length","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"alphabet":"01","min_len":1,"max_codepoint":255},"n":{"min_val":1}},"assumptions":["n == len(s)"],"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == sum(1 for i in range(min(len(s), n)) if s[i] == '1')"},{"assertion":"result == s.count('1')"}]},{"id":"pc_4","description":"Edge Case: Rotations greater than string length","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"alphabet":"01","min_len":1,"max_codepoint":255},"n":{"min_val":1}},"assumptions":["n > len(s)"],"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == sum(1 for i in range(min(len(s), n)) if s[i] == '1')"},{"assertion":"result == s.count('1')"}]},{"id":"pc_5","description":"Edge Case: String with all '0's","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"value":"00000","min_len":1,"max_codepoint":255},"n":{"min_val":0}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_6","description":"Edge Case: String with all '1's","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"value":"11111","min_len":1,"max_codepoint":255},"n":{"min_val":0}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == sum(1 for i in range(min(len(s), n)) if s[i] == '1')"},{"assertion":"result == min(len(s), n)"}]},{"id":"pc_7","description":"Edge Case: Single character string '0'","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"value":"0","max_codepoint":255},"n":{"min_val":0}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_8","description":"Edge Case: Single character string '1'","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"value":"1","max_codepoint":255},"n":{"min_val":0}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == sum(1 for i in range(min(len(s), n)) if s[i] == '1')"},{"assertion":"result == min(1, n)"}]},{"id":"pc_9","description":"Negative Test: Invalid type for string argument (int)","input_types":{"s":"int","n":"int"},"input_constraints":{"n":{"min_val":0}},"execution_statement":"try: result = odd_Equivalent(s, n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Invalid type for string argument (float)","input_types":{"s":"float","n":"int"},"input_constraints":{"n":{"min_val":0}},"execution_statement":"try: result = odd_Equivalent(s, n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Negative Test: Invalid type for rotations argument (float)","input_types":{"s":"str","n":"float"},"input_constraints":{"s":{"alphabet":"01","min_len":1,"max_codepoint":255}},"execution_statement":"try: result = odd_Equivalent(s, n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: Invalid type for rotations argument (str)","input_types":{"s":"str","n":"str"},"input_constraints":{"s":{"alphabet":"01","min_len":1,"max_codepoint":255},"n":{"min_len":1,"max_codepoint":255}},"execution_statement":"try: result = odd_Equivalent(s, n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Large number of rotations","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"alphabet":"01","min_len":1,"max_len":100,"max_codepoint":255},"n":{"min_val":1000,"max_val":2000}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == sum(1 for i in range(min(len(s), n)) if s[i] == '1')"},{"assertion":"result >= 0"}]},{"id":"pc_14","description":"Long binary string","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"alphabet":"01","min_len":100,"max_len":200,"max_codepoint":255},"n":{"min_val":0,"max_val":50}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == sum(1 for i in range(min(len(s), n)) if s[i] == '1')"},{"assertion":"result >= 0"}]},{"id":"pc_15","description":"String with mixed '0' and '1' and moderate rotations","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"alphabet":"01","min_len":10,"max_len":50,"is_mixed":true,"max_codepoint":255},"n":{"min_val":5,"max_val":20,"is_mixed":true}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == sum(1 for i in range(min(len(s), n)) if s[i] == '1')"}]},{"id":"pc_16","description":"Rotations equal to string length - 1","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"alphabet":"01","min_len":2,"max_codepoint":255},"n":{"min_val":1}},"assumptions":["n == len(s) - 1"],"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == sum(1 for i in range(min(len(s), n)) if s[i] == '1')"},{"assertion":"result >= 0"}]},{"id":"pc_17","description":"Rotations equal to string length + 1","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"alphabet":"01","min_len":1,"max_codepoint":255},"n":{"min_val":1}},"assumptions":["n == len(s) + 1"],"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == sum(1 for i in range(min(len(s), n)) if s[i] == '1')"},{"assertion":"result == s.count('1')"}]},{"id":"pc_18","description":"String with only one '1'","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"alphabet":"01","min_len":1,"max_len":50,"max_codepoint":255},"n":{"min_val":0,"max_val":50}},"assumptions":["s.count('1') == 1"],"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == (1 if n > s.find('1') else 0)"}]},{"id":"pc_19","description":"String with only one '0'","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"alphabet":"01","min_len":1,"max_len":50,"max_codepoint":255},"n":{"min_val":0,"max_val":50}},"assumptions":["s.count('0') == 1"],"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == (min(len(s), n) - 1 if n > s.find('0') else min(len(s), n))"}]},{"id":"pc_20","description":"Large string and large rotations, ensuring count is bounded","input_types":{"s":"str","n":"int"},"input_constraints":{"s":{"alphabet":"01","min_len":100,"max_len":500,"max_codepoint":255},"n":{"min_val":100,"max_val":500}},"execution_statement":"result = odd_Equivalent(s, n)","postconditions":[{"assertion":"result == sum(1 for i in range(min(len(s), n)) if s[i] == '1')"},{"assertion":"result <= min(len(s), n)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6159"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic integer lists","execution_statement":"result = common_in_nested_lists(nested_lists)","input_types":{"nested_lists":"list[list[int]]"},"input_constraints":{"nested_lists":{"min_size":2,"elements":{"min_size":1,"elements":{"min_val":1,"max_val":100}}}},"postconditions":[{"assertion":"result == sorted(list(set.intersection(*(set(sublist) for sublist in nested_lists))))"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Lists with strings","execution_statement":"result = common_in_nested_lists(nested_lists)","input_types":{"nested_lists":"list[list[str]]"},"input_constraints":{"nested_lists":{"min_size":2,"elements":{"min_size":1,"elements":{"min_len":1,"max_len":10,"pattern":"^[a-z]+$"},"max_codepoint":127},"max_codepoint":127}},"postconditions":[{"assertion":"result == sorted(list(set.intersection(*(set(sublist) for sublist in nested_lists))))"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Empty outer list","execution_statement":"result = common_in_nested_lists(nested_lists)","input_types":{"nested_lists":"list[list[int]]"},"input_constraints":{"nested_lists":{"min_size":0,"max_size":0}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: One inner list is empty","execution_statement":"result = common_in_nested_lists(nested_lists)","input_types":{"nested_lists":"list[list[int]]"},"input_constraints":{"nested_lists":{"min_size":2,"elements":{"min_size":0,"max_size":5,"elements":{"min_val":1,"max_val":100}}}},"postconditions":[{"assertion":"result == []"}],"assumptions":["any(len(sublist) == 0 for sublist in nested_lists)"]},{"id":"pc_5","description":"Edge Case: All inner lists are empty","execution_statement":"result = common_in_nested_lists(nested_lists)","input_types":{"nested_lists":"list[list[int]]"},"input_constraints":{"nested_lists":{"min_size":2,"max_size":5,"elements":{"min_size":0,"max_size":0}}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_6","description":"Mixed types (hashable)","execution_statement":"result = common_in_nested_lists(nested_lists)","input_types":{"nested_lists":"list[list[Any]]"},"input_constraints":{"nested_lists":{"min_size":2,"elements":{"min_size":1,"elements":{"hashable_mix":true}},"is_mixed":true}},"postconditions":[{"assertion":"result == sorted(list(set.intersection(*(set(sublist) for sublist in nested_lists))))"}],"assumptions":[]},{"id":"pc_7","description":"No common elements","execution_statement":"result = common_in_nested_lists(nested_lists)","input_types":{"nested_lists":"list[list[int]]"},"input_constraints":{"nested_lists":{"min_size":2,"elements":{"min_size":1,"elements":{"min_val":1,"max_val":100}}}},"postconditions":[{"assertion":"result == []"}],"assumptions":["len(set.intersection(*(set(sublist) for sublist in nested_lists))) == 0"]},{"id":"pc_8","description":"All elements are common","execution_statement":"result = common_in_nested_lists(nested_lists)","input_types":{"nested_lists":"list[list[int]]"},"input_constraints":{"nested_lists":{"min_size":2,"max_size":3,"elements":{"min_size":1,"max_size":5,"elements":{"min_val":1,"max_val":5}}}},"postconditions":[{"assertion":"result == sorted(list(set.intersection(*(set(sublist) for sublist in nested_lists))))"}],"assumptions":["len(set.intersection(*(set(sublist) for sublist in nested_lists))) == len(set(nested_lists[0]))"]},{"id":"pc_9","description":"Lists with tuples","execution_statement":"result = common_in_nested_lists(nested_lists)","input_types":{"nested_lists":"list[list[tuple[int, str]]]"},"input_constraints":{"nested_lists":{"min_size":2,"elements":{"min_size":1,"elements":{"min_len":2,"max_len":2,"elements":[{"min_val":1,"max_val":10},{"min_len":1,"max_len":5,"pattern":"^[a-z]+$"}]},"max_codepoint":127},"max_codepoint":127}},"postconditions":[{"assertion":"result == sorted(list(set.intersection(*(set(sublist) for sublist in nested_lists))))"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Invalid input type (int)","execution_statement":"try: result = common_in_nested_lists(nested_lists) except Exception as e: result = e","input_types":{"nested_lists":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Invalid input type (None)","execution_statement":"try: result = common_in_nested_lists(nested_lists) except Exception as e: result = e","input_types":{"nested_lists":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Inner list contains unhashable type (list)","execution_statement":"try: result = common_in_nested_lists(nested_lists) except Exception as e: result = e","input_types":{"nested_lists":"list[list[Any]]"},"input_constraints":{"nested_lists":{"min_size":2,"elements":{"min_size":1,"elements":{"is_mixed":true,"allow_none":true}}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["any(isinstance(item, list) for sublist in nested_lists for item in sublist)"]},{"id":"pc_13","description":"Large numbers and strings","execution_statement":"result = common_in_nested_lists(nested_lists)","input_types":{"nested_lists":"list[list[Any]]"},"input_constraints":{"nested_lists":{"min_size":2,"elements":{"min_size":1,"elements":{"hashable_mix":true,"max_len":50,"min_val":-1000000,"max_val":1000000}}}},"postconditions":[{"assertion":"result == sorted(list(set.intersection(*(set(sublist) for sublist in nested_lists))))"}],"assumptions":[]},{"id":"pc_14","description":"Single element lists with common elements","execution_statement":"result = common_in_nested_lists(nested_lists)","input_types":{"nested_lists":"list[list[int]]"},"input_constraints":{"nested_lists":{"min_size":2,"max_size":5,"elements":{"min_size":1,"max_size":1,"elements":{"min_val":1,"max_val":10}}}},"postconditions":[{"assertion":"result == sorted(list(set.intersection(*(set(sublist) for sublist in nested_lists))))"}],"assumptions":["len(set.intersection(*(set(sublist) for sublist in nested_lists))) == 1"]},{"id":"pc_15","description":"Lists with booleans and None","execution_statement":"result = common_in_nested_lists(nested_lists)","input_types":{"nested_lists":"list[list[Any]]"},"input_constraints":{"nested_lists":{"min_size":2,"elements":{"min_size":1,"elements":{"is_mixed":true,"allow_none":true}}}},"postconditions":[{"assertion":"result == sorted(list(set.intersection(*(set(sublist) for sublist in nested_lists))))"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc615a"},"test_cases":[{"id":"pc_1","description":"Happy Path: Valid positive integer string","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^[-9]+$","min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Valid negative integer string","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^-[-9]+$","min_len":2,"max_len":11,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: Valid positive signed integer string","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^\\+[-9]+$","min_len":2,"max_len":11,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Empty string","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == None"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: String with only a sign ('+')","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"min_len":1,"max_len":1,"pattern":"^\\+$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: String with only a sign ('-')","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"min_len":1,"max_len":1,"pattern":"^\\-$","max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Invalid Case: String with non-digit characters","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^[a-zA-Z]+$","min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_8","description":"Invalid Case: String with mixed digits and letters","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^[a-zA-Z-9]+$","min_len":2,"max_len":10,"is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not (input_string.isdigit() or input_string.lstrip('+-').isdigit())"]},{"id":"pc_9","description":"Invalid Case: String with decimal point","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^[-9]+\\.[-9]+$","min_len":3,"max_len":15,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_10","description":"Invalid Case: String with leading/trailing spaces","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^\\s+[-9]+\\s+$","min_len":3,"max_len":15,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_11","description":"Invalid Case: String with leading/trailing spaces and sign","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^\\s+[+-][-9]+\\s+$","min_len":4,"max_len":16,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_12","description":"Edge Case: String with leading zeros","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^0+[-9]+$","min_len":2,"max_len":11,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_13","description":"Edge Case: String with leading zeros and sign","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^[+-]0+[-9]+$","min_len":3,"max_len":12,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_14","description":"Invalid Case: String with special characters","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^[a-zA-Z-9!@#$%^&*()_+=-`~]+$","min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"result == False"}],"assumptions":["not input_string.isalnum()"]},{"id":"pc_15","description":"Negative Test: Non-string input (float)","execution_statement":"try: result = check_integer(input_val) except Exception as e: result = e","input_types":{"input_val":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: Non-string input (int)","execution_statement":"try: result = check_integer(input_val) except Exception as e: result = e","input_types":{"input_val":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_17","description":"Negative Test: Non-string input (None)","execution_statement":"try: result = check_integer(input_val) except Exception as e: result = e","input_types":{"input_val":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_18","description":"Large valid integer string","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^[-9]+$","min_len":50,"max_len":100,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_19","description":"Large valid negative integer string","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^-[-9]+$","min_len":51,"max_len":101,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_20","description":"String with only zeros","execution_statement":"result = check_integer(input_string)","input_types":{"input_string":"str"},"input_constraints":{"input_string":{"pattern":"^0+$","min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc615b"},"test_cases":[{"id":"pc_1","description":"Happy Path: List with only empty dictionaries","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"type":"dict","max_size":0}}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: List with a mix of empty and non-empty dictionaries","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"type":"dict","allow_empty":true,"max_size":5}}},"postconditions":[{"assertion":"result == False"}],"assumptions":["any(not d for d in list1)"]},{"id":"pc_3","description":"Happy Path: List with only non-empty dictionaries","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"elements":{"type":"dict","min_size":1,"max_size":5}}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Empty list","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"max_len":0}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: List with one empty dictionary","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":1,"max_len":1,"elements":{"type":"dict","max_size":0}}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: List with one non-empty dictionary","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":1,"max_len":1,"elements":{"type":"dict","min_size":1}}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_7","description":"Large list with only empty dictionaries","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":100,"max_len":100,"elements":{"type":"dict","max_size":0}}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_8","description":"Large list with only non-empty dictionaries","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":100,"max_len":100,"elements":{"type":"dict","min_size":1}}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = empty_dit(list1) except Exception as e: result = e","input_types":{"list1":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = empty_dit(list1) except Exception as e: result = e","input_types":{"list1":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: List contains non-dictionary element (int)","execution_statement":"try: result = empty_dit(list1) except Exception as e: result = e","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"type":"int"}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: List contains non-dictionary element (str)","execution_statement":"try: result = empty_dit(list1) except Exception as e: result = e","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"type":"str"}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: List contains non-dictionary element (None)","execution_statement":"try: result = empty_dit(list1) except Exception as e: result = e","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"type":"None"}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"List with dictionaries containing various types of values (should be considered non-empty)","execution_statement":"result = empty_dit(list1)","input_types":{"list1":"list[dict]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"elements":{"type":"dict","keys":{"type":"str"},"values":{"type":"any"},"min_size":1}}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc615c"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical tuple of positive integers","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":5,"elements":{"min_val":1,"max_val":1000}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"str(result) == ''.join(map(str, nums))"},{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_2","description":"Boundary Case: Tuple with a single smallest positive integer","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1,"elements":{"min_val":1,"max_val":1}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Case: Tuple with a single large positive integer","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1,"elements":{"min_val":100000,"max_val":999999}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"str(result) == ''.join(map(str, nums))"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Tuple with multiple smallest positive integers","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":10,"elements":{"min_val":1,"max_val":1}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"str(result) == '1' * len(nums)"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Tuple with numbers that have multiple digits","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":4,"elements":{"min_val":10,"max_val":99}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"str(result) == ''.join(map(str, nums))"}],"assumptions":[]},{"id":"pc_6","description":"Invariant Test: General positive integers","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":10,"elements":{"min_val":1,"max_val":10000},"unique":true}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"str(result) == ''.join(map(str, nums))"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Input is not a tuple (list)","execution_statement":"try: result = tuple_to_int(nums) except Exception as e: result = e","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Input is not a tuple (string)","execution_statement":"try: result = tuple_to_int(nums) except Exception as e: result = e","input_types":{"nums":"str"},"input_constraints":{"nums":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Input is not a tuple (integer)","execution_statement":"try: result = tuple_to_int(nums) except Exception as e: result = e","input_types":{"nums":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Tuple contains a non-integer element (float)","execution_statement":"try: result = tuple_to_int(nums) except Exception as e: result = e","input_types":{"nums":"tuple[float]"},"input_constraints":{"nums":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Tuple contains a non-integer element (string)","execution_statement":"try: result = tuple_to_int(nums) except Exception as e: result = e","input_types":{"nums":"tuple[str]"},"input_constraints":{"nums":{"min_len":1,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Tuple contains a non-integer element (None)","execution_statement":"try: result = tuple_to_int(nums) except Exception as e: result = e","input_types":{"nums":"tuple[int | None]"},"input_constraints":{"nums":{"min_len":0,"elements":{"allow_none":true}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["None in nums"]},{"id":"pc_13","description":"Boundary Case: Tuple with a very large number of elements","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":100,"elements":{"min_val":1,"max_val":9}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"str(result) == ''.join(map(str, nums))"}],"assumptions":[]},{"id":"pc_14","description":"Typical Case: Tuple with mixed length positive integers","execution_statement":"result = tuple_to_int(nums)","input_types":{"nums":"tuple[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":6,"elements":{"min_val":1,"max_val":9999},"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"str(result) == ''.join(map(str, nums))"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc615d"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic conversion of integers and floats","input_types":{"test_list":"list[list[Union[int, float, str]]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_constraints":{"min_len":2,"max_len":2,"elements":{"min_val":-100,"max_val":100}}}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(sublist, tuple) for sublist in result)"},{"assertion":"all(isinstance(item, float) or isinstance(item, str) for sublist in result for item in sublist)"}]},{"id":"pc_2","description":"Edge Case: Empty input list","input_types":{"test_list":"list[list[Union[int, float, str]]]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"result == []"}]},{"id":"pc_3","description":"Edge Case: List with empty inner lists","input_types":{"test_list":"list[list[Union[int, float, str]]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":3,"inner_constraints":{"min_len":0,"max_len":0}}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"all(isinstance(sublist, tuple) and len(sublist) == 0 for sublist in result)"}]},{"id":"pc_4","description":"Mixed types within inner lists (convertible and non-convertible)","input_types":{"test_list":"list[list[Any]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_constraints":{"min_len":2,"max_len":2,"elements":{"is_mixed":true}},"is_mixed":true}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(sublist, tuple) for sublist in result)"},{"assertion":"all(isinstance(item, float) or isinstance(item, str) for sublist in result for item in sublist)"}]},{"id":"pc_5","description":"Large numbers for conversion","input_types":{"test_list":"list[list[Union[int, float, str]]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":3,"inner_constraints":{"min_len":2,"max_len":2,"elements":{"min_val":-1E+10,"max_val":1E+10}}}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(sublist, tuple) for sublist in result)"},{"assertion":"all(isinstance(item, float) or isinstance(item, str) for sublist in result for item in sublist)"}]},{"id":"pc_6","description":"Strings that are valid floats","input_types":{"test_list":"list[list[str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_constraints":{"min_len":2,"max_len":2,"elements":{"pattern":"^-?\\d+(\\.\\d+)?$"}}}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(sublist, tuple) for sublist in result)"},{"assertion":"all(isinstance(item, float) for sublist in result for item in sublist)"}]},{"id":"pc_7","description":"Strings that are not valid floats (should be kept as strings)","input_types":{"test_list":"list[list[Any]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_constraints":{"min_len":2,"max_len":2,"elements":{"is_mixed":true}}}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(sublist, tuple) for sublist in result)"},{"assertion":"all(isinstance(item, float) or isinstance(item, str) for sublist in result for item in sublist)"}]},{"id":"pc_8","description":"Negative Test: Input is not a list","input_types":{"test_list":"int"},"input_constraints":{},"execution_statement":"try: result = list_to_float(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: Inner element is not iterable (e.g., int)","input_types":{"test_list":"list[int]"},"input_constraints":{"test_list":{"min_len":1,"max_len":3}},"execution_statement":"try: result = list_to_float(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Inner element is not a list/tuple (e.g., string)","input_types":{"test_list":"list[str]"},"input_constraints":{"test_list":{"min_len":1,"max_len":3}},"execution_statement":"try: result = list_to_float(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Negative Test: Element within inner list is not convertible and not alpha","input_types":{"test_list":"list[list[Any]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":3,"inner_constraints":{"min_len":2,"max_len":2,"elements":{"is_mixed":true}}}},"execution_statement":"try: result = list_to_float(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, ValueError) or isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Inner lists with only alphabetic strings","input_types":{"test_list":"list[list[str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_constraints":{"min_len":2,"max_len":2,"elements":{"pattern":"^[a-zA-Z]+$"}}}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(sublist, tuple) for sublist in result)"},{"assertion":"all(isinstance(item, str) for sublist in result for item in sublist)"}]},{"id":"pc_13","description":"Inner lists with only non-convertible strings (not alpha, not numeric)","input_types":{"test_list":"list[list[str]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_constraints":{"min_len":2,"max_len":2,"elements":{"pattern":"^[^\\d\\w]+$"}}}},"execution_statement":"try: result = list_to_float(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, ValueError) or isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Inner lists with None values","input_types":{"test_list":"list[list[Any]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_constraints":{"min_len":2,"max_len":2,"elements":{"allow_none":true,"is_mixed":true}}}},"execution_statement":"try: result = list_to_float(test_list) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, ValueError) or isinstance(result, TypeError)"}]},{"id":"pc_15","description":"Inner lists with boolean values","input_types":{"test_list":"list[list[Union[int, float, str, bool]]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"inner_constraints":{"min_len":2,"max_len":2,"elements":{"min_val":-100,"max_val":100}}}},"execution_statement":"result = list_to_float(test_list)","postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(sublist, tuple) for sublist in result)"},{"assertion":"all(isinstance(item, float) or isinstance(item, str) for sublist in result for item in sublist)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc615e"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic string with spaces","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":100,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(isinstance(s, str) for s in result)"},{"assertion":"result == string.split(' ')"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":0,"max_len":0,"max_codepoint":255}},"postconditions":[{"assertion":"result == ['']"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String with no spaces","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":50,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == [string]"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: String with only spaces","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":20,"pattern":"^ +$","max_codepoint":255}},"postconditions":[{"assertion":"all(s == '' for s in result)"},{"assertion":"len(result) == string.count(' ') + 1"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: String with multiple spaces between words","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":0,"max_len":25,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == string.split(' ')"}],"assumptions":["'  ' in string"]},{"id":"pc_6","description":"Edge Case: String with leading spaces","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":2,"max_len":100,"pattern":"^ +[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result[0] == ''"},{"assertion":"result == string.split(' ')"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: String with trailing spaces","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":2,"max_len":100,"pattern":"^[a-zA-Z ]+ +$","max_codepoint":255}},"postconditions":[{"assertion":"result[-1] == ''"},{"assertion":"result == string.split(' ')"}],"assumptions":[]},{"id":"pc_8","description":"Edge Case: String with leading and trailing spaces","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":3,"max_len":100,"pattern":"^ +[a-zA-Z ]+ +$","max_codepoint":255}},"postconditions":[{"assertion":"result[0] == ''"},{"assertion":"result[-1] == ''"},{"assertion":"result == string.split(' ')"}],"assumptions":[]},{"id":"pc_9","description":"Long string with spaces","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":500,"max_len":1000,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == string.split(' ')"}],"assumptions":[]},{"id":"pc_10","description":"String with mixed characters and spaces","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":100,"pattern":"^[a-zA-Z-9_.,!@#$%^&*() ]+$","is_mixed":true,"max_codepoint":255}},"postconditions":[{"assertion":"result == string.split(' ')"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Input is not a string (integer)","execution_statement":"try: result = string_to_list(string) except Exception as e: result = e","input_types":{"string":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Input is not a string (float)","execution_statement":"try: result = string_to_list(string) except Exception as e: result = e","input_types":{"string":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Input is not a string (None)","execution_statement":"try: result = string_to_list(string) except Exception as e: result = e","input_types":{"string":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_14","description":"String with single space","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":3,"max_len":50,"pattern":"^[a-zA-Z]+ +[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == ['word1', 'word2']"}],"assumptions":[]},{"id":"pc_15","description":"String with tabs and newlines (treated as non-space separators by split(' '))","execution_statement":"result = string_to_list(string)","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":5,"max_len":100,"pattern":"^[a-zA-Z\\t\\n ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == string.split(' ')"}],"assumptions":["'\\t' in string or '\\n' in string"]}]}
{"_id":{"$oid":"692adffe1b18223597bc615f"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical sorted array with one unique element","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":5,"max_len":20,"unique_elements_count":1}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result == arr[0] or result == arr[1] or result == arr[2] or result == arr[3] or result == arr[4]"}]},{"id":"pc_2","description":"Boundary Case: Array with only two elements, one unique","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":2,"max_len":2,"unique_elements_count":1}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result == arr[0] or result == arr[1]"}]},{"id":"pc_3","description":"Edge Case: Array with a single element (which is unique)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":1,"max_len":1,"unique_elements_count":1}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result == arr[0]"}]},{"id":"pc_4","description":"Case: Unique element is the first element","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":5,"max_len":20,"unique_elements_count":1,"unique_element_position":"first"}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result == arr[0]"}]},{"id":"pc_5","description":"Case: Unique element is the last element","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":5,"max_len":20,"unique_elements_count":1,"unique_element_position":"last"}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result == arr[-1]"}]},{"id":"pc_6","description":"Case: Unique element is in the middle","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":5,"max_len":20,"unique_elements_count":1,"unique_element_position":"middle"}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result == arr[len(arr) // 2]"}]},{"id":"pc_7","description":"Case: Array with negative numbers, unique element is negative","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":5,"max_len":20,"unique_elements_count":1,"elements":{"min_val":-100,"max_val":-1}}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result < 0"}]},{"id":"pc_8","description":"Case: Array with positive numbers, unique element is positive","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":5,"max_len":20,"unique_elements_count":1,"elements":{"min_val":1,"max_val":100}}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result > 0"}]},{"id":"pc_9","description":"Case: Array with zeros, unique element is zero","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":5,"max_len":20,"unique_elements_count":1,"elements":{"min_val":0,"max_val":0}}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_10","description":"Case: Mixed positive, negative, and zero, unique element is positive","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":5,"max_len":20,"unique_elements_count":1,"elements":{"min_val":-100,"max_val":100},"is_mixed":true}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result in arr"}]},{"id":"pc_11","description":"Case: Mixed positive, negative, and zero, unique element is negative","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":5,"max_len":20,"unique_elements_count":1,"elements":{"min_val":-100,"max_val":100},"is_mixed":true}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result in arr"}]},{"id":"pc_12","description":"Case: Mixed positive, negative, and zero, unique element is zero","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":5,"max_len":20,"unique_elements_count":1,"elements":{"min_val":-100,"max_val":100},"is_mixed":true}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result in arr"}]},{"id":"pc_13","description":"Negative Test: Empty list (should not happen based on problem constraints, but good to check if function handles it)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":0,"max_len":0}},"execution_statement":"try: result = search(arr) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, Exception)"}]},{"id":"pc_14","description":"Negative Test: Input is not a list (e.g., integer)","input_types":{"arr":"int"},"input_constraints":{},"execution_statement":"try: result = search(arr) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_15","description":"Negative Test: Input is not a list (e.g., string)","input_types":{"arr":"str"},"input_constraints":{"arr":{"min_len":1,"max_codepoint":255}},"execution_statement":"try: result = search(arr) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_16","description":"Negative Test: Input list contains non-numeric types (e.g., string)","input_types":{"arr":"list[str]"},"input_constraints":{"arr":{"min_len":1,"elements":{"min_len":1}}},"execution_statement":"try: result = search(arr) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_17","description":"Negative Test: Input list contains non-numeric types (e.g., None)","input_types":{"arr":"list[int | None]"},"input_constraints":{"arr":{"min_len":1,"allow_none":true}},"execution_statement":"try: result = search(arr) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_18","description":"Case: Large numbers, unique element is large","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":5,"max_len":20,"unique_elements_count":1,"elements":{"min_val":1000000,"max_val":10000000}}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result in arr"}]},{"id":"pc_19","description":"Case: Small negative numbers, unique element is small negative","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":5,"max_len":20,"unique_elements_count":1,"elements":{"min_val":-1000000,"max_val":-100000}}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result in arr"}]},{"id":"pc_20","description":"Case: Array with floats, unique element is float","input_types":{"arr":"list[float]"},"input_constraints":{"arr":{"sorted":"ascending","min_len":5,"max_len":20,"unique_elements_count":1,"allow_nan":false,"allow_infinity":false}},"execution_statement":"result = search(arr)","postconditions":[{"assertion":"result in arr"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6160"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list of tuples with positive integers","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"element_constraints":{"min_value":1,"max_value":100}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"},{"assertion":"result >= 0"}]},{"id":"pc_2","description":"Happy Path: List with tuples containing negative integers","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"element_constraints":{"min_value":-100,"max_value":-1}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"},{"assertion":"result >= 0"}]},{"id":"pc_3","description":"Happy Path: List with tuples containing mixed positive and negative integers","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"element_constraints":{"min_value":-100,"max_value":100},"is_mixed":true}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"},{"assertion":"result >= 0"}]},{"id":"pc_4","description":"Edge Case: List with a single tuple","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":1,"element_constraints":{"min_value":-50,"max_value":50}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result == abs(list1[0][0] * list1[0][1])"}]},{"id":"pc_5","description":"Edge Case: List with tuples containing zero","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"element_constraints":{"min_value":0,"max_value":100}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"},{"assertion":"result >= 0"}]},{"id":"pc_6","description":"Edge Case: List with tuples containing zero and negative numbers","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"element_constraints":{"min_value":-100,"max_value":0}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"},{"assertion":"result >= 0"}]},{"id":"pc_7","description":"Edge Case: List with tuples containing very large numbers","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_value":1000000,"max_value":10000000}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"pc_8","description":"Edge Case: List with tuples containing very small numbers (close to zero)","input_types":{"list1":"list[tuple[float, float]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"element_constraints":{"min_value":-1E-06,"max_value":1E-06}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"abs(result - max([abs(x * y) for x, y in list1])) < 1e-9"}]},{"id":"pc_9","description":"Edge Case: List with tuples containing floats","input_types":{"list1":"list[tuple[float, float]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"element_constraints":{"min_value":-100.5,"max_value":100.5}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"abs(result - max([abs(x * y) for x, y in list1])) < 1e-9"}]},{"id":"pc_10","description":"Negative Test: Empty list (should raise IndexError)","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":0,"max_len":0}},"execution_statement":"try: result = max_product_tuple(list1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, IndexError)"}]},{"id":"pc_11","description":"Negative Test: List with non-tuple elements (should raise TypeError)","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"is_mixed":true}},"execution_statement":"try: result = max_product_tuple(list1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: List with tuples of incorrect length (should raise ValueError or TypeError)","input_types":{"list1":"list[tuple[int, int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_length":3,"max_length":3,"min_value":1,"max_value":10}}},"execution_statement":"try: result = max_product_tuple(list1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, (ValueError, TypeError))"}]},{"id":"pc_13","description":"Negative Test: List with tuples containing non-numeric types (should raise TypeError)","input_types":{"list1":"list[tuple[int, str]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_length":2,"max_length":2,"element_constraints":[{"min_value":1,"max_value":10},{"min_len":1,"max_len":5}]}}},"execution_statement":"try: result = max_product_tuple(list1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Test with maximum list size","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":10,"max_len":10,"element_constraints":{"min_value":1,"max_value":100}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"pc_15","description":"Test with minimum list size (already covered, but explicit)","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":1,"element_constraints":{"min_value":1,"max_value":100}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result == abs(list1[0][0] * list1[0][1])"}]},{"id":"pc_16","description":"Test with tuples containing only the smallest possible positive integers","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"element_constraints":{"min_value":1,"max_value":1}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result == 1"}]},{"id":"pc_17","description":"Test with tuples containing only the largest possible negative integers","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"element_constraints":{"min_value":-1,"max_value":-1}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result == 1"}]},{"id":"pc_18","description":"Test with tuples containing a mix of 0, 1, and -1","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":10,"element_constraints":{"values":[-1,0,1]}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"},{"assertion":"result == 1 or result == 0"}]},{"id":"pc_19","description":"Test with tuples containing large negative numbers","input_types":{"list1":"list[tuple[int, int]]"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"element_constraints":{"min_value":-10000000,"max_value":-1000000}}},"execution_statement":"result = max_product_tuple(list1)","postconditions":[{"assertion":"result == max([abs(x * y) for x, y in list1])"}]},{"id":"pc_20","description":"Negative Test: List containing None (should raise TypeError)","input_types":{"list1":"list"},"input_constraints":{"list1":{"min_len":1,"max_len":5,"is_mixed":true,"allow_none":true}},"execution_statement":"try: result = max_product_tuple(list1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6161"},"test_cases":[{"id":"pc_1","description":"Happy Path: Small limit with known amicable pair","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":284,"max_val":500}},"postconditions":[{"assertion":"result == 504"}]},{"id":"pc_2","description":"Happy Path: Limit below first amicable pair","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1,"max_val":283}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_3","description":"Happy Path: Limit including multiple amicable pairs","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1300,"max_val":1500}},"postconditions":[{"assertion":"result == 2964"}]},{"id":"pc_4","description":"Happy Path: Larger limit to test performance and correctness","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":10000,"max_val":15000}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}]},{"id":"pc_5","description":"Invariance: Sum should be non-decreasing as limit increases","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1,"max_val":10000}},"assumptions":["limit + 1 <= 10000"],"postconditions":[{"assertion":"amicable_numbers_sum(limit) <= amicable_numbers_sum(limit + 1)"}]},{"id":"pc_6","description":"Negative Test: Limit is zero","execution_statement":"try: result = amicable_numbers_sum(limit) except Exception as e: result = e","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 'Input must be bigger than 0!'"}]},{"id":"pc_7","description":"Negative Test: Limit is negative","execution_statement":"try: result = amicable_numbers_sum(limit) except Exception as e: result = e","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"result == 'Input must be bigger than 0!'"}]},{"id":"pc_8","description":"Negative Test: Limit is a float","execution_statement":"try: result = amicable_numbers_sum(limit) except Exception as e: result = e","input_types":{"limit":"float"},"input_constraints":{"limit":{"min_val":1.0,"max_val":1000.0}},"postconditions":[{"assertion":"result == 'Input is not an integer!'"}]},{"id":"pc_9","description":"Negative Test: Limit is a string","execution_statement":"try: result = amicable_numbers_sum(limit) except Exception as e: result = e","input_types":{"limit":"str"},"input_constraints":{"limit":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"result == 'Input is not an integer!'"}]},{"id":"pc_10","description":"Negative Test: Limit is None","execution_statement":"try: result = amicable_numbers_sum(limit) except Exception as e: result = e","input_types":{"limit":"NoneType"},"postconditions":[{"assertion":"result == 'Input is not an integer!'"}]},{"id":"pc_11","description":"Happy Path: Limit is exactly 220 (first number of the first pair)","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":220,"max_val":220}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_12","description":"Happy Path: Limit is exactly 284 (second number of the first pair)","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":284,"max_val":284}},"postconditions":[{"assertion":"result == 504"}]},{"id":"pc_13","description":"Happy Path: Limit is 1","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_14","description":"Happy Path: Limit is 1184 (first number of second pair)","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1184,"max_val":1184}},"postconditions":[{"assertion":"result == 504"}]},{"id":"pc_15","description":"Happy Path: Limit is 1210 (second number of second pair)","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1210,"max_val":1210}},"postconditions":[{"assertion":"result == 2394"}]},{"id":"pc_16","description":"Invariance: Sum should be non-decreasing with larger increments","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":1,"max_val":10000}},"assumptions":["limit + 10 <= 10000"],"postconditions":[{"assertion":"amicable_numbers_sum(limit) <= amicable_numbers_sum(limit + 10)"}]},{"id":"pc_17","description":"Happy Path: Limit is a large number, checking for integer output","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":100000,"max_val":200000}},"postconditions":[{"assertion":"isinstance(result, int)"}]},{"id":"pc_18","description":"Happy Path: Limit is a very large number, checking for non-negative output","execution_statement":"result = amicable_numbers_sum(limit)","input_types":{"limit":"int"},"input_constraints":{"limit":{"min_val":500000,"max_val":1000000}},"postconditions":[{"assertion":"result >= 0"}]},{"id":"pc_19","description":"Negative Test: Limit is a boolean True (treated as 1)","execution_statement":"try: result = amicable_numbers_sum(limit) except Exception as e: result = e","input_types":{"limit":"bool"},"input_constraints":{"limit":{"allow_none":false}},"postconditions":[{"assertion":"result == 'Input is not an integer!'"}]},{"id":"pc_20","description":"Negative Test: Limit is a boolean False (treated as 0)","execution_statement":"try: result = amicable_numbers_sum(limit) except Exception as e: result = e","input_types":{"limit":"bool"},"input_constraints":{"limit":{"allow_none":false}},"postconditions":[{"assertion":"result == 'Input must be bigger than 0!'"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6162"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical complex number","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-100.0,"max_val":100.0},"b":{"min_val":-100.0,"max_val":100.0}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"-math.pi < result <= math.pi"},{"assertion":"math.isclose(result, cmath.phase(complex(a, b)))"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Positive Real Axis","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":1.0,"max_val":100.0},"b":{"value":0.0}},"postconditions":[{"assertion":"math.isclose(result, 0.0)"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Negative Real Axis","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-100.0,"max_val":-1.0},"b":{"value":0.0}},"postconditions":[{"assertion":"math.isclose(result, math.pi)"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Positive Imaginary Axis","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"value":0.0},"b":{"min_val":1.0,"max_val":100.0}},"postconditions":[{"assertion":"math.isclose(result, math.pi / 2)"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Negative Imaginary Axis","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"value":0.0},"b":{"min_val":-100.0,"max_val":-1.0}},"postconditions":[{"assertion":"math.isclose(result, -math.pi / 2)"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Origin (0, 0)","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"value":0.0},"b":{"value":0.0}},"postconditions":[{"assertion":"math.isclose(result, 0.0)"}],"assumptions":[]},{"id":"pc_7","description":"Quadrant 1: Positive Real and Imaginary","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":1.0,"max_val":100.0},"b":{"min_val":1.0,"max_val":100.0}},"postconditions":[{"assertion":"result > 0"},{"assertion":"result <= math.pi / 2"}],"assumptions":[]},{"id":"pc_8","description":"Quadrant 2: Negative Real, Positive Imaginary","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-100.0,"max_val":-1.0},"b":{"min_val":1.0,"max_val":100.0}},"postconditions":[{"assertion":"result > math.pi / 2"},{"assertion":"result <= math.pi"}],"assumptions":[]},{"id":"pc_9","description":"Quadrant 3: Negative Real, Negative Imaginary","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-100.0,"max_val":-1.0},"b":{"min_val":-100.0,"max_val":-1.0}},"postconditions":[{"assertion":"result > -math.pi"},{"assertion":"result <= -math.pi / 2"}],"assumptions":[]},{"id":"pc_10","description":"Quadrant 4: Positive Real, Negative Imaginary","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":1.0,"max_val":100.0},"b":{"min_val":-100.0,"max_val":-1.0}},"postconditions":[{"assertion":"result > -math.pi / 2"},{"assertion":"result <= 0"}],"assumptions":[]},{"id":"pc_11","description":"Large Magnitude Numbers","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-1E+100,"max_val":1E+100},"b":{"min_val":-1E+100,"max_val":1E+100}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"-math.pi < result <= math.pi"}],"assumptions":[]},{"id":"pc_12","description":"Small Magnitude Numbers","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-1E-100,"max_val":1E-100},"b":{"min_val":-1E-100,"max_val":1E-100}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"-math.pi < result <= math.pi"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Non-numeric input for 'a'","execution_statement":"try: result = angle_complex(a, b) except Exception as e: result = e","input_types":{"a":"str","b":"float"},"input_constraints":{"a":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Non-numeric input for 'b'","execution_statement":"try: result = angle_complex(a, b) except Exception as e: result = e","input_types":{"a":"float","b":"str"},"input_constraints":{"b":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: null input for 'a'","execution_statement":"try: result = angle_complex(a, b) except Exception as e: result = e","input_types":{"a":"None","b":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"Negative Test: null input for 'b'","execution_statement":"try: result = angle_complex(a, b) except Exception as e: result = e","input_types":{"a":"float","b":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_17","description":"Symmetry Test: Conjugate pairs","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"float","b":"float"},"input_constraints":{"a":{"min_val":-100.0,"max_val":100.0},"b":{"min_val":-100.0,"max_val":100.0}},"postconditions":[{"assertion":"math.isclose(result, -cmath.phase(complex(a, -b)))"}],"assumptions":["b != 0"]},{"id":"pc_18","description":"Test with integer inputs","execution_statement":"result = angle_complex(a, b)","input_types":{"a":"int","b":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":100},"b":{"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, float)"},{"assertion":"-math.pi < result <= math.pi"},{"assertion":"math.isclose(result, cmath.phase(complex(a, b)))"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6163"},"test_cases":[{"id":"pc_1","description":"Happy Path: Arbitrary binary string","input_types":{"string":"str"},"input_constraints":{"string":{"alphabet":"01","min_len":1,"max_len":100,"max_codepoint":255}},"execution_statement":"result = find_length(string)","postconditions":[{"assertion":"isinstance(result, int) and result >= 0"},{"assertion":"result == calculate_max_diff_zeros_ones(string)"}]},{"id":"pc_2","description":"Edge Case: Empty string","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":0,"max_len":0,"max_codepoint":255}},"execution_statement":"result = find_length(string)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_3","description":"Edge Case: String with all zeros","input_types":{"string":"str"},"input_constraints":{"string":{"alphabet":"0","min_len":1,"max_len":50,"max_codepoint":255}},"execution_statement":"result = find_length(string)","postconditions":[{"assertion":"result == len(string)"}]},{"id":"pc_4","description":"Edge Case: String with all ones","input_types":{"string":"str"},"input_constraints":{"string":{"alphabet":"1","min_len":1,"max_len":50,"max_codepoint":255}},"execution_statement":"result = find_length(string)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_5","description":"Edge Case: String with single zero","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":1,"alphabet":"0","max_codepoint":255}},"execution_statement":"result = find_length(string)","postconditions":[{"assertion":"result == 1"}]},{"id":"pc_6","description":"Edge Case: String with single one","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":1,"max_len":1,"alphabet":"1","max_codepoint":255}},"execution_statement":"result = find_length(string)","postconditions":[{"assertion":"result == 0"}]},{"id":"pc_7","description":"Long string with alternating zeros and ones","input_types":{"string":"str"},"input_constraints":{"string":{"alphabet":"01","min_len":100,"max_len":200,"max_codepoint":255}},"execution_statement":"result = find_length(string)","postconditions":[{"assertion":"isinstance(result, int) and result >= 0"},{"assertion":"result == calculate_max_diff_zeros_ones(string)"}]},{"id":"pc_8","description":"String with a dominant substring of zeros","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":50,"max_len":150,"pattern":"^1*0{30}1*$","max_codepoint":255}},"execution_statement":"result = find_length(string)","postconditions":[{"assertion":"isinstance(result, int) and result >= 0"},{"assertion":"result == calculate_max_diff_zeros_ones(string)"}]},{"id":"pc_9","description":"String with a dominant substring of ones","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":50,"max_len":150,"pattern":"^0*1{30}0*$","max_codepoint":255}},"execution_statement":"result = find_length(string)","postconditions":[{"assertion":"isinstance(result, int) and result >= 0"},{"assertion":"result == calculate_max_diff_zeros_ones(string)"}]},{"id":"pc_10","description":"Negative Test: Non-string input (integer)","input_types":{"string":"int"},"input_constraints":{},"execution_statement":"try: result = find_length(string) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Negative Test: Non-string input (float)","input_types":{"string":"float"},"input_constraints":{},"execution_statement":"try: result = find_length(string) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: Non-string input (None)","input_types":{"string":"None"},"input_constraints":{},"execution_statement":"try: result = find_length(string) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"String with mixed zeros and ones, testing internal logic","input_types":{"string":"str"},"input_constraints":{"string":{"alphabet":"01","min_len":20,"max_len":80,"is_mixed":true,"max_codepoint":255}},"execution_statement":"result = find_length(string)","postconditions":[{"assertion":"isinstance(result, int) and result >= 0"},{"assertion":"result == calculate_max_diff_zeros_ones(string)"}]},{"id":"pc_14","description":"String where max difference occurs in a middle substring","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":60,"max_len":120,"pattern":"^0*1{10}0{10}1{10}0*$","max_codepoint":255}},"execution_statement":"result = find_length(string)","postconditions":[{"assertion":"isinstance(result, int) and result >= 0"},{"assertion":"result == calculate_max_diff_zeros_ones(string)"}]},{"id":"pc_15","description":"String with a pattern that might reset current_sum to 0 frequently","input_types":{"string":"str"},"input_constraints":{"string":{"min_len":70,"max_len":130,"pattern":"^(01){20}0?$","max_codepoint":255}},"execution_statement":"result = find_length(string)","postconditions":[{"assertion":"isinstance(result, int) and result >= 0"},{"assertion":"result == calculate_max_diff_zeros_ones(string)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6164"},"test_cases":[{"id":"pc_1","description":"Happy Path - Standard Multiplication","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":100},"y":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_2","description":"Multiply by Zero","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":100},"y":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_3","description":"Multiply by One","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":100},"y":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == x"}]},{"id":"pc_4","description":"Multiply Negative Number by Positive","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":-1},"y":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_5","description":"Multiply Positive Number by Negative","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":1,"max_val":10},"y":{"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_6","description":"Multiply Two Negative Numbers","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-100,"max_val":-1},"y":{"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_7","description":"Large positive numbers","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":10000,"max_val":20000},"y":{"min_val":10000,"max_val":20000}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_8","description":"Large negative numbers","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":-20000,"max_val":-10000},"y":{"min_val":-20000,"max_val":-10000}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_9","description":"Large positive and negative numbers","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":10000,"max_val":20000},"y":{"min_val":-20000,"max_val":-10000}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_10","description":"Recursive calls with small positive y","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":2,"max_val":5},"y":{"min_val":2,"max_val":5}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_11","description":"Recursive calls with small negative y","execution_statement":"result = multiply_int(x, y)","input_types":{"x":"int","y":"int"},"input_constraints":{"x":{"min_val":2,"max_val":5},"y":{"min_val":-5,"max_val":-2}},"postconditions":[{"assertion":"result == x * y"}]},{"id":"pc_12","description":"Negative Test: Invalid Type for y (float)","execution_statement":"try: result = multiply_int(x, y) except Exception as e: result = e","input_types":{"x":"int","y":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Negative Test: Invalid Type for x (string)","execution_statement":"try: result = multiply_int(x, y) except Exception as e: result = e","input_types":{"x":"str","y":"int"},"input_constraints":{"x":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Negative Test: Invalid Type for y (None)","execution_statement":"try: result = multiply_int(x, y) except Exception as e: result = e","input_types":{"x":"int","y":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6165"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic functionality with typical inputs.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":0,"max_val":10},"str":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"all(word in str.split(' ') for word in result)"},{"assertion":"all(len(word) <= n for word in str.split(' ') if word not in result)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: n = 0, should return all non-empty words.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"value":0},"str":{"min_len":1,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > 0 for word in result)"},{"assertion":"all(word in str.split(' ') for word in result)"},{"assertion":"all(len(word) <= 0 for word in str.split(' ') if word not in result)"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: n is larger than any word length.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":20,"max_val":30},"str":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":["all(len(word) <= n for word in str.split(' '))"]},{"id":"pc_4","description":"Edge Case: Input string contains only spaces.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":0,"max_val":5},"str":{"min_len":5,"max_len":20,"pattern":"^ +$","max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Input string with empty words (multiple spaces).","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":0,"max_val":5},"str":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z ]* +[a-zA-Z ]*$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"all(word in str.split(' ') for word in result)"},{"assertion":"all(len(word) <= n for word in str.split(' ') if word not in result)"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Empty input string.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":0,"max_val":5},"str":{"value":"","max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_7","description":"Test with very long words.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":50,"max_val":100},"str":{"min_len":100,"max_len":200,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"all(word in str.split(' ') for word in result)"},{"assertion":"all(len(word) <= n for word in str.split(' ') if word not in result)"}],"assumptions":[]},{"id":"pc_8","description":"Test with words containing only uppercase letters.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":0,"max_val":10},"str":{"min_len":5,"max_len":50,"pattern":"^[A-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"all(word in str.split(' ') for word in result)"},{"assertion":"all(len(word) <= n for word in str.split(' ') if word not in result)"}],"assumptions":[]},{"id":"pc_9","description":"Test with words containing only lowercase letters.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":0,"max_val":10},"str":{"min_len":5,"max_len":50,"pattern":"^[a-z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"all(word in str.split(' ') for word in result)"},{"assertion":"all(len(word) <= n for word in str.split(' ') if word not in result)"}],"assumptions":[]},{"id":"pc_10","description":"Test with a mix of word lengths and n values.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":1,"max_val":15},"str":{"min_len":10,"max_len":100,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"all(word in str.split(' ') for word in result)"},{"assertion":"all(len(word) <= n for word in str.split(' ') if word not in result)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Invalid type for 'n' (float).","execution_statement":"try: result = long_words(n, str) except Exception as e: result = e","input_types":{"n":"float","str":"str"},"input_constraints":{"n":{"min_val":0.0,"max_val":10.0},"str":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Invalid type for 'str' (int).","execution_statement":"try: result = long_words(n, str) except Exception as e: result = e","input_types":{"n":"int","str":"int"},"input_constraints":{"n":{"min_val":0,"max_val":10}},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Invalid type for 'str' (None).","execution_statement":"try: result = long_words(n, str) except Exception as e: result = e","input_types":{"n":"int","str":"NoneType"},"input_constraints":{"n":{"min_val":0,"max_val":10}},"postconditions":[{"assertion":"isinstance(result, AttributeError)"}],"assumptions":[]},{"id":"pc_14","description":"Test with words containing numbers and spaces.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":0,"max_val":10},"str":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z-9 ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"all(word in str.split(' ') for word in result)"},{"assertion":"all(len(word) <= n for word in str.split(' ') if word not in result)"}],"assumptions":[]},{"id":"pc_15","description":"Test with words containing punctuation and spaces.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":0,"max_val":10},"str":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z.,! ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"all(word in str.split(' ') for word in result)"},{"assertion":"all(len(word) <= n for word in str.split(' ') if word not in result)"}],"assumptions":[]},{"id":"pc_16","description":"Test with a very large n value.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":1000,"max_val":2000},"str":{"min_len":5,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_17","description":"Test with a string that has only one word, longer than n.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":0,"max_val":5},"str":{"min_len":6,"max_len":10,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == [str]"}],"assumptions":["len(str) > n"]},{"id":"pc_18","description":"Test with a string that has only one word, shorter than or equal to n.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":5,"max_val":10},"str":{"min_len":1,"max_len":5,"pattern":"^[a-zA-Z]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == []"}],"assumptions":["len(str) <= n"]},{"id":"pc_19","description":"Test with a mix of short and long words, and n that filters most.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":3,"max_val":7},"str":{"min_len":10,"max_len":100,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"all(len(word) > n for word in result)"},{"assertion":"all(word in str.split(' ') for word in result)"},{"assertion":"all(len(word) <= n for word in str.split(' ') if word not in result)"}],"assumptions":[]},{"id":"pc_20","description":"Test with a string containing only words of the exact length n+1.","execution_statement":"result = long_words(n, str)","input_types":{"n":"int","str":"str"},"input_constraints":{"n":{"min_val":1,"max_val":5},"str":{"min_len":10,"max_len":50,"pattern":"^[a-zA-Z ]+$","max_codepoint":255}},"postconditions":[{"assertion":"result == str.split(' ')"}],"assumptions":["all(len(word) == n + 1 for word in str.split(' '))"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6166"},"test_cases":[{"id":"pc_1","description":"Valid 3x3 magic square","execution_statement":"result = magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_2","description":"Non-magic square","execution_statement":"result = magic_square_test([[1, 2, 3], [4, 5, 6], [7, 8, 9]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_3","description":"1x1 matrix (always magic)","execution_statement":"result = magic_square_test([[5]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_4","description":"Matrix with negative numbers (valid magic square)","execution_statement":"result = magic_square_test([[-1, -2, 3], [0, 1, -2], [2, -3, 1]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_5","description":"Matrix with negative numbers (not magic)","execution_statement":"result = magic_square_test([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_6","description":"Matrix with zeros (valid magic square)","execution_statement":"result = magic_square_test([[0, 0, 0], [0, 0, 0], [0, 0, 0]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_7","description":"Larger matrix (4x4) - magic square","execution_statement":"result = magic_square_test([[16, 3, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":4,"max_len":4}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_8","description":"Larger matrix (4x4) - not magic","execution_statement":"result = magic_square_test([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":4,"max_len":4}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_9","description":"Matrix with duplicate numbers (magic)","execution_statement":"result = magic_square_test([[1, 1, 1], [1, 1, 1], [1, 1, 1]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_10","description":"Matrix with duplicate numbers (not magic)","execution_statement":"result = magic_square_test([[1, 2, 1], [1, 1, 1], [1, 1, 1]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_11","description":"Empty matrix (should be handled by precondition or return False)","execution_statement":"result = magic_square_test([])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_12","description":"Non-square matrix (should be handled by precondition)","execution_statement":"result = magic_square_test([[1, 2], [3, 4], [5, 6]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3}},"assumptions":["len(my_matrix) != len(my_matrix[0])"],"postconditions":[{"assertion":"result == False"}]},{"id":"pc_13","description":"Matrix with large integers (magic)","execution_statement":"result = magic_square_test([[1000, 1000, 1000], [1000, 1000, 1000], [1000, 1000, 1000]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_14","description":"Matrix with large integers (not magic)","execution_statement":"result = magic_square_test([[1000, 1001, 1002], [1003, 1004, 1005], [1006, 1007, 1008]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3}},"postconditions":[{"assertion":"result == False"}]},{"id":"pc_15","description":"Negative Test: Input is not a list of lists (e.g., list of ints)","execution_statement":"try: result = magic_square_test([1, 2, 3]) except Exception as e: result = e","input_types":{"my_matrix":"list[int]"},"input_constraints":{"my_matrix":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_16","description":"Negative Test: Input is not a list of lists (e.g., int)","execution_statement":"try: result = magic_square_test(123) except Exception as e: result = e","input_types":{"my_matrix":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_17","description":"Negative Test: Matrix contains non-integer elements (float)","execution_statement":"try: result = magic_square_test([[1, 2.5], [3, 4]]) except Exception as e: result = e","input_types":{"my_matrix":"list[list[Union[int, float]]]"},"input_constraints":{"my_matrix":{"min_len":2,"max_len":2}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_18","description":"Negative Test: Matrix contains non-integer elements (string)","execution_statement":"try: result = magic_square_test([[1, 'a'], [3, 4]]) except Exception as e: result = e","input_types":{"my_matrix":"list[list[Union[int, str]]]"},"input_constraints":{"my_matrix":{"min_len":2,"max_len":2}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_19","description":"Matrix with mixed positive and negative numbers (magic)","execution_statement":"result = magic_square_test([[8, 1, 6], [3, 5, 7], [4, 9, 2]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"is_mixed":true}},"postconditions":[{"assertion":"result == True"}]},{"id":"pc_20","description":"Matrix with mixed positive and negative numbers (not magic)","execution_statement":"result = magic_square_test([[1, -2, 3], [-4, 5, -6], [7, -8, 9]])","input_types":{"my_matrix":"list[list[int]]"},"input_constraints":{"my_matrix":{"min_len":3,"max_len":3,"is_mixed":true}},"postconditions":[{"assertion":"result == False"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6167"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list with integers","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":50,"min_val":-100,"max_val":100}},"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result in nums"},{"assertion":"Counter(nums)[result] >= Counter(nums)[other] for other in set(nums)"}]},{"id":"pc_2","description":"Edge Case: Empty list","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":0,"max_len":0}},"execution_statement":"try: result = max_occurrences(nums) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, ValueError)"}]},{"id":"pc_3","description":"Edge Case: List with a single element","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1,"min_val":-100,"max_val":100}},"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result == nums[0]"}]},{"id":"pc_4","description":"Edge Case: All elements are the same","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":20,"min_val":5,"max_val":5}},"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result == nums[0]"}]},{"id":"pc_5","description":"Tie for maximum frequency","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":30,"min_val":-10,"max_val":10}},"assumptions":["len(set(nums)) > 1"],"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result in nums"},{"assertion":"Counter(nums)[result] == max(Counter(nums).values())"},{"assertion":"nums.index(result) == min(nums.index(item) for item, freq in Counter(nums).items() if freq == Counter(nums)[result])"}]},{"id":"pc_6","description":"List with negative integers","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":-1000,"max_val":-1}},"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result in nums"},{"assertion":"Counter(nums)[result] >= Counter(nums)[other] for other in set(nums)"}]},{"id":"pc_7","description":"List with large integers","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":1000000,"max_val":2000000}},"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result in nums"},{"assertion":"Counter(nums)[result] >= Counter(nums)[other] for other in set(nums)"}]},{"id":"pc_8","description":"List with mixed positive and negative integers","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":-500,"max_val":500,"is_mixed":true}},"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result in nums"},{"assertion":"Counter(nums)[result] >= Counter(nums)[other] for other in set(nums)"}]},{"id":"pc_9","description":"List with zero","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":-10,"max_val":10}},"assumptions":["0 in nums"],"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result in nums"},{"assertion":"Counter(nums)[result] >= Counter(nums)[other] for other in set(nums)"}]},{"id":"pc_10","description":"List with only one distinct element, repeated","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":10,"max_len":20,"min_val":7,"max_val":7}},"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result == 7"}]},{"id":"pc_11","description":"Negative Test: Input is not a list (e.g., int)","input_types":{"nums":"int"},"input_constraints":{},"execution_statement":"try: result = max_occurrences(nums) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: Input is not a list (e.g., string)","input_types":{"nums":"str"},"input_constraints":{"nums":{"min_len":1,"max_codepoint":255}},"execution_statement":"try: result = max_occurrences(nums) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Negative Test: Input is not a list (e.g., None)","input_types":{"nums":"None"},"input_constraints":{},"execution_statement":"try: result = max_occurrences(nums) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"List with mixed hashable types (int, str, tuple)","input_types":{"nums":"list[Any]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"is_hashable_mix":true,"is_mixed":true}},"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result in nums"},{"assertion":"Counter(nums)[result] >= Counter(nums)[other] for other in set(nums)"}]},{"id":"pc_15","description":"List with boolean values (True/False treated as 1/0)","input_types":{"nums":"list[bool]"},"input_constraints":{"nums":{"min_len":5,"max_len":50}},"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result in nums"},{"assertion":"Counter(nums)[result] >= Counter(nums)[other] for other in set(nums)"}]},{"id":"pc_16","description":"List with floats","input_types":{"nums":"list[float]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":-100.0,"max_val":100.0}},"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result in nums"},{"assertion":"Counter(nums)[result] >= Counter(nums)[other] for other in set(nums)"}]},{"id":"pc_17","description":"List with tuples","input_types":{"nums":"list[tuple[int]]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"elements":{"min_len":1,"max_len":3,"min_val":-10,"max_val":10}}},"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result in nums"},{"assertion":"Counter(nums)[result] >= Counter(nums)[other] for other in set(nums)"}]},{"id":"pc_18","description":"Tie for max frequency with negative numbers","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":30,"min_val":-20,"max_val":-5}},"assumptions":["len(set(nums)) > 1"],"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result in nums"},{"assertion":"Counter(nums)[result] == max(Counter(nums).values())"},{"assertion":"nums.index(result) == min(nums.index(item) for item, freq in Counter(nums).items() if freq == Counter(nums)[result])"}]},{"id":"pc_19","description":"List with many distinct elements, each appearing once","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":10,"max_len":20,"unique":true,"min_val":1,"max_val":100}},"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result in nums"},{"assertion":"Counter(nums)[result] == 1"}]},{"id":"pc_20","description":"List with a mix of integers and floats","input_types":{"nums":"list[Union[int, float]]"},"input_constraints":{"nums":{"min_len":5,"max_len":50,"min_val":-50.0,"max_val":50.0}},"execution_statement":"result = max_occurrences(nums)","postconditions":[{"assertion":"result in nums"},{"assertion":"Counter(nums)[result] >= Counter(nums)[other] for other in set(nums)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6168"},"test_cases":[{"id":"pc_1","description":"Happy Path: Mixed vowels and consonants","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":1,"max_size":100,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ","is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":0,"max_size":0,"max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String with no vowels","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":1,"max_size":50,"alphabet":"bcdfghjklmnpqrstvwxzBCDFGHJKLMNPQRSTVWXZ","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: String with only vowels","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":1,"max_size":50,"alphabet":"aeiouAEIOU","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: String with all same characters (vowels)","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":5,"max_size":50,"alphabet":"a","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: String with all same characters (consonants)","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":5,"max_size":50,"alphabet":"b","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_7","description":"Invariant: Vowel count remains the same","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":1,"max_size":100,"max_codepoint":127}},"postconditions":[{"assertion":"count_vowels(input_string) == count_vowels(result)"}],"assumptions":[]},{"id":"pc_8","description":"Invariant: Consonant count remains the same","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":1,"max_size":100,"max_codepoint":127}},"postconditions":[{"assertion":"count_consonants(input_string) == count_consonants(result)"}],"assumptions":[]},{"id":"pc_9","description":"Unicode characters (non-alphabetic)","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":1,"max_size":100,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+=-`~[]{}|;':,./<>?","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_10","description":"Long string with mixed content","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":100,"max_size":500,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZaeiouAEIOU","is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_11","description":"String with only uppercase vowels","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":1,"max_size":50,"alphabet":"AEIOU","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_12","description":"String with only lowercase vowels","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":1,"max_size":50,"alphabet":"aeiou","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_13","description":"String with mixed case vowels","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":1,"max_size":50,"alphabet":"aEiOu","is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_14","description":"String with numbers and vowels","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":1,"max_size":50,"alphabet":"aeiouAEIOU0123456789","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_15","description":"String with special characters and vowels","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":1,"max_size":50,"alphabet":"aeiouAEIOU!@#$%^&*()","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_16","description":"String with spaces and vowels","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":1,"max_size":50,"alphabet":"aeiouAEIOU ","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_17","description":"String with only one vowel","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":1,"max_size":50,"alphabet":"bcdfghjklmnpqrstvwxzBCDFGHJKLMNPQRSTVWXZa","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_18","description":"String with two vowels","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":2,"max_size":50,"alphabet":"bcdfghjklmnpqrstvwxzBCDFGHJKLMNPQRSTVWXZae","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_19","description":"String with many vowels","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":10,"max_size":100,"alphabet":"aeiouAEIOUbcdfghjklmnpqrstvwxz","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]},{"id":"pc_20","description":"String with many consonants","execution_statement":"result = reverse_vowels(input_string)","input_types":{"input_string":"string"},"input_constraints":{"input_string":{"min_size":10,"max_size":100,"alphabet":"bcdfghjklmnpqrstvwxzBCDFGHJKLMNPQRSTVWXZaeiou","max_codepoint":127}},"postconditions":[{"assertion":"output_is_string(result)"},{"assertion":"vowel_positions_preserved(input_string, result)"},{"assertion":"vowels_are_reversed(input_string, result)"},{"assertion":"consonants_are_unchanged(input_string, result)"},{"assertion":"length_is_preserved(input_string, result)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6169"},"test_cases":[{"id":"pc_1","description":"Happy Path: Tuple of strings","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"elements":{"min_len":1,"max_len":10}}},"execution_statement":"result = tup_string(tup1)","postconditions":[{"assertion":"result == ''.join(tup1)"}]},{"id":"pc_2","description":"Happy Path: Tuple of mixed hashable types","input_types":{"tup1":"tuple"},"input_constraints":{"tup1":{"min_len":0,"max_len":5,"elements":{"allow_none":true,"is_mixed":true},"is_mixed":true}},"execution_statement":"result = tup_string(tup1)","postconditions":[{"assertion":"result == ''.join(str(x) for x in tup1)"}]},{"id":"pc_3","description":"Edge Case: Empty tuple","input_types":{"tup1":"tuple"},"input_constraints":{"tup1":{"min_len":0,"max_len":0}},"execution_statement":"result = tup_string(tup1)","postconditions":[{"assertion":"result == ''"}]},{"id":"pc_4","description":"Edge Case: Tuple with single string element","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":1,"max_len":1,"elements":{"min_len":5,"max_len":5}}},"execution_statement":"result = tup_string(tup1)","postconditions":[{"assertion":"result == ''.join(tup1)"}]},{"id":"pc_5","description":"Edge Case: Tuple with numbers","input_types":{"tup1":"tuple[int]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"elements":{"min_val":-100,"max_val":100}}},"execution_statement":"result = tup_string(tup1)","postconditions":[{"assertion":"result == ''.join(str(x) for x in tup1)"}]},{"id":"pc_6","description":"Edge Case: Tuple with floats","input_types":{"tup1":"tuple[float]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"elements":{"allow_nan":false,"allow_inf":false,"min_val":-100.0,"max_val":100.0}}},"execution_statement":"result = tup_string(tup1)","postconditions":[{"assertion":"result == ''.join(str(x) for x in tup1)"}]},{"id":"pc_7","description":"Edge Case: Tuple with booleans","input_types":{"tup1":"tuple[bool]"},"input_constraints":{"tup1":{"min_len":1,"max_len":5}},"execution_statement":"result = tup_string(tup1)","postconditions":[{"assertion":"result == ''.join(str(x) for x in tup1)"}]},{"id":"pc_8","description":"Negative Test: Tuple containing unhashable type (list)","input_types":{"tup1":"tuple"},"input_constraints":{"tup1":{"min_len":1,"max_len":3,"elements":{"allow_none":false,"is_mixed":true,"max_codepoint":10}}},"execution_statement":"try: result = tup_string(tup1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: Non-tuple input (integer)","input_types":{"tup1":"int"},"input_constraints":{},"execution_statement":"try: result = tup_string(tup1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Non-tuple input (string)","input_types":{"tup1":"str"},"input_constraints":{"tup1":{"min_len":1,"max_len":10,"max_codepoint":255}},"execution_statement":"try: result = tup_string(tup1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Negative Test: Non-tuple input (None)","input_types":{"tup1":"None"},"input_constraints":{},"execution_statement":"try: result = tup_string(tup1) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Tuple with None elements","input_types":{"tup1":"tuple"},"input_constraints":{"tup1":{"min_len":1,"max_len":5,"elements":{"allow_none":true,"max_codepoint":10}}},"execution_statement":"result = tup_string(tup1)","postconditions":[{"assertion":"result == ''.join(str(x) for x in tup1)"}]},{"id":"pc_13","description":"Tuple with very long strings","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":1,"max_len":2,"elements":{"min_len":50,"max_len":100}}},"execution_statement":"result = tup_string(tup1)","postconditions":[{"assertion":"result == ''.join(tup1)"}]},{"id":"pc_14","description":"Tuple with large integers","input_types":{"tup1":"tuple[int]"},"input_constraints":{"tup1":{"min_len":1,"max_len":3,"elements":{"min_val":1000000,"max_val":2000000}}},"execution_statement":"result = tup_string(tup1)","postconditions":[{"assertion":"result == ''.join(str(x) for x in tup1)"}]},{"id":"pc_15","description":"Tuple with special characters in strings","input_types":{"tup1":"tuple[str]"},"input_constraints":{"tup1":{"min_len":1,"max_len":4,"elements":{"alphabet":"!@#$%^&*()_+=-`~[]{}|;':,./<>?","min_len":1,"max_len":5}}},"execution_statement":"result = tup_string(tup1)","postconditions":[{"assertion":"result == ''.join(tup1)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc616a"},"test_cases":[{"id":"pc_1","description":"Happy Path: Mixed positive and negative numbers","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"min_len":1,"max_len":100,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(n for n in numbers if n < 0)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with only positive numbers","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"min_value":0.0,"min_len":1,"max_len":100}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: List with only negative numbers","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"max_value":0.0,"min_len":1,"max_len":100}},"postconditions":[{"assertion":"result == sum(numbers)"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: List with zeros","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"min_value":0.0,"max_value":0.0,"min_len":1,"max_len":100}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_6","description":"Large numbers: Mixed positive and negative","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"min_value":-1E+18,"max_value":1E+18,"min_len":1,"max_len":100,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(n for n in numbers if n < 0)"}],"assumptions":[]},{"id":"pc_7","description":"Large list with negative numbers","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"max_value":0.0,"min_len":1000,"max_len":2000}},"postconditions":[{"assertion":"result == sum(numbers)"}],"assumptions":[]},{"id":"pc_8","description":"List with single negative number","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"max_value":-1E-06,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == numbers[0]"}],"assumptions":[]},{"id":"pc_9","description":"List with single positive number","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"min_value":1E-06,"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_10","description":"Invariant: Result is always non-negative","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"min_len":1,"max_len":100}},"postconditions":[{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_11","description":"Invariant: Result type is numeric","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"min_len":1,"max_len":100}},"postconditions":[{"assertion":"isinstance(result, (int, float))"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Non-list input (int)","execution_statement":"try: result = sum_negativenum(numbers) except Exception as e: result = e","input_types":{"numbers":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Non-list input (None)","execution_statement":"try: result = sum_negativenum(numbers) except Exception as e: result = e","input_types":{"numbers":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: List with non-numeric types (string)","execution_statement":"try: result = sum_negativenum(numbers) except Exception as e: result = e","input_types":{"numbers":"list[str]"},"input_constraints":{"numbers":{"min_len":1,"max_len":5,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: List with non-numeric types (None)","execution_statement":"try: result = sum_negativenum(numbers) except Exception as e: result = e","input_types":{"numbers":"list[Optional[float]]"},"input_constraints":{"numbers":{"allow_none":true,"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"List with very small negative numbers","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"max_value":-1E-18,"min_value":-1E-09,"min_len":1,"max_len":100}},"postconditions":[{"assertion":"result == sum(n for n in numbers if n < 0)"}],"assumptions":[]},{"id":"pc_17","description":"List with very small positive numbers","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[float]"},"input_constraints":{"numbers":{"min_value":1E-18,"max_value":1E-09,"min_len":1,"max_len":100}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_18","description":"List with a mix of integers and floats","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[Union[int, float]]"},"input_constraints":{"numbers":{"min_len":1,"max_len":100}},"postconditions":[{"assertion":"result == sum(n for n in numbers if n < 0)"}],"assumptions":[]},{"id":"pc_19","description":"List with only integers","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"min_len":1,"max_len":100}},"postconditions":[{"assertion":"result == sum(n for n in numbers if n < 0)"}],"assumptions":[]},{"id":"pc_20","description":"List with large negative integers","execution_statement":"result = sum_negativenum(numbers)","input_types":{"numbers":"list[int]"},"input_constraints":{"numbers":{"max_value":-1,"min_value":-1000000000,"min_len":1,"max_len":100}},"postconditions":[{"assertion":"result == sum(numbers)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc616b"},"test_cases":[{"id":"pc_1","description":"Happy Path: Small positive integer","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":100}},"postconditions":[{"assertion":"result == n * (2 * n - 1)"},{"assertion":"result >= 1"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Larger positive integer","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":101,"max_value":100000}},"postconditions":[{"assertion":"result == n * (2 * n - 1)"},{"assertion":"result >= 1"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Case: Smallest valid input (n=1)","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":1}},"postconditions":[{"assertion":"result == 1"},{"assertion":"result == n * (2 * n - 1)"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Case: Large valid input","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":999999,"max_value":1000000}},"postconditions":[{"assertion":"result == n * (2 * n - 1)"},{"assertion":"result >= 1"}],"assumptions":[]},{"id":"pc_5","description":"Negative Test: Invalid Type (float)","execution_statement":"try: result = hexagonal_num(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: Invalid Type (string)","execution_statement":"try: result = hexagonal_num(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Invalid Type (None)","execution_statement":"try: result = hexagonal_num(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Zero input (should raise ValueError)","execution_statement":"try: result = hexagonal_num(n) except Exception as e: result = e","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":0,"max_value":0}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Negative integer input (should raise ValueError)","execution_statement":"try: result = hexagonal_num(n) except Exception as e: result = e","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":-100,"max_value":-1}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_10","description":"Invariant Test: Non-decreasing sequence (n=2)","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":2,"max_value":2}},"postconditions":[{"assertion":"result >= hexagonal_num(1)"}],"assumptions":[]},{"id":"pc_11","description":"Invariant Test: Non-decreasing sequence (n=10)","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":10,"max_value":10}},"postconditions":[{"assertion":"result >= hexagonal_num(9)"}],"assumptions":[]},{"id":"pc_12","description":"Invariant Test: Non-decreasing sequence (large n)","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":50000,"max_value":50000}},"postconditions":[{"assertion":"result >= hexagonal_num(49999)"}],"assumptions":[]},{"id":"pc_13","description":"Test with a moderately large number","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1000,"max_value":5000}},"postconditions":[{"assertion":"result == n * (2 * n - 1)"}],"assumptions":[]},{"id":"pc_14","description":"Test with a number that results in a large hexagonal number","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":50001,"max_value":100000}},"postconditions":[{"assertion":"result == n * (2 * n - 1)"}],"assumptions":[]},{"id":"pc_15","description":"Test with a number that results in a very large hexagonal number","execution_statement":"result = hexagonal_num(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":100001,"max_value":1000000}},"postconditions":[{"assertion":"result == n * (2 * n - 1)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc616c"},"test_cases":[{"id":"pc_1","description":"Happy Path: Mixed integers","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":20,"is_mixed":true}},"execution_statement":"result = zero_count(nums)","postconditions":[{"assertion":"result == (nums.count(0) / (len(nums) - nums.count(0))) if len(nums) > nums.count(0) else float('inf')"}]},{"id":"pc_2","description":"Boundary Case: All zeroes","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":10}},"assumptions":["all(x == 0 for x in nums)"],"execution_statement":"result = zero_count(nums)","postconditions":[{"assertion":"result == float('inf')"}]},{"id":"pc_3","description":"Boundary Case: No zeroes","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":10}},"assumptions":["all(x != 0 for x in nums)"],"execution_statement":"result = zero_count(nums)","postconditions":[{"assertion":"result == 0.0"}]},{"id":"pc_4","description":"Edge Case: Empty list","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"max_len":0}},"execution_statement":"try: result = zero_count(nums) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, ZeroDivisionError)"}]},{"id":"pc_5","description":"Edge Case: Single zero","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1}},"assumptions":["nums == [0]"],"execution_statement":"result = zero_count(nums)","postconditions":[{"assertion":"result == float('inf')"}]},{"id":"pc_6","description":"Edge Case: Single non-zero","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1}},"assumptions":["nums != [0]"],"execution_statement":"result = zero_count(nums)","postconditions":[{"assertion":"result == 0.0"}]},{"id":"pc_7","description":"Large numbers, mixed","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_value":-1000000,"max_value":1000000,"min_len":10,"max_len":50,"is_mixed":true}},"execution_statement":"result = zero_count(nums)","postconditions":[{"assertion":"result == (nums.count(0) / (len(nums) - nums.count(0))) if len(nums) > nums.count(0) else float('inf')"}]},{"id":"pc_8","description":"Negative Test: Invalid type (float)","input_types":{"nums":"float"},"execution_statement":"try: result = zero_count(nums) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Negative Test: Invalid type (string)","input_types":{"nums":"str"},"execution_statement":"try: result = zero_count(nums) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: Invalid type (None)","input_types":{"nums":"None"},"execution_statement":"try: result = zero_count(nums) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"List with many zeroes and few non-zeroes","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":10,"max_len":30}},"assumptions":["nums.count(0) > len(nums) / 2"],"execution_statement":"result = zero_count(nums)","postconditions":[{"assertion":"result == (nums.count(0) / (len(nums) - nums.count(0))) if len(nums) > nums.count(0) else float('inf')"}]},{"id":"pc_12","description":"List with few zeroes and many non-zeroes","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":10,"max_len":30}},"assumptions":["nums.count(0) < len(nums) / 2 and nums.count(0) > 0"],"execution_statement":"result = zero_count(nums)","postconditions":[{"assertion":"result == (nums.count(0) / (len(nums) - nums.count(0))) if len(nums) > nums.count(0) else float('inf')"}]},{"id":"pc_13","description":"List with only positive numbers","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_value":1,"max_value":100,"min_len":5,"max_len":20}},"execution_statement":"result = zero_count(nums)","postconditions":[{"assertion":"result == 0.0"}]},{"id":"pc_14","description":"List with only negative numbers","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_value":-100,"max_value":-1,"min_len":5,"max_len":20}},"execution_statement":"result = zero_count(nums)","postconditions":[{"assertion":"result == 0.0"}]},{"id":"pc_15","description":"List with large positive and negative numbers, and zeroes","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_value":-1000000000,"max_value":1000000000,"min_len":10,"max_len":50}},"execution_statement":"result = zero_count(nums)","postconditions":[{"assertion":"result == (nums.count(0) / (len(nums) - nums.count(0))) if len(nums) > nums.count(0) else float('inf')"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc616d"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical positive integers","execution_statement":"result = is_Sum_Of_Powers_Of_Two(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == (number > 0 and (number & (number - 1) == 0))"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Powers of 2","execution_statement":"result = is_Sum_Of_Powers_Of_Two(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":1,"max_val":1024,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["bin(number).count('1') == 1"]},{"id":"pc_3","description":"Happy Path: Sums of distinct powers of 2","execution_statement":"result = is_Sum_Of_Powers_Of_Two(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":3,"max_val":1000,"allow_none":false}},"postconditions":[{"assertion":"result == True"}],"assumptions":["bin(number).count('1') > 1"]},{"id":"pc_4","description":"Edge Case: Zero input","execution_statement":"result = is_Sum_Of_Powers_Of_Two(number)","input_types":{"number":"int"},"input_constraints":{"number":{"value":0}},"postconditions":[{"assertion":"result == False"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Smallest sum of powers of 2 (3)","execution_statement":"result = is_Sum_Of_Powers_Of_Two(number)","input_types":{"number":"int"},"input_constraints":{"number":{"value":3}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Largest power of 2 within a range","execution_statement":"result = is_Sum_Of_Powers_Of_Two(number)","input_types":{"number":"int"},"input_constraints":{"number":{"value":1024}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: Number just below a power of 2 (sum of powers)","execution_statement":"result = is_Sum_Of_Powers_Of_Two(number)","input_types":{"number":"int"},"input_constraints":{"number":{"value":1023}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Float input","execution_statement":"try: result = is_Sum_Of_Powers_Of_Two(number) except Exception as e: result = e","input_types":{"number":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: String input","execution_statement":"try: result = is_Sum_Of_Powers_Of_Two(number) except Exception as e: result = e","input_types":{"number":"str"},"input_constraints":{"number":{"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: null input","execution_statement":"try: result = is_Sum_Of_Powers_Of_Two(number) except Exception as e: result = e","input_types":{"number":"NoneType"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Invariant: Result is always boolean","execution_statement":"result = is_Sum_Of_Powers_Of_Two(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":0,"max_val":10000}},"postconditions":[{"assertion":"isinstance(result, bool)"}],"assumptions":[]},{"id":"pc_12","description":"Large number test","execution_statement":"result = is_Sum_Of_Powers_Of_Two(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":100000,"max_val":1000000}},"postconditions":[{"assertion":"result == (number > 0 and (number & (number - 1) == 0))"}],"assumptions":[]},{"id":"pc_13","description":"Test with a number that is not a sum of powers of 2","execution_statement":"result = is_Sum_Of_Powers_Of_Two(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == False"}],"assumptions":["bin(number).count('1') > 1 and not (number & (number - 1) == 0)"]},{"id":"pc_14","description":"Test with a number that is a sum of powers of 2 (larger value)","execution_statement":"result = is_Sum_Of_Powers_Of_Two(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":1000,"max_val":2000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["bin(number).count('1') > 1 and (number & (number - 1) == 0)"]},{"id":"pc_15","description":"Test with a number that is a power of 2 (larger value)","execution_statement":"result = is_Sum_Of_Powers_Of_Two(number)","input_types":{"number":"int"},"input_constraints":{"number":{"min_val":1000,"max_val":2000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["bin(number).count('1') == 1"]}]}
{"_id":{"$oid":"692adffe1b18223597bc616e"},"test_cases":[{"id":"pc_1","description":"Happy Path: Positive float radius","execution_statement":"result = circle_circumference(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_value":0.1,"max_value":1000.0}},"postconditions":[{"assertion":"abs(result - (2 * 3.1415 * r)) < 1e-9"},{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Zero radius","execution_statement":"result = circle_circumference(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_value":0.0,"max_value":0.0}},"postconditions":[{"assertion":"abs(result - (2 * 3.1415 * r)) < 1e-9"},{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Very small positive radius","execution_statement":"result = circle_circumference(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_value":1E-09,"max_value":0.001}},"postconditions":[{"assertion":"abs(result - (2 * 3.1415 * r)) < 1e-9"},{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Very large radius","execution_statement":"result = circle_circumference(r)","input_types":{"r":"float"},"input_constraints":{"r":{"min_value":1E+06,"max_value":1E+18}},"postconditions":[{"assertion":"abs(result - (2 * 3.1415 * r)) < 1e-9"},{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_5","description":"Negative Test: Negative radius (expecting TypeError or incorrect result based on implementation)","execution_statement":"try: result = circle_circumference(r) except Exception as e: result = e","input_types":{"r":"float"},"input_constraints":{"r":{"min_value":-1000.0,"max_value":-0.1}},"postconditions":[{"assertion":"isinstance(result, TypeError) or result < 0"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: String input for radius","execution_statement":"try: result = circle_circumference(r) except Exception as e: result = e","input_types":{"r":"str"},"input_constraints":{"r":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: null input for radius","execution_statement":"try: result = circle_circumference(r) except Exception as e: result = e","input_types":{"r":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Happy Path: Integer radius","execution_statement":"result = circle_circumference(r)","input_types":{"r":"int"},"input_constraints":{"r":{"min_value":1,"max_value":1000}},"postconditions":[{"assertion":"abs(result - (2 * 3.1415 * r)) < 1e-9"},{"assertion":"result >= 0"}],"assumptions":[]},{"id":"pc_9","description":"Edge Case: Zero integer radius","execution_statement":"result = circle_circumference(r)","input_types":{"r":"int"},"input_constraints":{"r":{"min_value":0,"max_value":0}},"postconditions":[{"assertion":"abs(result - (2 * 3.1415 * r)) < 1e-9"},{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_10","description":"Edge Case: Large integer radius","execution_statement":"result = circle_circumference(r)","input_types":{"r":"int"},"input_constraints":{"r":{"min_value":1000000,"max_value":1000000000000000000}},"postconditions":[{"assertion":"abs(result - (2 * 3.1415 * r)) < 1e-9"},{"assertion":"result >= 0"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc616f"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list of lists with integers.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":10,"items":{"min_len":1,"max_len":10,"items":{"min_val":-100,"max_val":100}}}},"postconditions":[{"assertion":"all(isinstance(item, int) for item in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"all(item in set(e for sublist in test_list for e in sublist) for item in result)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty outer list.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Outer list with empty inner lists.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"items":{"min_len":0,"max_len":0}}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Mixed empty and non-empty inner lists.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":0,"max_len":2,"items":{"min_len":0,"max_len":2,"items":{"min_val":-50,"max_val":2}},"is_mixed":true}},"postconditions":[{"assertion":"all(isinstance(item, int) for item in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"all(item in set(e for sublist in test_list for e in sublist) for item in result)"}],"assumptions":["any(len(sublist) == 0 for sublist in test_list)"]},{"id":"pc_5","description":"Case: All inner lists contain duplicate elements.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5,"items":{"min_len":5,"max_len":10,"items":{"min_val":1,"max_val":20}}}},"postconditions":[{"assertion":"all(isinstance(item, int) for item in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"all(item in set(e for sublist in test_list for e in sublist) for item in result)"}],"assumptions":[]},{"id":"pc_6","description":"Case: Inner lists have overlapping elements.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5,"items":{"min_len":3,"max_len":7,"items":{"min_val":1,"max_val":50}}}},"postconditions":[{"assertion":"all(isinstance(item, int) for item in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"all(item in set(e for sublist in test_list for e in sublist) for item in result)"}],"assumptions":["any(set(test_list[i]) & set(test_list[j]) for i in range(len(test_list)) for j in range(i + 1, len(test_list)))"]},{"id":"pc_7","description":"Case: All elements are the same across all inner lists.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":2,"max_len":5,"items":{"min_len":5,"max_len":10,"items":{"min_val":10,"max_val":10}}}},"postconditions":[{"assertion":"result == [10]"}],"assumptions":[]},{"id":"pc_8","description":"Case: Large numbers.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"items":{"min_len":1,"max_len":5,"items":{"min_val":100000,"max_val":200000}}}},"postconditions":[{"assertion":"all(isinstance(item, int) for item in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"all(item in set(e for sublist in test_list for e in sublist) for item in result)"}],"assumptions":[]},{"id":"pc_9","description":"Case: Negative numbers.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":1,"max_len":5,"items":{"min_len":1,"max_len":5,"items":{"min_val":-200,"max_val":-100}}}},"postconditions":[{"assertion":"all(isinstance(item, int) for item in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"all(item in set(e for sublist in test_list for e in sublist) for item in result)"}],"assumptions":[]},{"id":"pc_10","description":"Case: Mixed positive, negative, and zero.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":0,"max_len":2,"items":{"min_len":0,"max_len":2,"items":{"min_val":-100,"max_val":2}},"is_mixed":true}},"postconditions":[{"assertion":"all(isinstance(item, int) for item in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"all(item in set(e for sublist in test_list for e in sublist) for item in result)"}],"assumptions":["any(0 in sublist for sublist in test_list)"]},{"id":"pc_11","description":"Negative Test: Invalid input type (float instead of list).","execution_statement":"try: result = extract_singly(test_list) except Exception as e: result = e","input_types":{"test_list":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Invalid input type (int instead of list).","execution_statement":"try: result = extract_singly(test_list) except Exception as e: result = e","input_types":{"test_list":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Inner list contains non-integer type (string).","execution_statement":"try: result = extract_singly(test_list) except Exception as e: result = e","input_types":{"test_list":"list[list[int | str]]"},"input_constraints":{"test_list":{"min_len":0,"max_len":2,"items":{"min_len":0,"max_len":2},"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["any(isinstance(e, str) for sublist in test_list for e in sublist)"]},{"id":"pc_14","description":"Negative Test: Inner list contains non-integer type (None).","execution_statement":"try: result = extract_singly(test_list) except Exception as e: result = e","input_types":{"test_list":"list[list[int | None]]"},"input_constraints":{"test_list":{"min_len":0,"max_len":2,"items":{"min_len":0,"max_len":2,"allow_none":true}}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":["any(e is None for sublist in test_list for e in sublist)"]},{"id":"pc_15","description":"Large scale test: Many inner lists and many elements.","execution_statement":"result = extract_singly(test_list)","input_types":{"test_list":"list[list[int]]"},"input_constraints":{"test_list":{"min_len":50,"max_len":100,"items":{"min_len":50,"max_len":100,"items":{"min_val":-1000,"max_val":1000}}}},"postconditions":[{"assertion":"all(isinstance(item, int) for item in result)"},{"assertion":"len(result) == len(set(result))"},{"assertion":"all(item in set(e for sublist in test_list for e in sublist) for item in result)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6170"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical list of integers","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":20,"unique":true}},"postconditions":[{"assertion":"result == sorted(nums)"},{"assertion":"len(result) == len(nums)"},{"assertion":"set(result) == set(nums)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Already sorted list","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":20,"sorted":"ascending","unique":true}},"postconditions":[{"assertion":"result == sorted(nums)"},{"assertion":"len(result) == len(nums)"},{"assertion":"set(result) == set(nums)"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Reverse sorted list","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":20,"sorted":"descending","unique":true}},"postconditions":[{"assertion":"result == sorted(nums)"},{"assertion":"len(result) == len(nums)"},{"assertion":"set(result) == set(nums)"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: List with duplicate elements","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":20}},"postconditions":[{"assertion":"result == sorted(nums)"},{"assertion":"len(result) == len(nums)"},{"assertion":"sorted(result) == sorted(nums)"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: List with a single element","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == sorted(nums)"},{"assertion":"len(result) == len(nums)"},{"assertion":"set(result) == set(nums)"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: List with all identical elements","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":10,"elements":{"type":"integers","value":[5]}}},"postconditions":[{"assertion":"result == sorted(nums)"},{"assertion":"len(result) == len(nums)"},{"assertion":"set(result) == set(nums)"}],"assumptions":[]},{"id":"pc_7","description":"Boundary Case: Smallest possible list length (1 element)","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == sorted(nums)"}],"assumptions":[]},{"id":"pc_8","description":"Boundary Case: Largest allowed list length","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":20,"max_len":20,"unique":true}},"postconditions":[{"assertion":"result == sorted(nums)"},{"assertion":"len(result) == len(nums)"},{"assertion":"set(result) == set(nums)"}],"assumptions":[]},{"id":"pc_9","description":"Boundary Case: Integers at the boundary of typical range","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":10,"elements":{"min_val":1,"max_val":10},"unique":true}},"postconditions":[{"assertion":"result == sorted(nums)"}],"assumptions":[]},{"id":"pc_10","description":"Boundary Case: Large integers","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":10,"elements":{"min_val":1000000000,"max_val":1000000000},"unique":true}},"postconditions":[{"assertion":"result == sorted(nums)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = pancake_sort(nums) except Exception as e: result = e","input_types":{"nums":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = pancake_sort(nums) except Exception as e: result = e","input_types":{"nums":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Input is not a list (float)","execution_statement":"try: result = pancake_sort(nums) except Exception as e: result = e","input_types":{"nums":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: List contains non-comparable types (int and str)","execution_statement":"try: result = pancake_sort(nums) except Exception as e: result = e","input_types":{"nums":"list[Union[int, str]]"},"input_constraints":{"nums":{"min_len":2,"max_len":5,"hashable_mix":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: List contains non-comparable types (int and None)","execution_statement":"try: result = pancake_sort(nums) except Exception as e: result = e","input_types":{"nums":"list[Union[int, None]]"},"input_constraints":{"nums":{"min_len":2,"max_len":5,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"Test with negative integers","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":15,"elements":{"min_val":-1000,"max_val":-1},"unique":true}},"postconditions":[{"assertion":"result == sorted(nums)"},{"assertion":"len(result) == len(nums)"},{"assertion":"set(result) == set(nums)"}],"assumptions":[]},{"id":"pc_17","description":"Test with mixed positive and negative integers","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":15,"elements":{"min_val":-500,"max_val":500},"unique":true,"is_mixed":true}},"postconditions":[{"assertion":"result == sorted(nums)"},{"assertion":"len(result) == len(nums)"},{"assertion":"set(result) == set(nums)"}],"assumptions":[]},{"id":"pc_18","description":"Test with a list containing zero","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":5,"max_len":15,"elements":{"min_val":-100,"max_val":100}}},"postconditions":[{"assertion":"result == sorted(nums)"},{"assertion":"len(result) == len(nums)"},{"assertion":"set(result) == set(nums)"}],"assumptions":[]},{"id":"pc_19","description":"Test with a very small list (2 elements)","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[int]"},"input_constraints":{"nums":{"min_len":2,"max_len":2,"unique":true}},"postconditions":[{"assertion":"result == sorted(nums)"}],"assumptions":[]},{"id":"pc_20","description":"Test with a list of strings (lexicographical sort)","execution_statement":"result = pancake_sort(nums)","input_types":{"nums":"list[str]"},"input_constraints":{"nums":{"min_len":5,"max_len":15,"elements":{"min_length":1,"max_length":10,"max_codepoint":127},"unique":true,"max_codepoint":127}},"postconditions":[{"assertion":"result == sorted(nums)"},{"assertion":"len(result) == len(nums)"},{"assertion":"set(result) == set(nums)"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6171"},"test_cases":[{"id":"pc_1","description":"Happy Path: All lists are identical and non-empty","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":5,"max_len":10},"list3":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result == len(list1)"}],"assumptions":["list1 == list2","list2 == list3"]},{"id":"pc_2","description":"Happy Path: Lists with some overlapping elements","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"integers":{"min_val":1,"max_val":5}},"list2":{"min_len":5,"max_len":10,"integers":{"min_val":1,"max_val":5}},"list3":{"min_len":5,"max_len":10,"integers":{"min_val":1,"max_val":5}}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(list1)"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: All lists are empty","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"max_len":0},"list2":{"max_len":0},"list3":{"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: One list is empty","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"max_len":0},"list3":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Two lists are empty","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"max_len":0},"list3":{"max_len":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_6","description":"Happy Path: Lists with different lengths, some matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":3,"max_len":7},"list3":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= min(len(list1), len(list2), len(list3))"}],"assumptions":[]},{"id":"pc_7","description":"Happy Path: Lists with mixed types (hashable)","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[Any]","list2":"list[Any]","list3":"list[Any]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"hashable_mix":true,"is_mixed":true},"list2":{"min_len":5,"max_len":10,"hashable_mix":true,"is_mixed":true},"list3":{"min_len":5,"max_len":10,"hashable_mix":true,"is_mixed":true}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= min(len(list1), len(list2), len(list3))"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: list1 is not iterable (int)","execution_statement":"try: result = count_samepair(list1, list2, list3) except Exception as e: result = e","input_types":{"list1":"int","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list2":{"min_len":1},"list3":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: list2 is not iterable (float)","execution_statement":"try: result = count_samepair(list1, list2, list3) except Exception as e: result = e","input_types":{"list1":"list[int]","list2":"float","list3":"list[int]"},"input_constraints":{"list1":{"min_len":1},"list3":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: list3 is not iterable (None)","execution_statement":"try: result = count_samepair(list1, list2, list3) except Exception as e: result = e","input_types":{"list1":"list[int]","list2":"list[int]","list3":"None"},"input_constraints":{"list1":{"min_len":1},"list2":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Happy Path: Lists with strings","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[str]","list2":"list[str]","list3":"list[str]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"max_codepoint":127},"list2":{"min_len":5,"max_len":10,"max_codepoint":127},"list3":{"min_len":5,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(list1)"}],"assumptions":[]},{"id":"pc_12","description":"Happy Path: Lists with booleans","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[bool]","list2":"list[bool]","list3":"list[bool]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":5,"max_len":10},"list3":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(list1)"}],"assumptions":[]},{"id":"pc_13","description":"Happy Path: Lists with None values","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[None]","list2":"list[None]","list3":"list[None]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":5,"max_len":10},"list3":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result == len(list1)"}],"assumptions":[]},{"id":"pc_14","description":"Happy Path: Lists with floats","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[float]","list2":"list[float]","list3":"list[float]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"floats":{"allow_nan":false,"allow_infinity":false}},"list2":{"min_len":5,"max_len":10,"floats":{"allow_nan":false,"allow_infinity":false}},"list3":{"min_len":5,"max_len":10,"floats":{"allow_nan":false,"allow_infinity":false}}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(list1)"}],"assumptions":[]},{"id":"pc_15","description":"Happy Path: Lists with tuples","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[tuple[int, str]]","list2":"list[tuple[int, str]]","list3":"list[tuple[int, str]]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"max_codepoint":127},"list2":{"min_len":5,"max_len":10,"max_codepoint":127},"list3":{"min_len":5,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"result >= 0"},{"assertion":"result <= len(list1)"}],"assumptions":[]},{"id":"pc_16","description":"Happy Path: Lists with different lengths and no matches","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"integers":{"min_val":1,"max_val":10}},"list2":{"min_len":5,"max_len":10,"integers":{"min_val":11,"max_val":20}},"list3":{"min_len":5,"max_len":10,"integers":{"min_val":21,"max_val":30}}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_17","description":"Happy Path: Lists with identical elements at specific positions","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":5,"max_len":10},"list3":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result >= 3"}],"assumptions":["list1[0] == list2[0] == list3[0]","list1[2] == list2[2] == list3[2]","list1[4] == list2[4] == list3[4]"]},{"id":"pc_18","description":"Happy Path: Lists with different lengths and all elements match up to min length","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":5,"max_len":10},"list3":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result == min(len(list1), len(list2), len(list3))"}],"assumptions":["list1 == list2","list2 == list3"]},{"id":"pc_19","description":"Happy Path: Lists with negative integers","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"integers":{"max_val":-1}},"list2":{"min_len":5,"max_len":10,"integers":{"max_val":-1}},"list3":{"min_len":5,"max_len":10,"integers":{"max_val":-1}}},"postconditions":[{"assertion":"result == len(list1)"}],"assumptions":["list1 == list2","list2 == list3"]},{"id":"pc_20","description":"Happy Path: Lists with zero","execution_statement":"result = count_samepair(list1, list2, list3)","input_types":{"list1":"list[int]","list2":"list[int]","list3":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10,"integers":{"max_val":0}},"list2":{"min_len":5,"max_len":10,"integers":{"max_val":0}},"list3":{"min_len":5,"max_len":10,"integers":{"max_val":0}}},"postconditions":[{"assertion":"result == len(list1)"}],"assumptions":["list1 == list2","list2 == list3"]}]}
{"_id":{"$oid":"692adffe1b18223597bc6172"},"test_cases":[{"id":"pc_1","description":"Happy Path: Input is a list","execution_statement":"result = find_lists(input_tuple)","input_types":{"input_tuple":"list"},"input_constraints":{"input_tuple":{"min_len":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Input is a tuple with lists","execution_statement":"result = find_lists(input_tuple)","input_types":{"input_tuple":"tuple"},"input_constraints":{"input_tuple":{"elements":[{"type":"lists","elements":{"type":"integers"},"min_size":1},{"type":"lists","elements":{"type":"integers"},"min_size":0}],"min_size":2,"max_size":5}},"postconditions":[{"assertion":"result == 2"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: Input is a tuple with no lists","execution_statement":"result = find_lists(input_tuple)","input_types":{"input_tuple":"tuple"},"input_constraints":{"input_tuple":{"elements":[{"type":"integers"},{"type":"strings"},{"type":"floats"}],"min_size":1,"max_size":5}},"postconditions":[{"assertion":"result == len(input_tuple)"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Empty tuple","execution_statement":"result = find_lists(input_tuple)","input_types":{"input_tuple":"tuple"},"input_constraints":{"input_tuple":{"min_size":0,"max_size":0}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Tuple with nested lists","execution_statement":"result = find_lists(input_tuple)","input_types":{"input_tuple":"tuple"},"input_constraints":{"input_tuple":{"elements":[{"type":"lists","elements":{"type":"lists","elements":{"type":"integers"}}},{"type":"lists","elements":{"type":"integers"}}],"min_size":2,"max_size":2}},"postconditions":[{"assertion":"result == 2"}],"assumptions":[]},{"id":"pc_6","description":"Negative Test: Input is an integer","execution_statement":"try: result = find_lists(input_tuple) except Exception as e: result = e","input_types":{"input_tuple":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_7","description":"Negative Test: Input is a string","execution_statement":"try: result = find_lists(input_tuple) except Exception as e: result = e","input_types":{"input_tuple":"str"},"input_constraints":{"input_tuple":{"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Input is a float","execution_statement":"try: result = find_lists(input_tuple) except Exception as e: result = e","input_types":{"input_tuple":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Input is None","execution_statement":"try: result = find_lists(input_tuple) except Exception as e: result = e","input_types":{"input_tuple":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Happy Path: Tuple with mixed types including lists","execution_statement":"result = find_lists(input_tuple)","input_types":{"input_tuple":"tuple"},"input_constraints":{"input_tuple":{"elements":[{"type":"integers"},{"type":"lists","elements":{"type":"integers"}},{"type":"strings"},{"type":"lists","elements":{"type":"strings"}},{"type":"floats"},{"type":"booleans"},{"type":"none"}],"min_size":3,"max_size":7,"is_mixed":true}},"postconditions":[{"assertion":"result == sum(1 for item in input_tuple if isinstance(item, list))"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6173"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical array with positive and negative integers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"result == (max(arr) - min(arr))"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Array with only positive integers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"min_val":1,"max_val":1000}},"postconditions":[{"assertion":"result == (max(arr) - min(arr))"}],"assumptions":[]},{"id":"pc_3","description":"Happy Path: Array with only negative integers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"min_val":-1000,"max_val":-1}},"postconditions":[{"assertion":"result == (max(arr) - min(arr))"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Array with two elements.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"max_len":2,"min_val":-1000,"max_val":1000}},"postconditions":[{"assertion":"result == (max(arr) - min(arr))"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Array with all identical elements.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"min_val":5,"max_val":5}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_6","description":"Happy Path: Array with large integers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"min_val":-1000000,"max_val":1000000}},"postconditions":[{"assertion":"result == (max(arr) - min(arr))"}],"assumptions":[]},{"id":"pc_7","description":"Happy Path: Array with floating-point numbers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[float]"},"input_constraints":{"arr":{"min_len":2,"allow_nan":false,"allow_infinity":false,"min_val":-1000.0,"max_val":1000.0}},"postconditions":[{"assertion":"result == (max(arr) - min(arr))"}],"assumptions":[]},{"id":"pc_8","description":"Happy Path: Array including zero.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"result == (max(arr) - min(arr))"}],"assumptions":["0 in arr"]},{"id":"pc_9","description":"Negative Test: Empty array.","execution_statement":"try: result = max_Abs_Diff(arr) except Exception as e: result = e","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"max_len":0}},"postconditions":[{"assertion":"isinstance(result, IndexError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Array with non-numeric type (string).","execution_statement":"try: result = max_Abs_Diff(arr) except Exception as e: result = e","input_types":{"arr":"list[str]"},"input_constraints":{"arr":{"min_len":1,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Array with non-numeric type (None).","execution_statement":"try: result = max_Abs_Diff(arr) except Exception as e: result = e","input_types":{"arr":"list[Optional[int]]"},"input_constraints":{"arr":{"min_len":1,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Happy Path: Mixed integers and floats.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[Union[int, float]]"},"input_constraints":{"arr":{"min_len":2,"allow_nan":false,"allow_infinity":false,"min_val":-1000,"max_val":1000,"is_mixed":true}},"postconditions":[{"assertion":"result == (max(arr) - min(arr))"}],"assumptions":[]},{"id":"pc_13","description":"Edge Case: Array with a single element (should ideally return 0 or raise error depending on implementation, current implementation raises IndexError for empty, but for single element it should be 0).","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_14","description":"Happy Path: Array with zero and positive numbers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"min_val":0,"max_val":100}},"postconditions":[{"assertion":"result == (max(arr) - min(arr))"}],"assumptions":[]},{"id":"pc_15","description":"Happy Path: Array with zero and negative numbers.","execution_statement":"result = max_Abs_Diff(arr)","input_types":{"arr":"list[int]"},"input_constraints":{"arr":{"min_len":2,"min_val":-100,"max_val":0}},"postconditions":[{"assertion":"result == (max(arr) - min(arr))"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6174"},"test_cases":[{"id":"pc_1","description":"Happy Path: General case with positive coefficients and n","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None or (a * result[0] + b * result[1] == n)"}]},{"id":"pc_2","description":"Happy Path: General case with mixed sign coefficients and n","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":100,"is_mixed":true},"b":{"min_val":-100,"max_val":100,"is_mixed":true},"n":{"min_val":-1000,"max_val":1000,"is_mixed":true}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None or (a * result[0] + b * result[1] == n)"}]},{"id":"pc_3","description":"Edge Case: a is zero, n is divisible by b","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"const":0},"b":{"min_val":1,"max_val":100},"n":{"min_val":-1000,"max_val":1000}},"assumptions":["n % b == 0"],"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is not None and result[1] == n // b"},{"assertion":"a * result[0] + b * result[1] == n"}]},{"id":"pc_4","description":"Edge Case: a is zero, n is not divisible by b","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"const":0},"b":{"min_val":1,"max_val":100},"n":{"min_val":-1000,"max_val":1000}},"assumptions":["n % b != 0"],"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None"}]},{"id":"pc_5","description":"Edge Case: b is zero, n is divisible by a","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"const":0},"n":{"min_val":-1000,"max_val":1000}},"assumptions":["n % a == 0"],"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is not None and result[0] == n // a"},{"assertion":"a * result[0] + b * result[1] == n"}]},{"id":"pc_6","description":"Edge Case: b is zero, n is not divisible by a","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"const":0},"n":{"min_val":-1000,"max_val":1000}},"assumptions":["n % a != 0"],"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None"}]},{"id":"pc_7","description":"Edge Case: Both a and b are zero, n is zero","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"const":0},"b":{"const":0},"n":{"const":0}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None"}]},{"id":"pc_8","description":"Edge Case: Both a and b are zero, n is non-zero","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"const":0},"b":{"const":0},"n":{"min_val":1,"max_val":100}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None"}]},{"id":"pc_9","description":"Large values for a, b, and n","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":10000,"max_val":100000},"b":{"min_val":10000,"max_val":100000},"n":{"min_val":100000,"max_val":1000000}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None or (a * result[0] + b * result[1] == n)"}]},{"id":"pc_10","description":"Large negative values for a, b, and n","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":-100000,"max_val":-10000},"b":{"min_val":-100000,"max_val":-10000},"n":{"min_val":-1000000,"max_val":-100000}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None or (a * result[0] + b * result[1] == n)"}]},{"id":"pc_11","description":"Co-prime coefficients, solution should always exist","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100},"n":{"min_val":-1000,"max_val":1000}},"assumptions":["math.gcd(a, b) == 1"],"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is not None"},{"assertion":"a * result[0] + b * result[1] == n"}]},{"id":"pc_12","description":"Non-co-prime coefficients, n divisible by gcd","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":2,"max_val":100},"b":{"min_val":2,"max_val":100},"n":{"min_val":-1000,"max_val":1000}},"assumptions":["math.gcd(a, b) > 1","n % math.gcd(a, b) == 0"],"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is not None"},{"assertion":"a * result[0] + b * result[1] == n"}]},{"id":"pc_13","description":"Non-co-prime coefficients, n not divisible by gcd","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":2,"max_val":100},"b":{"min_val":2,"max_val":100},"n":{"min_val":-1000,"max_val":1000}},"assumptions":["math.gcd(a, b) > 1","n % math.gcd(a, b) != 0"],"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None"}]},{"id":"pc_14","description":"Negative Test: Invalid type for 'a' (float)","input_types":{"a":"float","b":"int","n":"int"},"input_constraints":{"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":1000}},"execution_statement":"try: result = find_solution(a, b, n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_15","description":"Negative Test: Invalid type for 'b' (string)","input_types":{"a":"int","b":"str","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_len":1,"max_len":10,"max_codepoint":255},"n":{"min_val":1,"max_val":1000}},"execution_statement":"try: result = find_solution(a, b, n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_16","description":"Negative Test: Invalid type for 'n' (None)","input_types":{"a":"int","b":"int","n":"None"},"input_constraints":{"a":{"min_val":1,"max_val":100},"b":{"min_val":1,"max_val":100}},"execution_statement":"try: result = find_solution(a, b, n) except Exception as e: result = e","postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_17","description":"Test with very small negative numbers","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":-100,"max_val":-1},"b":{"min_val":-100,"max_val":-1},"n":{"min_val":-1000,"max_val":-100}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None or (a * result[0] + b * result[1] == n)"}]},{"id":"pc_18","description":"Test with mixed small positive and negative numbers","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":-50,"max_val":50,"is_mixed":true},"b":{"min_val":-50,"max_val":50,"is_mixed":true},"n":{"min_val":-500,"max_val":500,"is_mixed":true}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None or (a * result[0] + b * result[1] == n)"}]},{"id":"pc_19","description":"Test where the loop for 'i' might run many times","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":1,"max_val":5},"b":{"min_val":1,"max_val":100},"n":{"min_val":500,"max_val":1000}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None or (a * result[0] + b * result[1] == n)"}]},{"id":"pc_20","description":"Test where the loop for 'i' might not run at all (i*a > n)","input_types":{"a":"int","b":"int","n":"int"},"input_constraints":{"a":{"min_val":100,"max_val":200},"b":{"min_val":1,"max_val":100},"n":{"min_val":1,"max_val":50}},"execution_statement":"result = find_solution(a, b, n)","postconditions":[{"assertion":"result is None or (a * result[0] + b * result[1] == n)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6175"},"test_cases":[{"id":"pc_1","description":"Happy Path: Remove elements from a list of integers.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":20},"list2":{"min_len":0,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(item not in list2 for item in result)"},{"assertion":"set(result) == set(list1) - set(list2)"}],"assumptions":[]},{"id":"pc_2","description":"Happy Path: Remove elements from a list of strings.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[str]","list2":"list[str]"},"input_constraints":{"list1":{"min_len":5,"max_len":20,"max_codepoint":122},"list2":{"min_len":0,"max_len":10,"max_codepoint":122}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(item not in list2 for item in result)"},{"assertion":"set(result) == set(list1) - set(list2)"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: Empty list1.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":0},"list2":{"min_len":0,"max_len":10}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Empty list2.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":20},"list2":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == list1"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: All elements in list1 are also in list2.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":10},"list2":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result == []"}],"assumptions":["set(list1).issubset(set(list2))"]},{"id":"pc_6","description":"Happy Path: Mixed data types (hashable).","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[Any]","list2":"list[Any]"},"input_constraints":{"list1":{"min_len":5,"max_len":20,"hashable_mix":true,"is_mixed":true},"list2":{"min_len":0,"max_len":10,"hashable_mix":true,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(item not in list2 for item in result)"},{"assertion":"set(result) == set(list1) - set(list2)"}],"assumptions":[]},{"id":"pc_7","description":"Happy Path: Duplicates in list1, elements to remove are present.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":20,"unique":false},"list2":{"min_len":1,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(item not in list2 for item in result)"},{"assertion":"set(result) == set(list1) - set(list2)"}],"assumptions":[]},{"id":"pc_8","description":"Happy Path: Duplicates in list2.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":20},"list2":{"min_len":5,"max_len":10,"unique":false}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(item not in list2 for item in result)"},{"assertion":"set(result) == set(list1) - set(list2)"}],"assumptions":[]},{"id":"pc_9","description":"Edge Case: list1 and list2 are identical.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":5}},"postconditions":[{"assertion":"result == []"}],"assumptions":["list1 == list2"]},{"id":"pc_10","description":"Edge Case: list1 contains only one element, which is in list2.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":1,"max_len":1},"list2":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == []"}],"assumptions":["list1[0] in list2"]},{"id":"pc_11","description":"Edge Case: list1 contains only one element, which is NOT in list2.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":1,"max_len":1},"list2":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"result == list1"}],"assumptions":["list1[0] not in list2"]},{"id":"pc_12","description":"Negative Test: list1 is not iterable (int).","execution_statement":"try: result = remove_elements(list1, list2) except Exception as e: result = e","input_types":{"list1":"int","list2":"list[int]"},"input_constraints":{"list2":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: list2 is not iterable (float).","execution_statement":"try: result = remove_elements(list1, list2) except Exception as e: result = e","input_types":{"list1":"list[int]","list2":"float"},"input_constraints":{"list1":{"min_len":1,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Happy Path: Large lists.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":100,"max_len":500},"list2":{"min_len":100,"max_len":500}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(item not in list2 for item in result)"},{"assertion":"set(result) == set(list1) - set(list2)"}],"assumptions":[]},{"id":"pc_15","description":"Happy Path: Elements to remove are not present in list1.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":5,"max_len":20},"list2":{"min_len":5,"max_len":10}},"postconditions":[{"assertion":"result == list1"}],"assumptions":["set(list2).isdisjoint(set(list1))"]},{"id":"pc_16","description":"Happy Path: list1 contains None, list2 contains None.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[Optional[int]]","list2":"list[Optional[int]]"},"input_constraints":{"list1":{"min_len":5,"max_len":20,"allow_none":true},"list2":{"min_len":0,"max_len":10,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(item not in list2 for item in result)"},{"assertion":"set(result) == set(list1) - set(list2)"}],"assumptions":[]},{"id":"pc_17","description":"Happy Path: list1 contains booleans, list2 contains booleans.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[bool]","list2":"list[bool]"},"input_constraints":{"list1":{"min_len":5,"max_len":20},"list2":{"min_len":0,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(item not in list2 for item in result)"},{"assertion":"set(result) == set(list1) - set(list2)"}],"assumptions":[]},{"id":"pc_18","description":"Happy Path: list1 contains tuples, list2 contains tuples.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[tuple[int, str]]","list2":"list[tuple[int, str]]"},"input_constraints":{"list1":{"min_len":5,"max_len":20,"max_codepoint":127},"list2":{"min_len":0,"max_len":10,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, list)"},{"assertion":"all(item not in list2 for item in result)"},{"assertion":"set(result) == set(list1) - set(list2)"}],"assumptions":[]},{"id":"pc_19","description":"Edge Case: list1 is very long, list2 is empty.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":1000,"max_len":2000},"list2":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == list1"}],"assumptions":[]},{"id":"pc_20","description":"Edge Case: list1 is empty, list2 is very long.","execution_statement":"result = remove_elements(list1, list2)","input_types":{"list1":"list[int]","list2":"list[int]"},"input_constraints":{"list1":{"min_len":0,"max_len":0},"list2":{"min_len":1000,"max_len":2000}},"postconditions":[{"assertion":"result == []"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6176"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical positive integer input","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":100}},"postconditions":[{"assertion":"result == sum(n - 2*i for i in range(n // 3))"}]},{"id":"pc_2","description":"Edge Case: n = 0","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_3","description":"Edge Case: n = 1","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1,"max_val":1}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_4","description":"Large positive integer input","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":1000,"max_val":10000}},"postconditions":[{"assertion":"result == sum(n - 2*i for i in range(n // 3))"}]},{"id":"pc_5","description":"Negative Test: Invalid Type (float)","execution_statement":"try: result = sum_series(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_6","description":"Negative Test: Invalid Type (string)","execution_statement":"try: result = sum_series(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_7","description":"Negative Test: Invalid Type (None)","execution_statement":"try: result = sum_series(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_8","description":"Negative Test: Invalid Type (list)","execution_statement":"try: result = sum_series(n) except Exception as e: result = e","input_types":{"n":"list"},"input_constraints":{"n":{"min_len":1}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_9","description":"Test with n = 2","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":2,"max_val":2}},"postconditions":[{"assertion":"result == 2"}]},{"id":"pc_10","description":"Test with n = 3","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":3,"max_val":3}},"postconditions":[{"assertion":"result == 3"}]},{"id":"pc_11","description":"Test with n = 4","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":4,"max_val":4}},"postconditions":[{"assertion":"result == 4"}]},{"id":"pc_12","description":"Test with n = 5","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":5,"max_val":5}},"postconditions":[{"assertion":"result == 5"}]},{"id":"pc_13","description":"Test with n = 10","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10,"max_val":10}},"postconditions":[{"assertion":"result == 10"}]},{"id":"pc_14","description":"Test with n = 11","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":11,"max_val":11}},"postconditions":[{"assertion":"result == 11"}]},{"id":"pc_15","description":"Test with n = 10000","execution_statement":"result = sum_series(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_val":10000,"max_val":10000}},"postconditions":[{"assertion":"result == sum(n - 2*i for i in range(n // 3))"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc6177"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical integer sides and float length","execution_statement":"result = area_polygon(s, l)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":3,"max_val":100},"l":{"min_val":1E-06,"max_val":1000.0}},"postconditions":[{"assertion":"result > 0"},{"assertion":"isinstance(result, float)"},{"assertion":"abs(result - (s * (l ** 2) / (4 * tan(pi / s)))) < 1e-9"}],"assumptions":[]},{"id":"pc_2","description":"Boundary Case: Minimum number of sides (3)","execution_statement":"result = area_polygon(s, l)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":3,"max_val":3},"l":{"min_val":1E-06,"max_val":100.0}},"postconditions":[{"assertion":"result > 0"},{"assertion":"isinstance(result, float)"},{"assertion":"abs(result - (s * (l ** 2) / (4 * tan(pi / s)))) < 1e-9"}],"assumptions":[]},{"id":"pc_3","description":"Boundary Case: Very small side length","execution_statement":"result = area_polygon(s, l)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":4,"max_val":20},"l":{"min_val":1E-09,"max_val":0.001}},"postconditions":[{"assertion":"result > 0"},{"assertion":"isinstance(result, float)"},{"assertion":"abs(result - (s * (l ** 2) / (4 * tan(pi / s)))) < 1e-9"}],"assumptions":[]},{"id":"pc_4","description":"Boundary Case: Large side length and number of sides","execution_statement":"result = area_polygon(s, l)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":100,"max_val":1000},"l":{"min_val":1E+06,"max_val":1E+10}},"postconditions":[{"assertion":"result > 0"},{"assertion":"isinstance(result, float)"},{"assertion":"abs(result - (s * (l ** 2) / (4 * tan(pi / s)))) < 1e-9"}],"assumptions":[]},{"id":"pc_5","description":"Invariant: Area increases with side length (fixed sides)","execution_statement":"result = area_polygon(s, l)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":5,"max_val":2},"l":{"min_val":1E-06,"max_val":100.0}},"postconditions":[{"assertion":"result_1 <= result_2"}],"assumptions":["l_1 <= l_2"]},{"id":"pc_6","description":"Invariant: Area increases with number of sides (fixed length)","execution_statement":"result = area_polygon(s, l)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":3,"max_val":2},"l":{"min_val":10.0,"max_val":10.0}},"postconditions":[{"assertion":"result_1 <= result_2"}],"assumptions":["s_1 <= s_2"]},{"id":"pc_7","description":"Negative Test: Invalid type for number of sides (float)","execution_statement":"try: result = area_polygon(s, l) except Exception as e: result = e","input_types":{"s":"float","l":"float"},"input_constraints":{"s":{"min_val":3.0,"max_val":100.0},"l":{"min_val":1E-06,"max_val":100.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_8","description":"Negative Test: Invalid type for number of sides (string)","execution_statement":"try: result = area_polygon(s, l) except Exception as e: result = e","input_types":{"s":"str","l":"float"},"input_constraints":{"s":{"min_len":1,"max_len":10,"max_codepoint":255},"l":{"min_val":1E-06,"max_val":100.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Invalid type for side length (string)","execution_statement":"try: result = area_polygon(s, l) except Exception as e: result = e","input_types":{"s":"int","l":"str"},"input_constraints":{"s":{"min_val":3,"max_val":100},"l":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Invalid type for side length (None)","execution_statement":"try: result = area_polygon(s, l) except Exception as e: result = e","input_types":{"s":"int","l":"NoneType"},"input_constraints":{"s":{"min_val":3,"max_val":100}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Number of sides is zero","execution_statement":"try: result = area_polygon(s, l) except Exception as e: result = e","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":0,"max_val":0},"l":{"min_val":1E-06,"max_val":100.0}},"postconditions":[{"assertion":"isinstance(result, ZeroDivisionError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Number of sides is negative","execution_statement":"try: result = area_polygon(s, l) except Exception as e: result = e","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":-100,"max_val":-1},"l":{"min_val":1E-06,"max_val":100.0}},"postconditions":[{"assertion":"isinstance(result, ValueError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Side length is zero","execution_statement":"result = area_polygon(s, l)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":3,"max_val":100},"l":{"min_val":0.0,"max_val":0.0}},"postconditions":[{"assertion":"result == 0.0"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Side length is negative","execution_statement":"result = area_polygon(s, l)","input_types":{"s":"int","l":"float"},"input_constraints":{"s":{"min_val":3,"max_val":100},"l":{"min_val":-100.0,"max_val":-1E-06}},"postconditions":[{"assertion":"result > 0"},{"assertion":"isinstance(result, float)"},{"assertion":"abs(result - (s * (l ** 2) / (4 * tan(pi / s)))) < 1e-9"}],"assumptions":[]},{"id":"pc_15","description":"Test with mixed number types (int and float for length)","execution_statement":"result = area_polygon(s, l)","input_types":{"s":"int","l":"Union[int, float]"},"input_constraints":{"s":{"min_val":3,"max_val":50,"is_mixed":true},"l":{"min_val":1E-06,"max_val":100.0,"is_mixed":true}},"postconditions":[{"assertion":"result > 0"},{"assertion":"isinstance(result, float)"},{"assertion":"abs(result - (s * (l ** 2) / (4 * tan(pi / s)))) < 1e-9"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6178"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical positive integers","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_value":1,"max_value":10000},"num2":{"min_value":1,"max_value":10000}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Both inputs are 1","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_value":1,"max_value":1},"num2":{"min_value":1,"max_value":1}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: One input is 1, the other is a small number","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_value":1,"max_value":1},"num2":{"min_value":2,"max_value":10}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":[]},{"id":"pc_4","description":"Edge Case: Large numbers","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_value":10001,"max_value":100000},"num2":{"min_value":10001,"max_value":100000}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":[]},{"id":"pc_5","description":"Edge Case: Perfect numbers (e.g., 6, 28)","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"values":[6,28,496]},"num2":{"values":[6,28,496]}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":[]},{"id":"pc_6","description":"Edge Case: Prime numbers (e.g., 7, 13)","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"values":[7,13,19,23]},"num2":{"values":[7,13,19,23]}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":[]},{"id":"pc_7","description":"Test Case: Amicable numbers (220, 284)","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"values":[220]},"num2":{"values":[284]}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_8","description":"Test Case: Amicable numbers (1184, 1210)","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"values":[1184]},"num2":{"values":[1210]}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_9","description":"Test Case: Non-amicable numbers","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_value":10,"max_value":50},"num2":{"min_value":10,"max_value":50}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":["num1 != num2"]},{"id":"pc_10","description":"Negative Test: Invalid Type (float for num1)","execution_statement":"try: result = are_equivalent(num1, num2) except Exception as e: result = e","input_types":{"num1":"float","num2":"int"},"input_constraints":{"num1":{"min_value":1.0,"max_value":100.0},"num2":{"min_value":1,"max_value":100}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Invalid Type (string for num2)","execution_statement":"try: result = are_equivalent(num1, num2) except Exception as e: result = e","input_types":{"num1":"int","num2":"str"},"input_constraints":{"num1":{"min_value":1,"max_value":100},"num2":{"min_len":1,"max_len":10,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Invalid Type (None for num1)","execution_statement":"try: result = are_equivalent(num1, num2) except Exception as e: result = e","input_types":{"num1":"None","num2":"int"},"input_constraints":{"num2":{"min_value":1,"max_value":100}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Test Case: Identical perfect numbers","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"values":[6]},"num2":{"values":[6]}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_14","description":"Test Case: Identical prime numbers","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"values":[7]},"num2":{"values":[7]}},"postconditions":[{"assertion":"result == True"}],"assumptions":[]},{"id":"pc_15","description":"Test Case: Large identical numbers","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_value":50000,"max_value":60000},"num2":{"min_value":50000,"max_value":60000}},"postconditions":[{"assertion":"result == True"}],"assumptions":["num1 == num2"]},{"id":"pc_16","description":"Test Case: Numbers with few divisors","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"values":[2,3,4,5,9,10]},"num2":{"values":[2,3,4,5,9,10]}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":[]},{"id":"pc_17","description":"Test Case: Numbers with many divisors","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"values":[12,18,24,30,36,40]},"num2":{"values":[12,18,24,30,36,40]}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":[]},{"id":"pc_18","description":"Test Case: One large, one small number","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"min_value":1,"max_value":10},"num2":{"min_value":1000,"max_value":2000}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":[]},{"id":"pc_19","description":"Negative Test: Invalid Type (int for num1, float for num2)","execution_statement":"try: result = are_equivalent(num1, num2) except Exception as e: result = e","input_types":{"num1":"int","num2":"float"},"input_constraints":{"num1":{"min_value":1,"max_value":100},"num2":{"min_value":1.0,"max_value":100.0}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_20","description":"Test Case: Numbers that are powers of 2","execution_statement":"result = are_equivalent(num1, num2)","input_types":{"num1":"int","num2":"int"},"input_constraints":{"num1":{"values":[2,4,8,16,32,64]},"num2":{"values":[2,4,8,16,32,64]}},"postconditions":[{"assertion":"result == (div_sum(num1) == div_sum(num2))"}],"assumptions":[]}]}
{"_id":{"$oid":"692adffe1b18223597bc6179"},"test_cases":[{"id":"pc_1","description":"Happy Path: Typical strings with mixed case and characters.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"min_length":0,"max_length":100,"alphabet":"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()","is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result <= len(s)"},{"assertion":"result == sum(1 for i, char in enumerate(s) if 'a' <= char.lower() <= 'z' and ord(char.lower()) - ord('a') == i)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty string.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"value":"","max_codepoint":127}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: String with only characters that match their position.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"pattern":"^[a-zA-Z]$","min_length":1,"max_length":26}},"postconditions":[{"assertion":"result == len(s)"}],"assumptions":["ord(s[i].lower()) - ord('a') == i for i in range(len(s))"]},{"id":"pc_4","description":"Edge Case: String with no characters matching their position.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"min_length":1,"max_length":50,"max_codepoint":127}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["not ('a' <= char.lower() <= 'z' and ord(char.lower()) - ord('a') == i) for i, char in enumerate(s)"]},{"id":"pc_5","description":"Boundary Case: String with all lowercase alphabet characters.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"alphabet":"abcdefghijklmnopqrstuvwxyz","min_length":1,"max_length":26,"max_codepoint":127}},"postconditions":[{"assertion":"result == sum(1 for i, char in enumerate(s) if ord(char) - ord('a') == i)"}],"assumptions":[]},{"id":"pc_6","description":"Boundary Case: String with all uppercase alphabet characters.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"alphabet":"ABCDEFGHIJKLMNOPQRSTUVWXYZ","min_length":1,"max_length":26,"max_codepoint":127}},"postconditions":[{"assertion":"result == sum(1 for i, char in enumerate(s) if ord(char) - ord('A') == i)"}],"assumptions":[]},{"id":"pc_7","description":"Edge Case: String with only numbers.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"alphabet":"0123456789","min_length":1,"max_length":50,"max_codepoint":127}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_8","description":"Edge Case: String with only symbols.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"alphabet":"!@#$%^&*()_+=-`~[]{}|;':\",./<>?","min_length":1,"max_length":50,"max_codepoint":127}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_9","description":"Mixed Case: String with alternating matching and non-matching characters.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"min_length":10,"max_length":30,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"result == sum(1 for i, char in enumerate(s) if 'a' <= char.lower() <= 'z' and ord(char.lower()) - ord('a') == i)"}],"assumptions":["all( (ord(s[i].lower()) - ord('a') == i) or (ord(s[i].lower()) - ord('a') != i) for i in range(len(s)) )"]},{"id":"pc_10","description":"Long String: Test with a longer string to check performance and correctness.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"min_length":100,"max_length":500,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result <= len(s)"},{"assertion":"result == sum(1 for i, char in enumerate(s) if 'a' <= char.lower() <= 'z' and ord(char.lower()) - ord('a') == i)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Invalid input type (integer).","execution_statement":"try: result = count_char_position(s) except Exception as e: result = e","input_types":{"s":"integer"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"Negative Test: Invalid input type (float).","execution_statement":"try: result = count_char_position(s) except Exception as e: result = e","input_types":{"s":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_13","description":"Negative Test: Invalid input type (None).","execution_statement":"try: result = count_char_position(s) except Exception as e: result = e","input_types":{"s":"null"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_14","description":"Negative Test: Invalid input type (list).","execution_statement":"try: result = count_char_position(s) except Exception as e: result = e","input_types":{"s":"list"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_15","description":"Negative Test: Invalid input type (dictionary).","execution_statement":"try: result = count_char_position(s) except Exception as e: result = e","input_types":{"s":"dict"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_16","description":"String with characters outside the standard ASCII range.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"min_length":1,"max_length":50,"max_codepoint":1114111}},"postconditions":[{"assertion":"result == sum(1 for i, char in enumerate(s) if 'a' <= char.lower() <= 'z' and ord(char.lower()) - ord('a') == i)"}],"assumptions":[]},{"id":"pc_17","description":"String with only one character that matches its position.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"min_length":1,"max_length":1,"max_codepoint":127}},"postconditions":[{"assertion":"result == 1"}],"assumptions":["'a' <= s[0].lower() <= 'z' and ord(s[0].lower()) - ord('a') == 0"]},{"id":"pc_18","description":"String with only one character that does not match its position.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"min_length":1,"max_length":1,"max_codepoint":127}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["not ('a' <= s[0].lower() <= 'z' and ord(s[0].lower()) - ord('a') == 0)"]},{"id":"pc_19","description":"String with repeated characters, some matching position, some not.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"min_length":5,"max_length":20,"max_codepoint":127}},"postconditions":[{"assertion":"result == sum(1 for i, char in enumerate(s) if 'a' <= char.lower() <= 'z' and ord(char.lower()) - ord('a') == i)"}],"assumptions":[]},{"id":"pc_20","description":"String with characters that are close to matching their position but not exactly.","execution_statement":"result = count_char_position(s)","input_types":{"s":"string"},"input_constraints":{"s":{"min_length":5,"max_length":20,"max_codepoint":127}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["not ('a' <= char.lower() <= 'z' and ord(char.lower()) - ord('a') == i) for i, char in enumerate(s) if abs(ord(char.lower()) - ord('a') - i) <= 2"]}]}
{"_id":{"$oid":"692adffe1b18223597bc617a"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic list of integers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":10}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result <= len(A) * (len(A) - 1) // 2"}]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":0,"max_len":0}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_3","description":"Edge Case: Single element list","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_4","description":"Happy Path: All even numbers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":10,"elements":{"even":true}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result == len(A) * (len(A) - 1) // 2"}]},{"id":"pc_5","description":"Happy Path: All odd numbers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":10,"elements":{"odd":true}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result == len(A) * (len(A) - 1) // 2"}]},{"id":"pc_6","description":"Happy Path: Mixed even and odd numbers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":10,"is_mixed":true}},"assumptions":["sum(1 for x in A if x % 2 == 0) > 0 and sum(1 for x in A if x % 2 != 0) > 0"],"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result <= len(A) * (len(A) - 1) // 2"},{"assertion":"result == (sum(1 for x in A if x % 2 == 0) * (sum(1 for x in A if x % 2 == 0) - 1) // 2) + (sum(1 for x in A if x % 2 != 0) * (sum(1 for x in A if x % 2 != 0) - 1) // 2)"}]},{"id":"pc_7","description":"Edge Case: List with zeros","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":10,"elements":{"allow_none":false,"min_val":0,"max_val":10}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}]},{"id":"pc_8","description":"Edge Case: List with negative numbers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":10,"elements":{"min_val":-10,"max_val":-1}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result == len(A) * (len(A) - 1) // 2"}]},{"id":"pc_9","description":"Edge Case: List with large integers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":10,"elements":{"min_val":1000000,"max_val":2000000}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}]},{"id":"pc_10","description":"Happy Path: List with duplicate numbers","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":10,"unique":false}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"}]},{"id":"pc_11","description":"Negative Test: Input is not a list (int)","execution_statement":"try: result = find_even_pair(A) except Exception as e: result = e","input_types":{"A":"int"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_12","description":"Negative Test: Input is not a list (float)","execution_statement":"try: result = find_even_pair(A) except Exception as e: result = e","input_types":{"A":"float"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_13","description":"Negative Test: Input is not a list (None)","execution_statement":"try: result = find_even_pair(A) except Exception as e: result = e","input_types":{"A":"None"},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_14","description":"Negative Test: List contains non-integer (string)","execution_statement":"try: result = find_even_pair(A) except Exception as e: result = e","input_types":{"A":"list[str]"},"input_constraints":{"A":{"min_len":2,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_15","description":"Negative Test: List contains non-integer (float)","execution_statement":"try: result = find_even_pair(A) except Exception as e: result = e","input_types":{"A":"list[float]"},"input_constraints":{"A":{"min_len":2,"max_len":5}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_16","description":"Happy Path: List with only two elements (even XOR)","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":2,"elements":{"min_val":2,"max_val":10,"even":true}}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_17","description":"Happy Path: List with only two elements (odd XOR)","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":2,"elements":{"min_val":1,"max_val":9,"odd":true}}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_18","description":"Happy Path: List with two elements (one even, one odd)","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":2}},"assumptions":["(A[0] % 2 == 0 and A[1] % 2 != 0) or (A[0] % 2 != 0 and A[1] % 2 == 0)"],"postconditions":[{"assertion":"result == 0"}]},{"id":"pc_19","description":"Happy Path: Larger list with mixed parity","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":50,"max_len":100,"is_mixed":true}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result >= 0"},{"assertion":"result <= len(A) * (len(A) - 1) // 2"},{"assertion":"result == (sum(1 for x in A if x % 2 == 0) * (sum(1 for x in A if x % 2 == 0) - 1) // 2) + (sum(1 for x in A if x % 2 != 0) * (sum(1 for x in A if x % 2 != 0) - 1) // 2)"}]},{"id":"pc_20","description":"Happy Path: List with identical elements","execution_statement":"result = find_even_pair(A)","input_types":{"A":"list[int]"},"input_constraints":{"A":{"min_len":2,"max_len":10,"elements":{"min_val":5,"max_val":5}}},"postconditions":[{"assertion":"isinstance(result, int)"},{"assertion":"result == len(A) * (len(A) - 1) // 2"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc617b"},"test_cases":[{"id":"pc_1","description":"Happy Path: General non-negative integers","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":0,"max_value":1000000}},"postconditions":[{"assertion":"result > 0 and (result & (result - 1)) == 0"},{"assertion":"result >= n"},{"assertion":"n <= 1 or result // 2 < n"}]},{"id":"pc_2","description":"Edge Case: Input is 0","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":0,"max_value":0}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_3","description":"Edge Case: Input is 1","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":1,"max_value":1}},"postconditions":[{"assertion":"result == 1"}]},{"id":"pc_4","description":"Edge Case: Input is already a power of 2","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":2,"max_value":1024}},"assumptions":["(n & (n - 1)) == 0"],"postconditions":[{"assertion":"result == n"}]},{"id":"pc_5","description":"Edge Case: Input is one less than a power of 2","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":3,"max_value":1023}},"assumptions":["(n & (n - 1)) != 0","n > 1"],"postconditions":[{"assertion":"result == n + 1"}]},{"id":"pc_6","description":"Edge Case: Input is one more than a power of 2","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":3,"max_value":1025}},"assumptions":["(n & (n - 1)) != 0","n > 1"],"postconditions":[{"assertion":"result == (n | (n >> 1) | (n >> 2) | (n >> 4) | (n >> 8) | (n >> 16)) + 1"}]},{"id":"pc_7","description":"Large numbers test","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":0,"max_value":2147483647}},"postconditions":[{"assertion":"result > 0 and (result & (result - 1)) == 0"},{"assertion":"result >= n"},{"assertion":"n <= 1 or result // 2 < n"}]},{"id":"pc_8","description":"Very large numbers test","execution_statement":"result = next_power_of_2(n)","input_types":{"n":"int"},"input_constraints":{"n":{"min_value":0,"max_value":9223372036854775807}},"postconditions":[{"assertion":"result > 0 and (result & (result - 1)) == 0"},{"assertion":"result >= n"},{"assertion":"n <= 1 or result // 2 < n"}]},{"id":"pc_9","description":"Negative Test: Float input","execution_statement":"try: result = next_power_of_2(n) except Exception as e: result = e","input_types":{"n":"float"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_10","description":"Negative Test: String input","execution_statement":"try: result = next_power_of_2(n) except Exception as e: result = e","input_types":{"n":"str"},"input_constraints":{"n":{"min_len":1,"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]},{"id":"pc_11","description":"Negative Test: null input","execution_statement":"try: result = next_power_of_2(n) except Exception as e: result = e","input_types":{"n":"None"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}]}]}
{"_id":{"$oid":"692adffe1b18223597bc617c"},"test_cases":[{"id":"pc_1","description":"Happy Path: Basic integer list and number","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":100},"x":{"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":[]},{"id":"pc_2","description":"Edge Case: Empty list","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":0,"max_len":0},"x":{"min_val":-100,"max_val":100}},"postconditions":[{"assertion":"result == 0"}],"assumptions":[]},{"id":"pc_3","description":"Edge Case: List with all elements matching the number","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50},"x":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == len(a)"}],"assumptions":["all(val == x for val in a)"]},{"id":"pc_4","description":"Edge Case: List with no elements matching the number","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50},"x":{"min_val":100,"max_val":200}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["all(val != x for val in a)"]},{"id":"pc_5","description":"Large list with mixed occurrences","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":100,"max_len":1000,"is_mixed":true},"x":{"min_val":-500,"max_val":500,"is_mixed":true}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":[]},{"id":"pc_6","description":"List with negative numbers and negative target","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50},"x":{"min_val":-100,"max_val":-1}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":[]},{"id":"pc_7","description":"List with only zeros and target is zero","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50},"x":{"min_val":0,"max_val":0}},"postconditions":[{"assertion":"result == len(a)"}],"assumptions":["all(val == 0 for val in a)"]},{"id":"pc_8","description":"Negative Test: Invalid type for list argument (int)","execution_statement":"try: result = frequency(a, x) except Exception as e: result = e","input_types":{"a":"int","x":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_9","description":"Negative Test: Invalid type for list argument (None)","execution_statement":"try: result = frequency(a, x) except Exception as e: result = e","input_types":{"a":"None","x":"int"},"input_constraints":{},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_10","description":"Negative Test: Invalid type for number argument (float)","execution_statement":"try: result = frequency(a, x) except Exception as e: result = e","input_types":{"a":"list[int]","x":"float"},"input_constraints":{"a":{"min_len":1,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_11","description":"Negative Test: Invalid type for number argument (str)","execution_statement":"try: result = frequency(a, x) except Exception as e: result = e","input_types":{"a":"list[int]","x":"str"},"input_constraints":{"a":{"min_len":1,"max_len":50},"x":{"max_codepoint":255}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_12","description":"List with large integers","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":100},"x":{"min_val":1000000,"max_val":2000000}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":[]},{"id":"pc_13","description":"List with mixed positive and negative integers, target is positive","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":100,"is_mixed":true},"x":{"min_val":1,"max_val":100,"is_mixed":true}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":[]},{"id":"pc_14","description":"List with mixed positive and negative integers, target is negative","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":100,"is_mixed":true},"x":{"min_val":-100,"max_val":-1,"is_mixed":true}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":[]},{"id":"pc_15","description":"List with single element, target matches","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 1"}],"assumptions":["a[0] == x"]},{"id":"pc_16","description":"List with single element, target does not match","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":1}},"postconditions":[{"assertion":"result == 0"}],"assumptions":["a[0] != x"]},{"id":"pc_17","description":"List with duplicate numbers, target is one of them","execution_statement":"result = frequency(a, x)","input_types":{"a":"list[int]","x":"int"},"input_constraints":{"a":{"min_len":2,"max_len":50},"x":{"min_val":1,"max_val":10}},"postconditions":[{"assertion":"result == a.count(x)"}],"assumptions":["a.count(x) > 1"]},{"id":"pc_18","description":"List with mixed types (should fail if not integers)","execution_statement":"try: result = frequency(a, x) except Exception as e: result = e","input_types":{"a":"list[Union[int, str]]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50,"is_mixed":true,"max_codepoint":127}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_19","description":"List with floats, target is int (should fail)","execution_statement":"try: result = frequency(a, x) except Exception as e: result = e","input_types":{"a":"list[float]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]},{"id":"pc_20","description":"List with None values, target is int (should fail)","execution_statement":"try: result = frequency(a, x) except Exception as e: result = e","input_types":{"a":"list[Optional[int]]","x":"int"},"input_constraints":{"a":{"min_len":1,"max_len":50,"allow_none":true}},"postconditions":[{"assertion":"isinstance(result, TypeError)"}],"assumptions":[]}]}
