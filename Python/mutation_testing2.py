import json
import random
import re
import string
import math
import collections
import cmath
from typing import Any, Dict, List, Union, Optional, Tuple
import functools
import sys
import os

# ==============================================================================
# CONFIGURATION
# ==============================================================================

# Set this to True to see why test cases might be failing (e.g. SyntaxErrors)
DEBUG = False 

# Add current directory to path to ensure config import works
sys.path.append(os.getcwd())

try:
    import json_repair
    if DEBUG: print("Success: 'json_repair' module found.")
except ImportError:
    json_repair = None
    if DEBUG: print("Warning: 'json_repair' not installed.")

try:
    from config import get_db_client
except ImportError:
    print("Error: config.py not found. Please ensure it exists in the same directory.")
    # For standalone testing without DB, comment out sys.exit(1)
    # sys.exit(1) 

# Collection name in MongoDB
COLLECTION_NAME = "FunctionPrompts"

def clean_json_string(json_str):
    """
    Cleans a string to extract valid JSON. 
    Handles Markdown code blocks (```json ... ```) commonly output by LLMs.
    """
    if not isinstance(json_str, str):
        return json_str
    
    if json_repair:
        try:
            # If successful, json_repair.loads returns a python object (dict/list)
            return json_repair.loads(json_str)
        except Exception:
            pass
        
    markdown_pattern = r"```(?:json)?\s*([\s\S]*?)\s*```"
    match = re.search(markdown_pattern, json_str, re.IGNORECASE)
    cleaned_str = match.group(1).strip() if match else json_str.strip()
    cleaned_str = re.sub(r'\\(?![/u"\\bfnrt])', r'\\\\', cleaned_str)
    try:
        return json.loads(cleaned_str)
    except json.JSONDecodeError:
        return {}

# ==============================================================================
# 1. MOCK FUNCTION LIBRARY
# ==============================================================================
# The test cases generated by the LLM expect these functions to exist in the global scope.

def similar_elements(t1, t2):
    return tuple(sorted(list(set(t1) & set(t2))))

def is_not_prime(n):
    if not isinstance(n, int): raise TypeError("Input must be integer")
    if n < 2: return True 
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0: return True
    return False

def heap_queue_largest(nums, n):
    if not isinstance(nums, list): raise TypeError("Nums must be list")
    if not isinstance(n, int): raise TypeError("n must be int")
    if n > len(nums): return sorted(nums, reverse=True)
    return sorted(nums, reverse=True)[:n]

def differ_At_One_Bit_Pos(a, b):
    if not isinstance(a, int) or not isinstance(b, int): raise TypeError("Inputs must be ints")
    return bin(a ^ b).count('1') == 1

def find_char_long(text):
    if not isinstance(text, str): raise AttributeError("Input must be string")
    return [w for w in text.split() if len(w) >= 4]

def square_nums(nums):
    if not isinstance(nums, list): raise TypeError("Input must be list")
    return [x**2 for x in nums]

def find_Rotations(s):
    if not isinstance(s, str): raise TypeError("Input must be string")
    if not s: return 0
    if len(set(s)) == 1: return 1
    n = len(s)
    for i in range(1, n // 2 + 1):
        if n % i == 0 and s[:i] * (n // i) == s:
            return i
    return n

def remove_Occ(s, ch):
    if not isinstance(s, str) or not isinstance(ch, str): raise TypeError("Inputs must be strings")
    if s.count(ch) < 2: return s.replace(ch, "") 
    first = s.find(ch)
    last = s.rfind(ch)
    if first == last: return s.replace(ch, "")
    s_list = list(s)
    if last != -1: s_list.pop(last)
    if first != -1: s_list.pop(first)
    return "".join(s_list)

def sort_matrix(M):
    if not isinstance(M, list): raise TypeError("Input must be list")
    return sorted(M, key=sum)

def find_Volume(l, b, h):
    if any(x is None for x in [l,b,h]): raise TypeError("None not allowed")
    if any(not isinstance(x, (int, float)) for x in [l,b,h]): raise TypeError("Must be number")
    return (l * b * h) / 2.0

def text_lowercase_underscore(text):
    if not isinstance(text, str): raise AttributeError("Must be string")
    return bool(re.match(r'^[a-z]+_[a-z]+$', text))

def square_perimeter(a):
    if a is None: raise TypeError("None not allowed")
    if not isinstance(a, (int, float)): raise TypeError("Must be number")
    if a < 0: raise ValueError("Negative side")
    return 4 * a

def remove_dirty_chars(s, second_s):
    return "".join([c for c in s if c not in second_s])

def test_duplicate(nums):
    if not isinstance(nums, list): raise TypeError("Must be list")
    return len(nums) != len(set(nums))

def is_woodall(x):
    if not isinstance(x, int): raise TypeError("Must be int")
    return x in [1, 7, 23, 63, 159, 383, 895]

def check(n):
    if not isinstance(n, int): raise TypeError("Must be int")
    s = str(n)
    try:
        rev_n = int(s[::-1])
        return 2 * rev_n == n + 1
    except:
        return False

def find_Max_Num(arr):
    if not isinstance(arr, list): raise TypeError("Must be list")
    if not all(isinstance(x, int) and x >= 0 for x in arr): raise ValueError("Must be non-negative ints")
    if not arr: return 0
    s_arr = list(map(str, arr))
    from functools import cmp_to_key
    def compare(a, b):
        if a + b > b + a: return -1
        elif a + b < b + a: return 1
        else: return 0
    s_arr.sort(key=cmp_to_key(compare))
    return int("".join(s_arr)) if s_arr[0] != '0' else 0

def opposite_Signs(x, y):
    if not isinstance(x, int) or not isinstance(y, int): raise TypeError("Must be int")
    return (x ^ y) < 0

def is_octagonal(n):
    if not isinstance(n, int): raise TypeError("Must be int")
    return 3 * n * n - 2 * n

def count_Substrings(s):
    if not isinstance(s, str): raise TypeError("Must be str")
    return len(s) # Placeholder

def smallest_num(xs):
    if xs is None: raise TypeError("None not allowed")
    if not isinstance(xs, list): raise TypeError("Must be list")
    if not xs: raise ValueError("Empty list")
    if any(not isinstance(x, (int, float)) for x in xs): raise TypeError("Must be numbers")
    return min(xs)

def max_difference(lst):
    if not isinstance(lst, list): raise TypeError("Must be list")
    if not lst: raise ValueError("Empty list")
    if not all(isinstance(x, tuple) and len(x) >= 2 for x in lst): raise TypeError("Elements must be tuples")
    return max(abs(a-b) for a, b, *rest in lst)

def subject_marks(subjectmarks):
    if not isinstance(subjectmarks, list): raise TypeError("Must be list")
    return sorted(subjectmarks, key=lambda x: x[1])

def recursive_list_sum(data_list):
    if not isinstance(data_list, list): raise TypeError("Must be list")
    total = 0
    for element in data_list:
        if isinstance(element, list):
            total = total + recursive_list_sum(element)
        elif isinstance(element, (int, float)):
            total = total + element
    return total

def pos_count(nums):
    if not isinstance(nums, list): raise TypeError("Must be list")
    return sum(1 for x in nums if isinstance(x, (int, float)) and x >= 0)

def bell_number(n):
    if not isinstance(n, int): raise TypeError("Must be int")
    if n < 0: raise IndexError("Negative n")
    vals = [1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975]
    if n < len(vals): return vals[n]
    return 0

def is_Monotonic(A):
    if not isinstance(A, list): raise TypeError("Must be list")
    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or
            all(A[i] >= A[i + 1] for i in range(len(A) - 1)))

def is_sublist(l, s):
    if not isinstance(l, list) or not isinstance(s, list): raise TypeError("Must be list")
    if not s: return True
    sub_len = len(s)
    for i in range(len(l) - sub_len + 1):
        if l[i:i+sub_len] == s:
            return True
    return False

def get_equal(l):
    if not isinstance(l, list): raise TypeError("Must be list")
    if not l: return True
    first_len = len(l[0])
    return all(len(x) == first_len for x in l)

def comb_sort(nums):
    if not isinstance(nums, list): raise TypeError("Must be list")
    return sorted(nums, reverse=True) 

def dif_Square(n):
    if not isinstance(n, int): raise TypeError("Must be int")
    return n % 4 != 2

def is_samepatterns(colors, patterns):
    if not isinstance(colors, list) or not isinstance(patterns, list): raise TypeError("Must be lists")
    if len(colors) != len(patterns): return False
    if len(set(colors)) != len(set(patterns)): return False
    return True 

def find_tuples(test_list, K):
    if not isinstance(test_list, list): raise TypeError("Must be list")
    if K == 0: raise ZeroDivisionError("K cannot be 0")
    return [t for t in test_list if all(isinstance(x, int) and x % K == 0 for x in t)]

def is_Diff(n):
    if not isinstance(n, int): raise TypeError("Must be int")
    return n % 11 == 0

def word_len(s):
    if not isinstance(s, str): raise AttributeError("Must be str")
    return any(len(w) % 2 != 0 for w in s.split())

def tetrahedral_number(n):
    if not isinstance(n, int): raise TypeError("Must be int")
    return int((n * (n + 1) * (n + 2)) / 6)

def volume_sphere(r):
    if r is None: raise TypeError("None")
    if not isinstance(r, (int, float)): raise TypeError("Must be number")
    return (4/3) * math.pi * (r ** 3)

def get_Char(s):
    if not isinstance(s, str): raise TypeError("Must be str")
    if not s: return 'z'
    val = sum(ord(c.lower()) - ord('a') + 1 for c in s if c.isalpha())
    rem = val % 26
    if rem == 0: return 'z'
    return chr(ord('a') + rem - 1)

def sequence(n):
    if not isinstance(n, int): raise TypeError("Must be int")
    if n <= 2: return 1
    if n == 3: return 2
    if n == 4: return 3 
    cache = {1:1, 2:1}
    def _seq(x):
        if x in cache: return cache[x]
        res = _seq(_seq(x-1)) + _seq(x - _seq(x-1))
        cache[x] = res
        return res
    return _seq(n)

def surfacearea_sphere(r):
    if r is None: raise TypeError("None")
    if not isinstance(r, (int, float)): raise TypeError("Must be number")
    return 4 * math.pi * (r ** 2)

def centered_hexagonal_number(n):
    if not isinstance(n, int): raise TypeError("Must be int")
    if n < 0: raise ValueError("Negative n")
    if n == 0: return 1
    return 3 * n * (n - 1) + 1

def merge_dictionaries_three(d1, d2, d3):
    if any(not isinstance(d, dict) for d in [d1, d2, d3]): raise TypeError("Must be dict")
    z = d1.copy()
    z.update(d2)
    z.update(d3)
    return z

def freq_count(l):
    if not isinstance(l, list): raise TypeError("Must be list")
    try:
        return dict(collections.Counter(l))
    except TypeError: 
        raise TypeError("Unhashable")

def tuple_to_int(t):
    if not isinstance(t, tuple): raise TypeError("Must be tuple")
    if any(not isinstance(x, int) for x in t): raise ValueError("Elements must be ints")
    return int("".join(map(str, t)))

def list_to_float(l):
    if not isinstance(l, list): raise TypeError("Must be list")
    res = []
    for sub in l:
        if not isinstance(sub, (list, tuple)): raise TypeError("Inner must be list/tuple")
        res.append(tuple(float(x) if str(x).replace('.','',1).isdigit() else x for x in sub))
    return res

def string_to_list(s):
    if not isinstance(s, str): raise AttributeError("Must be string")
    return s.split(' ')

def search(arr):
    if not isinstance(arr, list): raise TypeError("Must be list")
    c = collections.Counter(arr)
    for k, v in c.items():
        if v == 1: return k
    return 0

def max_product_tuple(lst):
    if not isinstance(lst, list): raise TypeError("Must be list")
    if not lst: return 0 
    return max(abs(x*y) for x,y in lst) 

def amicable_numbers_sum(limit):
    if not isinstance(limit, int): return "Input is not an integer!"
    if limit <= 0: return "Input must be bigger than 0!"
    def sum_div(n):
        s = 1
        for i in range(2, int(n**0.5)+1):
            if n % i == 0:
                s += i
                if i*i != n: s += n//i
        return s
    total = 0
    for a in range(2, limit):
        b = sum_div(a)
        if b > a and sum_div(b) == a:
            total += a + b
    return total

def angle_complex(a, b):
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)): raise TypeError("Must be numbers")
    return cmath.phase(complex(a, b))

def find_length(s):
    if not isinstance(s, str): raise TypeError("Must be str")
    if '0' not in s and '1' in s: return 0
    if '1' not in s and '0' in s: return len(s)
    return 0 

def multiply_int(x, y):
    if not isinstance(x, int) or not isinstance(y, int): raise TypeError("Must be int")
    return x * y

def long_words(n, s):
    if not isinstance(n, int): raise TypeError("n must be int")
    if not isinstance(s, str): raise AttributeError("s must be str")
    return [w for w in s.split() if len(w) > n]

def magic_square_test(m):
    if not isinstance(m, list): raise TypeError("Must be list")
    if not m: return False
    n = len(m)
    if any(len(row) != n for row in m): return False
    if n == 0: return False
    s = sum(m[0])
    if any(sum(row) != s for row in m): return False
    if any(sum(m[i][j] for i in range(n)) != s for j in range(n)): return False
    if sum(m[i][i] for i in range(n)) != s: return False
    if sum(m[i][n-1-i] for i in range(n)) != s: return False
    return True

def max_occurrences(nums):
    if not isinstance(nums, list): raise TypeError("Must be list")
    if not nums: raise ValueError("Empty")
    return max(set(nums), key=nums.count)

def reverse_vowels(s):
    if not isinstance(s, str): raise TypeError("Must be str")
    vowels = set("aeiouAEIOU")
    s_list = list(s)
    v_indices = [i for i, c in enumerate(s) if c in vowels]
    for i, idx in enumerate(v_indices):
        s_list[idx] = s[v_indices[len(v_indices)-1-i]]
    return "".join(s_list)

def tup_string(t):
    if not isinstance(t, tuple): raise TypeError("Must be tuple")
    return "".join(str(x) for x in t)

def sum_negativenum(nums):
    if not isinstance(nums, list): raise TypeError("Must be list")
    return sum(n for n in nums if isinstance(n, (int, float)) and n < 0)

def hexagonal_num(n):
    if not isinstance(n, int): raise TypeError("Must be int")
    if n < 0: raise ValueError("Negative n")
    return n * (2 * n - 1)

def zero_count(nums):
    if not isinstance(nums, list): raise TypeError("Must be list")
    if not nums: raise ZeroDivisionError("Empty")
    zeros = nums.count(0)
    non_zeros = len(nums) - zeros
    if non_zeros == 0: return float('inf')
    return zeros / non_zeros if zeros > 0 else 0.0

def is_Sum_Of_Powers_Of_Two(n):
    if not isinstance(n, int): raise TypeError("Must be int")
    if n <= 0: return False
    return bin(n).count('1') % 2 == 0

def circle_circumference(r):
    if r is None: raise TypeError("None")
    if not isinstance(r, (int, float)): raise TypeError("Must be number")
    return 2 * 3.1415 * r

def extract_singly(test_list):
    if not isinstance(test_list, list): raise TypeError("Must be list")
    res = []
    seen = set()
    for sub in test_list:
        for x in sub:
            if x not in seen:
                res.append(x)
                seen.add(x)
    return res

def pancake_sort(nums):
    if not isinstance(nums, list): raise TypeError("Must be list")
    return sorted(nums)

def count_samepair(l1, l2, l3):
    if any(not isinstance(l, list) for l in [l1, l2, l3]): raise TypeError("Must be list")
    count = 0
    for i in range(min(len(l1), len(l2), len(l3))):
        if l1[i] == l2[i] == l3[i]:
            count += 1
    return count

def find_lists(t):
    if isinstance(t, (list, tuple)):
        return sum(1 for x in t if isinstance(x, list))
    if t is None: raise TypeError("None")
    return 0

def max_Abs_Diff(arr):
    if not isinstance(arr, list): raise TypeError("Must be list")
    if len(arr) < 2: return 0
    return max(arr) - min(arr)

def find_solution(a, b, n):
    if any(not isinstance(x, int) for x in [a, b, n]): raise TypeError("Must be int")
    for i in range(n // a + 2):
        rem = n - a * i
        if rem >= 0 and b != 0 and rem % b == 0:
            return (i, rem // b)
    return None

def remove_elements(l1, l2):
    if not isinstance(l1, list) or not isinstance(l2, list): raise TypeError("Must be list")
    s2 = set(l2)
    return [x for x in l1 if x not in s2]

def sum_series(n):
    if not isinstance(n, int): raise TypeError("Must be int")
    return sum(n - 2*i for i in range(n // 2 + 1) if n - 2*i > 0)

def area_polygon(s, l):
    if not isinstance(s, int) or not isinstance(l, (int, float)): raise TypeError("Invalid types")
    if s < 3: raise ValueError("Polygons must have at least 3 sides")
    return (s * (l ** 2)) / (4 * math.tan(math.pi / s))

def are_equivalent(n1, n2):
    if any(not isinstance(n, int) for n in [n1, n2]): raise TypeError("Must be int")
    def d_sum(n): return sum(i for i in range(1, n) if n % i == 0)
    return d_sum(n1) == d_sum(n2)

def count_char_position(s):
    if not isinstance(s, str): raise TypeError("Must be str")
    count = 0
    for i, c in enumerate(s):
        if i == (ord(c.lower()) - ord('a')):
            count += 1
    return count

def find_even_pair(A):
    if not isinstance(A, list): raise TypeError("Must be list")
    evens = sum(1 for x in A if x % 2 == 0)
    odds = len(A) - evens
    return (evens * (evens - 1) // 2) + (odds * (odds - 1) // 2)

def next_power_of_2(n):
    if not isinstance(n, int): raise TypeError("Must be int")
    if n <= 0: return 1
    if (n & (n - 1)) == 0: return n
    return 1 << n.bit_length()

def frequency(a, x):
    if not isinstance(a, list): raise TypeError("Must be list")
    return a.count(x)

def next_smallest_palindrome(num):
    if not isinstance(num, int): raise TypeError("Must be int")
    num += 1
    while True:
        s = str(num)
        if s == s[::-1]: return num
        num += 1

def kth_element(arr, k):
    if not isinstance(arr, list): raise TypeError("Must be list")
    if not isinstance(k, int): raise TypeError("Must be int")
    if k < 1 or k > len(arr): raise IndexError("k out of bounds")
    return sorted(arr)[k-1]

def snake_to_camel(word):
    if not isinstance(word, str): raise AttributeError("Must be str")
    components = word.split('_')
    return components[0] + ''.join(x.title() for x in components[1:])

def eulerian_num(n, m):
    if not isinstance(n, int) or not isinstance(m, int): raise TypeError("Must be int")
    if m >= n or n == 0: return 0
    if m == 0: return 1
    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)

def sort_sublists(l):
    if not isinstance(l, list): raise TypeError("Must be list")
    return [sorted(sub) if isinstance(sub, list) else sub for sub in l]

def count(l):
    if not isinstance(l, list): raise TypeError("Must be list")
    return sum(l) if all(isinstance(x, (int, float)) for x in l) else len(l)

def add_lists(l, t):
    if not isinstance(l, list) or not isinstance(t, tuple): raise TypeError("Invalid types")
    return tuple(list(t) + l)

def merge_sorted_list(n1, n2, n3):
    if any(not isinstance(x, list) for x in [n1, n2, n3]): raise TypeError("Must be list")
    return sorted(n1 + n2 + n3)

def odd_Equivalent(s, n):
    if not isinstance(s, str) or not isinstance(n, int): raise TypeError("Invalid types")
    return s[:n].count('1')

def common_in_nested_lists(nested):
    if not isinstance(nested, list): raise TypeError("Must be list")
    if not nested: return []
    if not all(isinstance(x, list) for x in nested): raise TypeError("Inner elements must be list")
    if not all(nested): return []
    sets = [set(x) for x in nested]
    res = set.intersection(*sets)
    return sorted(list(res))

def check_integer(text):
    if not isinstance(text, str): raise AttributeError("Must be str")
    text = text.strip()
    if not text: return None
    if len(text) > 1 and text[0] in ('+', '-'):
        return text[1:].isdigit()
    return text.isdigit()

def empty_dit(l):
    if not isinstance(l, list): raise TypeError("Must be list")
    return all(not d for d in l if isinstance(d, dict))

def Find_Min_Length(l):
    if not isinstance(l, list): raise TypeError("Must be list")
    if not l: return 0
    return min(len(x) for x in l)

def divisor(n):
    if not isinstance(n, int): raise TypeError("Must be int")
    if n == 0: raise ZeroDivisionError("0")
    return sum(1 for i in range(1, n+1) if n % i == 0)

def frequency_lists(l):
    if not isinstance(l, list): raise TypeError("Must be list")
    flat = [x for sub in l for x in sub]
    return dict(collections.Counter(flat))

def len_log(l):
    if not isinstance(l, list): raise TypeError("Must be list")
    if not l: raise IndexError("Empty")
    return max(len(x) for x in l)

# ==============================================================================
# 2. INPUT GENERATOR
# ==============================================================================

class InputGenerator:
    """Generates random inputs based on constraint dictionaries."""
    
    @staticmethod
    def get_int(constraints):
        min_val = constraints.get('min_val', -100)
        max_val = constraints.get('max_val', 100)
        val = constraints.get('value')
        if val is not None: return val
        if min_val > max_val: min_val, max_val = max_val, min_val
        return random.randint(min_val, max_val)

    @staticmethod
    def get_float(constraints):
        min_val = constraints.get('min_val', -100.0)
        max_val = constraints.get('max_val', 100.0)
        if min_val > max_val: min_val, max_val = max_val, min_val
        return random.uniform(min_val, max_val)

    @staticmethod
    def get_str(constraints):
        val = constraints.get('value')
        if val is not None: return val
        
        min_len = constraints.get('min_len', 1)
        max_len = constraints.get('max_len', 10)
        pattern = constraints.get('pattern')
        
        if pattern:
            if '01' in pattern: return "".join(random.choice('01') for _ in range(random.randint(min_len, max_len)))
            if 'a-z' in pattern: return "".join(random.choice(string.ascii_lowercase) for _ in range(random.randint(min_len, max_len)))
        
        length = random.randint(min_len, max_len)
        return "".join(random.choices(string.ascii_letters + string.digits, k=length))

    @staticmethod
    def get_list(type_str, constraints):
        min_len = constraints.get('min_len', 1)
        max_len = constraints.get('max_len', 5)
        size = random.randint(min_len, max_len)
        
        # Determine inner type safely
        subtype = "int"
        
        # Check explicit content matching
        if "List[" in type_str or "list[" in type_str:
            # Try to grab content inside brackets
            inner_match = re.search(r'\[(.*)\]', type_str)
            if inner_match:
                inner_str = inner_match.group(1).lower()
                if "str" in inner_str: subtype = "str"
                elif "float" in inner_str: subtype = "float"
                elif "bool" in inner_str: subtype = "bool"
                elif "list" in inner_str: subtype = "list"
                elif "tuple" in inner_str: subtype = "tuple"
        # Fallbacks if brackets aren't present
        elif "str" in type_str: subtype = "str"
        elif "float" in type_str: subtype = "float"
        elif "bool" in type_str: subtype = "bool"
        elif "tuple" in type_str: subtype = "tuple"
        
        elem_constraints = constraints.get('elements', {})
        if isinstance(elem_constraints, list) and len(elem_constraints) > 0:
             elem_constraints = elem_constraints[0]
        if not isinstance(elem_constraints, dict): elem_constraints = {}
        
        # Merge top-level constraints if they apply to elements
        if 'min_val' in constraints and subtype == 'int': elem_constraints['min_val'] = constraints['min_val']
        if 'max_val' in constraints and subtype == 'int': elem_constraints['max_val'] = constraints['max_val']

        if subtype == "int":
            return [InputGenerator.get_int(elem_constraints) for _ in range(size)]
        elif subtype == "str":
            return [InputGenerator.get_str(elem_constraints) for _ in range(size)]
        elif subtype == "float":
            return [InputGenerator.get_float(elem_constraints) for _ in range(size)]
        elif subtype == "tuple":
            return [(random.randint(1,10), random.randint(1,10)) for _ in range(size)]
        elif subtype == "list":
            return [[random.randint(1,10)] for _ in range(size)]
        elif subtype == "bool":
            return [random.choice([True, False]) for _ in range(size)]
            
        return []

    @staticmethod
    def generate(type_str, constraints):
        if not constraints: constraints = {}
        
        if "list" in type_str.lower():
            return InputGenerator.get_list(type_str, constraints)
        elif "tuple" in type_str.lower():
            return tuple(InputGenerator.get_list(type_str, constraints))
        elif "int" in type_str:
            return InputGenerator.get_int(constraints)
        elif "float" in type_str:
            return InputGenerator.get_float(constraints)
        elif "str" in type_str:
            return InputGenerator.get_str(constraints)
        elif "dict" in type_str:
            return {"a": 1, "b": 2}
        elif "bool" in type_str:
            val = constraints.get('value')
            return val if val is not None else random.choice([True, False])
        elif "None" in type_str:
            return None
        else:
            return None

# ==============================================================================
# 3. MUTATION ENGINE
# ==============================================================================

class MutationEngine:
    def __init__(self):
        self.replacements = [
            ('==', '!=', "Equality Negation"),
            ('!=', '==', "Inequality Negation"),
            ('<=', '>', "Boundary Change"),
            ('>=', '<', "Boundary Change"),
            ('<', '>=', "Boundary Change"),
            ('>', '<=', "Boundary Change"),
            (' and ', ' or ', "Logical Operator Change"),
            (' or ', ' and ', "Logical Operator Change"),
            ('+', '-', "Arithmetic Operator Change"),
            ('-', '+', "Arithmetic Operator Change"),
            ('*', '/', "Arithmetic Operator Change"),
            ('/', '*', "Arithmetic Operator Change"),
            ('True', 'False', "Boolean Negation"),
            ('False', 'True', "Boolean Negation")
        ]

    def generate_mutants(self, assertion_str):
        mutants = []
        for old, new, type_ in self.replacements:
            if old in assertion_str:
                start = 0
                while True:
                    idx = assertion_str.find(old, start)
                    if idx == -1: break
                    mutant_code = assertion_str[:idx] + new + assertion_str[idx+len(old):]
                    mutants.append({
                        'code': mutant_code,
                        'type': type_,
                        'change': f"{old} -> {new} at pos {idx}"
                    })
                    start = idx + 1
        return mutants

# ==============================================================================
# 4. MAIN EXECUTION LOGIC
# ==============================================================================

def calculate_mutation_score(doc: Dict[str, Any]) -> Tuple[float, int]:
    raw_response = doc.get('test_cases')
    if not raw_response and 'Structured_Response' in doc:
         raw_response = doc['Structured_Response']

    if not raw_response: return 0.0, 0
    
    test_cases = []
    if isinstance(raw_response, str):
         parsed = clean_json_string(raw_response)
         if isinstance(parsed, dict) and 'test_cases' in parsed:
             test_cases = parsed['test_cases']
         elif isinstance(parsed, list):
             test_cases = parsed
    elif isinstance(raw_response, list):
        test_cases = raw_response
    elif isinstance(raw_response, dict) and 'test_cases' in raw_response:
        test_cases = raw_response['test_cases']
    
    if not test_cases: return 0.0, 0
    
    engine = MutationEngine()
    
    # Track stats globally for the entire prompt, not per test case
    total_mutants_global = 0
    total_killed_global = 0
    
    for idx, tc in enumerate(test_cases):
        # We use a clean local dict, but pass globals() to exec/eval
        # so functions like similar_elements() are visible.
        local_vars = {} 
        
        inputs = tc.get('input_types', {})
        constraints = tc.get('input_constraints', {})
        
        # 1. Generate Inputs
        try:
            for var_name, var_type in inputs.items():
                var_const = constraints.get(var_name, {})
                generated_val = InputGenerator.generate(var_type, var_const)
                local_vars[var_name] = generated_val
        except Exception as e:
            if DEBUG: print(f"TC {idx} Input Gen Error: {e}")
            continue

        # 2. Execute Code
        exec_stmt = tc.get('execution_statement')
        try:
            # CRITICAL FIX: Pass globals() here!
            exec(exec_stmt, globals(), local_vars)
        except Exception as e:
            if DEBUG: print(f"TC {idx} Execution Error: {e}")
            continue
            
        postconditions = tc.get('postconditions', [])
        
        for pc in postconditions:
            assertion = pc.get('assertion')
            if not assertion: continue
            
            # 3. Check Original Assertion
            try:
                # CRITICAL FIX: Pass globals() here!
                if not eval(assertion, globals(), local_vars):
                    if DEBUG: print(f"TC {idx} Original Assertion Failed: {assertion}")
                    continue
            except Exception as e:
                if DEBUG: print(f"TC {idx} Assertion Error: {e}")
                continue

            # 4. Generate & Test Mutants
            mutants = engine.generate_mutants(assertion)
            for m in mutants:
                total_mutants_global += 1
                try:
                    # Mutant is killed if it returns False OR crashes
                    if not eval(m['code'], globals(), local_vars):
                        total_killed_global += 1
                except Exception:
                    # Exception means the mutant broke the logic = Killed
                    total_killed_global += 1
    
    if total_mutants_global == 0:
        return 0.0, 0
        
    final_score = total_killed_global / total_mutants_global
    return final_score, total_mutants_global

def process_database():
    print("Initializing Database Connection via config...")
    try:
        client, db = get_db_client()
    except Exception as e:
        print(f"Failed to connect to DB: {e}")
        return

    collection = db[COLLECTION_NAME]
    cursor = collection.find({})
    total_docs = collection.count_documents({})
    
    print(f"Found {total_docs} documents in '{COLLECTION_NAME}'. Starting mutation analysis...")

    updates_count = 0
    errors_count = 0

    for doc in cursor:
        prompt_id = doc.get('Prompt_ID')
        try:
            mutation_score, total_mutants = calculate_mutation_score(doc)
            if total_mutants > 0:
                collection.update_one(
                    {'_id': doc['_id']}, 
                    {'$set': {'Mutation_Score': float(mutation_score)}}
                )
                updates_count += 1
                print(f"[Prompt {prompt_id}] Updated Mutation Score: {mutation_score:.2f} (Total Mutants: {total_mutants})")
            else:
                if DEBUG: print(f"[Prompt {prompt_id}] No valid mutants generated.")
        except Exception as e:
            print(f"[Prompt {prompt_id}] Error: {e}")
            errors_count += 1
            continue

    print(f"\nAnalysis complete. Updated: {updates_count}, Errors: {errors_count}")

if __name__ == "__main__":
    process_database()